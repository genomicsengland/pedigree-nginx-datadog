 window.PedigreeHostProvidesEnvVariable = true;
/*! ESAPI-JS - v0.1.3
 *  Release on: 2015-06-08
 *  https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API
 *  Copyright (c) 2015 OWASP
 *  Licensed BSD */
// Utility and Core API Methods
var $namespace = function(name, separator, container){
    var ns = name.split(separator || '.'),
        o = container || window,
        i,
        len;
    for(i = 0, len = ns.length; i < len; i++){
        o = o[ns[i]] = o[ns[i]] || {};
    }
    return o;
};

var $type = function( oVar, oType ) {
    if ( !oVar instanceof oType ) {
        throw new SyntaxError();
    }
};

if (!$) {
    var $ = function( sElementID ) {
        return document.getElementById( sElementID );
    };
}

/* Commented out because of how they mess up the for each loops over arrays.
 if (!Array.prototype.each) {
 Array.prototype.each = function(fIterator) {
 if (typeof fIterator != 'function') {
 throw 'Illegal Argument for Array.each';
 }
 for (var i = 0; i < this.length; i ++) {
 fIterator(this[i]);
 }
 };
 }
 if (!Array.prototype.contains) {
 Array.prototype.contains = function(srch) {
 var found = false;
 this.each(function(e) {
 if ( ( srch.equals && srch.equals(e) ) || e == srch) {
 found = true;
 return;
 }
 });
 return found;
 };
 }
 if (!Array.prototype.containsKey) {
 Array.prototype.containsKey = function(srch) {
 for ( var key in this ) {
 if ( key.toLowerCase() == srch.toLowerCase() ) {
 return true;
 }
 }
 return false;
 };
 }
 if (!Array.prototype.getCaseInsensitive) {
 Array.prototype.getCaseInsensitive = function(key) {
 for (var k in this) {
 if (k.toLowerCase() == key.toLowerCase()) {
 return this[k];
 }
 }
 return null;
 };
 }*/

if (!String.prototype.charCodeAt) {
    String.prototype.charCodeAt = function( idx ) {
        var c = this.charAt(idx);
        for ( var i=0;i<65536;i++) {
            var s = String.fromCharCode(i);
            if ( s == c ) { return i; }
        }
        return 0;
    };
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function( test ) {
        return this.substr( ( this.length - test.length ), test.length ) == test;
    };
}

// Declare Core Exceptions
if ( !Exception ) {
    var Exception = function( sMsg, oException ) {
        this.cause = oException;
        this.errorMessage = sMsg;
    };

    Exception.prototype = Error.prototype;

    Exception.prototype.getCause = function() { return this.cause; };

    Exception.prototype.getMessage = function() { return this.message; };

    /**
     * This method creates the stacktrace for the Exception only when it is called the first time and
     * caches it for access after that. Since building a stacktrace is a fairly expensive process, we
     * only want to do it if it is called.
     */
    Exception.prototype.getStackTrace = function() {
        if ( this.callstack ) {
            return this.callstack;
        }

        if ( this.stack ) { // Mozilla
            var lines = stack.split("\n");
            for ( var i=0, len=lines.length; i<len; i ++ ) {
                if ( lines[i].match( /^\s*[A-Za-z0-9\=+\$]+\(/ ) ) {
                    this.callstack.push(lines[i]);
                }
            }
            this.callstack.shift();
            return this.callstack;
        }
        else if ( window.opera && this.message ) { // Opera
            var lines = this.message.split('\n');
            for ( var i=0, len=lines.length; i<len; i++ ) {
                if ( lines[i].match( /^\s*[A-Za-z0-9\=+\$]+\(/ ) ) {
                    var entry = lines[i];
                    if ( lines[i+1] ) {
                        entry += " at " + lines[i+1];
                        i++;
                    }
                    this.callstack.push(entry);
                }
            }
            this.callstack.shift();
            return this.callstack;
        }
        else { // IE and Safari
            var currentFunction = arguments.callee.caller;
            while ( currentFunction ) {
                var fn = currentFunction.toString();
                var fname = fn.substring(fn.indexOf("function")+8,fn.indexOf("(")) || "anonymous";
                this.callstack.push(fname);
                currentFunction = currentFunction.caller;
            }
            return this.callstack;
        }
    };

    Exception.prototype.printStackTrace = function( writer ) {
        var out = this.getMessage() + "|||" + this.getStackTrace().join( "|||" );

        if ( this.cause ) {
            if ( this.cause.printStackTrace ) {
                out += "||||||Caused by " + this.cause.printStackTrace().replace( "\n", "|||" );
            }
        }

        if ( !writer ) {
            return writer.replace( "|||", "\n" );
        } else if ( writer.value ) {
            writer.value = out.replace( "|||", "\n" );
        } else if ( writer.writeln ) {
            writer.writeln( out.replace( "|||", "\n" ) );
        } else if ( writer.innerHTML ) {
            writer.innerHTML = out.replace( "|||", "<br/>" );
        } else if ( writer.textContent ) {
            writer.textContent = out.replace( "|||", "<br/>" );
        } else if ( writer.append ) {
            writer.append( out.replace( "|||", "\n" ) );
        } else if ( writer instanceof Function ) {
            writer(out.replace( "|||", "\n" ) );
        }
    };
}

if ( !RuntimeException ) {
    var RuntimeException = Exception;
}

if ( !IllegalArgumentException ) {
    var IllegalArgumentException = Exception;
}

if ( !DateFormat ) {
    // Based on http://jacwright.com/projects/javascript/date_format
    var DateFormat = function( sFmt ) {

        var fmt = sFmt;

        var replaceChars = {
            longMonths: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            longDays: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],

            // Day
            d: function(date) { return (date.getDate() < 10 ? '0' : '') + date.getDate(); },
            D: function(date) { return replaceChars.shortDays[date.getDay()]; },
            j: function(date) { return date.getDate(); },
            l: function(date) { return replaceChars.longDays[date.getDay()]; },
            N: function(date) { return date.getDay() + 1; },
            S: function(date) { return (date.getDate() % 10 == 1 && date.getDate() != 11 ? 'st' : (date.getDate() % 10 == 2 && date.getDate() != 12 ? 'nd' : (date.getDate() % 10 == 3 && date.getDate() != 13 ? 'rd' : 'th'))); },
            w: function(date) { return date.getDay(); },
            z: function(date) { return "Not Yet Supported"; },
            // Week
            W: function(date) { return "Not Yet Supported"; },
            // Month
            F: function(date) { return replaceChars.longMonths[date.getMonth()]; },
            m: function(date) { return (date.getMonth() < 9 ? '0' : '') + (date.getMonth() + 1); },
            M: function(date) { return replaceChars.shortMonths[date.getMonth()]; },
            n: function(date) { return date.getMonth() + 1; },
            t: function(date) { return "Not Yet Supported"; },
            // Year
            L: function(date) { return (((date.getFullYear()%4==0)&&(date.getFullYear()%100 != 0)) || (date.getFullYear()%400==0)) ? '1' : '0'; },
            o: function(date) { return "Not Supported"; },
            Y: function(date) { return date.getFullYear(); },
            y: function(date) { return ('' + date.getFullYear()).substr(2); },
            // Time
            a: function(date) { return date.getHours() < 12 ? 'am' : 'pm'; },
            A: function(date) { return date.getHours() < 12 ? 'AM' : 'PM'; },
            B: function(date) { return "Not Yet Supported"; },
            g: function(date) { return date.getHours() % 12 || 12; },
            G: function(date) { return date.getHours(); },
            h: function(date) { return ((date.getHours() % 12 || 12) < 10 ? '0' : '') + (date.getHours() % 12 || 12); },
            H: function(date) { return (date.getHours() < 10 ? '0' : '') + date.getHours(); },
            i: function(date) { return (date.getMinutes() < 10 ? '0' : '') + date.getMinutes(); },
            s: function(date) { return (date.getSeconds() < 10 ? '0' : '') + date.getSeconds(); },
            // Timezone
            e: function(date) { return "Not Yet Supported"; },
            I: function(date) { return "Not Supported"; },
            O: function(date) { return (-date.getTimezoneOffset() < 0 ? '-' : '+') + (Math.abs(date.getTimezoneOffset() / 60) < 10 ? '0' : '') + (Math.abs(date.getTimezoneOffset() / 60)) + '00'; },
            P: function(date) { return (-date.getTimezoneOffset() < 0 ? '-' : '+') + (Math.abs(date.getTimezoneOffset() / 60) < 10 ? '0' : '') + (Math.abs(date.getTimezoneOffset() / 60)) + ':' + (Math.abs(date.getTimezoneOffset() % 60) < 10 ? '0' : '') + (Math.abs(date.getTimezoneOffset() % 60)); },
            T: function(date) { var m = date.getMonth(); date.setMonth(0); var result = date.toTimeString().replace(/^.+ \(?([^\)]+)\)?$/, '$1'); date.setMonth(m); return result;},
            Z: function(date) { return -date.getTimezoneOffset() * 60; },
            // Full Date/Time
            c: function(date) { return date.format("Y-m-d") + "T" + date.format("H:i:sP"); },
            r: function(date) { return date.toString(); },
            U: function(date) { return date.getTime() / 1000; }
        };


        return {
            format: function(oDate) {
                var out = '';
                for(var i=0;i<fmt.length;i++) {
                    var c = fmt.charAt(i);
                    if ( replaceChars[c] ) {
                        out += replaceChars[c].call(oDate);
                    } else {
                        out += c;
                    }
                }
                return out;
            }
        };
    };

    DateFormat.getDateInstance = function() {
        return new DateFormat("M/d/y h:i a");
    };
}

$namespace('org.owasp.esapi');

org.owasp.esapi.ESAPI = function( oProperties ) {
    var _properties = oProperties;

    if ( !_properties ) throw new RuntimeException("Configuration Error - Unable to load $ESAPI_Properties Object");

    var _encoder = null;
    var _validator = null;
    var _logFactory = null;
    var _resourceBundle = null;
    var _httputilities = null;

    return {
        properties: _properties,

        encoder: function() {
            if (!_encoder) {
                if (!_properties.encoder.Implementation) throw new RuntimeException('Configuration Error - $ESAPI.properties.encoder.Implementation object not found.');
                _encoder = new _properties.encoder.Implementation();
            }
            return _encoder;
        },

        logFactory: function() {
            if ( !_logFactory ) {
                if (!_properties.logging.Implementation) throw new RuntimeException('Configuration Error - $ESAPI.properties.logging.Implementation object not found.');
                _logFactory = new _properties.logging.Implementation();
            }
            return _logFactory;
        },

        logger: function(sModuleName) {
            return this.logFactory().getLogger(sModuleName);
        },

        locale: function() {
            return org.owasp.esapi.i18n.Locale.getLocale( _properties.localization.DefaultLocale );
        },

        resourceBundle: function() {
            if (!_resourceBundle) {
                if(!_properties.localization.StandardResourceBundle) throw new RuntimeException("Configuration Error - $ESAPI.properties.localization.StandardResourceBundle not found.");
                _resourceBundle = new org.owasp.esapi.i18n.ObjectResourceBundle( _properties.localization.StandardResourceBundle );
            }
            return _resourceBundle;
        },

        validator: function() {
            if (!_validator) {
                if (!_properties.validation.Implementation) throw new RuntimeException('Configuration Error - $ESAPI.properties.validation.Implementation object not found.');
                _validator = new _properties.validation.Implementation();
            }
            return _validator;
        },

        httpUtilities: function() {
            if (!_httputilities) _httputilities = new org.owasp.esapi.HTTPUtilities();
            return _httputilities;
        }
    };
};

var $ESAPI = null;

org.owasp.esapi.ESAPI.initialize = function() {
    $ESAPI = new org.owasp.esapi.ESAPI( Base.esapi.properties );
};

$namespace('org.owasp.esapi');

org.owasp.esapi.Encoder = function() {

}
$namespace('org.owasp.esapi');

org.owasp.esapi.EncoderConstants = {
    CHAR_LOWERS: [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ],
    CHAR_UPPERS: [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' ],
    CHAR_DIGITS: [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ],
    CHAR_SPECIALS: [ '!', '$', '*', '+', '-', '.', '=', '?', '@', '^', '_', '|', '~' ],
    CHAR_LETTERS: [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' ],
    CHAR_ALNUM: [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ]
};
$namespace('org.owasp.esapi');

org.owasp.esapi.EnterpriseSecurityException = function(sUserMessage, sLogMessage, oException) {
    var _logMessage = sLogMessage;
    var _super = new Exception(sUserMessage, oException);

    return {
        getMessage: _super.getMessage,
        getUserMessage: _super.getMessage,
        getLogMessage: function() {
            return _logMessage;
        },
        getStackTrace: _super.getStackTrace,
        printStackTrace: _super.printStackTrace
    };
};
$namespace('org.owasp.esapi');

org.owasp.esapi.HTTPUtilities = function() {
    var log = $ESAPI.logger("HTTPUtilities");
    var resourceBundle = $ESAPI.resourceBundle();
    var EventType = org.owasp.esapi.Logger.EventType;

    return {
        addCookie: function( oCookie ) {
            $type(oCookie,org.owasp.esapi.net.Cookie);

            if ( window.top.location.protocol != 'http:' || window.top.location.protocol != 'https:' )
                throw new RuntimeException(resourceBundle.getString( "HTTPUtilities.Cookie.Protocol", {"protocol":window.top.location.protocol}));

            var name = oCookie.getName(),
                value = oCookie.getValue(),
                maxAge = oCookie.getMaxAge(),
                domain = oCookie.getDomain(),
                path = oCookie.getPath(),
                secure = oCookie.getSecure();

            var validationErrors = new org.owasp.esapi.ValidationErrorList();
            var cookieName = $ESAPI.validator().getValidInput("cookie name", name, "HttpCookieName", 50, false, validationErrors );
            var cookieValue = $ESAPI.validator().getValidInput("cookie value", value, "HttpCookieValue", 5000, false, validationErrors );

            if (validationErrors.size() == 0) {
                var header = name+'='+escape(value);
                header += maxAge?";expires=" + ( new Date( ( new Date() ).getTime() + ( 1000 * maxAge ) ).toGMTString() ) : "";
                header += path?";path="+path:"";
                header += domain?";domain="+domain:"";
                header += secure||$ESAPI.properties.httputilities.cookies.ForceSecure?";secure":"";
                document.cookie=header;
            }
            else
            {
                log.warning(EventType.SECURITY_FAILURE, resourceBundle.getString("HTTPUtilities.Cookie.UnsafeData", { 'name':name, 'value':value } ) );
            }
        },

        /**
         * Returns a {@link org.owasp.esapi.net.Cookie} containing the name and value of the requested cookie.
         *
         * IMPORTANT: The value of the cookie is not sanitized at this level. It is the responsibility of the calling
         * code to sanitize the value for proper output encoding prior to using it.
         *
         * @param sName {String} The name of the cookie to retrieve
         * @return {org.owasp.esapi.net.Cookie}
         */
        getCookie: function(sName) {
            var cookieJar = document.cookie.split("; ");
            for(var i=0,len=cookieJar.length;i<len;i++) {
                var cookie = cookieJar[i].split("=");
                if (cookie[0] == escape(sName)) {
                    return new org.owasp.esapi.net.Cookie( sName, cookie[1]?unescape(cookie[1]):'' );
                }
            }
            return null;
        },

        /**
         * Will attempt to kill any cookies associated with the current request (domain,path,secure). If a cookie cannot
         * be deleted, a RuntimeException will be thrown.
         *
         * @throws RuntimeException if one of the cookies cannot be deleted.
         */
        killAllCookies: function() {
            var cookieJar = document.cookie.split("; ");
            for(var i=0,len=cookieJar.length;i<len;i++) {
                var cookie = cookieJar[i].split("=");
                var name = unescape(cookie[0]);
                // RuntimeException will bubble through if the cookie cannot be deleted
                if (!this.killCookie(name)) {
                    // Something is wrong - cookieJar contains a cookie that is inaccesible using getCookie
                    throw new RuntimeException(resourceBundle.getString("HTTPUtilities.Cookie.CantKill", {"name":name}));
                }
            }
        },

        /**
         * Will kill a single cookie. If that cookie cannot be deleted a RuntimeException will be thrown
         * @param sName {String} The name of the cookie
         */
        killCookie: function(sName) {
            var c = this.getCookie(sName);
            if ( c ) {
                c.setMaxAge( -10 );
                this.addCookie(c);
                if (this.getCookie(sName)) {
                    throw new RuntimeException(resourceBundle.getString("HTTPUtilities.Cookie.CantKill", {"name":sName}));
                }
                return true;
            }
            return false;
        },

        /**
         * This only works for GET parameters and is meerly a convenience method for accessing that information if need be
         * @param sName {String} The name of the parameter to retrieve
         */
        getRequestParameter: function( sName ) {
            var url = window.top.location.search.substring(1);
            var pIndex = url.indexOf(sName);
            if (pIndex<0) return null;
            pIndex=pIndex+sName.length;
            var lastIndex=url.indexOf("&",pIndex);
            if (lastIndex<0) lastIndex=url.length;
            return unescape(url.substring(pIndex,lastIndex));
        }
    };
};
$namespace('org.owasp.esapi');

org.owasp.esapi.IntrusionException = function(sUserMessage, sLogMessage, oCause) {
    var _super = new org.owasp.esapi.EnterpriseSecurityException(sUserMessage, sLogMessage, oCause);

    return {
        getMessage: _super.getMessage,
        getUserMessage: _super.getMessage,
        getLogMessage: _super.getLogMessage,
        getStackTrace: _super.getStackTrace,
        printStackTrace: _super.printStackTrace
    };
};
$namespace('org.owasp.esapi');

org.owasp.esapi.LogFactory = function() {
    return {
        getLogger: false
    };
}
$namespace('org.owasp.esapi');

org.owasp.esapi.Logger = function() {
    return {
        setLevel: false,
        fatal: false,
        error: false,
        isErrorEnabled: false,
        warning: false,
        isWarningEnabled: false,
        info: false,
        isInfoEnabled: false,
        debug: false,
        isDebugEnabled: false,
        trace: false,
        isTraceEnabled: false
    };
};

org.owasp.esapi.Logger.EventType = function( sName, bNewSuccess ) {
    var type = sName;
    var success = bNewSuccess;

    return {
        isSuccess: function() {
            return success;
        },

        toString: function() {
            return type;
        }
    };
};

with(org.owasp.esapi.Logger) {

    EventType.SECURITY_SUCCESS = new EventType( "SECURITY SUCCESS", true );
    EventType.SECURITY_FAILURE = new EventType( "SECURITY FAILURE", false );
    EventType.EVENT_SUCCESS    = new EventType( "EVENT SUCCESS", true );
    EventType.EVENT_FAILURE    = new EventType( "EVENT FAILURE", false );

    OFF = Number.MAX_VALUE;
    FATAL = 1000;
    ERROR = 800;
    WARNING = 600;
    INFO = 400;
    DEBUG = 200;
    TRACE = 100;
    ALL = Number.MIN_VALUE;
}
$namespace('org.owasp.esapi');

org.owasp.esapi.PreparedString = function(sTemplate, oCodec, sParameterCharacter) {
    // Private Scope
    var parts = [];
    var parameters = [];

    function split(s) {
        var idx = 0, pcount = 0;
        for (var i = 0; i < s.length; i ++) {
            if (s.charAt(i) == sParameterCharacter) {
                pcount ++;
                parts.push(s.substr(idx, i));
                idx = i + 1;
            }
        }
        parts.push(s.substr(idx));
        parameters = new Array(pcount);
    }

    ;

    if (!sParameterCharacter) {
        sParameterCharacter = '?';
    }

    split(sTemplate);

    return {
        set: function(iIndex, sValue, codec) {
            if (iIndex < 1 || iIndex > parameters.length) {
                throw new IllegalArgumentException("Attempt to set parameter: " + iIndex + " on a PreparedString with only " + parameters.length + " placeholders");
            }
            if (!codec) {
                codec = oCodec;
            }
            parameters[iIndex - 1] = codec.encode([], sValue);
        },

        toString: function() {
            for (var ix = 0; ix < parameters.length; ix ++) {
                if (parameters[ix] == null) {
                    throw new RuntimeException("Attempt to render PreparedString without setting parameter " + (ix + 1));
                }
            }
            var out = '', i = 0;
            for (var p = 0; p < parts.length; p ++) {
                out += parts[p];
                if (i < parameters.length) {
                    out += parameters[i++];
                }
            }
            return out;
        }
    };
};

$namespace('org.owasp.esapi');

org.owasp.esapi.ValidationErrorList = function() {
    var errorList = Array();

    return {
        addError: function( sContext, oValidationException ) {
            if ( sContext == null ) throw new RuntimeException( "Context cannot be null: " + oValidationException.getLogMessage(), oValidationException );
            if ( oValidationException == null ) throw new RuntimeException( "Context (" + sContext + ") - Error cannot be null" );
            if ( errorList[sContext] ) throw new RuntimeException( "Context (" + sContext + ") already exists. must be unique." );
            errorList[sContext] = oValidationException;
        },

        errors: function() {
            return errorList;
        },

        isEmpty: function() {
            return errorList.length == 0;
        },

        size: function() {
            return errorList.length;
        }
    };
};

$namespace('org.owasp.esapi');

org.owasp.esapi.ValidationRule = function() {
    return {
        getValid: false,
        setAllowNull: false,
        getTypeName: false,
        setTypeName: false,
        setEncoder: false,
        assertValid: false,
        getSafe: false,
        isValid: false,
        whitelist: false
    };
};

$namespace('org.owasp.esapi');

org.owasp.esapi.Validator = function() {
    return {
        addRule: false,
        getRule: false,
        getValidInput: false,
        isValidDate: false,
        getValidDate: false,
        isValidSafeHTML: false,
        getValidSafeHTML: false,
        isValidCreditCard: false,
        getValidCreditCard: false,
        isValidFilename: false,
        getValidFilename: false,
        isValidNumber: false,
        getValidNumber: false,
        isValidPrintable: false,
        getValidPrintable: false
    };
};

$namespace('org.owasp.esapi.codecs.Base64');

org.owasp.esapi.codecs.Base64 = {
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encode: function(sInput) {
        if (!sInput) {
            return null;
        }

        var out = '';
        var ch1,ch2,ch3,enc1,enc2,enc3,enc4;
        var i = 0;

        var input = org.owasp.esapi.codecs.UTF8.encode(sInput);

        while (i < input.length) {
            ch1 = input.charCodeAt(i++);
            ch2 = input.charCodeAt(i++);
            ch3 = input.charCodeAt(i++);

            enc1 = ch1 >> 2;
            enc2 = ((ch1 & 3) << 4) | (ch2 >> 4);
            enc3 = ((ch2 & 15) << 2) | (ch3 >> 6);
            enc4 = ch3 & 63;

            if (isNaN(ch2)) {
                enc3 = enc4 = 64;
            }
            else if (isNaN(ch3)) {
                enc4 = 64;
            }

            out += this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
        }

        return out;
    },

    decode: function(sInput) {
        if (!sInput) {
            return null;
        }

        var out = '';
        var ch1, ch2, ch3, enc1, enc2, enc3, enc4;
        var i = 0;

        var input = sInput.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {
            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            ch1 = (enc1 << 2) | (enc2 >> 4);
            ch2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            ch3 = ((enc3 & 3) << 6) | enc4;

            out += String.fromCharCode(ch1);
            if (enc3 != 64) {
                out += String.fromCharCode(ch2);
            }
            if (enc4 != 64) {
                out += String.fromCharCode(ch3);
            }
        }

        out = org.owasp.esapi.codecs.UTF8.decode(out);
        return out;
    }
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.CSSCodec = function() {
    var _super = new org.owasp.esapi.codecs.Codec();

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (aImmune.indexOf(c) > -1) {
                return c;
            }

            var hex = org.owasp.esapi.codecs.Codec.getHexForNonAlphanumeric(c);
            if (hex == null) {
                return c;
            }

            return "\\" + hex + " ";
        },

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null) {
                oPushbackString.reset();
                return null;
            }

            if (first != '\\') {
                oPushbackString.reset();
                return null;
            }

            var second = oPushbackString.next();
            if (second == null) {
                oPushbackString.reset();
                return null;
            }

            if (oPushbackString.isHexDigit(second)) {
                var out = second;
                for (var i = 0; i < 6; i ++) {
                    var c = oPushbackString.next();
                    if (c == null || c.charCodeAt(0) == 0x20) {
                        break;
                    }
                    if (oPushbackString.isHexDigit(c)) {
                        out += c;
                    } else {
                        input.pushback(c);
                        break;
                    }
                }

                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            }

            return second;
        }
    };
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.Codec = function() {
    return {
        /**
         * Encode a String so that it can be safely used in a specific context.
         *
         * @param aImmune
         *              array of immune characters
         * @param sInput
         *              the String to encode
         * @return the encoded String
         */
        encode: function(aImmune, sInput) {
            var out = '';
            for (var i = 0; i < sInput.length; i ++) {
                var c = sInput.charAt(i);
                out += this.encodeCharacter(aImmune, c);
            }
            return out;
        },

        /**
         * Default implementation that should be overridden in specific codecs.
         *
         * @param aImmune
         *              array of immune characters
         * @param c
         *              the Character to encode
         * @return
         *              the encoded Character
         */
        encodeCharacter: function(aImmune, c) {
            return c;
        },

        /**
         * Decode a String that was encoded using the encode method in this Class
         *
         * @param sInput
         *              the String to decode
         * @return
         *              the decoded String
         */
        decode: function(sInput) {
            var out = '';
            var pbs = new org.owasp.esapi.codecs.PushbackString(sInput);
            while (pbs.hasNext()) {
                var c = this.decodeCharacter(pbs);
                if (c != null) {
                    out += c;
                } else {
                    out += pbs.next();
                }
            }
            return out;
        },

        /**
         * Returns the decoded version of the next character from the input string and advances the
         * current character in the PushbackString.  If the current character is not encoded, this
         * method MUST reset the PushbackString.
         *
         * @param oPushbackString the Character to decode
         * @return the decoded Character
         */
        decodeCharacter: function(oPushbackString) {
            return oPushbackString.next();
        }
    };
};

org.owasp.esapi.codecs.Codec.getHexForNonAlphanumeric = function(c) {
    if (c.charCodeAt(0) < 256) {
        return org.owasp.esapi.codecs.Codec.hex[c.charCodeAt(0)];
    }
    return c.charCodeAt(0).toString(16);
};

org.owasp.esapi.codecs.Codec.hex = [];
for ( var c = 0; c < 0xFF; c ++ ) {
    if ( c >= 0x30 && c <= 0x39 || c>= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A ) {
        org.owasp.esapi.codecs.Codec.hex[c] = null;
    } else {
        org.owasp.esapi.codecs.Codec.hex[c] = c.toString(16);
    }
};

var entityToCharacterMap = [];
entityToCharacterMap["&quot"]        = "34";      /* 34 : quotation mark */
entityToCharacterMap["&amp"]         = "38";      /* 38 : ampersand */
entityToCharacterMap["&lt"]          = "60";        /* 60 : less-than sign */
entityToCharacterMap["&gt"]          = "62";        /* 62 : greater-than sign */
entityToCharacterMap["&nbsp"]        = "160";      /* 160 : no-break space */
entityToCharacterMap["&iexcl"]       = "161";     /* 161 : inverted exclamation mark */
entityToCharacterMap["&cent"]			= "162";	/* 162  : cent sign */
entityToCharacterMap["&pound"]			= "163";	/* 163  : pound sign */
entityToCharacterMap["&curren"]			= "164";	/* 164  : currency sign */
entityToCharacterMap["&yen"]			= "165";	/* 165  : yen sign */
entityToCharacterMap["&brvbar"]			= "166";	/* 166  : broken bar */
entityToCharacterMap["&sect"]			= "167";	/* 167  : section sign */
entityToCharacterMap["&uml"]			= "168";	/* 168  : diaeresis */
entityToCharacterMap["&copy"]			= "169";	/* 169  : copyright sign */
entityToCharacterMap["&ordf"]			= "170";	/* 170  : feminine ordinal indicator */
entityToCharacterMap["&laquo"]          = "171";    /* 171 : left-pointing double angle quotation mark */
entityToCharacterMap["&not"]			= "172";	/* 172  : not sign */
entityToCharacterMap["&shy"]			= "173";	/* 173  : soft hyphen */
entityToCharacterMap["&reg"]			= "174";	/* 174  : registered sign */
entityToCharacterMap["&macr"]			= "175";	/* 175  : macron */
entityToCharacterMap["&deg"]			= "176";	/* 176  : degree sign */
entityToCharacterMap["&plusmn"]         = "177";    /* 177 : plus-minus sign */
entityToCharacterMap["&sup2"]			= "178";	/* 178  : superscript two */
entityToCharacterMap["&sup3"]			= "179";	/* 179  : superscript three */
entityToCharacterMap["&acute"]			= "180";	/* 180  : acute accent */
entityToCharacterMap["&micro"]			= "181";	/* 181  : micro sign */
entityToCharacterMap["&para"]			= "182";	/* 182  : pilcrow sign */
entityToCharacterMap["&middot"]			= "183";	/* 183  : middle dot */
entityToCharacterMap["&cedil"]			= "184";	/* 184  : cedilla */
entityToCharacterMap["&sup1"]			= "185";	/* 185  : superscript one */
entityToCharacterMap["&ordm"]			= "186";	/* 186  : masculine ordinal indicator */
entityToCharacterMap["&raquo"]          = "187";    /* 187 : right-pointing double angle quotation mark */
entityToCharacterMap["&frac14"]			= "188";	/* 188  : vulgar fraction one quarter */
entityToCharacterMap["&frac12"]			= "189";	/* 189  : vulgar fraction one half */
entityToCharacterMap["&frac34"]			= "190";	/* 190  : vulgar fraction three quarters */
entityToCharacterMap["&iquest"]			= "191";	/* 191  : inverted question mark */
entityToCharacterMap["&Agrave"]			= "192";	/* 192  : Latin capital letter a with grave */
entityToCharacterMap["&Aacute"]			= "193";	/* 193  : Latin capital letter a with acute */
entityToCharacterMap["&Acirc"]			= "194";	/* 194  : Latin capital letter a with circumflex */
entityToCharacterMap["&Atilde"]			= "195";	/* 195  : Latin capital letter a with tilde */
entityToCharacterMap["&Auml"]			= "196";	/* 196  : Latin capital letter a with diaeresis */
entityToCharacterMap["&Aring"]			= "197";	/* 197  : Latin capital letter a with ring above */
entityToCharacterMap["&AElig"]			= "198";	/* 198  : Latin capital letter ae */
entityToCharacterMap["&Ccedil"]			= "199";	/* 199  : Latin capital letter c with cedilla */
entityToCharacterMap["&Egrave"]			= "200";	/* 200  : Latin capital letter e with grave */
entityToCharacterMap["&Eacute"]			= "201";	/* 201  : Latin capital letter e with acute */
entityToCharacterMap["&Ecirc"]			= "202";	/* 202  : Latin capital letter e with circumflex */
entityToCharacterMap["&Euml"]			= "203";	/* 203  : Latin capital letter e with diaeresis */
entityToCharacterMap["&Igrave"]			= "204";	/* 204  : Latin capital letter i with grave */
entityToCharacterMap["&Iacute"]			= "205";	/* 205  : Latin capital letter i with acute */
entityToCharacterMap["&Icirc"]			= "206";	/* 206  : Latin capital letter i with circumflex */
entityToCharacterMap["&Iuml"]			= "207";	/* 207  : Latin capital letter i with diaeresis */
entityToCharacterMap["&ETH"]			    = "208";	/* 208  : Latin capital letter eth */
entityToCharacterMap["&Ntilde"]			= "209";	/* 209  : Latin capital letter n with tilde */
entityToCharacterMap["&Ograve"]			= "210";	/* 210  : Latin capital letter o with grave */
entityToCharacterMap["&Oacute"]			= "211";	/* 211  : Latin capital letter o with acute */
entityToCharacterMap["&Ocirc"]           = "212";  /* 212 : Latin capital letter o with circumflex */
entityToCharacterMap["&Otilde"]			= "213";	 /* 213 : Latin capital letter o with tilde */
entityToCharacterMap["&Ouml"]			= "214";	 /* 214 : Latin capital letter o with diaeresis */
entityToCharacterMap["&times"]			= "215";	 /* 215 : multiplication sign */
entityToCharacterMap["&Oslash"]			= "216";	 /* 216 : Latin capital letter o with stroke */
entityToCharacterMap["&Ugrave"]			= "217";	 /* 217 : Latin capital letter u with grave */
entityToCharacterMap["&Uacute"]			= "218";	 /* 218 : Latin capital letter u with acute */
entityToCharacterMap["&Ucirc"]			= "219";	 /* 219 : Latin capital letter u with circumflex */
entityToCharacterMap["&Uuml"]			= "220";	 /* 220 : Latin capital letter u with diaeresis */
entityToCharacterMap["&Yacute"]			= "221";	 /* 221 : Latin capital letter y with acute */
entityToCharacterMap["&THORN"]			= "222";	 /* 222 : Latin capital letter thorn */
entityToCharacterMap["&szlig"]           = "223";   /* 223 : Latin small letter sharp s, German Eszett */
entityToCharacterMap["&agrave"]			= "224";	 /* 224 : Latin small letter a with grave */
entityToCharacterMap["&aacute"]			= "225";	 /* 225 : Latin small letter a with acute */
entityToCharacterMap["&acirc"]			= "226";	 /* 226 : Latin small letter a with circumflex */
entityToCharacterMap["&atilde"]			= "227";	 /* 227 : Latin small letter a with tilde */
entityToCharacterMap["&auml"]			= "228";	 /* 228 : Latin small letter a with diaeresis */
entityToCharacterMap["&aring"]			= "229";	 /* 229 : Latin small letter a with ring above */
entityToCharacterMap["&aelig"]			= "230";	 /* 230 : Latin lowercase ligature ae */
entityToCharacterMap["&ccedil"]			= "231";	 /* 231 : Latin small letter c with cedilla */
entityToCharacterMap["&egrave"]			= "232";	 /* 232 : Latin small letter e with grave */
entityToCharacterMap["&eacute"]			= "233";	 /* 233 : Latin small letter e with acute */
entityToCharacterMap["&ecirc"]			= "234";	 /* 234 : Latin small letter e with circumflex */
entityToCharacterMap["&euml"]			= "235";	 /* 235 : Latin small letter e with diaeresis */
entityToCharacterMap["&igrave"]			= "236";	 /* 236 : Latin small letter i with grave */
entityToCharacterMap["&iacute"]			= "237";	 /* 237 : Latin small letter i with acute */
entityToCharacterMap["&icirc"]			= "238";	 /* 238 : Latin small letter i with circumflex */
entityToCharacterMap["&iuml"]			= "239";	 /* 239 : Latin small letter i with diaeresis */
entityToCharacterMap["&eth"]			    = "240";	 /* 240 : Latin small letter eth */
entityToCharacterMap["&ntilde"]			= "241";	 /* 241 : Latin small letter n with tilde */
entityToCharacterMap["&ograve"]			= "242";	 /* 242 : Latin small letter o with grave */
entityToCharacterMap["&oacute"]			= "243";	 /* 243 : Latin small letter o with acute */
entityToCharacterMap["&ocirc"]			= "244";	 /* 244 : Latin small letter o with circumflex */
entityToCharacterMap["&otilde"]			= "245";	 /* 245 : Latin small letter o with tilde */
entityToCharacterMap["&ouml"]			= "246";	 /* 246 : Latin small letter o with diaeresis */
entityToCharacterMap["&divide"]			= "247";	 /* 247 : division sign */
entityToCharacterMap["&oslash"]			= "248";	 /* 248 : Latin small letter o with stroke */
entityToCharacterMap["&ugrave"]			= "249";	 /* 249 : Latin small letter u with grave */
entityToCharacterMap["&uacute"]			= "250";	 /* 250 : Latin small letter u with acute */
entityToCharacterMap["&ucirc"]			= "251";	 /* 251 : Latin small letter u with circumflex */
entityToCharacterMap["&uuml"]			= "252";	 /* 252 : Latin small letter u with diaeresis */
entityToCharacterMap["&yacute"]			= "253";	 /* 253 : Latin small letter y with acute */
entityToCharacterMap["&thorn"]			= "254";	 /* 254 : Latin small letter thorn */
entityToCharacterMap["&yuml"]			= "255";	 /* 255 : Latin small letter y with diaeresis */
entityToCharacterMap["&OElig"]			= "338";	 /* 338 : Latin capital ligature oe */
entityToCharacterMap["&oelig"]			= "339";	 /* 339 : Latin small ligature oe */
entityToCharacterMap["&Scaron"]			= "352";	 /* 352 : Latin capital letter s with caron */
entityToCharacterMap["&scaron"]			= "353";	 /* 353 : Latin small letter s with caron */
entityToCharacterMap["&Yuml"]			= "376";	 /* 376 : Latin capital letter y with diaeresis */
entityToCharacterMap["&fnof"]			= "402";	 /* 402 : Latin small letter f with hook */
entityToCharacterMap["&circ"]			= "710";	 /* 710 : modifier letter circumflex accent */
entityToCharacterMap["&tilde"]			= "732";	 /* 732 : small tilde */
entityToCharacterMap["&Alpha"]			= "913";	 /* 913 : Greek capital letter alpha */
entityToCharacterMap["&Beta"]			= "914";	 /* 914 : Greek capital letter beta */
entityToCharacterMap["&Gamma"]			= "915";	 /* 915 : Greek capital letter gamma */
entityToCharacterMap["&Delta"]			= "916";	 /* 916 : Greek capital letter delta */
entityToCharacterMap["&Epsilon"]			= "917";	 /* 917 : Greek capital letter epsilon */
entityToCharacterMap["&Zeta"]			= "918";	 /* 918 : Greek capital letter zeta */
entityToCharacterMap["&Eta"]			    = "919";	 /* 919 : Greek capital letter eta */
entityToCharacterMap["&Theta"]			= "920";	 /* 920 : Greek capital letter theta */
entityToCharacterMap["&Iota"]			= "921";	 /* 921 : Greek capital letter iota */
entityToCharacterMap["&Kappa"]			= "922";	 /* 922 : Greek capital letter kappa */
entityToCharacterMap["&Lambda"]			= "923";	 /* 923 : Greek capital letter lambda */
entityToCharacterMap["&Mu"]			= "924";	 /* 924 : Greek capital letter mu */
entityToCharacterMap["&Nu"]			= "925";	 /* 925 : Greek capital letter nu */
entityToCharacterMap["&Xi"]			= "926";	 /* 926 : Greek capital letter xi */
entityToCharacterMap["&Omicron"]			= "927";	 /* 927 : Greek capital letter omicron */
entityToCharacterMap["&Pi"]			= "928";	 /* 928 : Greek capital letter pi */
entityToCharacterMap["&Rho"]			= "929";	 /* 929 : Greek capital letter rho */
entityToCharacterMap["&Sigma"]			= "931";	 /* 931 : Greek capital letter sigma */
entityToCharacterMap["&Tau"]			= "932";	 /* 932 : Greek capital letter tau */
entityToCharacterMap["&Upsilon"]			= "933";	 /* 933 : Greek capital letter upsilon */
entityToCharacterMap["&Phi"]			= "934";	 /* 934 : Greek capital letter phi */
entityToCharacterMap["&Chi"]			= "935";	 /* 935 : Greek capital letter chi */
entityToCharacterMap["&Psi"]			= "936";	 /* 936 : Greek capital letter psi */
entityToCharacterMap["&Omega"]			= "937";	 /* 937 : Greek capital letter omega */
entityToCharacterMap["&alpha"]			= "945";	 /* 945 : Greek small letter alpha */
entityToCharacterMap["&beta"]			= "946";	 /* 946 : Greek small letter beta */
entityToCharacterMap["&gamma"]			= "947";	 /* 947 : Greek small letter gamma */
entityToCharacterMap["&delta"]			= "948";	 /* 948 : Greek small letter delta */
entityToCharacterMap["&epsilon"]			= "949";	 /* 949 : Greek small letter epsilon */
entityToCharacterMap["&zeta"]			= "950";	 /* 950 : Greek small letter zeta */
entityToCharacterMap["&eta"]			= "951";	 /* 951 : Greek small letter eta */
entityToCharacterMap["&theta"]			= "952";	 /* 952 : Greek small letter theta */
entityToCharacterMap["&iota"]			= "953";	 /* 953 : Greek small letter iota */
entityToCharacterMap["&kappa"]			= "954";	 /* 954 : Greek small letter kappa */
entityToCharacterMap["&lambda"]			= "955";	 /* 955 : Greek small letter lambda */
entityToCharacterMap["&mu"]			= "956";	 /* 956 : Greek small letter mu */
entityToCharacterMap["&nu"]			= "957";	 /* 957 : Greek small letter nu */
entityToCharacterMap["&xi"]			= "958";	 /* 958 : Greek small letter xi */
entityToCharacterMap["&omicron"]			= "959";	 /* 959 : Greek small letter omicron */
entityToCharacterMap["&pi"]			= "960";	 /* 960 : Greek small letter pi */
entityToCharacterMap["&rho"]			= "961";	 /* 961 : Greek small letter rho */
entityToCharacterMap["&sigmaf"]			= "962";	 /* 962 : Greek small letter final sigma */
entityToCharacterMap["&sigma"]			= "963";	 /* 963 : Greek small letter sigma */
entityToCharacterMap["&tau"]			= "964";	 /* 964 : Greek small letter tau */
entityToCharacterMap["&upsilon"]			= "965";	 /* 965 : Greek small letter upsilon */
entityToCharacterMap["&phi"]			= "966";	 /* 966 : Greek small letter phi */
entityToCharacterMap["&chi"]			= "967";	 /* 967 : Greek small letter chi */
entityToCharacterMap["&psi"]			= "968";	 /* 968 : Greek small letter psi */
entityToCharacterMap["&omega"]			= "969";	 /* 969 : Greek small letter omega */
entityToCharacterMap["&thetasym"]			= "977";	 /* 977 : Greek theta symbol */
entityToCharacterMap["&upsih"]			= "978";	 /* 978 : Greek upsilon with hook symbol */
entityToCharacterMap["&piv"]			= "982";	 /* 982 : Greek pi symbol */
entityToCharacterMap["&ensp"]			= "8194";	 /* 8194 : en space */
entityToCharacterMap["&emsp"]			= "8195";	 /* 8195 : em space */
entityToCharacterMap["&thinsp"]			= "8201";	 /* 8201 : thin space */
entityToCharacterMap["&zwnj"]            = "8204"; /* 8204 : zero width non-joiner */
entityToCharacterMap["&zwj"]			= "8205";	 /* 8205 : zero width joiner */
entityToCharacterMap["&lrm"]             = "8206"; /* 8206 : left-to-right mark */
entityToCharacterMap["&rlm"]             = "8207"; /* 8207 : right-to-left mark */
entityToCharacterMap["&ndash"]			= "8211";	 /* 8211 : en dash */
entityToCharacterMap["&mdash"]			= "8212";	 /* 8212 : em dash */
entityToCharacterMap["&lsquo"]			= "8216";	 /* 8216 : left single quotation mark */
entityToCharacterMap["&rsquo"]			= "8217";	 /* 8217 : right single quotation mark */
entityToCharacterMap["&sbquo"]           = "8218";  /* 8218 : single low-9 quotation mark */
entityToCharacterMap["&ldquo"]			= "8220";	 /* 8220 : left double quotation mark */
entityToCharacterMap["&rdquo"]			= "8221";	 /* 8221 : right double quotation mark */
entityToCharacterMap["&bdquo"]           = "8222";  /* 8222 : double low-9 quotation mark */
entityToCharacterMap["&dagger"]			= "8224";	 /* 8224 : dagger */
entityToCharacterMap["&Dagger"]			= "8225";	 /* 8225 : double dagger */
entityToCharacterMap["&bull"]			= "8226";	 /* 8226 : bullet */
entityToCharacterMap["&hellip"]			= "8230";	 /* 8230 : horizontal ellipsis */
entityToCharacterMap["&permil"]			= "8240";	 /* 8240 : per mille sign */
entityToCharacterMap["&prime"]			= "8242";	 /* 8242 : prime */
entityToCharacterMap["&Prime"]			= "8243";	 /* 8243 : double prime */
entityToCharacterMap["&lsaquo"]          = "8249";  /* 8249 : single left-pointing angle quotation mark */
entityToCharacterMap["&rsaquo"]          = "8250";  /* 8250 : single right-pointing angle quotation mark */
entityToCharacterMap["&oline"]			= "8254";	 /* 8254 : overline */
entityToCharacterMap["&frasl"]			= "8260";	 /* 8260 : fraction slash */
entityToCharacterMap["&euro"]			= "8364";	 /* 8364 : euro sign */
entityToCharacterMap["&image"]           = "8365";  /* 8465 : black-letter capital i */
entityToCharacterMap["&weierp"]          = "8472";  /* 8472 : script capital p, Weierstrass p */
entityToCharacterMap["&real"]            = "8476";  /* 8476 : black-letter capital r */
entityToCharacterMap["&trade"]			= "8482";	 /* 8482 : trademark sign */
entityToCharacterMap["&alefsym"]			= "8501";	 /* 8501 : alef symbol */
entityToCharacterMap["&larr"]			= "8592";	 /* 8592 : leftwards arrow */
entityToCharacterMap["&uarr"]			= "8593";	 /* 8593 : upwards arrow */
entityToCharacterMap["&rarr"]			= "8594";	 /* 8594 : rightwards arrow */
entityToCharacterMap["&darr"]			= "8595";	 /* 8595 : downwards arrow */
entityToCharacterMap["&harr"]			= "8596";	 /* 8596 : left right arrow */
entityToCharacterMap["&crarr"]			= "8629";	 /* 8629 : downwards arrow with corner leftwards */
entityToCharacterMap["&lArr"]			= "8656";	 /* 8656 : leftwards double arrow */
entityToCharacterMap["&uArr"]			= "8657";	 /* 8657 : upwards double arrow */
entityToCharacterMap["&rArr"]			= "8658";	 /* 8658 : rightwards double arrow */
entityToCharacterMap["&dArr"]			= "8659";	 /* 8659 : downwards double arrow */
entityToCharacterMap["&hArr"]			= "8660";	 /* 8660 : left right double arrow */
entityToCharacterMap["&forall"]			= "8704";	 /* 8704 : for all */
entityToCharacterMap["&part"]			= "8706";	 /* 8706 : partial differential */
entityToCharacterMap["&exist"]			= "8707";	 /* 8707 : there exists */
entityToCharacterMap["&empty"]			= "8709";	 /* 8709 : empty set */
entityToCharacterMap["&nabla"]			= "8711";	 /* 8711 : nabla */
entityToCharacterMap["&isin"]			= "8712";	 /* 8712 : element of */
entityToCharacterMap["&notin"]			= "8713";	 /* 8713 : not an element of */
entityToCharacterMap["&ni"]			    = "8715";	 /* 8715 : contains as member */
entityToCharacterMap["&prod"]            = "8719";  /* 8719 : n-ary product */
entityToCharacterMap["&sum"]             = "8721";  /* 8721 : n-ary summation */
entityToCharacterMap["&minus"]			= "8722";	 /* 8722 : minus sign */
entityToCharacterMap["&lowast"]			= "8727";	 /* 8727 : asterisk operator */
entityToCharacterMap["&radic"]			= "8730";	 /* 8730 : square root */
entityToCharacterMap["&prop"]			= "8733";	 /* 8733 : proportional to */
entityToCharacterMap["&infin"]			= "8734";	 /* 8734 : infinity */
entityToCharacterMap["&ang"]			= "8736";	 /* 8736 : angle */
entityToCharacterMap["&and"]			= "8743";	 /* 8743 : logical and */
entityToCharacterMap["&or"]			= "8744";	 /* 8744 : logical or */
entityToCharacterMap["&cap"]			= "8745";	 /* 8745 : intersection */
entityToCharacterMap["&cup"]			= "8746";	 /* 8746 : union */
entityToCharacterMap["&int"]			= "8747";	 /* 8747 : integral */
entityToCharacterMap["&there4"]			= "8756";	 /* 8756 : therefore */
entityToCharacterMap["&sim"]			= "8764";	 /* 8764 : tilde operator */
entityToCharacterMap["&cong"]			= "8773";	 /* 8773 : congruent to */
entityToCharacterMap["&asymp"]			= "8776";	 /* 8776 : almost equal to */
entityToCharacterMap["&ne"]			= "8800";	 /* 8800 : not equal to */
entityToCharacterMap["&equiv"]           = "8801";   /* 8801 : identical to, equivalent to */
entityToCharacterMap["&le"]              = "8804"; /* 8804 : less-than or equal to */
entityToCharacterMap["&ge"]              = "8805"; /* 8805 : greater-than or equal to */
entityToCharacterMap["&sub"]			= "8834";	 /* 8834 : subset of */
entityToCharacterMap["&sup"]			= "8835";	 /* 8835 : superset of */
entityToCharacterMap["&nsub"]			= "8836";	 /* 8836 : not a subset of */
entityToCharacterMap["&sube"]			= "8838";	 /* 8838 : subset of or equal to */
entityToCharacterMap["&supe"]			= "8839";	 /* 8839 : superset of or equal to */
entityToCharacterMap["&oplus"]			= "8853";	 /* 8853 : circled plus */
entityToCharacterMap["&otimes"]			= "8855";	 /* 8855 : circled times */
entityToCharacterMap["&perp"]			= "8869";	 /* 8869 : up tack */
entityToCharacterMap["&sdot"]			= "8901";	 /* 8901 : dot operator */
entityToCharacterMap["&lceil"]			= "8968";	 /* 8968 : left ceiling */
entityToCharacterMap["&rceil"]			= "8969";	 /* 8969 : right ceiling */
entityToCharacterMap["&lfloor"]			= "8970";	 /* 8970 : left floor */
entityToCharacterMap["&rfloor"]			= "8971";	 /* 8971 : right floor */
entityToCharacterMap["&lang"]            = "9001";  /* 9001 : left-pointing angle bracket */
entityToCharacterMap["&rang"]            = "9002";  /* 9002 : right-pointing angle bracket */
entityToCharacterMap["&loz"]			= "9674";	 /* 9674 : lozenge */
entityToCharacterMap["&spades"]			= "9824";	 /* 9824 : black spade suit */
entityToCharacterMap["&clubs"]			= "9827";	 /* 9827 : black club suit */
entityToCharacterMap["&hearts"]			= "9829";	 /* 9829 : black heart suit */
entityToCharacterMap["&diams"]			= "9830";	 /* 9830 : black diamond suit */

var characterToEntityMap = [];

for ( var entity in entityToCharacterMap ) {
    characterToEntityMap[entityToCharacterMap[entity]] = entity;
}
$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.HTMLEntityCodec = function() {
    var _super = new org.owasp.esapi.codecs.Codec();

    var getNumericEntity = function(input) {
        var first = input.peek();
        if (first == null) {
            return null;
        }

        if (first == 'x' || first == 'X') {
            input.next();
            return parseHex(input);
        }
        return parseNumber(input);
    };

    var parseNumber = function(input) {
        var out = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[0-9]/)) {
                out += c;
                input.next();
            } else if (c == ';') {
                input.next();
                break;
            } else {
                break;
            }
        }

        try {
            return parseInt(out);
        } catch (e) {
            return null;
        }
    };

    var parseHex = function(input) {
        var out = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[0-9A-Fa-f]/)) {
                out += c;
                input.next();
            } else if (c == ';') {
                input.next();
                break;
            } else {
                break;
            }
        }
        try {
            return parseInt(out, 16);
        } catch (e) {
            return null;
        }
    };

    var getNamedEntity = function(input) {
        var entity = '';
        while (input.hasNext()) {
            var c = input.peek();
            if (c.match(/[A-Za-z]/)) {
                entity += c;
                input.next();
                if (entityToCharacterMap.containsKey('&' + entity)) {
                    if (input.peek(';')) input.next();
                    break;
                }
            } else if (c == ';') {
                input.next();
            } else {
                break;
            }
        }

        return String.fromCharCode(entityToCharacterMap.getCaseInsensitive('&' + entity));
    };

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (aImmune.indexOf(c) > -1) {
                return c;
            }

            var hex = org.owasp.esapi.codecs.Codec.getHexForNonAlphanumeric(c);
            if (hex == null) {
                return c;
            }

            var cc = c.charCodeAt(0);
            if (( cc <= 0x1f && c != '\t' && c != '\n' && c != '\r' ) || ( cc >= 0x7f && cc <= 0x9f ) || c == ' ') {
                return " ";
            }

            var entityName = characterToEntityMap[cc];
            if (entityName != null) {
                return entityName + ";";
            }

            return "&#x" + hex + ";";
        },

        decodeCharacter: function(oPushbackString) {
            //noinspection UnnecessaryLocalVariableJS
            var input = oPushbackString;
            input.mark();
            var first = input.next();
            if (first == null || first != '&') {
                input.reset();
                return null;
            }

            var second = input.next();
            if (second == null) {
                input.reset();
                return null;
            }

            if (second == '#') {
                var c = getNumericEntity(input);
                if (c != null) {
                    return c;
                }
            } else if (second.match(/[A-Za-z]/)) {
                input.pushback(second);
                c = getNamedEntity(input);
                if (c != null) {
                    return c;
                }
            }
            input.reset();
            return null;
        }
    };
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.JavascriptCodec = function() {
    var _super = new org.owasp.esapi.codecs.Codec();

    return {
        encode: function(aImmune, sInput) {
            var out = '';
            for (var idx = 0; idx < sInput.length; idx ++) {
                var ch = sInput.charAt(idx);
                if (aImmune.indexOf(ch) > -1) {
                    out += ch;
                }
                else {
                    var hex = org.owasp.esapi.codecs.Codec.getHexForNonAlphanumeric(ch);
                    if (hex == null) {
                        out += ch;
                    }
                    else {
                        var tmp = ch.charCodeAt(0).toString(16);
                        if (ch.charCodeAt(0) < 256) {
                            var pad = "00".substr(tmp.length);
                            out += "\\x" + pad + tmp.toUpperCase();
                        }
                        else {
                            pad = "0000".substr(tmp.length);
                            out += "\\u" + pad + tmp.toUpperCase();
                        }
                    }
                }
            }
            return out;
        },

        decode: _super.decode,

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null) {
                oPushbackString.reset();
                return null;
            }

            if (first != '\\') {
                oPushbackString.reset();
                return null;
            }

            var second = oPushbackString.next();
            if (second == null) {
                oPushbackString.reset();
                return null;
            }

            // \0 collides with the octal decoder and is non-standard
            // if ( second.charValue() == '0' ) {
            //      return Character.valueOf( (char)0x00 );
            if (second == 'b') {
                return 0x08;
            } else if (second == 't') {
                return 0x09;
            } else if (second == 'n') {
                return 0x0a;
            } else if (second == 'v') {
                return 0x0b;
            } else if (second == 'f') {
                return 0x0c;
            } else if (second == 'r') {
                return 0x0d;
            } else if (second == '\"') {
                return 0x22;
            } else if (second == '\'') {
                return 0x27;
            } else if (second == '\\') {
                return 0x5c;
            } else if (second.toLowerCase() == 'x') {
                out = '';
                for (var i = 0; i < 2; i++) {
                    var c = oPushbackString.nextHex();
                    if (c != null) {
                        out += c;
                    } else {
                        input.reset();
                        return null;
                    }
                }
                try {
                    n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            } else if (second.toLowerCase() == 'u') {
                out = '';
                for (i = 0; i < 4; i++) {
                    c = oPushbackString.nextHex();
                    if (c != null) {
                        out += c;
                    } else {
                        input.reset();
                        return null;
                    }
                }
                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            } else if (oPushbackString.isOctalDigit(second)) {
                var out = second;
                var c2 = oPushbackString.next();
                if (!oPushbackString.isOctalDigit(c2)) {
                    oPushbackString.pushback(c2);
                } else {
                    out += c2;
                    var c3 = oPushbackString.next();
                    if (!oPushbackString.isOctalDigit(c3)) {
                        oPushbackString.pushback(c3);
                    } else {
                        out += c3;
                    }
                }

                try {
                    n = parseInt(out, 8);
                    return String.fromCharCode(n);
                } catch (e) {
                    oPushbackString.reset();
                    return null;
                }
            }
            return second;
        }
    };
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.PercentCodec = function() {
    var _super = new org.owasp.esapi.codecs.Codec();

    var ALPHA_NUMERIC_STR = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    var RFC_NON_ALPHANUMERIC_UNRESERVED_STR = "-._~";
    var ENCODED_NON_ALPHA_NUMERIC_UNRESERVED = true;
    var UNENCODED_STR = ALPHA_NUMERIC_STR + (ENCODED_NON_ALPHA_NUMERIC_UNRESERVED ? "" : RFC_NON_ALPHANUMERIC_UNRESERVED_STR);

    var getTwoUpperBytes = function(b) {
        var out = '';
        if (b < -128 || b > 127) {
            throw new IllegalArgumentException("b is not a byte (was " + b + ")");
        }
        b &= 0xFF;
        if (b < 0x10) {
            out += '0';
        }
        return out + b.toString(16).toUpperCase();
    };

    return {
        encode: _super.encode,

        decode: _super.decode,

        encodeCharacter: function(aImmune, c) {
            if (UNENCODED_STR.indexOf(c) > -1) {
                return c;
            }

            var bytes = org.owasp.esapi.codecs.UTF8.encode(c);
            var out = '';
            for (var b = 0; b < bytes.length; b++) {
                out += '%' + getTwoUpperBytes(bytes.charCodeAt(b));
            }
            return out;
        },

        decodeCharacter: function(oPushbackString) {
            oPushbackString.mark();
            var first = oPushbackString.next();
            if (first == null || first != '%') {
                oPushbackString.reset();
                return null;
            }

            var out = '';
            for (var i = 0; i < 2; i++) {
                var c = oPushbackString.nextHex();
                if (c != null) {
                    out += c;
                }
            }
            if (out.length == 2) {
                try {
                    var n = parseInt(out, 16);
                    return String.fromCharCode(n);
                } catch (e) {
                }
            }
            oPushbackString.reset();
            return null;
        }
    };
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.PushbackString = function(sInput) {
    var _input = sInput,
        _pushback = '',
        _temp = '',
        _index = 0,
        _mark = 0;

    return {
        pushback: function(c) {
            _pushback = c;
        },

        index: function() {
            return _index;
        },

        hasNext: function() {
            if (_pushback != null) return true;
            return !(_input == null || _input.length == 0 || _index >= _input.length);

        },

        next: function() {
            if (_pushback != null) {
                var save = _pushback;
                _pushback = null;
                return save;
            }
            if (_input == null || _input.length == 0 || _index >= _input.length) {
                return null;
            }
            return _input.charAt(_index++);
        },

        nextHex: function() {
            var c = this.next();
            if (this.isHexDigit(c)) return c;
            return null;
        },

        nextOctal: function() {
            var c = this.next();
            if (this.isOctalDigit(c)) return c;
            return null;
        },

        isHexDigit: function(c) {
            return c != null && ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'f' ) || ( c >= 'A' && c <= 'F' ) );
        },

        isOctalDigit: function(c) {
            return c != null && ( c >= '0' && c <= '7' );
        },

        peek: function(c) {
            if (!c) {
                if (_pushback != null) return _pushback;
                if (_input == null || _input.length == 0 || _index >= _input.length) return null;
                return _input.charAt(_index);
            } else {
                if (_pushback != null && _pushback == c) return true;
                if (_input == null || _input.length == 0 || _index >= _input.length) return false;
                return _input.charAt(_index) == c;
            }
        },

        mark: function() {
            _temp = _pushback;
            _mark = _index;
        },

        reset: function() {
            _pushback = _temp;
            _index = _mark;
        },

        remainder: function() {
            var out = _input.substr(_index);
            if (_pushback != null) {
                out = _pushback + out;
            }
            return out;
        }
    };
};

$namespace('org.owasp.esapi.codecs');

org.owasp.esapi.codecs.UTF8 = {
    encode: function(sInput) {
        var input = sInput.replace(/\r\n/g, "\n");
        var utftext = '';

        for (var n = 0; n < input.length; n ++) {
            var c = input.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if (( c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }

        return utftext;
    }
    ,

    decode: function(sInput) {
        var out = '';
        var i = c = c1 = c2 = 0;

        while (i < sInput.length) {
            c = sInput.charCodeAt(i);

            if (c < 128) {
                out += String.fromCharCode(c);
                i ++;
            }
            else if ((c > 191) && (c < 224)) {
                c2 = sInput.charCodeAt(i + 1);
                out += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }

        return out;
    }
};

$namespace('org.owasp.esapi.i18n');

org.owasp.esapi.i18n.ArrayResourceBundle = function( sName, oLocale, aMessages, oParent ) {
    with(org.owasp.esapi.i18n) var _super = new ResourceBundle( sName, oLocale, oParent );

    var messages = aMessages;

    return {
        getParent: _super.getParent,
        getLocale: _super.getLocale,
        getName: _super.getName,
        getString: _super.getString,
        getMessage: function(sKey) {
            return messages[sKey];
        }
    };
};

$namespace('org.owasp.esapi.i18n');

org.owasp.esapi.i18n.Locale = function( sLanguage, sCountry, sVariant ) {
    var language = sLanguage, country = sCountry, variant = sVariant;

    return {
        getLanguage: function() { return language; },
        getCountry: function() { return country; },
        getVariant: function() { return variant; },
        toString: function() { return language + ( country ? "-" + country + ( variant ? "-" + variant : "" ) : "" ); }
    };
};

org.owasp.esapi.i18n.Locale.US = new org.owasp.esapi.i18n.Locale("en","US");
org.owasp.esapi.i18n.Locale.GB = new org.owasp.esapi.i18n.Locale("en","GB");

org.owasp.esapi.i18n.Locale.getLocale = function(sLocale) {
    var l = sLocale.split("-");
    return new org.owasp.esapi.i18n.Locale( l[0], (l.length>1?l[1]:""), (l.length>2?l.length[2]:""));
};

org.owasp.esapi.i18n.Locale.getDefault = function() {
    var l = (navigator['language']?navigator['language']:(navigator['userLanguage']?navigator['userLanguage']:'en-US')).split("-");
    return new org.owasp.esapi.i18n.Locale( l[0], (l.length>1?l[1]:""), (l.length>2?l.length[2]:""));
};

$namespace('org.owasp.esapi.i18n');

org.owasp.esapi.i18n.ObjectResourceBundle = function( oResource, oParent ) {
    var _super = new org.owasp.esapi.i18n.ResourceBundle( oResource.name, org.owasp.esapi.i18n.Locale.getLocale(oResource.locale), oParent );

    var messages = oResource.messages;

    return {
        getParent: _super.getParent,
        getLocale: _super.getLocale,
        getName: _super.getName,
        getString: _super.getString,
        getMessage: function(sKey) {
            return messages[sKey];
        }
    };
};

$namespace('org.owasp.esapi.i18n');

org.owasp.esapi.i18n.ResourceBundle = function( sName, oLocale, oParentResourceBundle ) {
    var parent = oParentResourceBundle;
    var locale = oLocale;
    var name = sName;

    if ( !name ) throw new SyntaxError("Name required for implementations of org.owasp.esapi.i18n.ResourceBundle");
    if ( !locale ) throw new SyntaxError("Locale required for implementations of org.owasp.esapi.i18n.ResourceBundle");

    return {
        getParent: function() { return parent; },
        getLocale: function() { return locale; },
        getName: function() { return name; },
        getMessage: function(sKey) { return sKey; },
        getString: function( sKey, oContextMap ) {
            if ( arguments.length < 1 ) {
                throw new IllegalArgumentException("No key passed to getString");
            }

            var msg = this.getMessage(sKey);
            if ( !msg ) {
                if ( parent ) {
                    return parent.getString( sKey, oContextMap );
                } else {
                    return sKey;
                }
            }

            if ( !msg.match( /\{([A-Za-z]+)\}/ ) || !oContextMap ) {
                return msg;
            }

            var out = '', lastIndex = 0;
            while (true) {
                var nextVarIdx = msg.indexOf( "{", lastIndex );
                var endIndex = msg.indexOf( "}", nextVarIdx );

                if ( nextVarIdx < 0 ) {
                    out += msg.substr( lastIndex, msg.length-lastIndex );
                    break;
                }

                if ( nextVarIdx >= 0 && endIndex < -1 ) {
                    throw new SyntaxError("Invalid Message - Unclosed Context Reference: " + msg );
                }

                out += msg.substring( lastIndex, nextVarIdx );
                var contextKey = msg.substring( nextVarIdx+1, endIndex );
                if ( oContextMap[contextKey] ) {
                    out += oContextMap[contextKey];
                } else {
                    out += msg.substring( nextVarIdx, endIndex+1 );
                }

                lastIndex = endIndex + 1;
            }

            return out;
        }
    };
};

org.owasp.esapi.i18n.ResourceBundle.getResourceBundle = function(sResource, oLocale) {
    var classname = sResource + "_" + oLocale.toString().replace("-","_");

    with( org.owasp.esapi.i18n ) {
        if ( ResourceBundle[classname] instanceof Object ) {
            return ResourceBundle[classname];
        } else {
            return new ResourceBundle[classname]();
        }
    }
};
$namespace('org.owasp.esapi.net');

/**
 * Constructs a cookie with a specified name and value.
 * <p/>
 * The name must conform to RFC 2109. That means it can contain only ASCII alphanumeric characters and cannot contain
 * commas, semicolons, or white space or begin with a $ character. The cookie's name cannot be changed after creation.
 * <p/>
 * The value can be anything the server chooses to send. Its value is probably of interest only to the server. The
 * cookie's value can be changed after creation with the setValue method.
 * <p/>
 * By default, cookies are created according to the Netscape cookie specification. The version can be changed with the
 * {@link #setVersion} method.
 *
 * @constructor
 * @param sName {String} a <code>String</code> specifying the name of the cookie
 * @param sValue {String} a <code>String</code> specifying the value of the cookie
 * @throws  IllegalArgumentException
 *          if the cookie name contains illegal characters (for example, a comma, space, or semicolon) or it is one of
 *          the tokens reserved for use by the cookie protocol
 */
org.owasp.esapi.net.Cookie = function( sName, sValue ) {
    var name;       // NAME= ... "$Name" style is reserved
    var value;      // value of NAME

    var comment;    // ;Comment=VALUE ... describes the cookies use
    var domain;     // ;Domain=VALUE ... domain that sees the cookie
    var maxAge;     // ;Max-Age=VALUE ... cookies auto-expire
    var path;       // ;Path=VALUE ... URLs that see the cookie
    var secure;     // ;Secure ... e.g. use SSL
    var version;    // ;Version=1 ... means RFC-2109++ style

    var _resourceBundle = $ESAPI.resourceBundle();

    var tSpecials = ",; ";

    var isToken = function(sValue) {
        for(var i=0,len=sValue.length;i<len;i++) {
            var cc = sValue.charCodeAt(i),c=sValue.charAt(i);
            if (cc<0x20||cc>=0x7F||tSpecials.indexOf(c)!=-1) {
                return false;
            }
        }
        return true;
    };

    if ( !isToken(sName)
        || sName.toLowerCase() == 'comment'
        || sName.toLowerCase() == 'discard'
        || sName.toLowerCase() == 'domain'
        || sName.toLowerCase() == 'expires'
        || sName.toLowerCase() == 'max-age'
        || sName.toLowerCase() == 'path'
        || sName.toLowerCase() == 'secure'
        || sName.toLowerCase() == 'version'
        || sName.charAt(0) == '$' ) {
        var errMsg = _resourceBundle.getString( "Cookie.Name", { 'name':sName } );
        throw new IllegalArgumentException(errMsg);
    }

    name = sName;
    value = sValue;

    return {
        setComment: function(purpose) { comment = purpose; },
        getComment: function() { return comment; },
        setDomain: function(sDomain) { domain = sDomain.toLowerCase(); },
        getDomain: function() { return domain; },
        setMaxAge: function(nExpirey) { maxAge = nExpirey; },
        getMaxAge: function() { return maxAge; },
        setPath: function(sPath) { path = sPath; },
        getPath: function() { return path; },
        setSecure: function(bSecure) { secure = bSecure; },
        getSecure: function() { return secure; },
        getName: function() { return name; },
        setValue: function(sValue) { value = sValue; },
        getValue: function() { return value; },
        setVersion: function(nVersion) {
            if(nVersion<0||nVersion>1)throw new IllegalArgumentException(_resourceBundle.getString("Cookie.Version", { 'version':nVersion } ) );
            version = nVersion;
        },
        getVersion: function() { return version; }
    };
};
$namespace('org.owasp.esapi.reference.encoding');

org.owasp.esapi.reference.encoding.DefaultEncoder = function(aCodecs) {
    var _codecs = [],
        _htmlCodec = new org.owasp.esapi.codecs.HTMLEntityCodec(),
        _javascriptCodec = new org.owasp.esapi.codecs.JavascriptCodec(),
        _cssCodec = new org.owasp.esapi.codecs.CSSCodec(),
        _percentCodec = new org.owasp.esapi.codecs.PercentCodec();

    if (!aCodecs) {
        _codecs.push(_htmlCodec);
        _codecs.push(_javascriptCodec);
        _codecs.push(_cssCodec);
        _codecs.push(_percentCodec);
    } else {
        _codecs = aCodecs;
    }

    var IMMUNE_HTML = new Array(',', '.', '-', '_', ' ');
    var IMMUNE_HTMLATTR = new Array(',', '.', '-', '_');
    var IMMUNE_CSS = new Array();
    var IMMUNE_JAVASCRIPT = new Array(',', '.', '_');

    return {
        cananicalize: function(sInput, bStrict) {
            if (!sInput) {
                return null;
            }
            var working = sInput, codecFound = null, mixedCount = 1, foundCount = 0, clean = false;
            while (!clean) {
                clean = true;

                _codecs.each(function(codec) {
                    var old = working;
                    working = codec.decode(working);

                    if (old != working) {
                        if (codecFound != null && codecFound != codec) {
                            mixedCount ++;
                        }
                        codecFound = codec;
                        if (clean) {
                            foundCount ++;
                        }
                        clean = false;
                    }
                });
            }

            if (foundCount >= 2 && mixedCount > 1) {
                if (bStrict) {
                    throw new org.owasp.esapi.IntrusionException("Input validation failure", "Multiple (" + foundCount + "x) and mixed encoding (" + mixedCount + "x) detected in " + sInput);
                }
            }
            else if (foundCount >= 2) {
                if (bStrict) {
                    throw new org.owasp.esapi.IntrusionException("Input validation failure", "Multiple (" + foundCount + "x) encoding detected in " + sInput);
                }
            }
            else if (mixedCount > 1) {
                if (bStrict) {
                    throw new org.owasp.esapi.IntrusionException("Input validation failure", "Mixed (" + mixedCount + "x) encoding detected in " + sInput);
                }
            }
            return working;
        },

        normalize: function(sInput) {
            return sInput.replace(/[^\x00-\x7F]/g, '');
        },

        encodeForHTML: function(sInput) {
            return !sInput ? null : _htmlCodec.encode(IMMUNE_HTML, sInput);
        },

        decodeForHTML: function(sInput) {
            return !sInput ? null : _htmlCodec.decode(sInput);
        },

        encodeForHTMLAttribute: function(sInput) {
            return !sInput ? null : _htmlCodec.encode(IMMUNE_HTMLATTR, sInput);
        },

        encodeForCSS: function(sInput) {
            return !sInput ? null : _cssCodec.encode(IMMUNE_CSS, sInput);
        },

        encodeForJavaScript: function(sInput) {
            return !sInput ? null : _javascriptCodec.encode(IMMUNE_JAVASCRIPT, sInput);
        },

        encodeForJavascript: this.encodeForJavaScript,

        encodeForURL: function(sInput) {
            return !sInput ? null : escape(sInput);
        },

        decodeFromURL: function(sInput) {
            return !sInput ? null : unescape(sInput);
        },

        encodeForBase64: function(sInput) {
            return !sInput ? null : org.owasp.esapi.codecs.Base64.encode(sInput);
        },

        decodeFromBase64: function(sInput) {
            return !sInput ? null : org.owasp.esapi.codecs.Base64.decode(sInput);
        }
    };
};

$namespace('org.owasp.esapi.reference.logging');

org.owasp.esapi.reference.logging.Log4JSLogFactory = function() {
    var loggersMap = Array();

    var Log4JSLogger = function( sModuleName ) {
        var jsLogger = null;
        var moduleName = sModuleName?sModuleName:null;
        var Level = Log4js.Level;

        var logUrl = false, logApplicationName = false, encodingRequired = false, encodingFunction = $ESAPI.encoder().encodeForHTML;

        jsLogger = Log4js.getLogger( moduleName );

        var convertESAPILevel = function( nLevel ) {
            var Logger = org.owasp.esapi.Logger;
            switch (nLevel) {
                case Logger.OFF:        return Log4js.Level.OFF;
                case Logger.FATAL:      return Log4js.Level.FATAL;
                case Logger.ERROR:      return Log4js.Level.ERROR;
                case Logger.WARNING:    return Log4js.Level.WARN;
                case Logger.INFO:       return Log4js.Level.INFO;
                case Logger.DEBUG:      return Log4js.Level.DEBUG;
                case Logger.TRACE:      return Log4js.Level.TRACE;
                case Logger.ALL:        return Log4js.Level.ALL;
            }
        };

        return {
            setLevel: function( nLevel ) {
                try {
                    jsLogger.setLevel( convertESAPILevel( nLevel ) );
                } catch (e) {
                    this.error( org.owasp.esapi.Logger.SECURITY_FAILURE, "", e );
                }
            },

            trace: function( oEventType, sMessage, oException ) {
                this.log( Level.TRACE, oEventType, sMessage, oException );
            },

            debug: function( oEventType, sMessage, oException ) {
                this.log( Level.DEBUG, oEventType, sMessage, oException );
            },

            info: function( oEventType, sMessage, oException ) {
                this.log( Level.INFO, oEventType, sMessage, oException );
            },

            warning: function( oEventType, sMessage, oException ) {
                this.log( Level.WARN, oEventType, sMessage, oException );
            },

            error: function( oEventType, sMessage, oException ) {
                this.log( Level.ERROR, oEventType, sMessage, oException );
            },

            fatal: function( oEventType, sMessage, oException ) {
                this.log( Level.FATAL, oEventType, sMessage, oException );
            },

            log: function( oLevel, oEventType, sMessage, oException ) {
                switch(oLevel) {
                    case Level.TRACE:       if ( !jsLogger.isTraceEnabled() ) { return; } break;
                    case Level.DEBUG:       if ( !jsLogger.isDebugEnabled() ) { return; } break;
                    case Level.INFO:        if ( !jsLogger.isInfoEnabled()  ) { return; } break;
                    case Level.WARNING:     if ( !jsLogger.isWarnEnabled()  ) { return; } break;
                    case Level.ERROR:       if ( !jsLogger.isErrorEnabled() ) { return; } break;
                    case Level.FATAL:       if ( !jsLogger.isFatalEnabled() ) { return; } break;
                }

                if ( !sMessage ) {
                    sMessage = "";
                }

                sMessage = '[' + oEventType.toString() + '] - ' + sMessage;

                var clean = sMessage.replace("\n","_").replace("\r","_");
                if ( encodingRequired ) {
                    clean = encodingFunction(clean);
                    if ( clean != sMessage) {
                        clean += " [Encoded]";
                    }
                }

                var appInfo =   ( logUrl ? window.location.href : "" ) +
                    ( logApplicationName ? "/" + $ESAPI.properties.application.Name : "" );

                jsLogger.log( oLevel, ( appInfo != "" ? "[" + appInfo + "] " : "" ) + clean, oException );
            },

            addAppender: function( oAppender ) {
                jsLogger.addAppender( oAppender );
            },

            isLogUrl: function()                { return logUrl; },
            setLogUrl: function(b)              { logUrl = b; },
            isLogApplicationName: function()    { return logApplicationName; },
            setLogApplicationName: function(b)  { logApplicationName = b; },
            isEncodingRequired: function()      { return encodingRequired; },
            setEncodingRequired: function(b)    { encodingRequired = b; },
            setEncodingFunction: function(f)    { encodingFunction = f; },
            isDebugEnabled: function()          { return jsLogger.isDebugEnabled(); },
            isErrorEnabled: function()          { return jsLogger.isErrorEnabled(); },
            isFatalEnabled: function()          { return jsLogger.isFatalEnabled(); },
            isInfoEnabled: function()           { return jsLogger.isInfoEnabled(); },
            isTraceEnabled: function()          { return jsLogger.isTraceEnabled(); },
            isWarningEnabled: function()        { return jsLogger.isWarnEnabled(); }
        };
    };

    var getLoggerConfig = function( moduleName ) {
        var logConfig = $ESAPI.properties.logging;
        if ( logConfig[moduleName] ) {
            logConfig = logConfig[moduleName];
        }
        return logConfig;
    };

    return {
        getLogger: function ( moduleName ) {
            var key = ( typeof moduleName == 'string' ) ? moduleName : moduleName.constructor.toString();
            var logger = loggersMap[key];
            if ( !logger ) {
                logger = new Log4JSLogger(key);

                var logConfig = getLoggerConfig(moduleName);

                logger.setLevel( logConfig.Level );
                logger.setLogUrl( logConfig.LogUrl );
                logger.setLogApplicationName( logConfig.LogApplicationName );
                logger.setEncodingRequired( logConfig.EncodingRequired );

                if ( logConfig.EncodingFunction ) {
                    logger.setEncodingFunction( logConfig.EncodingFunction );
                }

                logConfig.Appenders.each(function(e){
                    if ( logConfig.Layout ) {
                        e.setLayout( logConfig.Layout );
                    }
                    logger.addAppender(e);
                });

                loggersMap[key] = logger;
            }
            return logger;
        }
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.BaseValidationRule = function( sTypeName, oEncoder, oLocale ) {
    var log = $ESAPI.logger( "Validation" );
    var EventType = org.owasp.esapi.Logger.EventType;

    var typename = sTypeName;
    var encoder = oEncoder?oEncoder:$ESAPI.encoder();
    var allowNull = false;

    var ResourceBundle = org.owasp.esapi.i18n.ResourceBundle;

    var locale = oLocale?oLocale:$ESAPI.locale();
    var resourceBundle;

    if ( $ESAPI.properties.validation.ResourceBundle ) {
        resourceBundle = ResourceBundle.getResourceBundle( $ESAPI.properties.validation.ResourceBundle, locale );
    }

    if ( !resourceBundle ) {
        resourceBundle = $ESAPI.resourceBundle();
        log.info( EventType.EVENT_FAILURE, "No Validation ResourceBundle - Defaulting to " + resourceBundle.getName() + "(" + resourceBundle.getLocale().toString() + ")" );
    }

    log.info( EventType.EVENT_SUCCESS, "Validation Rule Initialized with ResourceBundle: " + resourceBundle.getName() );

    return {
        setAllowNull: function(b) { allowNull = b; },

        isAllowNull: function() { return allowNull; },

        getTypeName: function() { return typename; },

        setTypeName: function(s) { typename = s; },

        setEncoder: function(oEncoder) { encoder = oEncoder; },

        getEncoder: function() { return encoder; },

        assertValid: function( sContext, sInput ) {
            this.getValid( sContext, sInput );
        },

        getValid: function( sContext, sInput, oValidationErrorList ) {
            var valid = null;
            try {
                valid = this.getValidInput( sContext, sInput );
            } catch (oValidationException) {
                return this.sanitize( sContext, sInput );
            }
            return valid;
        },

        getValidInput: function( sContext, sInput ) {
            return sInput;
        },

        getSafe: function( sContext, sInput ) {
            var valid = null;
            try {
                valid = this.getValidInput( sContext, sInput );
            } catch (oValidationException) {
                return this.sanitize( sContext, sInput );
            }
            return valid;
        },

        /**
         * The method is similar to ValidationRuile.getSafe except that it returns a
         * harmless object that <b>may or may not have any similarity to the original
         * input (in some cases you may not care)</b>. In most cases this should be the
         * same as the getSafe method only instead of throwing an exception, return
         * some default value.
         *
         * @param context
         * @param input
         * @return a parsed version of the input or a default value.
         */
        sanitize: function( sContext, sInput ) {
            return sInput;
        },

        isValid: function( sContext, sInput ) {
            var valid = false;
            try {
                this.getValidInput( sContext, sInput );
                valid = true;
            } catch (oValidationException) {
                return false;
            }
            return valid;
        },

        /**
         * Removes characters that aren't in the whitelist from the input String.
         * O(input.length) whitelist performance
         * @param input String to be sanitized
         * @param whitelist allowed characters
         * @return input stripped of all chars that aren't in the whitelist
         */
        whitelist: function( sInput, aWhitelist ) {
            var stripped = '';
            for ( var i=0;i<sInput.length;i++ ) {
                var c = sInput.charAt(i);
                if ( aWhitelist.indexOf(c) > -1 ) {
                    stripped += c;
                }
            }
            return stripped;
        },

        getUserMessage: function( sContext, sDefault, oContextValues ) {
            return this.getMessage( sContext+".Usr", sDefault+".Usr", oContextValues );
        },

        getLogMessage: function( sContext, sDefault, oContextValues ) {
            return this.getMessage( sContext+".Log", sDefault+".Log", oContextValues );
        },

        getMessage: function( sContext, sDefault, oContextValues ) {
            return resourceBundle.getString( sContext, oContextValues ) ? resourceBundle.getString( sContext, oContextValues ) : resourceBundle.getString( sDefault, oContextValues );
        },

        validationException: function( sContext, sDefault, sValidation, oContextValues ) {
            throw new org.owasp.esapi.reference.validation.ValidationException(
                this.getUserMessage( sContext+"."+sValidation, sDefault+"."+sValidation, oContextValues ),
                this.getLogMessage( sContext+"."+sValidation, sDefault+"."+sValidation, oContextValues ),
                sContext
            );
        }
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.CreditCardValidationRule = function( sTypeName, oEncoder, oLocale ) {
    var _super = new org.owasp.esapi.reference.validation.BaseValidationRule( sTypeName, oEncoder, oLocale );
    var _validationType = "CreditCard";

    var maxCardLength = 19;
    var ccrule;

    var readDefaultCreditCardRule = function() {
        var p = new RegExp( $ESAPI.properties.validation.CreditCard );
        var ccr = new org.owasp.esapi.reference.validation.StringValidationRule( "ccrule", _super.getEncoder(), oLocale, p );
        ccr.setMaxLength( maxCardLength );
        ccr.setAllowNull( false );
        return ccr;
    };

    ccRule = readDefaultCreditCardRule();

    var validCreditCardFormat = function( ccNum ) {
        var digitsonly = '';
        var c;
        for (var i=0;o<ccNum.length;i++) {
            c = ccNum.charAt(i);
            if ( c.match( /[0-9]/ ) ) digitsonly += c;
        }

        var sum = 0, digit = 0, addend = 0, timesTwo = false;

        for (var j=digitsonly.length-1; j>=0; j--) {
            digit = parseInt(digitsonly.substring(j,i+1));
            if ( timesTwo ) {
                addend = digit * 2;
                if ( addend > 9 ) addend -= 9;
            } else {
                addend = digit;
            }
            sum += addend;
            timesTwo = !timesTwo;
        }
        return sum % 10 == 0;
    };

    return {
        getMaxCardLength: function() { return maxCardLength; },

        setMaxCardLength: function(n) { maxCardLength = n; },

        setAllowNull: _super.setAllowNull,

        isAllowNull: _super.isAllowNull,

        getTypeName: _super.getTypeName,

        setTypeName: _super.setTypeName,

        setEncoder: _super.setEncoder,

        getEncoder: _super.getEncoder,

        assertValid: _super.assertValid,

        getValid: _super.getValid,

        getValidInput: function( sContext, sInput ) {
            if ( !sInput || sInput.trim() == '' ) {
                if ( this.isAllowNull() ) {
                    return null;
                }
                _super.validationException( sContext, _validationType, "Required", { "context":sContext, "input":sInput } );
            }

            var canonical = ccrule.getValid( sContext, sInput );

            if ( !validCreditCardFormat(canonical) ) {
                _super.validationException( sContext, _validationType, "Invalid", { "context":sContext, "input":sInput } );
            }

            return canonical;
        },

        getSafe: _super.getSafe,

        sanitize: function( sContext, sInput ) {
            return this.whitelist( sInput, org.owasp.esapi.EncoderConstants.CHAR_DIGITS );
        },

        isValid: _super.isValid,

        whitelist: _super.whitelist
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.DateValidationRule = function( sTypeName, oEncoder, oLocale ) {
    var _super = new org.owasp.esapi.reference.validation.BaseValidationRule( sTypeName, oEncoder, oLocale );
    var _validationTarget = "Date";

    var format = DateFormat.getDateInstance();

    var safelyParse = function(sContext,sInput) {
        if ( !sContext || sContext.trim() == '' ) {
            if ( _super.isAllowNull() ) {
                return null;
            }
            _super.validationException( sContext, _validationTarget, "Required", { "context":sContext, "input":sInput, "format":format } );
        }

        var canonical = _super.getEncoder().cananicalize(sInput);

        try {
            return format.parse(canonical);
        } catch (e) {
            _super.validationException( sContext, _validationTarget, "Invalid", { "context":sContext, "input":sInput, "format":format } );
        }
    };

    return {
        setDateFormat: function(fmt) {
            if ( !fmt ) {
                throw new IllegalArgumentException("DateValidationRule.setDateFormat requires a non-null DateFormat");
            }
            format = fmt;
        },

        setAllowNull: _super.setAllowNull,

        isAllowNull: _super.isAllowNull,

        getTypeName: _super.getTypeName,

        setTypeName: _super.setTypeName,

        setEncoder: _super.setEncoder,

        getEncoder: _super.getEncoder,

        assertValid: _super.assertValid,

        getValid: _super.getValid,

        getValidInput: function( sContext, sInput ) {
            return safelyParse(sContext,sInput);
        },

        getSafe: _super.getSafe,

        sanitize: function( sContext, sInput ) {
            var date = new Date(0);
            try {
                date = safelyParse(sContext,sInput);
            } catch (e) { }
            return date;
        },

        isValid: _super.isValid,

        whitelist: _super.whitelist
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.DefaultValidator = function( oEncoder, oLocale ) {
    var rules = Array();
    var encoder = oEncoder?oEncoder:$ESAPI.encoder();
    var locale = oLocale?oLocale:org.owasp.esapi.i18n.Locale.getDefault();

    var p = org.owasp.esapi.reference.validation;

    return {
        addRule: function( oValidationRule ) {
            rules[oValidationRule.getName()] = oValidationRule;
        },

        getRule: function( sName ) {
            return rules[sName];
        },

        isValidInput: function( sContext, sInput, sType, nMaxLength, bAllowNull ) {
            try {
                this.getValidInput( sContext, sInput, sType, nMaxLength, bAllowNull );
                return true;
            } catch (e) {
                return false;
            }
        },

        getValidInput: function( sContext, sInput, sType, nMaxLength, bAllowNull, oValidationErrorList ) {
            var rvr = new org.owasp.esapi.reference.validation.StringValidationRule( sType, encoder, locale );
            var p = new RegExp($ESAPI.properties.validation[sType]);
            if ( p && p instanceof RegExp ) {
                rvr.addWhitelistPattern( p );
            } else {
                throw new IllegalArgumentException("Invalid Type: " + sType + " not found.");
            }
            rvr.setMaxLength( nMaxLength );
            rvr.setAllowNull( bAllowNull );

            try {
                return rvr.getValid(sContext,sInput);
            } catch (e) {
                if ( e instanceof p.ValidationErrorList && oValidationErrorList ) {
                    oValidationErrorList.addError( sContext, e );
                }
                throw e;
            }
        },

        isValidDate: function( sContext, sInput, oDateFormat, bAllowNull ) {
            try {
                this.getValidDate( sContext, sInput, oDateFormat, bAllowNull );
                return true;
            } catch (e) {
                return false;
            }
        },

        getValidDate: function( sContext, sInput, oDateFormat, bAllowNull, oValidationErrorList ) {
            var dvr = new p.DateValidationRule( sContext, encoder, locale );
            dvr.setAllowNull( bAllowNull );
            dvr.setDateFormat(oDateFormat);
            try {
                return dvr.getValid( sContext, sInput );
            } catch (e) {
                if ( e instanceof p.ValidationErrorList && oValidationErrorList ) {
                    oValidationErrorList.addError( sContext, e );
                }
                throw e;
            }
        },

        getValidCreditCard: function( sContext, sInput, bAllowNull, oValidationErrorList ) {
            var ccr = new p.CreditCardValidationRule( sContext, encoder, locale );
            ccr.setAllowNull(bAllowNull);

            try {
                return ccr.getValid(sContext,sInput);
            } catch (e) {
                if ( e instanceof p.ValidationErrorList && oValidationErrorList ) {
                    oValidationErrorList.addError( sContext, e );
                }
                throw e;
            }
        },

        isValidCreditCard: function( sContext, sInput, bAllowNull ) {
            try {
                this.getValidCreditCard( sContext,sInput,bAllowNull );
                return true;
            } catch (e) {
                return false;
            }
        },

        getValidNumber: function( sContext, sInput, bAllowNull, nMinValue, nMaxValue, oValidationErrorList ) {
            var nvr = new p.NumberValidationRule( sContext, encoder, locale, nMinValue, nMaxValue );
            nvr.setAllowNull(bAllowNull);

            try {
                return nvr.getValid(sContext, sInput);
            } catch(e) {
                if ( e instanceof p.ValidationErrorList && oValidationErrorList ) {
                    oValidationErrorList.addError( sContext, e );
                }
                throw e;
            }
        },

        isValidNumber: function( sContext, sInput, bAllowNull, nMinValue, nMaxValue ) {
            try {
                this.getValidNumber(sContext,sInput,bAllowNull,nMinValue,nMaxValue);
                return true;
            } catch (e) {
                return false;
            }
        },

        getValidInteger: function( sContext, sInput, bAllowNull, nMinValue, nMaxValue, oValidationErrorList ) {
            var nvr = new p.IntegerValidationRule( sContext, encoder, locale, nMinValue, nMaxValue );
            nvr.setAllowNull(bAllowNull);

            try {
                return nvr.getValid(sContext, sInput);
            } catch(e) {
                if ( e instanceof p.ValidationErrorList && oValidationErrorList ) {
                    oValidationErrorList.addError( sContext, e );
                }
                throw e;
            }
        },

        isValidInteger: function( sContext, sInput, bAllowNull, nMinValue, nMaxValue ) {
            try {
                this.getValidInteger(sContext,sInput,bAllowNull,nMinValue,nMaxValue);
                return true;
            } catch (e) {
                return false;
            }
        }
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.IntegerValidationRule = function( sTypeName, oEncoder, oLocale, nMinValue, nMaxValue ) {
    var _super = new org.owasp.esapi.reference.validation.BaseValidationRule( sTypeName, oEncoder, oLocale );
    var _validationTarget = "Integer";

    var minValue = nMinValue?nMinValue:Number.MIN_VALUE;
    var maxValue = nMaxValue?nMaxValue:Number.MAX_VALUE;

    if ( minValue >= maxValue ) {
        throw new IllegalArgumentException( "minValue must be less than maxValue" );
    }

    var safelyParse = function(sContext,sInput) {
        if ( !sInput || sInput.trim() == '' ) {
            if ( _super.allowNull() ) {
                return null;
            }
            _super.validationException( sContext, _validationTarget, "Required", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }

        var canonical = _super.getEncoder().cananicalize(sInput);

        var n = parseInt(canonical);
        if ( n == 'NaN' ) {
            _super.validationException( sContext, _validationTarget, "NaN", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        if ( n < minValue ) {
            _super.validationException( sContext, _validationTarget, "MinValue", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        if ( n > maxValue ) {
            _super.validationException( sContext, _validationTarget, "MaxValue", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        return n;
    };

    return {
        setMinValue: function(n) { minValue = n; },

        getMinValue: function() { return minValue; },

        setMaxValue: function(n) { maxValue = n; },

        getMaxValue: function() { return maxValue; },

        setAllowNull: _super.setAllowNull,

        isAllowNull: _super.isAllowNull,

        getTypeName: _super.getTypeName,

        setTypeName: _super.setTypeName,

        setEncoder: _super.setEncoder,

        getEncoder: _super.getEncoder,

        assertValid: _super.assertValid,

        getValid: _super.getValid,

        getValidInput: function( sContext, sInput ) {
            return safelyParse(sContext,sInput);
        },

        getSafe: _super.getSafe,

        sanitize: function( sContext, sInput ) {
            var n = 0;
            try {
                n = safelyParse(sContext,sInput);
            } catch (e) { }
            return n;
        },

        isValid: _super.isValid,

        whitelist: _super.whitelist
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.NumberValidationRule = function( sTypeName, oEncoder, oLocale, fMinValue, fMaxValue ) {
    var _super = new org.owasp.esapi.reference.validation.BaseValidationRule( sTypeName, oEncoder, oLocale );
    var _validationTarget = 'Number';

    var minValue = fMinValue?fMinValue:Number.MIN_VALUE;
    var maxValue = fMaxValue?fMaxValue:Number.MAX_VALUE;

    if ( minValue >= maxValue ) throw new IllegalArgumentException("MinValue must be less that MaxValue");

    var safelyParse = function( sContext, sInput ) {
        if ( !sInput || sInput.trim() == '' ) {
            if ( _super.isAllowNull() ) {
                return null;
            }
            _super.validationException( sContext, _validationTarget, "Required", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }

        var canonical = _super.getEncoder().cananicalize( sInput );

        var f = 0.0;
        try {
            f = parseFloat( canonical );
        } catch (e) {
            _super.validationException( sContext, _validationTarget, "Invalid", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }

        if ( f == 'NaN' ) {
            _super.validationException( sContext, _validationTarget, "NaN", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        if ( f < minValue ) {
            _super.validationException( sContext, _validationTarget, "MinValue", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        if ( f > maxValue ) {
            _super.validationException( sContext, _validationTarget, "MaxValue", { "context":sContext, "input":sInput, "minValue":minValue, "maxValue":maxValue } );
        }
        return f;
    };

    return {
        setMinValue: function(n) { minValue = n; },

        getMinValue: function() { return minValue; },

        setMaxValue: function(n) { maxValue = n; },

        getMaxValue: function() { return maxValue; },

        setAllowNull: _super.setAllowNull,

        isAllowNull: _super.isAllowNull,

        getTypeName: _super.getTypeName,

        setTypeName: _super.setTypeName,

        setEncoder: _super.setEncoder,

        getEncoder: _super.getEncoder,

        assertValid: _super.assertValid,

        getValid: _super.getValid,

        getValidInput: function( sContext, sInput ) {
            return safelyParse(sContext,sInput);
        },

        getSafe: _super.getSafe,

        sanitize: function( sContext, sInput ) {
            var n = 0;
            try {
                n = safelyParse(sContext,sInput);
            } catch (e) { }
            return n;
        },

        isValid: _super.isValid,

        whitelist: _super.whitelist
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.StringValidationRule = function( sTypeName, oEncoder, oLocale, sWhiteListPattern ) {
    var _super = new org.owasp.esapi.reference.validation.BaseValidationRule( sTypeName, oEncoder, oLocale );
    var _validationTarget = 'String';

    var whitelistPatterns = Array();
    var blacklistPatterns = Array();
    var minLength = 0;
    var maxLength = Number.MAX_VALUE;
    var validateInputAndCanonical = true;

    if ( sWhiteListPattern ) {
        if ( sWhiteListPattern instanceof String ) {
            whitelistPatterns.push( new RegExp(sWhiteListPattern) );
        } else if ( sWhiteListPattern instanceof RegExp ) {
            whitelistPatterns.push( sWhiteListPattern );
        } else {
            throw new IllegalArgumentException("sWhiteListPattern must be a string containing RegExp or a RegExp Object");
        }
    }

    var checkWhitelist = function( sContext, sInput, sOrig ) {
        whitelistPatterns.each(function(p){
            if ( sInput.match(p) ) {
                _super.validationException( sContext, _validationTarget, "Whitelist", { "context":sContext, "input":sInput, "orig":sOrig, "pattern":p.toString(), "minLength":minLength, "maxLength":maxLength, "validateInputAndCanonical":validateInputAndCanonical } );
            }
        });
    };

    var checkBlacklist = function( sContext, sInput, sOrig ) {
        blacklistPatterns.each(function(p){
            if ( sInput.match(p) ) {
                _super.validationException( sContext, _validationTarget, "Blacklist", { "context":sContext, "input":sInput, "orig":sOrig, "pattern":p.toString(), "minLength":minLength, "maxLength":maxLength, "validateInputAndCanonical":validateInputAndCanonical } );
            }
        });
    };

    var checkLength = function( sContext, sInput, sOrig ) {
        if ( sInput.length < minLength ) {
            _super.validationException( sContext, _validationTarget, "MinLength", { "context":sContext, "input":sInput, "orig":sOrig, "minLength":minLength, "maxLength":maxLength, "validateInputAndCanonical":validateInputAndCanonical } );
        }
        if ( sInput.length > maxLength ) {
            _super.validationException( sContext, _validationTarget, "MaxLength", { "context":sContext, "input":sInput, "orig":sOrig, "minLength":minLength, "maxLength":maxLength, "validateInputAndCanonical":validateInputAndCanonical } );
        }
        return sInput;
    };

    var checkEmpty = function( sContext, sInput, sOrig ) {
        if ( !sInput || sInput.trim() == '' ) {
            if ( _super.isAllowNull() ) {
                return null;
            }
            _super.validationException( sContext, _validationTarget, "Required", { "context":sContext, "input":sInput, "orig":sOrig, "minLength":minLength, "maxLength":maxLength, "validateInputAndCanonical":validateInputAndCanonical } );
        }
    };

    return {
        addWhitelistPattern: function(p) {
            if ( p instanceof String ) {
                whitelistPatterns.push( new RegExp(p) );
            } else if ( p instanceof RegExp ) {
                whitelistPatterns.push(p);
            } else {
                throw new IllegalArgumentException("p must be a string containing RegExp or a RegExp Object");
            }
        },

        addBlacklistPattern: function(p) {
            if ( p instanceof String ) {
                blacklistPatterns.push( new RegExp(p) );
            } else if ( p instanceof RegExp ) {
                blacklistPatterns.push(p);
            } else {
                throw new IllegalArgumentException("p must be a string containing RegExp or a RegExp Object");
            }
        },

        setMinLength: function(n) { minLength = n; },

        getMinLength: function() { return minLength; },

        setMaxLength: function(n) { maxLength = n; },

        getMaxLength: function() { return maxLength; },

        setValidateInputAndCanonical: function(b) { validateInputAndCanonical = b; },

        isValidateInputAndCanonical: function() { return validateInputAndCanonical; },

        setAllowNull: _super.setAllowNull,

        isAllowNull: _super.isAllowNull,

        getTypeName: _super.getTypeName,

        setTypeName: _super.setTypeName,

        setEncoder: _super.setEncoder,

        getEncoder: _super.getEncoder,

        assertValid: _super.assertValid,

        getValid: _super.getValid,

        getValidInput: function( sContext, sInput ) {
            var canonical = null;

            if ( checkEmpty( sContext, sInput ) == null ) {
                return null;
            }

            if ( validateInputAndCanonical ) {
                checkLength(sContext, sInput);
                checkWhitelist(sContext,sInput);
                checkBlacklist(sContext,sInput);
            }

            canonical = this.getEncoder().cananicalize(sInput);

            if ( checkEmpty( sContext, canonical, sInput ) == null ) {
                return null;
            }

            checkLength( sContext, canonical, sInput );
            checkWhitelist( sContext, canonical, sInput );
            checkBlacklist( sContext, canonical, sInput );

            return canonical;
        },

        getSafe: _super.getSafe,

        sanitize: function( sContext, sInput ) {
            return this.whitelist( sInput, org.owasp.esapi.EncoderConstants.CHAR_ALNUM );
        },

        isValid: _super.isValid,

        whitelist: _super.whitelist
    };
};

$namespace('org.owasp.esapi.reference.validation');

org.owasp.esapi.reference.validation.ValidationException = function( sUserMessage, sLogMessage ) {
    var oException, sContext;
    if ( arguments[2] && arguments[2] instanceof Exception ) {
        oException = arguments[2];
        if ( arguments[3] && arguments[3] instanceof String ) {
            sContext = arguments[3];
        }
    } else if ( arguments[2] && arguments[2] instanceof String ) {
        sContext = arguments[2];
    }

    var _super = new org.owasp.esapi.EnterpriseSecurityException( sUserMessage, sLogMessage, oException );

    return {
        setContext: function(s) { sContext = s; },
        getContext: function() { return sContext; },
        getMessage: _super.getMessage,
        getUserMessage: _super.getMessage,
        getLogMessage: _super.getLogMessage,
        getStackTrace: _super.getStackTrace,
        printStackTrace: _super.printStackTrace
    };
};

/*standard js set EN_US */
var ESAPI_Standard_en_US = {
    name: 'ESAPI Standard Messages - US English',
    locale: 'en-US',
    messages: {
        "Test"                              : "This is test #{testnumber}",

        // Messages for validation
        "CreditCard.Required.Usr"           : "{context}: Input credit card required",
        "CreditCard.Required.Log"           : "Input credit card required: context={context}, input={input}",
        "CreditCard.Invalid.Usr"            : "{context}: Invalid credit card input",
        "CreditCard.Invalid.Log"            : "Invalid credit card input: context={context}, input={input}",
        "Date.Required.Usr"                 : "{context}: Input date required in {format} format",
        "Date.Required.Log"                 : "Date required: context={context}, input={input}, format={format}",
        "Date.Invalid.Usr"                  : "{context}: Invalid date, please use {format} format",
        "Date.Invalid.Log"                  : "Invalid date: context={context}, input={input}, format={format}",
        "Integer.Required.Usr"              : "{context}: Input number required",
        "Integer.Required.Log"              : "Input number required: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Integer.NaN.Usr"                   : "{context}: Invalid number",
        "Integer.NaN.Log"                   : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Integer.MinValue.Usr"              : "{context}: Invalid number - Must be greater than {minValue}",
        "Integer.MinValue.Log"              : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Integer.MaxValue.Usr"              : "{context}: Invalid number - Must be less than {maxValue}",
        "Integer.MaxValue.Log"              : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Number.Required.Usr"               : "{context}: Input number required",
        "Number.Required.Log"               : "Input number required: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Number.NaN.Usr"                    : "{context}: Invalid number",
        "Number.NaN.Log"                    : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Number.MinValue.Usr"               : "{context}: Invalid number - Must be greater than {minValue}",
        "Number.MinValue.Log"               : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "Number.MaxValue.Usr"               : "{context}: Invalid number - Must be less than {maxValue}",
        "Number.MaxValue.Log"               : "Invalid number: context={context}, input={input}, minValue={minValue}, maxValue={maxValue}",
        "String.Required.Usr"               : "{context}: Input required",
        "String.Required.Log"               : "Input required: context={context}, input={input}, original={orig}",
        "String.Whitelist.Usr"              : "{context}: Invalid input - Conform to regex {pattern}",
        "String.Whitelist.Log"              : "Invalid input - Whitelist validation failed: context={context}, input={input}, original={orig}, pattern={pattern}",
        "String.Blacklist.Usr"              : "{context}: Invalid input - Dangerous input matching {pattern} detected",
        "String.Blacklist.Log"              : "Invalid input - Blacklist validation failed: context={context}, input={input}, original={orig}, pattern={pattern}",
        "String.MinLength.Usr"              : "{context}: Invalid input - Minimum length is {minLength}",
        "String.MinLength.Log"              : "Invalid input - Too short: context={context}, input={input}, original={orig}, minLength={minLength}",
        "String.MaxLength.Usr"              : "{context}: Invalid input - Maximum length is {maxLength}",
        "String.MaxLength.Log"              : "Invalid input - Too long: context={context}, input={input}, original={orig}, maxLength={maxLength}",

        // Error Messages for Exceptions
        "HTTPUtilities.Cookie.Protocol"     : "Cookies disallowed on non http[s] requests. Current protocol: {protocol}",
        "HTTPUtilities.Cookie.UnsafeData"   : "Attempt to add unsafe data to cookie (skip mode) - Cookie: {name}={value}",
        "HTTPUtilities.Cookie.CantKill"     : "Unable to kill cookie named {name}",
        "Cookie.Name"                       : "Cookie name \"{name}\" is a reserved token",
        "Cookie.Version"                    : "Cookie version \"{version}\" is not a valid version. Version must be 0 or 1."
    }
};
/* end of standard EN_US */


/*
 * OWASP Enterprise Security API (ESAPI)
 *
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2008 - The OWASP Foundation
 *
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 */

$namespace('Base.esapi.properties');

Base.esapi.properties = {
    application: {
        // Change this value to reflect your application, or override it in an application scoped configuration.
        Name: 'ESAPI4JS Base Application'
    },

    httputilities: {
        cookies: {
            ForceSecure: true
        }
    },

    logging: {
        Implementation: org.owasp.esapi.reference.logging.Log4JSLogFactory,
        Level: org.owasp.esapi.Logger.OFF,
        // For a console that pops up in a seperate window
        // Appenders: [ new ConsoleAppender(true) ],
        // To log to a logging service on the server
        // Appenders: [ new AjaxAppender( '/log/' ) ],
        // Default to log nowhere
        Appenders: [],
        LogUrl: false,
        LogApplicationName: false,
        EncodingRequired: true
    },

    encoder: {
        Implementation: org.owasp.esapi.reference.encoding.DefaultEncoder,
        AllowMultipleEncoding: false
    },

    localization: {
        StandardResourceBundle: ESAPI_Standard_en_US,
        DefaultLocale: 'en-US'
    },

    validation: {
        Implementation: org.owasp.esapi.reference.validation.DefaultValidator,
        AccountName: '^[a-zA-Z0-9]{3,20}$',
        SafeString: '[a-zA-Z0-9\\-_+]*',
        Email: '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+\\.[a-zA-Z]{2,4}$',
        IPAddress: '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$',
        URL: '^(ht|f)tp(s?)\\:\\/\\/[0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*(:(0-9)*)*(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\:\\\'\\/\\\\\\+=&amp;%\\$#_]*)?$',
        CreditCard: '^(\\d{4}[- ]?){3}\\d{4}$',
        SSN: '^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$',
        HttpScheme: '^(http|https)$',
        HttpServerName: '^[a-zA-Z0-9_.\\-]*$',
        HttpParameterName: '^[a-zA-Z0-9_]{1,32}$',
        HttpParameterValue: '^[a-zA-Z0-9.\\-\\/+=_ ]*$',
        HttpCookieName: '^[a-zA-Z0-9\\-_]{1,32}$',
        HttpCookieValue: '^[a-zA-Z0-9\\-\\/+=_ ]*$'
    }
}

/*
Base.esapi.properties.logging['ApplicationLogger'] = {
    Level: org.owasp.esapi.Logger.ALL,
    Appenders: [ new Log4js.ConsoleAppender() ],
    LogUrl: true,
    LogApplicationName: true,
    EncodingRequired: true
};
*/

Base.esapi.properties.application.Name = "Pedigree Editor Tool";
org.owasp.esapi.ESAPI.initialize();
/*
 RequireJS 2.1.15 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
 */
var requirejs, require, define;
(function (ba) {
	function G(b) {
		return"[object Function]" === K.call(b)
	}

	function H(b) {
		return"[object Array]" === K.call(b)
	}

	function v(b, c) {
		if (b) {
			var d;
			for (d = 0; d < b.length && (!b[d] || !c(b[d], d, b)); d += 1);
		}
	}

	function T(b, c) {
		if (b) {
			var d;
			for (d = b.length - 1; -1 < d && (!b[d] || !c(b[d], d, b)); d -= 1);
		}
	}

	function t(b, c) {
		return fa.call(b, c)
	}

	function m(b, c) {
		return t(b, c) && b[c]
	}

	function B(b, c) {
		for (var d in b)if (t(b, d) && c(b[d], d))break
	}

	function U(b, c, d, e) {
		c && B(c, function (c, g) {
			if (d || !t(b, g))e && "object" === typeof c && c && !H(c) && !G(c) && !(c instanceof
				RegExp) ? (b[g] || (b[g] = {}), U(b[g], c, d, e)) : b[g] = c
		});
		return b
	}

	function u(b, c) {
		return function () {
			return c.apply(b, arguments)
		}
	}

	function ca(b) {
		throw b;
	}

	function da(b) {
		if (!b)return b;
		var c = ba;
		v(b.split("."), function (b) {
			c = c[b]
		});
		return c
	}

	function C(b, c, d, e) {
		c = Error(c + "\nhttp://requirejs.org/docs/errors.html#" + b);
		c.requireType = b;
		c.requireModules = e;
		d && (c.originalError = d);
		return c
	}

	function ga(b) {
		function c(a, k, b) {
			var f, l, c, d, e, g, i, p, k = k && k.split("/"), h = j.map, n = h && h["*"];
			if (a) {
				a = a.split("/");
				l = a.length - 1;
				j.nodeIdCompat &&
				Q.test(a[l]) && (a[l] = a[l].replace(Q, ""));
				"." === a[0].charAt(0) && k && (l = k.slice(0, k.length - 1), a = l.concat(a));
				l = a;
				for (c = 0; c < l.length; c++)if (d = l[c], "." === d)l.splice(c, 1), c -= 1; else if (".." === d && !(0 === c || 1 == c && ".." === l[2] || ".." === l[c - 1]) && 0 < c)l.splice(c - 1, 2), c -= 2;
				a = a.join("/")
			}
			if (b && h && (k || n)) {
				l = a.split("/");
				c = l.length;
				a:for (; 0 < c; c -= 1) {
					e = l.slice(0, c).join("/");
					if (k)for (d = k.length; 0 < d; d -= 1)if (b = m(h, k.slice(0, d).join("/")))if (b = m(b, e)) {
						f = b;
						g = c;
						break a
					}
					!i && (n && m(n, e)) && (i = m(n, e), p = c)
				}
				!f && i && (f = i, g = p);
				f && (l.splice(0,
					g, f), a = l.join("/"))
			}
			return(f = m(j.pkgs, a)) ? f : a
		}

		function d(a) {
			z && v(document.getElementsByTagName("script"), function (k) {
				if (k.getAttribute("data-requiremodule") === a && k.getAttribute("data-requirecontext") === i.contextName)return k.parentNode.removeChild(k), !0
			})
		}

		function e(a) {
			var k = m(j.paths, a);
			if (k && H(k) && 1 < k.length)return k.shift(), i.require.undef(a), i.makeRequire(null, {skipMap: !0})([a]), !0
		}

		function n(a) {
			var k, c = a ? a.indexOf("!") : -1;
			-1 < c && (k = a.substring(0, c), a = a.substring(c + 1, a.length));
			return[k, a]
		}

		function p(a, k, b, f) {
			var l, d, e = null, g = k ? k.name : null, j = a, p = !0, h = "";
			a || (p = !1, a = "_@r" + (K += 1));
			a = n(a);
			e = a[0];
			a = a[1];
			e && (e = c(e, g, f), d = m(r, e));
			a && (e ? h = d && d.normalize ? d.normalize(a, function (a) {
				return c(a, g, f)
			}) : -1 === a.indexOf("!") ? c(a, g, f) : a : (h = c(a, g, f), a = n(h), e = a[0], h = a[1], b = !0, l = i.nameToUrl(h)));
			b = e && !d && !b ? "_unnormalized" + (O += 1) : "";
			return{prefix: e, name: h, parentMap: k, unnormalized: !!b, url: l, originalName: j, isDefine: p, id: (e ? e + "!" + h : h) + b}
		}

		function s(a) {
			var k = a.id, b = m(h, k);
			b || (b = h[k] = new i.Module(a));
			return b
		}

		function q(a, k, b) {
			var f = a.id, c = m(h, f);
			if (t(r, f) && (!c || c.defineEmitComplete))"defined" === k && b(r[f]); else if (c = s(a), c.error && "error" === k)b(c.error); else c.on(k, b)
		}

		function w(a, b) {
			var c = a.requireModules, f = !1;
			if (b)b(a); else if (v(c, function (b) {
				if (b = m(h, b))b.error = a, b.events.error && (f = !0, b.emit("error", a))
			}), !f)g.onError(a)
		}

		function x() {
			R.length && (ha.apply(A, [A.length, 0].concat(R)), R = [])
		}

		function y(a) {
			delete h[a];
			delete V[a]
		}

		function F(a, b, c) {
			var f = a.map.id;
			a.error ? a.emit("error", a.error) : (b[f] = !0, v(a.depMaps, function (f, d) {
				var e = f.id, g = m(h, e);
				g && (!a.depMatched[d] && !c[e]) && (m(b, e) ? (a.defineDep(d, r[e]), a.check()) : F(g, b, c))
			}), c[f] = !0)
		}

		function D() {
			var a, b, c = (a = 1E3 * j.waitSeconds) && i.startTime + a < (new Date).getTime(), f = [], l = [], g = !1, h = !0;
			if (!W) {
				W = !0;
				B(V, function (a) {
					var i = a.map, j = i.id;
					if (a.enabled && (i.isDefine || l.push(a), !a.error))if (!a.inited && c)e(j) ? g = b = !0 : (f.push(j), d(j)); else if (!a.inited && (a.fetched && i.isDefine) && (g = !0, !i.prefix))return h = !1
				});
				if (c && f.length)return a = C("timeout", "Load timeout for modules: " + f, null,
					f), a.contextName = i.contextName, w(a);
				h && v(l, function (a) {
					F(a, {}, {})
				});
				if ((!c || b) && g)if ((z || ea) && !X)X = setTimeout(function () {
					X = 0;
					D()
				}, 50);
				W = !1
			}
		}

		function E(a) {
			t(r, a[0]) || s(p(a[0], null, !0)).init(a[1], a[2])
		}

		function I(a) {
			var a = a.currentTarget || a.srcElement, b = i.onScriptLoad;
			a.detachEvent && !Y ? a.detachEvent("onreadystatechange", b) : a.removeEventListener("load", b, !1);
			b = i.onScriptError;
			(!a.detachEvent || Y) && a.removeEventListener("error", b, !1);
			return{node: a, id: a && a.getAttribute("data-requiremodule")}
		}

		function J() {
			var a;
			for (x(); A.length;) {
				a = A.shift();
				if (null === a[0])return w(C("mismatch", "Mismatched anonymous define() module: " + a[a.length - 1]));
				E(a)
			}
		}

		var W, Z, i, L, X, j = {waitSeconds: 7, baseUrl: "./", paths: {}, bundles: {}, pkgs: {}, shim: {}, config: {}}, h = {}, V = {}, $ = {}, A = [], r = {}, S = {}, aa = {}, K = 1, O = 1;
		L = {require: function (a) {
			return a.require ? a.require : a.require = i.makeRequire(a.map)
		}, exports: function (a) {
			a.usingExports = !0;
			if (a.map.isDefine)return a.exports ? r[a.map.id] = a.exports : a.exports = r[a.map.id] = {}
		}, module: function (a) {
			return a.module ?
				a.module : a.module = {id: a.map.id, uri: a.map.url, config: function () {
				return m(j.config, a.map.id) || {}
			}, exports: a.exports || (a.exports = {})}
		}};
		Z = function (a) {
			this.events = m($, a.id) || {};
			this.map = a;
			this.shim = m(j.shim, a.id);
			this.depExports = [];
			this.depMaps = [];
			this.depMatched = [];
			this.pluginMaps = {};
			this.depCount = 0
		};
		Z.prototype = {init: function (a, b, c, f) {
			f = f || {};
			if (!this.inited) {
				this.factory = b;
				if (c)this.on("error", c); else this.events.error && (c = u(this, function (a) {
					this.emit("error", a)
				}));
				this.depMaps = a && a.slice(0);
				this.errback =
					c;
				this.inited = !0;
				this.ignore = f.ignore;
				f.enabled || this.enabled ? this.enable() : this.check()
			}
		}, defineDep: function (a, b) {
			this.depMatched[a] || (this.depMatched[a] = !0, this.depCount -= 1, this.depExports[a] = b)
		}, fetch: function () {
			if (!this.fetched) {
				this.fetched = !0;
				i.startTime = (new Date).getTime();
				var a = this.map;
				if (this.shim)i.makeRequire(this.map, {enableBuildCallback: !0})(this.shim.deps || [], u(this, function () {
					return a.prefix ? this.callPlugin() : this.load()
				})); else return a.prefix ? this.callPlugin() : this.load()
			}
		}, load: function () {
			var a =
				this.map.url;
			S[a] || (S[a] = !0, i.load(this.map.id, a))
		}, check: function () {
			if (this.enabled && !this.enabling) {
				var a, b, c = this.map.id;
				b = this.depExports;
				var f = this.exports, l = this.factory;
				if (this.inited)if (this.error)this.emit("error", this.error); else {
					if (!this.defining) {
						this.defining = !0;
						if (1 > this.depCount && !this.defined) {
							if (G(l)) {
								if (this.events.error && this.map.isDefine || g.onError !== ca)try {
									f = i.execCb(c, l, b, f)
								} catch (d) {
									a = d
								} else f = i.execCb(c, l, b, f);
								this.map.isDefine && void 0 === f && ((b = this.module) ? f = b.exports : this.usingExports &&
									(f = this.exports));
								if (a)return a.requireMap = this.map, a.requireModules = this.map.isDefine ? [this.map.id] : null, a.requireType = this.map.isDefine ? "define" : "require", w(this.error = a)
							} else f = l;
							this.exports = f;
							if (this.map.isDefine && !this.ignore && (r[c] = f, g.onResourceLoad))g.onResourceLoad(i, this.map, this.depMaps);
							y(c);
							this.defined = !0
						}
						this.defining = !1;
						this.defined && !this.defineEmitted && (this.defineEmitted = !0, this.emit("defined", this.exports), this.defineEmitComplete = !0)
					}
				} else this.fetch()
			}
		}, callPlugin: function () {
			var a =
				this.map, b = a.id, d = p(a.prefix);
			this.depMaps.push(d);
			q(d, "defined", u(this, function (f) {
				var l, d;
				d = m(aa, this.map.id);
				var e = this.map.name, P = this.map.parentMap ? this.map.parentMap.name : null, n = i.makeRequire(a.parentMap, {enableBuildCallback: !0});
				if (this.map.unnormalized) {
					if (f.normalize && (e = f.normalize(e, function (a) {
						return c(a, P, !0)
					}) || ""), f = p(a.prefix + "!" + e, this.map.parentMap), q(f, "defined", u(this, function (a) {
						this.init([], function () {
							return a
						}, null, {enabled: !0, ignore: !0})
					})), d = m(h, f.id)) {
						this.depMaps.push(f);
						if (this.events.error)d.on("error", u(this, function (a) {
							this.emit("error", a)
						}));
						d.enable()
					}
				} else d ? (this.map.url = i.nameToUrl(d), this.load()) : (l = u(this, function (a) {
					this.init([], function () {
						return a
					}, null, {enabled: !0})
				}), l.error = u(this, function (a) {
					this.inited = !0;
					this.error = a;
					a.requireModules = [b];
					B(h, function (a) {
						0 === a.map.id.indexOf(b + "_unnormalized") && y(a.map.id)
					});
					w(a)
				}), l.fromText = u(this, function (f, c) {
					var d = a.name, e = p(d), P = M;
					c && (f = c);
					P && (M = !1);
					s(e);
					t(j.config, b) && (j.config[d] = j.config[b]);
					try {
						g.exec(f)
					} catch (h) {
						return w(C("fromtexteval",
								"fromText eval for " + b + " failed: " + h, h, [b]))
					}
					P && (M = !0);
					this.depMaps.push(e);
					i.completeLoad(d);
					n([d], l)
				}), f.load(a.name, n, l, j))
			}));
			i.enable(d, this);
			this.pluginMaps[d.id] = d
		}, enable: function () {
			V[this.map.id] = this;
			this.enabling = this.enabled = !0;
			v(this.depMaps, u(this, function (a, b) {
				var c, f;
				if ("string" === typeof a) {
					a = p(a, this.map.isDefine ? this.map : this.map.parentMap, !1, !this.skipMap);
					this.depMaps[b] = a;
					if (c = m(L, a.id)) {
						this.depExports[b] = c(this);
						return
					}
					this.depCount += 1;
					q(a, "defined", u(this, function (a) {
						this.defineDep(b,
							a);
						this.check()
					}));
					this.errback && q(a, "error", u(this, this.errback))
				}
				c = a.id;
				f = h[c];
				!t(L, c) && (f && !f.enabled) && i.enable(a, this)
			}));
			B(this.pluginMaps, u(this, function (a) {
				var b = m(h, a.id);
				b && !b.enabled && i.enable(a, this)
			}));
			this.enabling = !1;
			this.check()
		}, on: function (a, b) {
			var c = this.events[a];
			c || (c = this.events[a] = []);
			c.push(b)
		}, emit: function (a, b) {
			v(this.events[a], function (a) {
				a(b)
			});
			"error" === a && delete this.events[a]
		}};
		i = {config: j, contextName: b, registry: h, defined: r, urlFetched: S, defQueue: A, Module: Z, makeModuleMap: p,
			nextTick: g.nextTick, onError: w, configure: function (a) {
				a.baseUrl && "/" !== a.baseUrl.charAt(a.baseUrl.length - 1) && (a.baseUrl += "/");
				var b = j.shim, c = {paths: !0, bundles: !0, config: !0, map: !0};
				B(a, function (a, b) {
					c[b] ? (j[b] || (j[b] = {}), U(j[b], a, !0, !0)) : j[b] = a
				});
				a.bundles && B(a.bundles, function (a, b) {
					v(a, function (a) {
						a !== b && (aa[a] = b)
					})
				});
				a.shim && (B(a.shim, function (a, c) {
					H(a) && (a = {deps: a});
					if ((a.exports || a.init) && !a.exportsFn)a.exportsFn = i.makeShimExports(a);
					b[c] = a
				}), j.shim = b);
				a.packages && v(a.packages, function (a) {
					var b,
						a = "string" === typeof a ? {name: a} : a;
					b = a.name;
					a.location && (j.paths[b] = a.location);
					j.pkgs[b] = a.name + "/" + (a.main || "main").replace(ia, "").replace(Q, "")
				});
				B(h, function (a, b) {
					!a.inited && !a.map.unnormalized && (a.map = p(b))
				});
				if (a.deps || a.callback)i.require(a.deps || [], a.callback)
			}, makeShimExports: function (a) {
				return function () {
					var b;
					a.init && (b = a.init.apply(ba, arguments));
					return b || a.exports && da(a.exports)
				}
			}, makeRequire: function (a, e) {
				function j(c, d, m) {
					var n, q;
					e.enableBuildCallback && (d && G(d)) && (d.__requireJsBuild = !0);
					if ("string" === typeof c) {
						if (G(d))return w(C("requireargs", "Invalid require call"), m);
						if (a && t(L, c))return L[c](h[a.id]);
						if (g.get)return g.get(i, c, a, j);
						n = p(c, a, !1, !0);
						n = n.id;
						return!t(r, n) ? w(C("notloaded", 'Module name "' + n + '" has not been loaded yet for context: ' + b + (a ? "" : ". Use require([])"))) : r[n]
					}
					J();
					i.nextTick(function () {
						J();
						q = s(p(null, a));
						q.skipMap = e.skipMap;
						q.init(c, d, m, {enabled: !0});
						D()
					});
					return j
				}

				e = e || {};
				U(j, {isBrowser: z, toUrl: function (b) {
					var d, e = b.lastIndexOf("."), k = b.split("/")[0];
					if (-1 !==
						e && (!("." === k || ".." === k) || 1 < e))d = b.substring(e, b.length), b = b.substring(0, e);
					return i.nameToUrl(c(b, a && a.id, !0), d, !0)
				}, defined: function (b) {
					return t(r, p(b, a, !1, !0).id)
				}, specified: function (b) {
					b = p(b, a, !1, !0).id;
					return t(r, b) || t(h, b)
				}});
				a || (j.undef = function (b) {
					x();
					var c = p(b, a, !0), e = m(h, b);
					d(b);
					delete r[b];
					delete S[c.url];
					delete $[b];
					T(A, function (a, c) {
						a[0] === b && A.splice(c, 1)
					});
					e && (e.events.defined && ($[b] = e.events), y(b))
				});
				return j
			}, enable: function (a) {
				m(h, a.id) && s(a).enable()
			}, completeLoad: function (a) {
				var b,
					c, d = m(j.shim, a) || {}, g = d.exports;
				for (x(); A.length;) {
					c = A.shift();
					if (null === c[0]) {
						c[0] = a;
						if (b)break;
						b = !0
					} else c[0] === a && (b = !0);
					E(c)
				}
				c = m(h, a);
				if (!b && !t(r, a) && c && !c.inited) {
					if (j.enforceDefine && (!g || !da(g)))return e(a) ? void 0 : w(C("nodefine", "No define call for " + a, null, [a]));
					E([a, d.deps || [], d.exportsFn])
				}
				D()
			}, nameToUrl: function (a, b, c) {
				var d, e, h;
				(d = m(j.pkgs, a)) && (a = d);
				if (d = m(aa, a))return i.nameToUrl(d, b, c);
				if (g.jsExtRegExp.test(a))d = a + (b || ""); else {
					d = j.paths;
					a = a.split("/");
					for (e = a.length; 0 < e; e -= 1)if (h = a.slice(0,
						e).join("/"), h = m(d, h)) {
						H(h) && (h = h[0]);
						a.splice(0, e, h);
						break
					}
					d = a.join("/");
					d += b || (/^data\:|\?/.test(d) || c ? "" : ".js");
					d = ("/" === d.charAt(0) || d.match(/^[\w\+\.\-]+:/) ? "" : j.baseUrl) + d
				}
				return j.urlArgs ? d + ((-1 === d.indexOf("?") ? "?" : "&") + j.urlArgs) : d
			}, load: function (a, b) {
				g.load(i, a, b)
			}, execCb: function (a, b, c, d) {
				return b.apply(d, c)
			}, onScriptLoad: function (a) {
				if ("load" === a.type || ja.test((a.currentTarget || a.srcElement).readyState))N = null, a = I(a), i.completeLoad(a.id)
			}, onScriptError: function (a) {
				var b = I(a);
				if (!e(b.id))return w(C("scripterror",
						"Script error for: " + b.id, a, [b.id]))
			}};
		i.require = i.makeRequire();
		return i
	}

	var g, x, y, D, I, E, N, J, s, O, ka = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg, la = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, Q = /\.js$/, ia = /^\.\//;
	x = Object.prototype;
	var K = x.toString, fa = x.hasOwnProperty, ha = Array.prototype.splice, z = !!("undefined" !== typeof window && "undefined" !== typeof navigator && window.document), ea = !z && "undefined" !== typeof importScripts, ja = z && "PLAYSTATION 3" === navigator.platform ? /^complete$/ : /^(complete|loaded)$/,
		Y = "undefined" !== typeof opera && "[object Opera]" === opera.toString(), F = {}, q = {}, R = [], M = !1;
	if ("undefined" === typeof define) {
		if ("undefined" !== typeof requirejs) {
			if (G(requirejs))return;
			q = requirejs;
			requirejs = void 0
		}
		"undefined" !== typeof require && !G(require) && (q = require, require = void 0);
		g = requirejs = function (b, c, d, e) {
			var n, p = "_";
			!H(b) && "string" !== typeof b && (n = b, H(c) ? (b = c, c = d, d = e) : b = []);
			n && n.context && (p = n.context);
			(e = m(F, p)) || (e = F[p] = g.s.newContext(p));
			n && e.configure(n);
			return e.require(b, c, d)
		};
		g.config = function (b) {
			return g(b)
		};
		g.nextTick = "undefined" !== typeof setTimeout ? function (b) {
			setTimeout(b, 4)
		} : function (b) {
			b()
		};
		require || (require = g);
		g.version = "2.1.15";
		g.jsExtRegExp = /^\/|:|\?|\.js$/;
		g.isBrowser = z;
		x = g.s = {contexts: F, newContext: ga};
		g({});
		v(["toUrl", "undef", "defined", "specified"], function (b) {
			g[b] = function () {
				var c = F._;
				return c.require[b].apply(c, arguments)
			}
		});
		if (z && (y = x.head = document.getElementsByTagName("head")[0], D = document.getElementsByTagName("base")[0]))y = x.head = D.parentNode;
		g.onError = ca;
		g.createNode = function (b) {
			var c =
				b.xhtml ? document.createElementNS("http://www.w3.org/1999/xhtml", "html:script") : document.createElement("script");
			c.type = b.scriptType || "text/javascript";
			c.charset = "utf-8";
			c.async = !0;
			return c
		};
		g.load = function (b, c, d) {
			var e = b && b.config || {};
			if (z)return e = g.createNode(e, c, d), e.setAttribute("data-requirecontext", b.contextName), e.setAttribute("data-requiremodule", c), e.attachEvent && !(e.attachEvent.toString && 0 > e.attachEvent.toString().indexOf("[native code")) && !Y ? (M = !0, e.attachEvent("onreadystatechange", b.onScriptLoad)) :
				(e.addEventListener("load", b.onScriptLoad, !1), e.addEventListener("error", b.onScriptError, !1)), e.src = d, J = e, D ? y.insertBefore(e, D) : y.appendChild(e), J = null, e;
			if (ea)try {
				importScripts(d), b.completeLoad(c)
			} catch (m) {
				b.onError(C("importscripts", "importScripts failed for " + c + " at " + d, m, [c]))
			}
		};
		z && !q.skipDataMain && T(document.getElementsByTagName("script"), function (b) {
			y || (y = b.parentNode);
			if (I = b.getAttribute("data-main"))return s = I, q.baseUrl || (E = s.split("/"), s = E.pop(), O = E.length ? E.join("/") + "/" : "./", q.baseUrl =
				O), s = s.replace(Q, ""), g.jsExtRegExp.test(s) && (s = I), q.deps = q.deps ? q.deps.concat(s) : [s], !0
		});
		define = function (b, c, d) {
			var e, g;
			"string" !== typeof b && (d = c, c = b, b = null);
			H(c) || (d = c, c = null);
			!c && G(d) && (c = [], d.length && (d.toString().replace(ka, "").replace(la, function (b, d) {
				c.push(d)
			}), c = (1 === d.length ? ["require"] : ["require", "exports", "module"]).concat(c)));
			if (M) {
				if (!(e = J))N && "interactive" === N.readyState || T(document.getElementsByTagName("script"), function (b) {
					if ("interactive" === b.readyState)return N = b
				}), e = N;
				e && (b ||
					(b = e.getAttribute("data-requiremodule")), g = F[e.getAttribute("data-requirecontext")])
			}
			(g ? g.defQueue : R).push([b, c, d])
		};
		define.amd = {jQuery: !0};
		g.exec = function (b) {
			return eval(b)
		};
		g(q)
	}
})(this);

/* Global Functions go here */
var Utils = (function(){
	return {
		
		// Check if css file / resource is loaded in dom
		checkIfCssExist : function (csslink) {
			var browserStyleSheets = document.styleSheets;
		
			if (!browserStyleSheets){
				return false;
			}
		
			for (var i = 0, max = browserStyleSheets.length; i < max; i++) {
				
				if (browserStyleSheets[i].href && (browserStyleSheets[i].href.match(csslink) || browserStyleSheets[i].href==csslink)){
					
					return true;
				}
			}
		
			return false;
				
		},
		getOffsetFromParent : function(elName){
			var returnVal = { x :0, y : 0};
			try {
				var el = document.getElementById(elName);
				
				if (el){
					var rect = el.getBoundingClientRect();
					
					returnVal.x = rect && rect.x || 0;
					returnVal.y = rect && rect.y || 0;

				}
			}
			catch(err) {
				console.log(err);
			}
			
			//console.log(  "Offset: x=" + returnVal.x + " ,y=" + returnVal.y);
			
			return returnVal;
			
		},
		getOffsetFromHost : function(){
			
			var pedigreeDivId = window.PedigreeEditorTool.divId;
			
			return Utils.getOffsetFromParent(pedigreeDivId);
			
		},
	 }
}());
(function() {

	var embeddedAppConfigFunc = window.embeddedAppConfig;
	var config = {};
	window.PedigreeEditorTool = window.PedigreeEditorTool || {};


    var PEDIGREE_SERVICE_URL_KEY = "pedigreeServiceUrl";
    var PEDIGREE_TOOL_URL_KEY = "pedigreeToolUrl";
    var LOOKUP_SERVICE_URL_KEY= "lookupServiceUrl";

    var loadEnvironmentVariable = function (variableName){
        var value = config[variableName];

        if (!value){
            throw "The environment variable '" + variableName + "' is not defined or available. It must be defined for pedigree tool app to work.";
        }

        return value;
    };


	if (embeddedAppConfigFunc && typeof embeddedAppConfigFunc === "function"){		
		config = embeddedAppConfigFunc();	
		// Bootstrapping this so loaded javascript files that refer to it can load it.
		window.PedigreeEditorTool.divId = config.divId;

		console.log("Pedigree DivId=" + window.PedigreeEditorTool.divId);

        if (window.PedigreeHostProvidesEnvVariable){
            //Load environment variables from host
            var pedigreeToolUrl = loadEnvironmentVariable(PEDIGREE_TOOL_URL_KEY);
            var pedigreeServiceUrl = loadEnvironmentVariable(PEDIGREE_SERVICE_URL_KEY);
            var lookupServiceUrl = loadEnvironmentVariable(LOOKUP_SERVICE_URL_KEY);

            window.CONSTANTS = window.CONSTANTS || { PEDIGREE_SERVICE_URL:pedigreeServiceUrl, PEDIGREE_TOOL_URL:pedigreeToolUrl, LOOKUP_SERVICE_URL:lookupServiceUrl};
        }
	}
	else{
		throw "embeddedAppConfig is not defined. It must be defined at window level for pedigree tool app to work.";		
	}


	//window.PedigreeHostProvidesEnvVariable


	
	if (document.stopObserving){
         document.stopObserving();
    }

}());
/*!  Prototype JavaScript framework, version 1.7.1
 *  (c) 2005-2010 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/
var Prototype = {Version: "1.7.1", Browser: (function () {
	var b = navigator.userAgent;
	var a = Object.prototype.toString.call(window.opera) == "[object Opera]";
	return{IE: !!window.attachEvent && !a, Opera: a, WebKit: b.indexOf("AppleWebKit/") > -1, Gecko: b.indexOf("Gecko") > -1 && b.indexOf("KHTML") === -1, MobileSafari: /Apple.*Mobile/.test(b)}
})(), BrowserFeatures: {XPath: !!document.evaluate, SelectorsAPI: !!document.querySelector, ElementExtensions: (function () {
	var a = window.Element || window.HTMLElement;
	return !!(a && a.prototype)
})(), SpecificElementExtensions: (function () {
	if (typeof window.HTMLDivElement !== "undefined") {
		return true
	}
	var c = document.createElement("div"), b = document.createElement("form"), a = false;
	if (c.__proto__ && (c.__proto__ !== b.__proto__)) {
		a = true
	}
	c = b = null;
	return a
})()}, ScriptFragment: "<script[^>]*>([\\S\\s]*?)<\/script\\s*>", JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/, emptyFunction: function () {
}, K: function (a) {
	return a
}};
if (Prototype.Browser.MobileSafari) {
	Prototype.BrowserFeatures.SpecificElementExtensions = false
}
var Class = (function () {
	var d = (function () {
		for (var e in {toString: 1}) {
			if (e === "toString") {
				return false
			}
		}
		return true
	})();

	function a() {
	}

	function b() {
		var h = null, g = $A(arguments);
		if (Object.isFunction(g[0])) {
			h = g.shift()
		}
		function e() {
			this.initialize.apply(this, arguments)
		}

		Object.extend(e, Class.Methods);
		e.superclass = h;
		e.subclasses = [];
		if (h) {
			a.prototype = h.prototype;
			e.prototype = new a;
			h.subclasses.push(e)
		}
		for (var f = 0, j = g.length; f < j; f++) {
			e.addMethods(g[f])
		}
		if (!e.prototype.initialize) {
			e.prototype.initialize = Prototype.emptyFunction
		}
		e.prototype.constructor = e;
		return e
	}

	function c(l) {
		var g = this.superclass && this.superclass.prototype, f = Object.keys(l);
		if (d) {
			if (l.toString != Object.prototype.toString) {
				f.push("toString")
			}
			if (l.valueOf != Object.prototype.valueOf) {
				f.push("valueOf")
			}
		}
		for (var e = 0, h = f.length; e < h; e++) {
			var k = f[e], j = l[k];
			if (g && Object.isFunction(j) && j.argumentNames()[0] == "$super") {
				var m = j;
				j = (function (i) {
					return function () {
						return g[i].apply(this, arguments)
					}
				})(k).wrap(m);
				j.valueOf = (function (i) {
					return function () {
						return i.valueOf.call(i)
					}
				})(m);
				j.toString = (function (i) {
					return function () {
						return i.toString.call(i)
					}
				})(m)
			}
			this.prototype[k] = j
		}
		return this
	}

	return{create: b, Methods: {addMethods: c}}
})();
(function () {
	var y = Object.prototype.toString, k = Object.prototype.hasOwnProperty, z = "Null", B = "Undefined", K = "Boolean", w = "Number", v = "String", I = "Object", i = "[object Function]", d = "[object Boolean]", j = "[object Number]", f = "[object String]", b = "[object Array]", H = "[object Date]", e = window.JSON && typeof JSON.stringify === "function" && JSON.stringify(0) === "0" && typeof JSON.stringify(Prototype.K) === "undefined";
	var q = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
	var a = (function () {
		for (var L in {toString: 1}) {
			if (L === "toString") {
				return false
			}
		}
		return true
	})();

	function D(M) {
		switch (M) {
			case null:
				return z;
			case (void 0):
				return B
		}
		var L = typeof M;
		switch (L) {
			case"boolean":
				return K;
			case"number":
				return w;
			case"string":
				return v
		}
		return I
	}

	function h(L, N) {
		for (var M in N) {
			L[M] = N[M]
		}
		return L
	}

	function l(L) {
		try {
			if (o(L)) {
				return"undefined"
			}
			if (L === null) {
				return"null"
			}
			return L.inspect ? L.inspect() : String(L)
		} catch (M) {
			if (M instanceof RangeError) {
				return"..."
			}
			throw M
		}
	}

	function A(L) {
		return m("", {"": L}, [])
	}

	function m(U, R, S) {
		var T = R[U];
		if (D(T) === I && typeof T.toJSON === "function") {
			T = T.toJSON(U)
		}
		var N = y.call(T);
		switch (N) {
			case j:
			case d:
			case f:
				T = T.valueOf()
		}
		switch (T) {
			case null:
				return"null";
			case true:
				return"true";
			case false:
				return"false"
		}
		var Q = typeof T;
		switch (Q) {
			case"string":
				return T.inspect(true);
			case"number":
				return isFinite(T) ? String(T) : "null";
			case"object":
				for (var M = 0, L = S.length; M < L; M++) {
					if (S[M] === T) {
						throw new TypeError("Cyclic reference to '" + T + "' in object")
					}
				}
				S.push(T);
				var P = [];
				if (N === b) {
					for (var M = 0, L = T.length; M < L; M++) {
						var O = m(M, T, S);
						P.push(typeof O === "undefined" ? "null" : O)
					}
					P = "[" + P.join(",") + "]"
				} else {
					var V = Object.keys(T);
					for (var M = 0, L = V.length; M < L; M++) {
						var U = V[M], O = m(U, T, S);
						if (typeof O !== "undefined") {
							P.push(U.inspect(true) + ":" + O)
						}
					}
					P = "{" + P.join(",") + "}"
				}
				S.pop();
				return P
		}
	}

	function J(L) {
		return JSON.stringify(L)
	}

	function C(L) {
		return $H(L).toQueryString()
	}

	function p(L) {
		return L && L.toHTML ? L.toHTML() : String.interpret(L)
	}

	function x(L) {
		if (D(L) !== I) {
			throw new TypeError()
		}
		var N = [];
		for (var O in L) {
			if (k.call(L, O)) {
				N.push(O)
			}
		}
		if (a) {
			for (var M = 0; O = q[M]; M++) {
				if (k.call(L, O)) {
					N.push(O)
				}
			}
		}
		return N
	}

	function G(L) {
		var M = [];
		for (var N in L) {
			M.push(L[N])
		}
		return M
	}

	function s(L) {
		return h({}, L)
	}

	function E(L) {
		return !!(L && L.nodeType == 1)
	}

	function u(L) {
		return y.call(L) === b
	}

	var c = (typeof Array.isArray == "function") && Array.isArray([]) && !Array.isArray({});
	if (c) {
		u = Array.isArray
	}
	function r(L) {
		return L instanceof Hash
	}

	function n(L) {
		return y.call(L) === i
	}

	function g(L) {
		return y.call(L) === f
	}

	function F(L) {
		return y.call(L) === j
	}

	function t(L) {
		return y.call(L) === H
	}

	function o(L) {
		return typeof L === "undefined"
	}

	h(Object, {extend: h, inspect: l, toJSON: e ? J : A, toQueryString: C, toHTML: p, keys: Object.keys || x, values: G, clone: s, isElement: E, isArray: u, isHash: r, isFunction: n, isString: g, isNumber: F, isDate: t, isUndefined: o})
})();
Object.extend(Function.prototype, (function () {
	var l = Array.prototype.slice;

	function d(p, m) {
		var o = p.length, n = m.length;
		while (n--) {
			p[o + n] = m[n]
		}
		return p
	}

	function j(n, m) {
		n = l.call(n, 0);
		return d(n, m)
	}

	function g() {
		var m = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, "").replace(/\s+/g, "").split(",");
		return m.length == 1 && !m[0] ? [] : m
	}

	function h(o) {
		if (arguments.length < 2 && Object.isUndefined(arguments[0])) {
			return this
		}
		if (!Object.isFunction(this)) {
			throw new TypeError("The object is not callable.")
		}
		var q = function () {
		};
		var m = this, n = l.call(arguments, 1);
		var p = function () {
			var r = j(n, arguments), s = o;
			var s = this instanceof p ? this : o;
			return m.apply(s, r)
		};
		q.prototype = this.prototype;
		p.prototype = new q();
		return p
	}

	function f(o) {
		var m = this, n = l.call(arguments, 1);
		return function (q) {
			var p = d([q || window.event], n);
			return m.apply(o, p)
		}
	}

	function k() {
		if (!arguments.length) {
			return this
		}
		var m = this, n = l.call(arguments, 0);
		return function () {
			var o = j(n, arguments);
			return m.apply(this, o)
		}
	}

	function e(o) {
		var m = this, n = l.call(arguments, 1);
		o = o * 1000;
		return window.setTimeout(function () {
			return m.apply(m, n)
		}, o)
	}

	function a() {
		var m = d([0.01], arguments);
		return this.delay.apply(this, m)
	}

	function c(n) {
		var m = this;
		return function () {
			var o = d([m.bind(this)], arguments);
			return n.apply(this, o)
		}
	}

	function b() {
		if (this._methodized) {
			return this._methodized
		}
		var m = this;
		return this._methodized = function () {
			var n = d([this], arguments);
			return m.apply(null, n)
		}
	}

	var i = {argumentNames: g, bindAsEventListener: f, curry: k, delay: e, defer: a, wrap: c, methodize: b};
	if (!Function.prototype.bind) {
		i.bind = h
	}
	return i
})());
(function (c) {
	function b() {
		return this.getUTCFullYear() + "-" + (this.getUTCMonth() + 1).toPaddedString(2) + "-" + this.getUTCDate().toPaddedString(2) + "T" + this.getUTCHours().toPaddedString(2) + ":" + this.getUTCMinutes().toPaddedString(2) + ":" + this.getUTCSeconds().toPaddedString(2) + "Z"
	}

	function a() {
		return this.toISOString()
	}

	if (!c.toISOString) {
		c.toISOString = b
	}
	if (!c.toJSON) {
		c.toJSON = a
	}
})(Date.prototype);
RegExp.prototype.match = RegExp.prototype.test;
RegExp.escape = function (a) {
	return String(a).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
};
var PeriodicalExecuter = Class.create({initialize: function (b, a) {
	this.callback = b;
	this.frequency = a;
	this.currentlyExecuting = false;
	this.registerCallback()
}, registerCallback: function () {
	this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000)
}, execute: function () {
	this.callback(this)
}, stop: function () {
	if (!this.timer) {
		return
	}
	clearInterval(this.timer);
	this.timer = null
}, onTimerEvent: function () {
	if (!this.currentlyExecuting) {
		try {
			this.currentlyExecuting = true;
			this.execute();
			this.currentlyExecuting = false
		} catch (a) {
			this.currentlyExecuting = false;
			throw a
		}
	}
}});
Object.extend(String, {interpret: function (a) {
	return a == null ? "" : String(a)
}, specialChar: {"\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", "\\": "\\\\"}});
Object.extend(String.prototype, (function () {
	var NATIVE_JSON_PARSE_SUPPORT = window.JSON && typeof JSON.parse === "function" && JSON.parse('{"test": true}').test;

	function prepareReplacement(replacement) {
		if (Object.isFunction(replacement)) {
			return replacement
		}
		var template = new Template(replacement);
		return function (match) {
			return template.evaluate(match)
		}
	}

	function gsub(pattern, replacement) {
		var result = "", source = this, match;
		replacement = prepareReplacement(replacement);
		if (Object.isString(pattern)) {
			pattern = RegExp.escape(pattern)
		}
		if (!(pattern.length || pattern.source)) {
			replacement = replacement("");
			return replacement + source.split("").join(replacement) + replacement
		}
		while (source.length > 0) {
			if (match = source.match(pattern)) {
				result += source.slice(0, match.index);
				result += String.interpret(replacement(match));
				source = source.slice(match.index + match[0].length)
			} else {
				result += source, source = ""
			}
		}
		return result
	}

	function sub(pattern, replacement, count) {
		replacement = prepareReplacement(replacement);
		count = Object.isUndefined(count) ? 1 : count;
		return this.gsub(pattern, function (match) {
			if (--count < 0) {
				return match[0]
			}
			return replacement(match)
		})
	}

	function scan(pattern, iterator) {
		this.gsub(pattern, iterator);
		return String(this)
	}

	function truncate(length, truncation) {
		length = length || 30;
		truncation = Object.isUndefined(truncation) ? "..." : truncation;
		return this.length > length ? this.slice(0, length - truncation.length) + truncation : String(this)
	}

	function strip() {
		return this.replace(/^\s+/, "").replace(/\s+$/, "")
	}

	function stripTags() {
		return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, "")
	}

	function stripScripts() {
		return this.replace(new RegExp(Prototype.ScriptFragment, "img"), "")
	}

	function extractScripts() {
		var matchAll = new RegExp(Prototype.ScriptFragment, "img"), matchOne = new RegExp(Prototype.ScriptFragment, "im");
		return(this.match(matchAll) || []).map(function (scriptTag) {
			return(scriptTag.match(matchOne) || ["", ""])[1]
		})
	}

	function evalScripts() {
		return this.extractScripts().map(function (script) {
			return eval(script)
		})
	}

	function escapeHTML() {
		return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
	}

	function unescapeHTML() {
		return this.stripTags().replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")
	}

	function toQueryParams(separator) {
		var match = this.strip().match(/([^?#]*)(#.*)?$/);
		if (!match) {
			return{}
		}
		return match[1].split(separator || "&").inject({}, function (hash, pair) {
			if ((pair = pair.split("="))[0]) {
				var key = decodeURIComponent(pair.shift()), value = pair.length > 1 ? pair.join("=") : pair[0];
				if (value != undefined) {
					value = decodeURIComponent(value)
				}
				if (key in hash) {
					if (!Object.isArray(hash[key])) {
						hash[key] = [hash[key]]
					}
					hash[key].push(value)
				} else {
					hash[key] = value
				}
			}
			return hash
		})
	}

	function toArray() {
		return this.split("")
	}

	function succ() {
		return this.slice(0, this.length - 1) + String.fromCharCode(this.charCodeAt(this.length - 1) + 1)
	}

	function times(count) {
		return count < 1 ? "" : new Array(count + 1).join(this)
	}

	function camelize() {
		return this.replace(/-+(.)?/g, function (match, chr) {
			return chr ? chr.toUpperCase() : ""
		})
	}

	function capitalize() {
		return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase()
	}

	function underscore() {
		return this.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/-/g, "_").toLowerCase()
	}

	function dasherize() {
		return this.replace(/_/g, "-")
	}

	function inspect(useDoubleQuotes) {
		var escapedString = this.replace(/[\x00-\x1f\\]/g, function (character) {
			if (character in String.specialChar) {
				return String.specialChar[character]
			}
			return"\\u00" + character.charCodeAt().toPaddedString(2, 16)
		});
		if (useDoubleQuotes) {
			return'"' + escapedString.replace(/"/g, '\\"') + '"'
		}
		return"'" + escapedString.replace(/'/g, "\\'") + "'"
	}

	function unfilterJSON(filter) {
		return this.replace(filter || Prototype.JSONFilter, "$1")
	}

	function isJSON() {
		var str = this;
		if (str.blank()) {
			return false
		}
		str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@");
		str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]");
		str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, "");
		return(/^[\],:{}\s]*$/).test(str)
	}

	function evalJSON(sanitize) {
		var json = this.unfilterJSON(), cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
		if (cx.test(json)) {
			json = json.replace(cx, function (a) {
				return"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
			})
		}
		try {
			if (!sanitize || json.isJSON()) {
				return eval("(" + json + ")")
			}
		} catch (e) {
		}
		throw new SyntaxError("Badly formed JSON string: " + this.inspect())
	}

	function parseJSON() {
		var json = this.unfilterJSON();
		return JSON.parse(json)
	}

	function include(pattern) {
		return this.indexOf(pattern) > -1
	}

	function startsWith(pattern) {
		return this.lastIndexOf(pattern, 0) === 0
	}

	function endsWith(pattern) {
		var d = this.length - pattern.length;
		return d >= 0 && this.indexOf(pattern, d) === d
	}

	function empty() {
		return this == ""
	}

	function blank() {
		return/^\s*$/.test(this)
	}

	function interpolate(object, pattern) {
		return new Template(this, pattern).evaluate(object)
	}

	return{gsub: gsub, sub: sub, scan: scan, truncate: truncate, strip: String.prototype.trim || strip, stripTags: stripTags, stripScripts: stripScripts, extractScripts: extractScripts, evalScripts: evalScripts, escapeHTML: escapeHTML, unescapeHTML: unescapeHTML, toQueryParams: toQueryParams, parseQuery: toQueryParams, toArray: toArray, succ: succ, times: times, camelize: camelize, capitalize: capitalize, underscore: underscore, dasherize: dasherize, inspect: inspect, unfilterJSON: unfilterJSON, isJSON: isJSON, evalJSON: NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON, include: include, startsWith: startsWith, endsWith: endsWith, empty: empty, blank: blank, interpolate: interpolate}
})());
var Template = Class.create({initialize: function (a, b) {
	this.template = a.toString();
	this.pattern = b || Template.Pattern
}, evaluate: function (a) {
	if (a && Object.isFunction(a.toTemplateReplacements)) {
		a = a.toTemplateReplacements()
	}
	return this.template.gsub(this.pattern, function (d) {
		if (a == null) {
			return(d[1] + "")
		}
		var f = d[1] || "";
		if (f == "\\") {
			return d[2]
		}
		var b = a, g = d[3], e = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
		d = e.exec(g);
		if (d == null) {
			return f
		}
		while (d != null) {
			var c = d[1].startsWith("[") ? d[2].replace(/\\\\]/g, "]") : d[1];
			b = b[c];
			if (null == b || "" == d[3]) {
				break
			}
			g = g.substring("[" == d[3] ? d[1].length : d[0].length);
			d = e.exec(g)
		}
		return f + String.interpret(b)
	})
}});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
var $break = {};
var Enumerable = (function () {
	function c(x, w) {
		try {
			this._each(x, w)
		} catch (y) {
			if (y != $break) {
				throw y
			}
		}
		return this
	}

	function r(z, y, x) {
		var w = -z, A = [], B = this.toArray();
		if (z < 1) {
			return B
		}
		while ((w += z) < B.length) {
			A.push(B.slice(w, w + z))
		}
		return A.collect(y, x)
	}

	function b(y, x) {
		y = y || Prototype.K;
		var w = true;
		this.each(function (A, z) {
			w = w && !!y.call(x, A, z, this);
			if (!w) {
				throw $break
			}
		}, this);
		return w
	}

	function i(y, x) {
		y = y || Prototype.K;
		var w = false;
		this.each(function (A, z) {
			if (w = !!y.call(x, A, z, this)) {
				throw $break
			}
		}, this);
		return w
	}

	function j(y, x) {
		y = y || Prototype.K;
		var w = [];
		this.each(function (A, z) {
			w.push(y.call(x, A, z, this))
		}, this);
		return w
	}

	function t(y, x) {
		var w;
		this.each(function (A, z) {
			if (y.call(x, A, z, this)) {
				w = A;
				throw $break
			}
		}, this);
		return w
	}

	function h(y, x) {
		var w = [];
		this.each(function (A, z) {
			if (y.call(x, A, z, this)) {
				w.push(A)
			}
		}, this);
		return w
	}

	function g(z, y, x) {
		y = y || Prototype.K;
		var w = [];
		if (Object.isString(z)) {
			z = new RegExp(RegExp.escape(z))
		}
		this.each(function (B, A) {
			if (z.match(B)) {
				w.push(y.call(x, B, A, this))
			}
		}, this);
		return w
	}

	function a(w) {
		if (Object.isFunction(this.indexOf)) {
			if (this.indexOf(w) != -1) {
				return true
			}
		}
		var x = false;
		this.each(function (y) {
			if (y == w) {
				x = true;
				throw $break
			}
		});
		return x
	}

	function q(x, w) {
		w = Object.isUndefined(w) ? null : w;
		return this.eachSlice(x, function (y) {
			while (y.length < x) {
				y.push(w)
			}
			return y
		})
	}

	function l(w, y, x) {
		this.each(function (A, z) {
			w = y.call(x, w, A, z, this)
		}, this);
		return w
	}

	function v(x) {
		var w = $A(arguments).slice(1);
		return this.map(function (y) {
			return y[x].apply(y, w)
		})
	}

	function p(y, x) {
		y = y || Prototype.K;
		var w;
		this.each(function (A, z) {
			A = y.call(x, A, z, this);
			if (w == null || A >= w) {
				w = A
			}
		}, this);
		return w
	}

	function n(y, x) {
		y = y || Prototype.K;
		var w;
		this.each(function (A, z) {
			A = y.call(x, A, z, this);
			if (w == null || A < w) {
				w = A
			}
		}, this);
		return w
	}

	function e(z, x) {
		z = z || Prototype.K;
		var y = [], w = [];
		this.each(function (B, A) {
			(z.call(x, B, A, this) ? y : w).push(B)
		}, this);
		return[y, w]
	}

	function f(x) {
		var w = [];
		this.each(function (y) {
			w.push(y[x])
		});
		return w
	}

	function d(y, x) {
		var w = [];
		this.each(function (A, z) {
			if (!y.call(x, A, z, this)) {
				w.push(A)
			}
		}, this);
		return w
	}

	function m(x, w) {
		return this.map(function (z, y) {
			return{value: z, criteria: x.call(w, z, y, this)}
		}, this).sort(function (B, A) {
			var z = B.criteria, y = A.criteria;
			return z < y ? -1 : z > y ? 1 : 0
		}).pluck("value")
	}

	function o() {
		return this.map();
	}

	function s() {
		var x = Prototype.K, w = $A(arguments);
		if (Object.isFunction(w.last())) {
			x = w.pop()
		}
		var y = [this].concat(w).map($A);
		return this.map(function (A, z) {
			return x(y.pluck(z))
		})
	}

	function k() {
		return this.toArray().length
	}

	function u() {
		return"#<Enumerable:" + this.toArray().inspect() + ">"
	}

	return{each: c, eachSlice: r, all: b, every: b, any: i, some: i, collect: j, map: j, detect: t, findAll: h, select: h, filter: h, grep: g, include: a, member: a, inGroupsOf: q, inject: l, invoke: v, max: p, min: n, partition: e, pluck: f, reject: d, sortBy: m, toArray1: o, entries1: o, zip: s, size: k, inspect: u, find: t}
})();
function $A(c) {
	if (!c) {
		return[]
	}
	if ("toArray" in Object(c)) {
		return c.toArray()
	}

	//added. James G to ensure backward compatibility after clash of some functions with TOMS App
    if ("toArray1" in Object(c)) {
        return c.toArray1();
     }

	var b = c.length || 0, a = new Array(b);
	while (b--) {
		a[b] = c[b]
	}
	return a
}
function $w(a) {
	if (!Object.isString(a)) {
		return[]
	}
	a = a.strip();
	return a ? a.split(/\s+/) : []
}

if (typeof Array.from === "undefined") { 
    // safe to use make this change
	Array.from = $A;
	console.error('Array.from changed');
}


(function () {
	var x = Array.prototype, p = x.slice, r = x.forEach;

	function b(D, C) {
		for (var B = 0, E = this.length >>> 0; B < E; B++) {
			if (B in this) {
				D.call(C, this[B], B, this)
			}
		}
	}

	if (!r) {
		r = b
	}
	function o() {
		this.length = 0;
		return this
	}

	function d() {
		return this[0]
	}

	function g() {
		return this[this.length - 1]
	}

	function k() {
		return this.select(function (B) {
			return B != null
		})
	}

	function A() {
		return this.inject([], function (C, B) {
			if (Object.isArray(B)) {
				return C.concat(B.flatten())
			}
			C.push(B);
			return C
		})
	}

	function j() {
		var B = p.call(arguments, 0);
		return this.select(function (C) {
			return !B.include(C)
		})
	}

	function f(B) {
		return(B === false ? this.toArray() : this)._reverse()
	}

	function n(B) {
		return this.inject([], function (E, D, C) {
			if (0 == C || (B ? E.last() != D : !E.include(D))) {
				E.push(D)
			}
			return E
		})
	}

	function s(B) {
		return this.uniq().findAll(function (C) {
			return B.indexOf(C) !== -1
		})
	}

	function v() {
		return p.call(this, 0)
	}

	function l() {
		return this.length
	}

	function y() {
		return"[" + this.map(Object.inspect).join(", ") + "]"
	}

	function a(E, C) {
		if (this == null) {
			throw new TypeError()
		}
		var F = Object(this), D = F.length >>> 0;
		if (D === 0) {
			return -1
		}
		C = Number(C);
		if (isNaN(C)) {
			C = 0
		} else {
			if (C !== 0 && isFinite(C)) {
				C = (C > 0 ? 1 : -1) * Math.floor(Math.abs(C))
			}
		}
		if (C > D) {
			return -1
		}
		var B = C >= 0 ? C : Math.max(D - Math.abs(C), 0);
		for (; B < D; B++) {
			if (B in F && F[B] === E) {
				return B
			}
		}
		return -1
	}

	function q(E, C) {
		if (this == null) {
			throw new TypeError()
		}
		var F = Object(this), D = F.length >>> 0;
		if (D === 0) {
			return -1
		}
		if (!Object.isUndefined(C)) {
			C = Number(C);
			if (isNaN(C)) {
				C = 0
			} else {
				if (C !== 0 && isFinite(C)) {
					C = (C > 0 ? 1 : -1) * Math.floor(Math.abs(C))
				}
			}
		} else {
			C = D
		}
		var B = C >= 0 ? Math.min(C, D - 1) : D - Math.abs(C);
		for (; B >= 0; B--) {
			if (B in F && F[B] === E) {
				return B
			}
		}
		return -1
	}

	function c(I) {
		var G = [], H = p.call(arguments, 0), J, C = 0;
		H.unshift(this);
		for (var F = 0, B = H.length; F < B; F++) {
			J = H[F];
			if (Object.isArray(J) && !("callee" in J)) {
				for (var E = 0, D = J.length; E < D; E++) {
					if (E in J) {
						G[C] = J[E]
					}
					C++
				}
			} else {
				G[C++] = J
			}
		}
		G.length = C;
		return G
	}

	function u(B) {
		return function () {
			if (arguments.length === 0) {
				return B.call(this, Prototype.K)
			} else {
				if (arguments[0] === undefined) {
					var C = p.call(arguments, 1);
					C.unshift(Prototype.K);
					return B.apply(this, C)
				} else {
					return B.apply(this, arguments)
				}
			}
		}
	}

	function w(F) {
		if (this == null) {
			throw new TypeError()
		}
		F = F || Prototype.K;
		var B = Object(this);
		var E = [], D = arguments[1], H = 0;
		for (var C = 0, G = B.length >>> 0; C < G; C++) {
			if (C in B) {
				E[H] = F.call(D, B[C], C, B)
			}
			H++
		}
		E.length = H;
		return E
	}

	if (x.map) {
		w = u(Array.prototype.map)
	}
	function h(F) {
		if (this == null || !Object.isFunction(F)) {
			throw new TypeError()
		}
		var B = Object(this);
		var E = [], D = arguments[1], H;
		for (var C = 0, G = B.length >>> 0; C < G; C++) {
			if (C in B) {
				H = B[C];
				if (F.call(D, H, C, B)) {
					E.push(H)
				}
			}
		}
		return E
	}

	if (x.filter) {
		h = Array.prototype.filter
	}
	function i(E) {
		if (this == null) {
			throw new TypeError()
		}
		E = E || Prototype.K;
		var D = arguments[1];
		var B = Object(this);
		for (var C = 0, F = B.length >>> 0; C < F; C++) {
			if (C in B && E.call(D, B[C], C, B)) {
				return true
			}
		}
		return false
	}

	if (x.some) {
		var i = u(Array.prototype.some)
	}
	function z(E) {
		if (this == null) {
			throw new TypeError()
		}
		E = E || Prototype.K;
		var D = arguments[1];
		var B = Object(this);
		for (var C = 0, F = B.length >>> 0; C < F; C++) {
			if (C in B && !E.call(D, B[C], C, B)) {
				return false
			}
		}
		return true
	}

	if (x.every) {
		var z = u(Array.prototype.every)
	}
	var t = x.reduce;

	function m(B, D) {
		D = D || Prototype.K;
		var C = arguments[2];
		return t.call(this, D.bind(C), B)
	}

	if (!x.reduce) {
		var m = Enumerable.inject
	}
	Object.extend(x, Enumerable);
	if (!x._reverse) {
		x._reverse = x.reverse
	}
	Object.extend(x, {_each: r, map: w, collect: w, select: h, filter: h, findAll: h, some: i, any: i, every: z, all: z, inject: m, clear: o, first: d, last: g, compact: k, flatten: A, without: j, reverse: f, uniq: n, intersect: s, clone: v, toArray: v, size: l, inspect: y});
	var e = (function () {
		return[].concat(arguments)[0][0] !== 1
	})(1, 2);
	if (e) {
		x.concat = c
	}
	if (!x.indexOf) {
		x.indexOf = a
	}
	if (!x.lastIndexOf) {
		x.lastIndexOf = q
	}
})();
function $H(a) {
	return new Hash(a)
}
var Hash = Class.create(Enumerable, (function () {
	function e(p) {
		this._object = Object.isHash(p) ? p.toObject() : Object.clone(p)
	}

	function f(r, q) {
		for (var p in this._object) {
			var s = this._object[p], t = [p, s];
			t.key = p;
			t.value = s;
			r.call(q, t)
		}
	}

	function j(p, q) {
		return this._object[p] = q
	}

	function c(p) {
		if (this._object[p] !== Object.prototype[p]) {
			return this._object[p]
		}
	}

	function m(p) {
		var q = this._object[p];
		delete this._object[p];
		return q
	}

	function o() {
		return Object.clone(this._object)
	}

	function n() {
		return this.pluck("key")
	}

	function l() {
		return this.pluck("value")
	}

	function g(q) {
		var p = this.detect(function (r) {
			return r.value === q
		});
		return p && p.key
	}

	function i(p) {
		return this.clone().update(p)
	}

	function d(p) {
		return new Hash(p).inject(this, function (q, r) {
			q.set(r.key, r.value);
			return q
		})
	}

	function b(p, q) {
		if (Object.isUndefined(q)) {
			return p
		}
		var q = String.interpret(q);
		q = q.gsub(/(\r)?\n/, "\r\n");
		q = encodeURIComponent(q);
		q = q.gsub(/%20/, "+");
		return p + "=" + q
	}

	function a() {
		return this.inject([], function (t, w) {
			var s = encodeURIComponent(w.key), q = w.value;
			if (q && typeof q == "object") {
				if (Object.isArray(q)) {
					var v = [];
					for (var r = 0, p = q.length, u; r < p; r++) {
						u = q[r];
						v.push(b(s, u))
					}
					return t.concat(v)
				}
			} else {
				t.push(b(s, q))
			}
			return t
		}).join("&")
	}

	function k() {
		return"#<Hash:{" + this.map(function (p) {
			return p.map(Object.inspect).join(": ")
		}).join(", ") + "}>"
	}

	function h() {
		return new Hash(this)
	}

	return{initialize: e, _each: f, set: j, get: c, unset: m, toObject: o, toTemplateReplacements: o, keys: n, values: l, index: g, merge: i, update: d, toQueryString: a, inspect: k, toJSON: o, clone: h}
})());
Hash.from = $H;
Object.extend(Number.prototype, (function () {
	function d() {
		return this.toPaddedString(2, 16)
	}

	function b() {
		return this + 1
	}

	function h(j, i) {
		$R(0, this, true).each(j, i);
		return this
	}

	function g(k, j) {
		var i = this.toString(j || 10);
		return"0".times(k - i.length) + i
	}

	function a() {
		return Math.abs(this)
	}

	function c() {
		return Math.round(this)
	}

	function e() {
		return Math.ceil(this)
	}

	function f() {
		return Math.floor(this)
	}

	return{toColorPart: d, succ: b, times: h, toPaddedString: g, abs: a, round: c, ceil: e, floor: f}
})());
function $R(c, a, b) {
	return new ObjectRange(c, a, b)
}
var ObjectRange = Class.create(Enumerable, (function () {
	function b(f, d, e) {
		this.start = f;
		this.end = d;
		this.exclusive = e
	}

	function c(e, d) {
		var f = this.start;
		while (this.include(f)) {
			e.call(d, f);
			f = f.succ()
		}
	}

	function a(d) {
		if (d < this.start) {
			return false
		}
		if (this.exclusive) {
			return d < this.end
		}
		return d <= this.end
	}

	return{initialize: b, _each: c, include: a}
})());
var Abstract = {};
var Try = {these: function () {
	var c;
	for (var b = 0, d = arguments.length; b < d; b++) {
		var a = arguments[b];
		try {
			c = a();
			break
		} catch (f) {
		}
	}
	return c
}};
var Ajax = {getTransport: function () {
	return Try.these(function () {
		return new XMLHttpRequest()
	}, function () {
		return new ActiveXObject("Msxml2.XMLHTTP")
	}, function () {
		return new ActiveXObject("Microsoft.XMLHTTP")
	}) || false
}, activeRequestCount: 0};
Ajax.Responders = {responders: [], _each: function (b, a) {
	this.responders._each(b, a)
}, register: function (a) {
	if (!this.include(a)) {
		this.responders.push(a)
	}
}, unregister: function (a) {
	this.responders = this.responders.without(a)
}, dispatch: function (d, b, c, a) {
	this.each(function (f) {
		if (Object.isFunction(f[d])) {
			try {
				f[d].apply(f, [b, c, a])
			} catch (g) {
			}
		}
	})
}};
Object.extend(Ajax.Responders, Enumerable);
Ajax.Responders.register({onCreate: function () {
	Ajax.activeRequestCount++
}, onComplete: function () {
	Ajax.activeRequestCount--
}});
Ajax.Base = Class.create({initialize: function (a) {
	this.options = {method: "post", asynchronous: true, contentType: "application/x-www-form-urlencoded", encoding: "UTF-8", parameters: "", evalJSON: true, evalJS: true};
	Object.extend(this.options, a || {});
	this.options.method = this.options.method.toLowerCase();
	if (Object.isHash(this.options.parameters)) {
		this.options.parameters = this.options.parameters.toObject()
	}
}});
Ajax.Request = Class.create(Ajax.Base, {_complete: false, initialize: function ($super, b, a) {
	$super(a);
	this.transport = Ajax.getTransport();
	this.request(b)
}, request: function (b) {
	if (typeof(b) == "string") {
		this.url = b
	} else {
		if (b && typeof(b.href) == "string") {
			this.url = b.href
		} else {
			this.url = b + ""
		}
	}
	this.method = this.options.method;
	var d = Object.isString(this.options.parameters) ? this.options.parameters : Object.toQueryString(this.options.parameters);
	if (!["get", "post"].include(this.method)) {
		d += (d ? "&" : "") + "_method=" + this.method;
		this.method = "post"
	}
	if (d && this.method === "get") {
		this.url += (this.url.include("?") ? "&" : "?") + d
	}
	this.parameters = d.toQueryParams();
	try {
		var a = new Ajax.Response(this);
		if (this.options.onCreate) {
			this.options.onCreate(a)
		}
		Ajax.Responders.dispatch("onCreate", this, a);
		this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous);
		if (this.options.asynchronous) {
			this.respondToReadyState.bind(this).defer(1)
		}
		this.transport.onreadystatechange = this.onStateChange.bind(this);
		this.setRequestHeaders();
		this.body = this.method == "post" ? (this.options.postBody || d) : null;
		this.transport.send(this.body);
		if (!this.options.asynchronous && this.transport.overrideMimeType) {
			this.onStateChange()
		}
	} catch (c) {
		this.dispatchException(c)
	}
}, onStateChange: function () {
	var a = this.transport.readyState;
	if (a > 1 && !((a == 4) && this._complete)) {
		this.respondToReadyState(this.transport.readyState)
	}
}, setRequestHeaders: function () {
	var e = {
		"X-Requested-With": "XMLHttpRequest", 
		"X-Prototype-Version": Prototype.Version, 
		Accept: "text/javascript, text/html, application/xml, text/xml, */*",
		"Access-Control-Allow-Origin": "*",
		"Authorization": PedigreeEditorTool.accessToken
	};
	if (this.method == "post") {
		e["Content-type"] = this.options.contentType + (this.options.encoding ? "; charset=" + this.options.encoding : "");
		if (this.transport.overrideMimeType && (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0, 2005])[1] < 2005) {
			e.Connection = "close"
		}
	}
	if (typeof this.options.requestHeaders == "object") {
		var c = this.options.requestHeaders;
		if (Object.isFunction(c.push)) {
			for (var b = 0, d = c.length; b < d; b += 2) {
				e[c[b]] = c[b + 1]
			}
		} else {
			$H(c).each(function (f) {
				e[f.key] = f.value
			})
		}
	}
	for (var a in e) {
		this.transport.setRequestHeader(a, e[a])
	}
}, success: function () {
	var a = this.getStatus();
	return !a || (a >= 200 && a < 300) || a == 304
}, getStatus: function () {
	try {
		if (this.transport.status === 1223) {
			return 204
		}
		return this.transport.status || 0
	} catch (a) {
		return 0
	}
}, respondToReadyState: function (a) {
	var c = Ajax.Request.Events[a], b = new Ajax.Response(this);
	if (c == "Complete") {
		try {
			this._complete = true;
			(this.options["on" + b.status] || this.options["on" + (this.success() ? "Success" : "Failure")] || Prototype.emptyFunction)(b, b.headerJSON)
		} catch (d) {
			this.dispatchException(d)
		}
		var f = b.getHeader("Content-type");
		if (this.options.evalJS == "force" || (this.options.evalJS && this.isSameOrigin() && f && f.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i))) {
			this.evalResponse()
		}
	}
	try {
		(this.options["on" + c] || Prototype.emptyFunction)(b, b.headerJSON);
		Ajax.Responders.dispatch("on" + c, this, b, b.headerJSON)
	} catch (d) {
		this.dispatchException(d)
	}
	if (c == "Complete") {
		this.transport.onreadystatechange = Prototype.emptyFunction
	}
}, isSameOrigin: function () {
	var a = this.url.match(/^\s*https?:\/\/[^\/]*/);
	return !a || (a[0] == "#{protocol}//#{domain}#{port}".interpolate({protocol: location.protocol, domain: document.domain, port: location.port ? ":" + location.port : ""}))
}, getHeader: function (a) {
	try {
		return this.transport.getResponseHeader(a) || null
	} catch (b) {
		return null
	}
}, evalResponse: function () {
	try {
		return eval((this.transport.responseText || "").unfilterJSON())
	} catch (e) {
		this.dispatchException(e)
	}
}, dispatchException: function (a) {
	(this.options.onException || Prototype.emptyFunction)(this, a);
	Ajax.Responders.dispatch("onException", this, a)
}});
Ajax.Request.Events = ["Uninitialized", "Loading", "Loaded", "Interactive", "Complete"];
Ajax.Response = Class.create({initialize: function (c) {
	this.request = c;
	var d = this.transport = c.transport, a = this.readyState = d.readyState;
	if ((a > 2 && !Prototype.Browser.IE) || a == 4) {
		this.status = this.getStatus();
		this.statusText = this.getStatusText();
		this.responseText = String.interpret(d.responseText);
		this.headerJSON = this._getHeaderJSON()
	}
	if (a == 4) {
		var b = d.responseXML;
		this.responseXML = Object.isUndefined(b) ? null : b;
		this.responseJSON = this._getResponseJSON()
	}
}, status: 0, statusText: "", getStatus: Ajax.Request.prototype.getStatus, getStatusText: function () {
	try {
		return this.transport.statusText || ""
	} catch (a) {
		return""
	}
}, getHeader: Ajax.Request.prototype.getHeader, getAllHeaders: function () {
	try {
		return this.getAllResponseHeaders()
	} catch (a) {
		return null
	}
}, getResponseHeader: function (a) {
	return this.transport.getResponseHeader(a)
}, getAllResponseHeaders: function () {
	return this.transport.getAllResponseHeaders()
}, _getHeaderJSON: function () {
	var a = this.getHeader("X-JSON");
	if (!a) {
		return null
	}
	try {
		a = decodeURIComponent(escape(a))
	} catch (b) {
	}
	try {
		return a.evalJSON(this.request.options.sanitizeJSON || !this.request.isSameOrigin())
	} catch (b) {
		this.request.dispatchException(b)
	}
}, _getResponseJSON: function () {
	var a = this.request.options;
	if (!a.evalJSON || (a.evalJSON != "force" && !(this.getHeader("Content-type") || "").include("application/json")) || this.responseText.blank()) {
		return null
	}
	try {
		return this.responseText.evalJSON(a.sanitizeJSON || !this.request.isSameOrigin())
	} catch (b) {
		this.request.dispatchException(b)
	}
}});
Ajax.Updater = Class.create(Ajax.Request, {initialize: function ($super, a, c, b) {
	this.container = {success: (a.success || a), failure: (a.failure || (a.success ? null : a))};
	b = Object.clone(b);
	var d = b.onComplete;
	b.onComplete = (function (e, f) {
		this.updateContent(e.responseText);
		if (Object.isFunction(d)) {
			d(e, f)
		}
	}).bind(this);
	$super(c, b)
}, updateContent: function (d) {
	var c = this.container[this.success() ? "success" : "failure"], a = this.options;
	if (!a.evalScripts) {
		d = d.stripScripts()
	}
	if (c = $(c)) {
		if (a.insertion) {
			if (Object.isString(a.insertion)) {
				var b = {};
				b[a.insertion] = d;
				c.insert(b)
			} else {
				a.insertion(c, d)
			}
		} else {
			c.update(d)
		}
	}
}});
Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {initialize: function ($super, a, c, b) {
	$super(b);
	this.onComplete = this.options.onComplete;
	this.frequency = (this.options.frequency || 2);
	this.decay = (this.options.decay || 1);
	this.updater = {};
	this.container = a;
	this.url = c;
	this.start()
}, start: function () {
	this.options.onComplete = this.updateComplete.bind(this);
	this.onTimerEvent()
}, stop: function () {
	this.updater.options.onComplete = undefined;
	clearTimeout(this.timer);
	(this.onComplete || Prototype.emptyFunction).apply(this, arguments)
}, updateComplete: function (a) {
	if (this.options.decay) {
		this.decay = (a.responseText == this.lastText ? this.decay * this.options.decay : 1);
		this.lastText = a.responseText
	}
	this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency)
}, onTimerEvent: function () {
	this.updater = new Ajax.Updater(this.container, this.url, this.options)
}});
(function (a6) {
	var aC;
	var aZ = Array.prototype.slice;
	var at = document.createElement("div");

	function aX(bm) {
		if (arguments.length > 1) {
			for (var F = 0, bo = [], bn = arguments.length; F < bn; F++) {
				bo.push(aX(arguments[F]))
			}
			return bo
		}
		if (Object.isString(bm)) {
			bm = document.getElementById(bm)
		}
		return aD.extend(bm)
	}

	a6.$ = aX;
	if (!a6.Node) {
		a6.Node = {}
	}
	if (!a6.Node.ELEMENT_NODE) {
		Object.extend(a6.Node, {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5, ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12})
	}
	var p = {};

	function aO(F, i) {
		if (F === "select") {
			return false
		}
		if ("type" in i) {
			return false
		}
		return true
	}

	var c = (function () {
		try {
			var i = document.createElement('<input name="x">');
			return i.tagName.toLowerCase() === "input" && i.name === "x"
		} catch (F) {
			return false
		}
	})();
	var aG = a6.Element;

	function aD(F, i) {
		i = i || {};
		F = F.toLowerCase();
		if (c && i.name) {
			F = "<" + F + ' name="' + i.name + '">';
			delete i.name;
			return aD.writeAttribute(document.createElement(F), i)
		}
		if (!p[F]) {
			p[F] = aD.extend(document.createElement(F))
		}
		var bm = aO(F, i) ? p[F].cloneNode(false) : document.createElement(F);
		return aD.writeAttribute(bm, i)
	}

	a6.Element = aD;
	Object.extend(a6.Element, aG || {});
	if (aG) {
		a6.Element.prototype = aG.prototype
	}
	aD.Methods = {ByTag: {}, Simulated: {}};
	var a1 = {};
	var E = {id: "id", className: "class"};

	function a8(F) {
		F = aX(F);
		var i = "<" + F.tagName.toLowerCase();
		var bm, bo;
		for (var bn in E) {
			bm = E[bn];
			bo = (F[bn] || "").toString();
			if (bo) {
				i += " " + bm + "=" + bo.inspect(true)
			}
		}
		return i + ">"
	}

	a1.inspect = a8;
	function t(i) {
		return aX(i).style.display !== "none"
	}

	function av(F, i) {
		F = aX(F);
		if (Object.isUndefined(i)) {
			i = !aD.visible(F)
		}
		aD[i ? "show" : "hide"](F);
		return F
	}

	function aF(i) {
		i = aX(i);
		i.style.display = "none";
		return i
	}

	function h(i) {
		i = aX(i);
		i.style.display = "";
		return i
	}

	Object.extend(a1, {visible: t, toggle: av, hide: aF, show: h});
	function ab(i) {
		i = aX(i);
		i.parentNode.removeChild(i);
		return i
	}

	var aR = (function () {
		var i = document.createElement("select"), F = true;
		i.innerHTML = '<option value="test">test</option>';
		if (i.options && i.options[0]) {
			F = i.options[0].nodeName.toUpperCase() !== "OPTION"
		}
		i = null;
		return F
	})();
	var G = (function () {
		try {
			var i = document.createElement("table");
			if (i && i.tBodies) {
				i.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
				var bm = typeof i.tBodies[0] == "undefined";
				i = null;
				return bm
			}
		} catch (F) {
			return true
		}
	})();
	var a0 = (function () {
		try {
			var i = document.createElement("div");
			i.innerHTML = "<link />";
			var bm = (i.childNodes.length === 0);
			i = null;
			return bm
		} catch (F) {
			return true
		}
	})();
	var v = aR || G || a0;
	var ao = (function () {
		var i = document.createElement("script"), bm = false;
		try {
			i.appendChild(document.createTextNode(""));
			bm = !i.firstChild || i.firstChild && i.firstChild.nodeType !== 3
		} catch (F) {
			bm = true
		}
		i = null;
		return bm
	})();

	function M(bo, bq) {
		bo = aX(bo);
		var br = bo.getElementsByTagName("*"), bn = br.length;
		while (bn--) {
			X(br[bn])
		}
		if (bq && bq.toElement) {
			bq = bq.toElement()
		}
		if (Object.isElement(bq)) {
			return bo.update().insert(bq)
		}
		bq = Object.toHTML(bq);
		var bm = bo.tagName.toUpperCase();
		if (bm === "SCRIPT" && ao) {
			bo.text = bq;
			return bo
		}
		if (v) {
			if (bm in J.tags) {
				while (bo.firstChild) {
					bo.removeChild(bo.firstChild)
				}
				var F = r(bm, bq.stripScripts());
				for (var bn = 0, bp; bp = F[bn]; bn++) {
					bo.appendChild(bp)
				}
			} else {
				if (a0 && Object.isString(bq) && bq.indexOf("<link") > -1) {
					while (bo.firstChild) {
						bo.removeChild(bo.firstChild)
					}
					var F = r(bm, bq.stripScripts(), true);
					for (var bn = 0, bp; bp = F[bn]; bn++) {
						bo.appendChild(bp)
					}
				} else {
					bo.innerHTML = bq.stripScripts()
				}
			}
		} else {
			bo.innerHTML = bq.stripScripts()
		}
		bq.evalScripts.bind(bq).defer();
		return bo
	}

	function af(F, bm) {
		F = aX(F);
		if (bm && bm.toElement) {
			bm = bm.toElement()
		} else {
			if (!Object.isElement(bm)) {
				bm = Object.toHTML(bm);
				var i = F.ownerDocument.createRange();
				i.selectNode(F);
				bm.evalScripts.bind(bm).defer();
				bm = i.createContextualFragment(bm.stripScripts())
			}
		}
		F.parentNode.replaceChild(bm, F);
		return F
	}

	var J = {before: function (i, F) {
		i.parentNode.insertBefore(F, i)
	}, top: function (i, F) {
		i.insertBefore(F, i.firstChild)
	}, bottom: function (i, F) {
		i.appendChild(F)
	}, after: function (i, F) {
		i.parentNode.insertBefore(F, i.nextSibling)
	}, tags: {TABLE: ["<table>", "</table>", 1], TBODY: ["<table><tbody>", "</tbody></table>", 2], TR: ["<table><tbody><tr>", "</tr></tbody></table>", 3], TD: ["<table><tbody><tr><td>", "</td></tr></tbody></table>", 4], SELECT: ["<select>", "</select>", 1]}};
	var aH = J.tags;
	Object.extend(aH, {THEAD: aH.TBODY, TFOOT: aH.TBODY, TH: aH.TD});
	function am(bm, bp) {
		bm = aX(bm);
		if (bp && bp.toElement) {
			bp = bp.toElement()
		}
		if (Object.isElement(bp)) {
			bm.parentNode.replaceChild(bp, bm);
			return bm
		}
		bp = Object.toHTML(bp);
		var bo = bm.parentNode, F = bo.tagName.toUpperCase();
		if (F in J.tags) {
			var bq = aD.next(bm);
			var i = r(F, bp.stripScripts());
			bo.removeChild(bm);
			var bn;
			if (bq) {
				bn = function (br) {
					bo.insertBefore(br, bq)
				}
			} else {
				bn = function (br) {
					bo.appendChild(br)
				}
			}
			i.each(bn)
		} else {
			bm.outerHTML = bp.stripScripts()
		}
		bp.evalScripts.bind(bp).defer();
		return bm
	}

	if ("outerHTML" in document.documentElement) {
		af = am
	}
	function a5(i) {
		if (Object.isUndefined(i) || i === null) {
			return false
		}
		if (Object.isString(i) || Object.isNumber(i)) {
			return true
		}
		if (Object.isElement(i)) {
			return true
		}
		if (i.toElement || i.toHTML) {
			return true
		}
		return false
	}

	function bk(bo, bq, F) {
		F = F.toLowerCase();
		var bs = J[F];
		if (bq && bq.toElement) {
			bq = bq.toElement()
		}
		if (Object.isElement(bq)) {
			bs(bo, bq);
			return bo
		}
		bq = Object.toHTML(bq);
		var bn = ((F === "before" || F === "after") ? bo.parentNode : bo).tagName.toUpperCase();
		var br = r(bn, bq.stripScripts());
		if (F === "top" || F === "after") {
			br.reverse()
		}
		for (var bm = 0, bp; bp = br[bm]; bm++) {
			bs(bo, bp)
		}
		bq.evalScripts.bind(bq).defer()
	}

	function O(F, bm) {
		F = aX(F);
		if (a5(bm)) {
			bm = {bottom: bm}
		}
		for (var i in bm) {
			bk(F, bm[i], i)
		}
		return F
	}

	function s(F, bm, i) {
		F = aX(F);
		if (Object.isElement(bm)) {
			aX(bm).writeAttribute(i || {})
		} else {
			if (Object.isString(bm)) {
				bm = new aD(bm, i)
			} else {
				bm = new aD("div", bm)
			}
		}
		if (F.parentNode) {
			F.parentNode.replaceChild(bm, F)
		}
		bm.appendChild(F);
		return bm
	}

	function u(F) {
		F = aX(F);
		var bm = F.firstChild;
		while (bm) {
			var i = bm.nextSibling;
			if (bm.nodeType === Node.TEXT_NODE && !/\S/.test(bm.nodeValue)) {
				F.removeChild(bm)
			}
			bm = i
		}
		return F
	}

	function a2(i) {
		return aX(i).innerHTML.blank()
	}

	function r(bp, bo, bq) {
		var bn = J.tags[bp], bs = at, br = bs;
		bs.style.display = "none";
		document.documentElement.appendChild(bs);
		var F = !!bn;
		if (!F && bq) {
			F = true;
			bn = ["", "", 0]
		}
		if (F) {
			bs.innerHTML = "&#160;" + bn[0] + bo + bn[1];
			bs.removeChild(bs.firstChild);
			for (var bm = bn[2]; bm--;) {
				bs = bs.firstChild
			}
		} else {
			bs.innerHTML = bo
		}
		document.documentElement.removeChild(br);
		br.style.display = "";
		return $A(bs.childNodes)
	}

	function C(bn, F) {
		if (!(bn = aX(bn))) {
			return
		}
		var bp = bn.cloneNode(F);
		if (!aW) {
			bp._prototypeUID = aC;
			if (F) {
				var bo = aD.select(bp, "*"), bm = bo.length;
				while (bm--) {
					bo[bm]._prototypeUID = aC
				}
			}
		}
		return aD.extend(bp)
	}

	function X(F) {
		var i = K(F);
		if (i) {
			aD.stopObserving(F);
			if (!aW) {
				F._prototypeUID = aC
			}
			delete aD.Storage[i]
		}
	}

	function bi(bm) {
		var F = bm.length;
		while (F--) {
			X(bm[F])
		}
	}

	function aq(bo) {
		var bn = bo.length, bm, F;
		while (bn--) {
			bm = bo[bn];
			F = K(bm);
			delete aD.Storage[F];
			delete Event.cache[F]
		}
	}

	if (aW) {
		bi = aq
	}
	function l(bm) {
		if (!(bm = aX(bm))) {
			return
		}
		X(bm);
		var bn = bm.getElementsByTagName("*"), F = bn.length;
		while (F--) {
			X(bn[F])
		}
		return null
	}

	Object.extend(a1, {remove: ab, update: M, replace: af, insert: O, wrap: s, cleanWhitespace: u, empty: a2, clone: C, purge: l});
	function ak(i, bm, bn) {
		i = aX(i);
		bn = bn || -1;
		var F = [];
		while (i = i[bm]) {
			if (i.nodeType === Node.ELEMENT_NODE) {
				F.push(aD.extend(i))
			}
			if (F.length === bn) {
				break
			}
		}
		return F
	}

	function aJ(i) {
		return ak(i, "parentNode")
	}

	function bj(i) {
		return aD.select(i, "*")
	}

	function V(i) {
		i = aX(i).firstChild;
		while (i && i.nodeType !== Node.ELEMENT_NODE) {
			i = i.nextSibling
		}
		return aX(i)
	}

	function bf(F) {
		var i = [], bm = aX(F).firstChild;
		while (bm) {
			if (bm.nodeType === Node.ELEMENT_NODE) {
				i.push(aD.extend(bm))
			}
			bm = bm.nextSibling
		}
		return i
	}

	function n(i) {
		return ak(i, "previousSibling")
	}

	function be(i) {
		return ak(i, "nextSibling")
	}

	function aT(i) {
		i = aX(i);
		var bm = n(i), F = be(i);
		return bm.reverse().concat(F)
	}

	function aP(F, i) {
		F = aX(F);
		if (Object.isString(i)) {
			return Prototype.Selector.match(F, i)
		}
		return i.match(F)
	}

	function aU(F, bm, bn, i) {
		F = aX(F), bn = bn || 0, i = i || 0;
		if (Object.isNumber(bn)) {
			i = bn, bn = null
		}
		while (F = F[bm]) {
			if (F.nodeType !== 1) {
				continue
			}
			if (bn && !Prototype.Selector.match(F, bn)) {
				continue
			}
			if (--i >= 0) {
				continue
			}
			return aD.extend(F)
		}
	}

	function Y(F, bm, i) {
		F = aX(F);
		if (arguments.length === 1) {
			return aX(F.parentNode)
		}
		return aU(F, "parentNode", bm, i)
	}

	function w(F, bn, i) {
		F = aX(F), bn = bn || 0, i = i || 0;
		if (Object.isNumber(bn)) {
			i = bn, bn = "*"
		}
		var bm = Prototype.Selector.select(bn, F)[i];
		return aD.extend(bm)
	}

	function g(F, bm, i) {
		return aU(F, "previousSibling", bm, i)
	}

	function az(F, bm, i) {
		return aU(F, "nextSibling", bm, i)
	}

	function a9(i) {
		i = aX(i);
		var F = aZ.call(arguments, 1).join(", ");
		return Prototype.Selector.select(F, i)
	}

	function aB(bn) {
		bn = aX(bn);
		var bp = aZ.call(arguments, 1).join(", ");
		var bq = aD.siblings(bn), bm = [];
		for (var F = 0, bo; bo = bq[F]; F++) {
			if (Prototype.Selector.match(bo, bp)) {
				bm.push(bo)
			}
		}
		return bm
	}

	function B(F, i) {
		F = aX(F), i = aX(i);
		while (F = F.parentNode) {
			if (F === i) {
				return true
			}
		}
		return false
	}

	function z(F, i) {
		F = aX(F), i = aX(i);
		if (!i.contains) {
			return B(F, i)
		}
		return i.contains(F) && i !== F
	}

	function H(F, i) {
		F = aX(F), i = aX(i);
		return(F.compareDocumentPosition(i) & 8) === 8
	}

	var aK;
	if (at.compareDocumentPosition) {
		aK = H
	} else {
		if (at.contains) {
			aK = z
		} else {
			aK = B
		}
	}
	Object.extend(a1, {recursivelyCollect: ak, ancestors: aJ, descendants: bj, firstDescendant: V, immediateDescendants: bf, previousSiblings: n, nextSiblings: be, siblings: aT, match: aP, up: Y, down: w, previous: g, next: az, select: a9, adjacent: aB, descendantOf: aK, getElementsBySelector: a9, childElements: bf});
	var R = 1;

	function aS(i) {
		i = aX(i);
		var F = aD.readAttribute(i, "id");
		if (F) {
			return F
		}
		do {
			F = "anonymous_element_" + R++
		} while (aX(F));
		aD.writeAttribute(i, "id", F);
		return F
	}

	function a7(F, i) {
		return aX(F).getAttribute(i)
	}

	function I(F, i) {
		F = aX(F);
		var bm = aE.read;
		if (bm.values[i]) {
			return bm.values[i](F, i)
		}
		if (bm.names[i]) {
			i = bm.names[i]
		}
		if (i.include(":")) {
			if (!F.attributes || !F.attributes[i]) {
				return null
			}
			return F.attributes[i].value
		}
		return F.getAttribute(i)
	}

	function d(F, i) {
		if (i === "title") {
			return F.title
		}
		return F.getAttribute(i)
	}

	var S = (function () {
		at.setAttribute("onclick", Prototype.emptyFunction);
		var i = at.getAttribute("onclick");
		var F = (typeof i === "function");
		at.removeAttribute("onclick");
		return F
	})();
	if (S) {
		a7 = I
	} else {
		if (Prototype.Browser.Opera) {
			a7 = d
		}
	}
	function aY(bn, bm, bp) {
		bn = aX(bn);
		var F = {}, bo = aE.write;
		if (typeof bm === "object") {
			F = bm
		} else {
			F[bm] = Object.isUndefined(bp) ? true : bp
		}
		for (var i in F) {
			bm = bo.names[i] || i;
			bp = F[i];
			if (bo.values[i]) {
				bm = bo.values[i](bn, bp)
			}
			if (bp === false || bp === null) {
				bn.removeAttribute(bm)
			} else {
				if (bp === true) {
					bn.setAttribute(bm, bm)
				} else {
					bn.setAttribute(bm, bp)
				}
			}
		}
		return bn
	}

	function W(i, bm) {
		bm = aE.has[bm] || bm;
		var F = aX(i).getAttributeNode(bm);
		return !!(F && F.specified)
	}

	a6.Element.Methods.Simulated.hasAttribute = W;
	function j(i) {
		return new aD.ClassNames(i)
	}

	var T = {};

	function e(F) {
		if (T[F]) {
			return T[F]
		}
		var i = new RegExp("(^|\\s+)" + F + "(\\s+|$)");
		T[F] = i;
		return i
	}

	function aj(i, F) {
		if (!(i = aX(i))) {
			return
		}
		var bm = i.className;
		if (bm.length === 0) {
			return false
		}
		if (bm === F) {
			return true
		}
		return e(F).test(bm)
	}

	function m(i, F) {
		if (!(i = aX(i))) {
			return
		}
		if (!aj(i, F)) {
			i.className += (i.className ? " " : "") + F
		}
		return i
	}

	function ar(i, F) {
		if (!(i = aX(i))) {
			return
		}
		i.className = i.className.replace(e(F), " ").strip();
		return i
	}

	function ac(F, bm, i) {
		if (!(F = aX(F))) {
			return
		}
		if (Object.isUndefined(i)) {
			i = !aj(F, bm)
		}
		var bn = aD[i ? "addClassName" : "removeClassName"];
		return bn(F, bm)
	}

	var aE = {};
	var aN = "className", ap = "for";
	at.setAttribute(aN, "x");
	if (at.className !== "x") {
		at.setAttribute("class", "x");
		if (at.className === "x") {
			aN = "class"
		}
	}
	var aI = document.createElement("label");
	aI.setAttribute(ap, "x");
	if (aI.htmlFor !== "x") {
		aI.setAttribute("htmlFor", "x");
		if (aI.htmlFor === "x") {
			ap = "htmlFor"
		}
	}
	aI = null;
	function aa(i, F) {
		return i.getAttribute(F)
	}

	function f(i, F) {
		return i.getAttribute(F, 2)
	}

	function y(i, bm) {
		var F = i.getAttributeNode(bm);
		return F ? F.value : ""
	}

	function bg(i, F) {
		return aX(i).hasAttribute(F) ? F : null
	}

	at.onclick = Prototype.emptyFunction;
	var N = at.getAttribute("onclick");
	var au;
	if (String(N).indexOf("{") > -1) {
		au = function (i, F) {
			var bm = i.getAttribute(F);
			if (!bm) {
				return null
			}
			bm = bm.toString();
			bm = bm.split("{")[1];
			bm = bm.split("}")[0];
			return bm.strip()
		}
	} else {
		if (N === "") {
			au = function (i, F) {
				var bm = i.getAttribute(F);
				if (!bm) {
					return null
				}
				return bm.strip()
			}
		}
	}
	aE.read = {names: {"class": aN, className: aN, "for": ap, htmlFor: ap}, values: {style: function (i) {
		return i.style.cssText.toLowerCase()
	}, title: function (i) {
		return i.title
	}}};
	aE.write = {names: {className: "class", htmlFor: "for", cellpadding: "cellPadding", cellspacing: "cellSpacing"}, values: {checked: function (i, F) {
		i.checked = !!F
	}, style: function (i, F) {
		i.style.cssText = F ? F : ""
	}}};
	aE.has = {names: {}};
	Object.extend(aE.write.names, aE.read.names);
	var a4 = $w("colSpan rowSpan vAlign dateTime accessKey tabIndex encType maxLength readOnly longDesc frameBorder");
	for (var ad = 0, ae; ae = a4[ad]; ad++) {
		aE.write.names[ae.toLowerCase()] = ae;
		aE.has.names[ae.toLowerCase()] = ae
	}
	Object.extend(aE.read.values, {href: f, src: f, type: aa, action: y, disabled: bg, checked: bg, readonly: bg, multiple: bg, onload: au, onunload: au, onclick: au, ondblclick: au, onmousedown: au, onmouseup: au, onmouseover: au, onmousemove: au, onmouseout: au, onfocus: au, onblur: au, onkeypress: au, onkeydown: au, onkeyup: au, onsubmit: au, onreset: au, onselect: au, onchange: au});
	Object.extend(a1, {identify: aS, readAttribute: a7, writeAttribute: aY, classNames: j, hasClassName: aj, addClassName: m, removeClassName: ar, toggleClassName: ac});
	function U(i) {
		if (i === "float" || i === "styleFloat") {
			return"cssFloat"
		}
		return i.camelize()
	}

	function bl(i) {
		if (i === "float" || i === "cssFloat") {
			return"styleFloat"
		}
		return i.camelize()
	}

	function A(bm, bn) {
		bm = aX(bm);
		var bq = bm.style, F;
		if (Object.isString(bn)) {
			bq.cssText += ";" + bn;
			if (bn.include("opacity")) {
				var i = bn.match(/opacity:\s*(\d?\.?\d*)/)[1];
				aD.setOpacity(bm, i)
			}
			return bm
		}
		for (var bp in bn) {
			if (bp === "opacity") {
				aD.setOpacity(bm, bn[bp])
			} else {
				var bo = bn[bp];
				if (bp === "float" || bp === "cssFloat") {
					bp = Object.isUndefined(bq.styleFloat) ? "cssFloat" : "styleFloat"
				}
				bq[bp] = bo
			}
		}
		return bm
	}

	function aM(F, bm) {
		F = aX(F);
		bm = U(bm);
		var bn = F.style[bm];
		if (!bn || bn === "auto") {
			var i = document.defaultView.getComputedStyle(F, null);
			bn = i ? i[bm] : null
		}
		if (bm === "opacity") {
			return bn ? parseFloat(bn) : 1
		}
		return bn === "auto" ? null : bn
	}

	function q(i, F) {
		switch (F) {
			case"height":
			case"width":
				if (!aD.visible(i)) {
					return null
				}
				var bm = parseInt(aM(i, F), 10);
				if (bm !== i["offset" + F.capitalize()]) {
					return bm + "px"
				}
				return aD.measure(i, F);
			default:
				return aM(i, F)
		}
	}

	function ah(i, F) {
		i = aX(i);
		F = bl(F);
		var bm = i.style[F];
		if (!bm && i.currentStyle) {
			bm = i.currentStyle[F]
		}
		if (F === "opacity" && !L) {
			return bc(i)
		}
		if (bm === "auto") {
			if ((F === "width" || F === "height") && aD.visible(i)) {
				return aD.measure(i, F) + "px"
			}
			return null
		}
		return bm
	}

	function ay(i) {
		return(i || "").replace(/alpha\([^\)]*\)/gi, "")
	}

	function Z(i) {
		if (!i.currentStyle || !i.currentStyle.hasLayout) {
			i.style.zoom = 1
		}
		return i
	}

	var L = (function () {
		at.style.cssText = "opacity:.55";
		return/^0.55/.test(at.style.opacity)
	})();

	function x(i, F) {
		i = aX(i);
		if (F == 1 || F === "") {
			F = ""
		} else {
			if (F < 0.00001) {
				F = 0
			}
		}
		i.style.opacity = F;
		return i
	}

	function bd(i, bn) {
		if (L) {
			return x(i, bn)
		}
		i = Z(aX(i));
		var bm = aD.getStyle(i, "filter"), F = i.style;
		if (bn == 1 || bn === "") {
			bm = ay(bm);
			if (bm) {
				F.filter = bm
			} else {
				F.removeAttribute("filter")
			}
			return i
		}
		if (bn < 0.00001) {
			bn = 0
		}
		F.filter = ay(bm) + "alpha(opacity=" + (bn * 100) + ")";
		return i
	}

	function bb(i) {
		return aD.getStyle(i, "opacity")
	}

	function bc(F) {
		if (L) {
			return bb(F)
		}
		var bm = aD.getStyle(F, "filter");
		if (bm.length === 0) {
			return 1
		}
		var i = (bm || "").match(/alpha\(opacity=(.*)\)/);
		if (i[1]) {
			return parseFloat(i[1]) / 100
		}
		return 1
	}

	Object.extend(a1, {setStyle: A, getStyle: aM, setOpacity: x, getOpacity: bb});
	if ("styleFloat" in at.style) {
		a1.getStyle = ah;
		a1.setOpacity = bd;
		a1.getOpacity = bc
	}
	var k = 0;
	a6.Element.Storage = {UID: 1};
	function K(i) {
		if (i === window) {
			return 0
		}
		if (typeof i._prototypeUID === "undefined") {
			i._prototypeUID = aD.Storage.UID++
		}
		return i._prototypeUID
	}

	function b(i) {
		if (i === window) {
			return 0
		}
		if (i == document) {
			return 1
		}
		return i.uniqueID
	}

	var aW = ("uniqueID" in at);
	if (aW) {
		K = b
	}
	function a(F) {
		if (!(F = aX(F))) {
			return
		}
		var i = K(F);
		if (!aD.Storage[i]) {
			aD.Storage[i] = $H()
		}
		return aD.Storage[i]
	}

	function a3(F, i, bm) {
		if (!(F = aX(F))) {
			return
		}
		var bn = a(F);
		if (arguments.length === 2) {
			bn.update(i)
		} else {
			bn.set(i, bm)
		}
		return F
	}

	function aL(bm, F, i) {
		if (!(bm = aX(bm))) {
			return
		}
		var bo = a(bm), bn = bo.get(F);
		if (Object.isUndefined(bn)) {
			bo.set(F, i);
			bn = i
		}
		return bn
	}

	Object.extend(a1, {getStorage: a, store: a3, retrieve: aL});
	var al = {}, aV = aD.Methods.ByTag, aA = Prototype.BrowserFeatures;
	if (!aA.ElementExtensions && ("__proto__" in at)) {
		a6.HTMLElement = {};
		a6.HTMLElement.prototype = at.__proto__;
		aA.ElementExtensions = true
	}
	function ba(i) {
		if (typeof window.Element === "undefined") {
			return false
		}
		var bm = window.Element.prototype;
		if (bm) {
			var bo = "_" + (Math.random() + "").slice(2), F = document.createElement(i);
			bm[bo] = "x";
			var bn = (F[bo] !== "x");
			delete bm[bo];
			F = null;
			return bn
		}
		return false
	}

	var an = ba("object");

	function ai(F, i) {
		for (var bn in i) {
			var bm = i[bn];
			if (Object.isFunction(bm) && !(bn in F)) {
				F[bn] = bm.methodize()
			}
		}
	}

	var bh = {};

	function aw(F) {
		var i = K(F);
		return(i in bh)
	}

	function ax(bm) {
		if (!bm || aw(bm)) {
			return bm
		}
		if (bm.nodeType !== Node.ELEMENT_NODE || bm == window) {
			return bm
		}
		var i = Object.clone(al), F = bm.tagName.toUpperCase();
		if (aV[F]) {
			Object.extend(i, aV[F])
		}
		ai(bm, i);
		bh[K(bm)] = true;
		return bm
	}

	function aQ(F) {
		if (!F || aw(F)) {
			return F
		}
		var i = F.tagName;
		if (i && (/^(?:object|applet|embed)$/i.test(i))) {
			ai(F, aD.Methods);
			ai(F, aD.Methods.Simulated);
			ai(F, aD.Methods.ByTag[i.toUpperCase()])
		}
		return F
	}

	if (aA.SpecificElementExtensions) {
		ax = an ? aQ : Prototype.K
	}
	function Q(F, i) {
		F = F.toUpperCase();
		if (!aV[F]) {
			aV[F] = {}
		}
		Object.extend(aV[F], i)
	}

	function o(F, bm, i) {
		if (Object.isUndefined(i)) {
			i = false
		}
		for (var bo in bm) {
			var bn = bm[bo];
			if (!Object.isFunction(bn)) {
				continue
			}
			if (!i || !(bo in F)) {
				F[bo] = bn.methodize()
			}
		}
	}

	function ag(bn) {
		var i;
		var bm = {OPTGROUP: "OptGroup", TEXTAREA: "TextArea", P: "Paragraph", FIELDSET: "FieldSet", UL: "UList", OL: "OList", DL: "DList", DIR: "Directory", H1: "Heading", H2: "Heading", H3: "Heading", H4: "Heading", H5: "Heading", H6: "Heading", Q: "Quote", INS: "Mod", DEL: "Mod", A: "Anchor", IMG: "Image", CAPTION: "TableCaption", COL: "TableCol", COLGROUP: "TableCol", THEAD: "TableSection", TFOOT: "TableSection", TBODY: "TableSection", TR: "TableRow", TH: "TableCell", TD: "TableCell", FRAMESET: "FrameSet", IFRAME: "IFrame"};
		if (bm[bn]) {
			i = "HTML" + bm[bn] + "Element"
		}
		if (window[i]) {
			return window[i]
		}
		i = "HTML" + bn + "Element";
		if (window[i]) {
			return window[i]
		}
		i = "HTML" + bn.capitalize() + "Element";
		if (window[i]) {
			return window[i]
		}
		var F = document.createElement(bn), bo = F.__proto__ || F.constructor.prototype;
		F = null;
		return bo
	}

	function P(bo) {
		if (arguments.length === 0) {
			D()
		}
		if (arguments.length === 2) {
			var bq = bo;
			bo = arguments[1]
		}
		if (!bq) {
			Object.extend(aD.Methods, bo || {})
		} else {
			if (Object.isArray(bq)) {
				for (var bp = 0, bn; bn = bq[bp]; bp++) {
					Q(bn, bo)
				}
			} else {
				Q(bq, bo)
			}
		}
		var bm = window.HTMLElement ? HTMLElement.prototype : aD.prototype;
		if (aA.ElementExtensions) {
			o(bm, aD.Methods);
			o(bm, aD.Methods.Simulated, true)
		}
		if (aA.SpecificElementExtensions) {
			for (var bn in aD.Methods.ByTag) {
				var F = ag(bn);
				if (Object.isUndefined(F)) {
					continue
				}
				o(F.prototype, aV[bn])
			}
		}
		Object.extend(aD, aD.Methods);
		Object.extend(aD, aD.Methods.Simulated);
		delete aD.ByTag;
		delete aD.Simulated;
		aD.extend.refresh();
		p = {}
	}

	Object.extend(a6.Element, {extend: ax, addMethods: P});
	if (ax === Prototype.K) {
		a6.Element.extend.refresh = Prototype.emptyFunction
	} else {
		a6.Element.extend.refresh = function () {
			if (Prototype.BrowserFeatures.ElementExtensions) {
				return
			}
			Object.extend(al, aD.Methods);
			Object.extend(al, aD.Methods.Simulated);
			bh = {}
		}
	}
	function D() {
		Object.extend(Form, Form.Methods);
		Object.extend(Form.Element, Form.Element.Methods);
		Object.extend(aD.Methods.ByTag, {FORM: Object.clone(Form.Methods), INPUT: Object.clone(Form.Element.Methods), SELECT: Object.clone(Form.Element.Methods), TEXTAREA: Object.clone(Form.Element.Methods), BUTTON: Object.clone(Form.Element.Methods)})
	}

	aD.addMethods(a1)
})(this);
(function () {
	function k(G) {
		var F = G.match(/^(\d+)%?$/i);
		if (!F) {
			return null
		}
		return(Number(F[1]) / 100)
	}

	function y(G, H) {
		G = $(G);
		var I = G.style[H];
		if (!I || I === "auto") {
			var F = document.defaultView.getComputedStyle(G, null);
			I = F ? F[H] : null
		}
		if (H === "opacity") {
			return I ? parseFloat(I) : 1
		}
		return I === "auto" ? null : I
	}

	function B(F, G) {
		var H = F.style[G];
		if (!H && F.currentStyle) {
			H = F.currentStyle[G]
		}
		return H
	}

	function r(H, G) {
		var J = H.offsetWidth;
		var L = u(H, "borderLeftWidth", G) || 0;
		var F = u(H, "borderRightWidth", G) || 0;
		var I = u(H, "paddingLeft", G) || 0;
		var K = u(H, "paddingRight", G) || 0;
		return J - L - F - I - K
	}

	if ("currentStyle" in document.documentElement) {
		y = B
	}
	function u(P, Q, G) {
		var J = null;
		if (Object.isElement(P)) {
			J = P;
			P = y(J, Q)
		}
		if (P === null || Object.isUndefined(P)) {
			return null
		}
		if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(P)) {
			return window.parseFloat(P)
		}
		var K = P.include("%"), H = (G === document.viewport);
		if (/\d/.test(P) && J && J.runtimeStyle && !(K && H)) {
			var F = J.style.left, O = J.runtimeStyle.left;
			J.runtimeStyle.left = J.currentStyle.left;
			J.style.left = P || 0;
			P = J.style.pixelLeft;
			J.style.left = F;
			J.runtimeStyle.left = O;
			return P
		}
		if (J && K) {
			G = G || J.parentNode;
			var I = k(P), L = null;
			var N = Q.include("left") || Q.include("right") || Q.include("width");
			var M = Q.include("top") || Q.include("bottom") || Q.include("height");
			if (G === document.viewport) {
				if (N) {
					L = document.viewport.getWidth()
				} else {
					if (M) {
						L = document.viewport.getHeight()
					}
				}
			} else {
				if (N) {
					L = $(G).measure("width")
				} else {
					if (M) {
						L = $(G).measure("height")
					}
				}
			}
			return(L === null) ? 0 : L * I
		}
		return 0
	}

	function j(F) {
		if (Object.isString(F) && F.endsWith("px")) {
			return F
		}
		return F + "px"
	}

	function m(F) {
		while (F && F.parentNode) {
			var G = F.getStyle("display");
			if (G === "none") {
				return false
			}
			F = $(F.parentNode)
		}
		return true
	}

	var g = Prototype.K;
	if ("currentStyle" in document.documentElement) {
		g = function (F) {
			if (!F.currentStyle.hasLayout) {
				F.style.zoom = 1
			}
			return F
		}
	}
	function i(F) {
		if (F.include("border")) {
			F = F + "-width"
		}
		return F.camelize()
	}

	Element.Layout = Class.create(Hash, {initialize: function ($super, G, F) {
		$super();
		this.element = $(G);
		Element.Layout.PROPERTIES.each(function (H) {
			this._set(H, null)
		}, this);
		if (F) {
			this._preComputing = true;
			this._begin();
			Element.Layout.PROPERTIES.each(this._compute, this);
			this._end();
			this._preComputing = false
		}
	}, _set: function (G, F) {
		return Hash.prototype.set.call(this, G, F)
	}, set: function (G, F) {
		throw"Properties of Element.Layout are read-only."
	}, get: function ($super, G) {
		var F = $super(G);
		return F === null ? this._compute(G) : F
	}, _begin: function () {
		if (this._isPrepared()) {
			return
		}
		var J = this.element;
		if (m(J)) {
			this._setPrepared(true);
			return
		}
		var L = {position: J.style.position || "", width: J.style.width || "", visibility: J.style.visibility || "", display: J.style.display || ""};
		J.store("prototype_original_styles", L);
		var M = y(J, "position"), F = J.offsetWidth;
		if (F === 0 || F === null) {
			J.style.display = "block";
			F = J.offsetWidth
		}
		var G = (M === "fixed") ? document.viewport : J.parentNode;
		var N = {visibility: "hidden", display: "block"};
		if (M !== "fixed") {
			N.position = "absolute"
		}
		J.setStyle(N);
		var H = J.offsetWidth, I;
		if (F && (H === F)) {
			I = r(J, G)
		} else {
			if (M === "absolute" || M === "fixed") {
				I = r(J, G)
			} else {
				var O = J.parentNode, K = $(O).getLayout();
				I = K.get("width") - this.get("margin-left") - this.get("border-left") - this.get("padding-left") - this.get("padding-right") - this.get("border-right") - this.get("margin-right")
			}
		}
		J.setStyle({width: I + "px"});
		this._setPrepared(true)
	}, _end: function () {
		var G = this.element;
		var F = G.retrieve("prototype_original_styles");
		G.store("prototype_original_styles", null);
		G.setStyle(F);
		this._setPrepared(false)
	}, _compute: function (G) {
		var F = Element.Layout.COMPUTATIONS;
		if (!(G in F)) {
			throw"Property not found."
		}
		return this._set(G, F[G].call(this, this.element))
	}, _isPrepared: function () {
		return this.element.retrieve("prototype_element_layout_prepared", false)
	}, _setPrepared: function (F) {
		return this.element.store("prototype_element_layout_prepared", F)
	}, toObject: function () {
		var F = $A(arguments);
		var G = (F.length === 0) ? Element.Layout.PROPERTIES : F.join(" ").split(" ");
		var H = {};
		G.each(function (I) {
			if (!Element.Layout.PROPERTIES.include(I)) {
				return
			}
			var J = this.get(I);
			if (J != null) {
				H[I] = J
			}
		}, this);
		return H
	}, toHash: function () {
		var F = this.toObject.apply(this, arguments);
		return new Hash(F)
	}, toCSS: function () {
		var F = $A(arguments);
		var H = (F.length === 0) ? Element.Layout.PROPERTIES : F.join(" ").split(" ");
		var G = {};
		H.each(function (I) {
			if (!Element.Layout.PROPERTIES.include(I)) {
				return
			}
			if (Element.Layout.COMPOSITE_PROPERTIES.include(I)) {
				return
			}
			var J = this.get(I);
			if (J != null) {
				G[i(I)] = J + "px"
			}
		}, this);
		return G
	}, inspect: function () {
		return"#<Element.Layout>"
	}});
	Object.extend(Element.Layout, {PROPERTIES: $w("height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height"), COMPOSITE_PROPERTIES: $w("padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height"), COMPUTATIONS: {height: function (H) {
		if (!this._preComputing) {
			this._begin()
		}
		var F = this.get("border-box-height");
		if (F <= 0) {
			if (!this._preComputing) {
				this._end()
			}
			return 0
		}
		var I = this.get("border-top"), G = this.get("border-bottom");
		var K = this.get("padding-top"), J = this.get("padding-bottom");
		if (!this._preComputing) {
			this._end()
		}
		return F - I - G - K - J
	}, width: function (H) {
		if (!this._preComputing) {
			this._begin()
		}
		var G = this.get("border-box-width");
		if (G <= 0) {
			if (!this._preComputing) {
				this._end()
			}
			return 0
		}
		var K = this.get("border-left"), F = this.get("border-right");
		var I = this.get("padding-left"), J = this.get("padding-right");
		if (!this._preComputing) {
			this._end()
		}
		return G - K - F - I - J
	}, "padding-box-height": function (G) {
		var F = this.get("height"), I = this.get("padding-top"), H = this.get("padding-bottom");
		return F + I + H
	}, "padding-box-width": function (F) {
		var G = this.get("width"), H = this.get("padding-left"), I = this.get("padding-right");
		return G + H + I
	}, "border-box-height": function (G) {
		if (!this._preComputing) {
			this._begin()
		}
		var F = G.offsetHeight;
		if (!this._preComputing) {
			this._end()
		}
		return F
	}, "border-box-width": function (F) {
		if (!this._preComputing) {
			this._begin()
		}
		var G = F.offsetWidth;
		if (!this._preComputing) {
			this._end()
		}
		return G
	}, "margin-box-height": function (G) {
		var F = this.get("border-box-height"), H = this.get("margin-top"), I = this.get("margin-bottom");
		if (F <= 0) {
			return 0
		}
		return F + H + I
	}, "margin-box-width": function (H) {
		var G = this.get("border-box-width"), I = this.get("margin-left"), F = this.get("margin-right");
		if (G <= 0) {
			return 0
		}
		return G + I + F
	}, top: function (F) {
		var G = F.positionedOffset();
		return G.top
	}, bottom: function (F) {
		var I = F.positionedOffset(), G = F.getOffsetParent(), H = G.measure("height");
		var J = this.get("border-box-height");
		return H - J - I.top
	}, left: function (F) {
		var G = F.positionedOffset();
		return G.left
	}, right: function (H) {
		var J = H.positionedOffset(), I = H.getOffsetParent(), F = I.measure("width");
		var G = this.get("border-box-width");
		return F - G - J.left
	}, "padding-top": function (F) {
		return u(F, "paddingTop")
	}, "padding-bottom": function (F) {
		return u(F, "paddingBottom")
	}, "padding-left": function (F) {
		return u(F, "paddingLeft")
	}, "padding-right": function (F) {
		return u(F, "paddingRight")
	}, "border-top": function (F) {
		return u(F, "borderTopWidth")
	}, "border-bottom": function (F) {
		return u(F, "borderBottomWidth")
	}, "border-left": function (F) {
		return u(F, "borderLeftWidth")
	}, "border-right": function (F) {
		return u(F, "borderRightWidth")
	}, "margin-top": function (F) {
		return u(F, "marginTop")
	}, "margin-bottom": function (F) {
		return u(F, "marginBottom")
	}, "margin-left": function (F) {
		return u(F, "marginLeft")
	}, "margin-right": function (F) {
		return u(F, "marginRight")
	}}});
	if ("getBoundingClientRect" in document.documentElement) {
		Object.extend(Element.Layout.COMPUTATIONS, {right: function (G) {
			var H = g(G.getOffsetParent());
			var I = G.getBoundingClientRect(), F = H.getBoundingClientRect();
			return(F.right - I.right).round()
		}, bottom: function (G) {
			var H = g(G.getOffsetParent());
			var I = G.getBoundingClientRect(), F = H.getBoundingClientRect();
			return(F.bottom - I.bottom).round()
		}})
	}
	Element.Offset = Class.create({initialize: function (G, F) {
		this.left = G.round();
		this.top = F.round();
		this[0] = this.left;
		this[1] = this.top
	}, relativeTo: function (F) {
		return new Element.Offset(this.left - F.left, this.top - F.top)
	}, inspect: function () {
		return"#<Element.Offset left: #{left} top: #{top}>".interpolate(this)
	}, toString: function () {
		return"[#{left}, #{top}]".interpolate(this)
	}, toArray: function () {
		return[this.left, this.top]
	}});
	function z(G, F) {
		return new Element.Layout(G, F)
	}

	function d(F, G) {
		return $(F).getLayout().get(G)
	}

	function q(F) {
		return Element.getDimensions(F).height
	}

	function c(F) {
		return Element.getDimensions(F).width
	}

	function s(G) {
		G = $(G);
		var K = Element.getStyle(G, "display");
		if (K && K !== "none") {
			return{width: G.offsetWidth, height: G.offsetHeight}
		}
		var H = G.style;
		var F = {visibility: H.visibility, position: H.position, display: H.display};
		var J = {visibility: "hidden", display: "block"};
		if (F.position !== "fixed") {
			J.position = "absolute"
		}
		Element.setStyle(G, J);
		var I = {width: G.offsetWidth, height: G.offsetHeight};
		Element.setStyle(G, F);
		return I
	}

	function p(F) {
		F = $(F);
		if (h(F) || f(F) || o(F) || n(F)) {
			return $(document.body)
		}
		var G = (Element.getStyle(F, "display") === "inline");
		if (!G && F.offsetParent) {
			return $(F.offsetParent)
		}
		while ((F = F.parentNode) && F !== document.body) {
			if (Element.getStyle(F, "position") !== "static") {
				return n(F) ? $(document.body) : $(F)
			}
		}
		return $(document.body)
	}

	function C(G) {
		G = $(G);
		var F = 0, H = 0;
		if (G.parentNode) {
			do {
				F += G.offsetTop || 0;
				H += G.offsetLeft || 0;
				G = G.offsetParent
			} while (G)
		}
		return new Element.Offset(H, F)
	}

	function w(G) {
		G = $(G);
		var H = G.getLayout();
		var F = 0, J = 0;
		do {
			F += G.offsetTop || 0;
			J += G.offsetLeft || 0;
			G = G.offsetParent;
			if (G) {
				if (o(G)) {
					break
				}
				var I = Element.getStyle(G, "position");
				if (I !== "static") {
					break
				}
			}
		} while (G);
		J -= H.get("margin-top");
		F -= H.get("margin-left");
		return new Element.Offset(J, F)
	}

	function b(G) {
		var F = 0, H = 0;
		do {
			F += G.scrollTop || 0;
			H += G.scrollLeft || 0;
			G = G.parentNode
		} while (G);
		return new Element.Offset(H, F)
	}

	function A(J) {
		var F = 0, I = 0, H = document.body;
		var G = $(J);
		do {
			F += G.offsetTop || 0;
			I += G.offsetLeft || 0;
			if (G.offsetParent == H && Element.getStyle(G, "position") == "absolute") {
				break
			}
		} while (G = G.offsetParent);
		G = J;
		do {
			if (G != H) {
				F -= G.scrollTop || 0;
				I -= G.scrollLeft || 0
			}
		} while (G = G.parentNode);
		return new Element.Offset(I, F)
	}

	function x(F) {
		F = $(F);
		if (Element.getStyle(F, "position") === "absolute") {
			return F
		}
		var J = p(F);
		var I = F.viewportOffset(), G = J.viewportOffset();
		var K = I.relativeTo(G);
		var H = F.getLayout();
		F.store("prototype_absolutize_original_styles", {left: F.getStyle("left"), top: F.getStyle("top"), width: F.getStyle("width"), height: F.getStyle("height")});
		F.setStyle({position: "absolute", top: K.top + "px", left: K.left + "px", width: H.get("width") + "px", height: H.get("height") + "px"});
		return F
	}

	function l(G) {
		G = $(G);
		if (Element.getStyle(G, "position") === "relative") {
			return G
		}
		var F = G.retrieve("prototype_absolutize_original_styles");
		if (F) {
			G.setStyle(F)
		}
		return G
	}

	function a(F) {
		F = $(F);
		var G = Element.cumulativeOffset(F);
		window.scrollTo(G.left, G.top);
		return F
	}

	function v(G) {
		G = $(G);
		var F = Element.getStyle(G, "position"), H = {};
		if (F === "static" || !F) {
			H.position = "relative";
			if (Prototype.Browser.Opera) {
				H.top = 0;
				H.left = 0
			}
			Element.setStyle(G, H);
			Element.store(G, "prototype_made_positioned", true)
		}
		return G
	}

	function t(F) {
		F = $(F);
		var H = Element.getStorage(F), G = H.get("prototype_made_positioned");
		if (G) {
			H.unset("prototype_made_positioned");
			Element.setStyle(F, {position: "", top: "", bottom: "", left: "", right: ""})
		}
		return F
	}

	function e(G) {
		G = $(G);
		var I = Element.getStorage(G), F = I.get("prototype_made_clipping");
		if (Object.isUndefined(F)) {
			var H = Element.getStyle(G, "overflow");
			I.set("prototype_made_clipping", H);
			if (H !== "hidden") {
				G.style.overflow = "hidden"
			}
		}
		return G
	}

	function D(F) {
		F = $(F);
		var H = Element.getStorage(F), G = H.get("prototype_made_clipping");
		if (!Object.isUndefined(G)) {
			H.unset("prototype_made_clipping");
			F.style.overflow = G || ""
		}
		return F
	}

	function E(G, K, F) {
		F = Object.extend({setLeft: true, setTop: true, setWidth: true, setHeight: true, offsetTop: 0, offsetLeft: 0}, F || {});
		K = $(K);
		G = $(G);
		var L, M, J, I = {};
		if (F.setLeft || F.setTop) {
			L = Element.viewportOffset(K);
			M = [0, 0];
			if (Element.getStyle(G, "position") === "absolute") {
				var H = Element.getOffsetParent(G);
				if (H !== document.body) {
					M = Element.viewportOffset(H)
				}
			}
		}
		if (F.setWidth || F.setHeight) {
			J = Element.getLayout(K)
		}
		if (F.setLeft) {
			I.left = (L[0] - M[0] + F.offsetLeft) + "px"
		}
		if (F.setTop) {
			I.top = (L[1] - M[1] + F.offsetTop) + "px"
		}
		if (F.setWidth) {
			I.width = J.get("border-box-width") + "px"
		}
		if (F.setHeight) {
			I.height = J.get("border-box-height") + "px"
		}
		return Element.setStyle(G, I)
	}

	if (Prototype.Browser.IE) {
		p = p.wrap(function (H, G) {
			G = $(G);
			if (h(G) || f(G) || o(G) || n(G)) {
				return $(document.body)
			}
			var F = G.getStyle("position");
			if (F !== "static") {
				return H(G)
			}
			G.setStyle({position: "relative"});
			var I = H(G);
			G.setStyle({position: F});
			return I
		});
		w = w.wrap(function (I, G) {
			G = $(G);
			if (!G.parentNode) {
				return new Element.Offset(0, 0)
			}
			var F = G.getStyle("position");
			if (F !== "static") {
				return I(G)
			}
			var H = G.getOffsetParent();
			if (H && H.getStyle("position") === "fixed") {
				g(H)
			}
			G.setStyle({position: "relative"});
			var J = I(G);
			G.setStyle({position: F});
			return J
		})
	} else {
		if (Prototype.Browser.Webkit) {
			C = function (G) {
				G = $(G);
				var F = 0, H = 0;
				do {
					F += G.offsetTop || 0;
					H += G.offsetLeft || 0;
					if (G.offsetParent == document.body) {
						if (Element.getStyle(G, "position") == "absolute") {
							break
						}
					}
					G = G.offsetParent
				} while (G);
				return new Element.Offset(H, F)
			}
		}
	}
	Element.addMethods({getLayout: z, measure: d, getWidth: c, getHeight: q, getDimensions: s, getOffsetParent: p, cumulativeOffset: C, positionedOffset: w, cumulativeScrollOffset: b, viewportOffset: A, absolutize: x, relativize: l, scrollTo: a, makePositioned: v, undoPositioned: t, makeClipping: e, undoClipping: D, clonePosition: E});
	function o(F) {
		return F.nodeName.toUpperCase() === "BODY"
	}

	function n(F) {
		return F.nodeName.toUpperCase() === "HTML"
	}

	function h(F) {
		return F.nodeType === Node.DOCUMENT_NODE
	}

	function f(F) {
		return F !== document.body && !Element.descendantOf(F, document.body)
	}

	if ("getBoundingClientRect" in document.documentElement) {
		Element.addMethods({viewportOffset: function (F) {
			F = $(F);
			if (f(F)) {
				return new Element.Offset(0, 0)
			}
			var G = F.getBoundingClientRect(), H = document.documentElement;
			return new Element.Offset(G.left - H.clientLeft, G.top - H.clientTop)
		}})
	}
})();
(function () {
	var c = Prototype.Browser.Opera && (window.parseFloat(window.opera.version()) < 9.5);
	var f = null;

	function b() {
		if (f) {
			return f
		}
		f = c ? document.body : document.documentElement;
		return f
	}

	function d() {
		return{width: this.getWidth(), height: this.getHeight()}
	}

	function a() {
		return b().clientWidth
	}

	function g() {
		return b().clientHeight
	}

	function e() {
		var h = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
		var i = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
		return new Element.Offset(h, i)
	}

	document.viewport = {getDimensions: d, getWidth: a, getHeight: g, getScrollOffsets: e}
})();
var $$ = function () {
	var a = $A(arguments).join(", ");
	return Prototype.Selector.select(a, document)
};
Prototype.Selector = (function () {
	function a() {
		throw new Error('Method "Prototype.Selector.select" must be defined.')
	}

	function c() {
		throw new Error('Method "Prototype.Selector.match" must be defined.')
	}

	function d(l, m, h) {
		h = h || 0;
		var g = Prototype.Selector.match, k = l.length, f = 0, j;
		for (j = 0; j < k; j++) {
			if (g(l[j], m) && h == f++) {
				return Element.extend(l[j])
			}
		}
	}

	function e(h) {
		for (var f = 0, g = h.length; f < g; f++) {
			Element.extend(h[f])
		}
		return h
	}

	var b = Prototype.K;
	return{select: a, match: c, find: d, extendElements: (Element.extend === b) ? b : e, extendElement: Element.extend}
})();
/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function () {
	var l = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g, m = 0, p = Object.prototype.toString, g = false, f = true, n = /\\/g, t = /\W/;
	[0, 0].sort(function () {
		f = false;
		return 0
	});
	var c = function (y, e, B, C) {
		B = B || [];
		e = e || document;
		var E = e;
		if (e.nodeType !== 1 && e.nodeType !== 9) {
			return[]
		}
		if (!y || typeof y !== "string") {
			return B
		}
		var v, G, J, u, F, I, H, A, x = true, w = c.isXML(e), z = [], D = y;
		do {
			l.exec("");
			v = l.exec(D);
			if (v) {
				D = v[3];
				z.push(v[1]);
				if (v[2]) {
					u = v[3];
					break
				}
			}
		} while (v);
		if (z.length > 1 && h.exec(y)) {
			if (z.length === 2 && i.relative[z[0]]) {
				G = q(z[0] + z[1], e)
			} else {
				G = i.relative[z[0]] ? [e] : c(z.shift(), e);
				while (z.length) {
					y = z.shift();
					if (i.relative[y]) {
						y += z.shift()
					}
					G = q(y, G)
				}
			}
		} else {
			if (!C && z.length > 1 && e.nodeType === 9 && !w && i.match.ID.test(z[0]) && !i.match.ID.test(z[z.length - 1])) {
				F = c.find(z.shift(), e, w);
				e = F.expr ? c.filter(F.expr, F.set)[0] : F.set[0]
			}
			if (e) {
				F = C ? {expr: z.pop(), set: j(C)} : c.find(z.pop(), z.length === 1 && (z[0] === "~" || z[0] === "+") && e.parentNode ? e.parentNode : e, w);
				G = F.expr ? c.filter(F.expr, F.set) : F.set;
				if (z.length > 0) {
					J = j(G)
				} else {
					x = false
				}
				while (z.length) {
					I = z.pop();
					H = I;
					if (!i.relative[I]) {
						I = ""
					} else {
						H = z.pop()
					}
					if (H == null) {
						H = e
					}
					i.relative[I](J, H, w)
				}
			} else {
				J = z = []
			}
		}
		if (!J) {
			J = G
		}
		if (!J) {
			c.error(I || y)
		}
		if (p.call(J) === "[object Array]") {
			if (!x) {
				B.push.apply(B, J)
			} else {
				if (e && e.nodeType === 1) {
					for (A = 0; J[A] != null; A++) {
						if (J[A] && (J[A] === true || J[A].nodeType === 1 && c.contains(e, J[A]))) {
							B.push(G[A])
						}
					}
				} else {
					for (A = 0; J[A] != null; A++) {
						if (J[A] && J[A].nodeType === 1) {
							B.push(G[A])
						}
					}
				}
			}
		} else {
			j(J, B)
		}
		if (u) {
			c(u, E, B, C);
			c.uniqueSort(B)
		}
		return B
	};
	c.uniqueSort = function (u) {
		if (o) {
			g = f;
			u.sort(o);
			if (g) {
				for (var e = 1; e < u.length; e++) {
					if (u[e] === u[e - 1]) {
						u.splice(e--, 1)
					}
				}
			}
		}
		return u
	};
	c.matches = function (e, u) {
		return c(e, null, null, u)
	};
	c.matchesSelector = function (e, u) {
		return c(u, null, null, [e]).length > 0
	};
	c.find = function (A, e, B) {
		var z;
		if (!A) {
			return[]
		}
		for (var w = 0, v = i.order.length; w < v; w++) {
			var x, y = i.order[w];
			if ((x = i.leftMatch[y].exec(A))) {
				var u = x[1];
				x.splice(1, 1);
				if (u.substr(u.length - 1) !== "\\") {
					x[1] = (x[1] || "").replace(n, "");
					z = i.find[y](x, e, B);
					if (z != null) {
						A = A.replace(i.match[y], "");
						break
					}
				}
			}
		}
		if (!z) {
			z = typeof e.getElementsByTagName !== "undefined" ? e.getElementsByTagName("*") : []
		}
		return{set: z, expr: A}
	};
	c.filter = function (E, D, H, x) {
		var z, e, v = E, J = [], B = D, A = D && D[0] && c.isXML(D[0]);
		while (E && D.length) {
			for (var C in i.filter) {
				if ((z = i.leftMatch[C].exec(E)) != null && z[2]) {
					var I, G, u = i.filter[C], w = z[1];
					e = false;
					z.splice(1, 1);
					if (w.substr(w.length - 1) === "\\") {
						continue
					}
					if (B === J) {
						J = []
					}
					if (i.preFilter[C]) {
						z = i.preFilter[C](z, B, H, J, x, A);
						if (!z) {
							e = I = true
						} else {
							if (z === true) {
								continue
							}
						}
					}
					if (z) {
						for (var y = 0; (G = B[y]) != null; y++) {
							if (G) {
								I = u(G, z, y, B);
								var F = x ^ !!I;
								if (H && I != null) {
									if (F) {
										e = true
									} else {
										B[y] = false
									}
								} else {
									if (F) {
										J.push(G);
										e = true
									}
								}
							}
						}
					}
					if (I !== undefined) {
						if (!H) {
							B = J
						}
						E = E.replace(i.match[C], "");
						if (!e) {
							return[]
						}
						break
					}
				}
			}
			if (E === v) {
				if (e == null) {
					c.error(E)
				} else {
					break
				}
			}
			v = E
		}
		return B
	};
	c.error = function (e) {
		throw"Syntax error, unrecognized expression: " + e
	};
	var i = c.selectors = {order: ["ID", "NAME", "TAG"], match: {ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/, CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/, NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/, ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/, TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/, CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/, POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/, PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/}, leftMatch: {}, attrMap: {"class": "className", "for": "htmlFor"}, attrHandle: {href: function (e) {
		return e.getAttribute("href")
	}, type: function (e) {
		return e.getAttribute("type")
	}}, relative: {"+": function (z, u) {
		var w = typeof u === "string", y = w && !t.test(u), A = w && !y;
		if (y) {
			u = u.toLowerCase()
		}
		for (var v = 0, e = z.length, x; v < e; v++) {
			if ((x = z[v])) {
				while ((x = x.previousSibling) && x.nodeType !== 1) {
				}
				z[v] = A || x && x.nodeName.toLowerCase() === u ? x || false : x === u
			}
		}
		if (A) {
			c.filter(u, z, true)
		}
	}, ">": function (z, u) {
		var y, x = typeof u === "string", v = 0, e = z.length;
		if (x && !t.test(u)) {
			u = u.toLowerCase();
			for (; v < e; v++) {
				y = z[v];
				if (y) {
					var w = y.parentNode;
					z[v] = w.nodeName.toLowerCase() === u ? w : false
				}
			}
		} else {
			for (; v < e; v++) {
				y = z[v];
				if (y) {
					z[v] = x ? y.parentNode : y.parentNode === u
				}
			}
			if (x) {
				c.filter(u, z, true)
			}
		}
	}, "": function (w, u, y) {
		var x, v = m++, e = r;
		if (typeof u === "string" && !t.test(u)) {
			u = u.toLowerCase();
			x = u;
			e = a
		}
		e("parentNode", u, v, w, x, y)
	}, "~": function (w, u, y) {
		var x, v = m++, e = r;
		if (typeof u === "string" && !t.test(u)) {
			u = u.toLowerCase();
			x = u;
			e = a
		}
		e("previousSibling", u, v, w, x, y)
	}}, find: {ID: function (u, v, w) {
		if (typeof v.getElementById !== "undefined" && !w) {
			var e = v.getElementById(u[1]);
			return e && e.parentNode ? [e] : []
		}
	}, NAME: function (v, y) {
		if (typeof y.getElementsByName !== "undefined") {
			var u = [], x = y.getElementsByName(v[1]);
			for (var w = 0, e = x.length; w < e; w++) {
				if (x[w].getAttribute("name") === v[1]) {
					u.push(x[w])
				}
			}
			return u.length === 0 ? null : u
		}
	}, TAG: function (e, u) {
		if (typeof u.getElementsByTagName !== "undefined") {
			return u.getElementsByTagName(e[1])
		}
	}}, preFilter: {CLASS: function (w, u, v, e, z, A) {
		w = " " + w[1].replace(n, "") + " ";
		if (A) {
			return w
		}
		for (var x = 0, y; (y = u[x]) != null; x++) {
			if (y) {
				if (z ^ (y.className && (" " + y.className + " ").replace(/[\t\n\r]/g, " ").indexOf(w) >= 0)) {
					if (!v) {
						e.push(y)
					}
				} else {
					if (v) {
						u[x] = false
					}
				}
			}
		}
		return false
	}, ID: function (e) {
		return e[1].replace(n, "")
	}, TAG: function (u, e) {
		return u[1].replace(n, "").toLowerCase()
	}, CHILD: function (e) {
		if (e[1] === "nth") {
			if (!e[2]) {
				c.error(e[0])
			}
			e[2] = e[2].replace(/^\+|\s*/g, "");
			var u = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(e[2] === "even" && "2n" || e[2] === "odd" && "2n+1" || !/\D/.test(e[2]) && "0n+" + e[2] || e[2]);
			e[2] = (u[1] + (u[2] || 1)) - 0;
			e[3] = u[3] - 0
		} else {
			if (e[2]) {
				c.error(e[0])
			}
		}
		e[0] = m++;
		return e
	}, ATTR: function (x, u, v, e, y, z) {
		var w = x[1] = x[1].replace(n, "");
		if (!z && i.attrMap[w]) {
			x[1] = i.attrMap[w]
		}
		x[4] = (x[4] || x[5] || "").replace(n, "");
		if (x[2] === "~=") {
			x[4] = " " + x[4] + " "
		}
		return x
	}, PSEUDO: function (x, u, v, e, y) {
		if (x[1] === "not") {
			if ((l.exec(x[3]) || "").length > 1 || /^\w/.test(x[3])) {
				x[3] = c(x[3], null, null, u)
			} else {
				var w = c.filter(x[3], u, v, true ^ y);
				if (!v) {
					e.push.apply(e, w)
				}
				return false
			}
		} else {
			if (i.match.POS.test(x[0]) || i.match.CHILD.test(x[0])) {
				return true
			}
		}
		return x
	}, POS: function (e) {
		e.unshift(true);
		return e
	}}, filters: {enabled: function (e) {
		return e.disabled === false && e.type !== "hidden"
	}, disabled: function (e) {
		return e.disabled === true
	}, checked: function (e) {
		return e.checked === true
	}, selected: function (e) {
		if (e.parentNode) {
			e.parentNode.selectedIndex
		}
		return e.selected === true
	}, parent: function (e) {
		return !!e.firstChild
	}, empty: function (e) {
		return !e.firstChild
	}, has: function (v, u, e) {
		return !!c(e[3], v).length
	}, header: function (e) {
		return(/h\d/i).test(e.nodeName)
	}, text: function (v) {
		var e = v.getAttribute("type"), u = v.type;
		return v.nodeName.toLowerCase() === "input" && "text" === u && (e === u || e === null)
	}, radio: function (e) {
		return e.nodeName.toLowerCase() === "input" && "radio" === e.type
	}, checkbox: function (e) {
		return e.nodeName.toLowerCase() === "input" && "checkbox" === e.type
	}, file: function (e) {
		return e.nodeName.toLowerCase() === "input" && "file" === e.type
	}, password: function (e) {
		return e.nodeName.toLowerCase() === "input" && "password" === e.type
	}, submit: function (u) {
		var e = u.nodeName.toLowerCase();
		return(e === "input" || e === "button") && "submit" === u.type
	}, image: function (e) {
		return e.nodeName.toLowerCase() === "input" && "image" === e.type
	}, reset: function (u) {
		var e = u.nodeName.toLowerCase();
		return(e === "input" || e === "button") && "reset" === u.type
	}, button: function (u) {
		var e = u.nodeName.toLowerCase();
		return e === "input" && "button" === u.type || e === "button"
	}, input: function (e) {
		return(/input|select|textarea|button/i).test(e.nodeName)
	}, focus: function (e) {
		return e === e.ownerDocument.activeElement
	}}, setFilters: {first: function (u, e) {
		return e === 0
	}, last: function (v, u, e, w) {
		return u === w.length - 1
	}, even: function (u, e) {
		return e % 2 === 0
	}, odd: function (u, e) {
		return e % 2 === 1
	}, lt: function (v, u, e) {
		return u < e[3] - 0
	}, gt: function (v, u, e) {
		return u > e[3] - 0
	}, nth: function (v, u, e) {
		return e[3] - 0 === u
	}, eq: function (v, u, e) {
		return e[3] - 0 === u
	}}, filter: {PSEUDO: function (v, A, z, B) {
		var e = A[1], u = i.filters[e];
		if (u) {
			return u(v, z, A, B)
		} else {
			if (e === "contains") {
				return(v.textContent || v.innerText || c.getText([v]) || "").indexOf(A[3]) >= 0
			} else {
				if (e === "not") {
					var w = A[3];
					for (var y = 0, x = w.length; y < x; y++) {
						if (w[y] === v) {
							return false
						}
					}
					return true
				} else {
					c.error(e)
				}
			}
		}
	}, CHILD: function (e, w) {
		var z = w[1], u = e;
		switch (z) {
			case"only":
			case"first":
				while ((u = u.previousSibling)) {
					if (u.nodeType === 1) {
						return false
					}
				}
				if (z === "first") {
					return true
				}
				u = e;
			case"last":
				while ((u = u.nextSibling)) {
					if (u.nodeType === 1) {
						return false
					}
				}
				return true;
			case"nth":
				var v = w[2], C = w[3];
				if (v === 1 && C === 0) {
					return true
				}
				var y = w[0], B = e.parentNode;
				if (B && (B.sizcache !== y || !e.nodeIndex)) {
					var x = 0;
					for (u = B.firstChild; u; u = u.nextSibling) {
						if (u.nodeType === 1) {
							u.nodeIndex = ++x
						}
					}
					B.sizcache = y
				}
				var A = e.nodeIndex - C;
				if (v === 0) {
					return A === 0
				} else {
					return(A % v === 0 && A / v >= 0)
				}
		}
	}, ID: function (u, e) {
		return u.nodeType === 1 && u.getAttribute("id") === e
	}, TAG: function (u, e) {
		return(e === "*" && u.nodeType === 1) || u.nodeName.toLowerCase() === e
	}, CLASS: function (u, e) {
		return(" " + (u.className || u.getAttribute("class")) + " ").indexOf(e) > -1
	}, ATTR: function (y, w) {
		var v = w[1], e = i.attrHandle[v] ? i.attrHandle[v](y) : y[v] != null ? y[v] : y.getAttribute(v), z = e + "", x = w[2], u = w[4];
		return e == null ? x === "!=" : x === "=" ? z === u : x === "*=" ? z.indexOf(u) >= 0 : x === "~=" ? (" " + z + " ").indexOf(u) >= 0 : !u ? z && e !== false : x === "!=" ? z !== u : x === "^=" ? z.indexOf(u) === 0 : x === "$=" ? z.substr(z.length - u.length) === u : x === "|=" ? z === u || z.substr(0, u.length + 1) === u + "-" : false
	}, POS: function (x, u, v, y) {
		var e = u[2], w = i.setFilters[e];
		if (w) {
			return w(x, v, u, y)
		}
	}}};
	var h = i.match.POS, b = function (u, e) {
		return"\\" + (e - 0 + 1)
	};
	for (var d in i.match) {
		i.match[d] = new RegExp(i.match[d].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
		i.leftMatch[d] = new RegExp(/(^(?:.|\r|\n)*?)/.source + i.match[d].source.replace(/\\(\d+)/g, b))
	}
	var j = function (u, e) {
		u = Array.prototype.slice.call(u, 0);
		if (e) {
			e.push.apply(e, u);
			return e
		}
		return u
	};
	try {
		Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType
	} catch (s) {
		j = function (x, w) {
			var v = 0, u = w || [];
			if (p.call(x) === "[object Array]") {
				Array.prototype.push.apply(u, x)
			} else {
				if (typeof x.length === "number") {
					for (var e = x.length; v < e; v++) {
						u.push(x[v])
					}
				} else {
					for (; x[v]; v++) {
						u.push(x[v])
					}
				}
			}
			return u
		}
	}
	var o, k;
	if (document.documentElement.compareDocumentPosition) {
		o = function (u, e) {
			if (u === e) {
				g = true;
				return 0
			}
			if (!u.compareDocumentPosition || !e.compareDocumentPosition) {
				return u.compareDocumentPosition ? -1 : 1
			}
			return u.compareDocumentPosition(e) & 4 ? -1 : 1
		}
	} else {
		o = function (B, A) {
			if (B === A) {
				g = true;
				return 0
			} else {
				if (B.sourceIndex && A.sourceIndex) {
					return B.sourceIndex - A.sourceIndex
				}
			}
			var y, u, v = [], e = [], x = B.parentNode, z = A.parentNode, C = x;
			if (x === z) {
				return k(B, A)
			} else {
				if (!x) {
					return -1
				} else {
					if (!z) {
						return 1
					}
				}
			}
			while (C) {
				v.unshift(C);
				C = C.parentNode
			}
			C = z;
			while (C) {
				e.unshift(C);
				C = C.parentNode
			}
			y = v.length;
			u = e.length;
			for (var w = 0; w < y && w < u; w++) {
				if (v[w] !== e[w]) {
					return k(v[w], e[w])
				}
			}
			return w === y ? k(B, e[w], -1) : k(v[w], A, 1)
		};
		k = function (u, e, v) {
			if (u === e) {
				return v
			}
			var w = u.nextSibling;
			while (w) {
				if (w === e) {
					return -1
				}
				w = w.nextSibling
			}
			return 1
		}
	}
	c.getText = function (e) {
		var u = "", w;
		for (var v = 0; e[v]; v++) {
			w = e[v];
			if (w.nodeType === 3 || w.nodeType === 4) {
				u += w.nodeValue
			} else {
				if (w.nodeType !== 8) {
					u += c.getText(w.childNodes)
				}
			}
		}
		return u
	};
	(function () {
		var u = document.createElement("div"), v = "script" + (new Date()).getTime(), e = document.documentElement;
		u.innerHTML = "<a name='" + v + "'/>";
		e.insertBefore(u, e.firstChild);
		if (document.getElementById(v)) {
			i.find.ID = function (x, y, z) {
				if (typeof y.getElementById !== "undefined" && !z) {
					var w = y.getElementById(x[1]);
					return w ? w.id === x[1] || typeof w.getAttributeNode !== "undefined" && w.getAttributeNode("id").nodeValue === x[1] ? [w] : undefined : []
				}
			};
			i.filter.ID = function (y, w) {
				var x = typeof y.getAttributeNode !== "undefined" && y.getAttributeNode("id");
				return y.nodeType === 1 && x && x.nodeValue === w
			}
		}
		e.removeChild(u);
		e = u = null
	})();
	(function () {
		var e = document.createElement("div");
		e.appendChild(document.createComment(""));
		if (e.getElementsByTagName("*").length > 0) {
			i.find.TAG = function (u, y) {
				var x = y.getElementsByTagName(u[1]);
				if (u[1] === "*") {
					var w = [];
					for (var v = 0; x[v]; v++) {
						if (x[v].nodeType === 1) {
							w.push(x[v])
						}
					}
					x = w
				}
				return x
			}
		}
		e.innerHTML = "<a href='#'></a>";
		if (e.firstChild && typeof e.firstChild.getAttribute !== "undefined" && e.firstChild.getAttribute("href") !== "#") {
			i.attrHandle.href = function (u) {
				return u.getAttribute("href", 2)
			}
		}
		e = null
	})();
	if (document.querySelectorAll) {
		(function () {
			var e = c, w = document.createElement("div"), v = "__sizzle__";
			w.innerHTML = "<p class='TEST'></p>";
			if (w.querySelectorAll && w.querySelectorAll(".TEST").length === 0) {
				return
			}
			c = function (H, y, C, G) {
				y = y || document;
				if (!G && !c.isXML(y)) {
					var F = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(H);
					if (F && (y.nodeType === 1 || y.nodeType === 9)) {
						if (F[1]) {
							return j(y.getElementsByTagName(H), C)
						} else {
							if (F[2] && i.find.CLASS && y.getElementsByClassName) {
								return j(y.getElementsByClassName(F[2]), C)
							}
						}
					}
					if (y.nodeType === 9) {
						if (H === "body" && y.body) {
							return j([y.body], C)
						} else {
							if (F && F[3]) {
								var B = y.getElementById(F[3]);
								if (B && B.parentNode) {
									if (B.id === F[3]) {
										return j([B], C)
									}
								} else {
									return j([], C)
								}
							}
						}
						try {
							return j(y.querySelectorAll(H), C)
						} catch (D) {
						}
					} else {
						if (y.nodeType === 1 && y.nodeName.toLowerCase() !== "object") {
							var z = y, A = y.getAttribute("id"), x = A || v, J = y.parentNode, I = /^\s*[+~]/.test(H);
							if (!A) {
								y.setAttribute("id", x)
							} else {
								x = x.replace(/'/g, "\\$&")
							}
							if (I && J) {
								y = y.parentNode
							}
							try {
								if (!I || J) {
									return j(y.querySelectorAll("[id='" + x + "'] " + H), C)
								}
							} catch (E) {
							} finally {
								if (!A) {
									z.removeAttribute("id")
								}
							}
						}
					}
				}
				return e(H, y, C, G)
			};
			for (var u in e) {
				c[u] = e[u]
			}
			w = null
		})()
	}
	(function () {
		var e = document.documentElement, v = e.matchesSelector || e.mozMatchesSelector || e.webkitMatchesSelector || e.msMatchesSelector;
		if (v) {
			var x = !v.call(document.createElement("div"), "div"), u = false;
			try {
				v.call(document.documentElement, "[test!='']:sizzle")
			} catch (w) {
				u = true
			}
			c.matchesSelector = function (z, B) {
				B = B.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
				if (!c.isXML(z)) {
					try {
						if (u || !i.match.PSEUDO.test(B) && !/!=/.test(B)) {
							var y = v.call(z, B);
							if (y || !x || z.document && z.document.nodeType !== 11) {
								return y
							}
						}
					} catch (A) {
					}
				}
				return c(B, null, null, [z]).length > 0
			}
		}
	})();
	(function () {
		var e = document.createElement("div");
		e.innerHTML = "<div class='test e'></div><div class='test'></div>";
		if (!e.getElementsByClassName || e.getElementsByClassName("e").length === 0) {
			return
		}
		e.lastChild.className = "e";
		if (e.getElementsByClassName("e").length === 1) {
			return
		}
		i.order.splice(1, 0, "CLASS");
		i.find.CLASS = function (u, v, w) {
			if (typeof v.getElementsByClassName !== "undefined" && !w) {
				return v.getElementsByClassName(u[1])
			}
		};
		e = null
	})();
	function a(u, z, y, C, A, B) {
		for (var w = 0, v = C.length; w < v; w++) {
			var e = C[w];
			if (e) {
				var x = false;
				e = e[u];
				while (e) {
					if (e.sizcache === y) {
						x = C[e.sizset];
						break
					}
					if (e.nodeType === 1 && !B) {
						e.sizcache = y;
						e.sizset = w
					}
					if (e.nodeName.toLowerCase() === z) {
						x = e;
						break
					}
					e = e[u]
				}
				C[w] = x
			}
		}
	}

	function r(u, z, y, C, A, B) {
		for (var w = 0, v = C.length; w < v; w++) {
			var e = C[w];
			if (e) {
				var x = false;
				e = e[u];
				while (e) {
					if (e.sizcache === y) {
						x = C[e.sizset];
						break
					}
					if (e.nodeType === 1) {
						if (!B) {
							e.sizcache = y;
							e.sizset = w
						}
						if (typeof z !== "string") {
							if (e === z) {
								x = true;
								break
							}
						} else {
							if (c.filter(z, [e]).length > 0) {
								x = e;
								break
							}
						}
					}
					e = e[u]
				}
				C[w] = x
			}
		}
	}

	if (document.documentElement.contains) {
		c.contains = function (u, e) {
			return u !== e && (u.contains ? u.contains(e) : true)
		}
	} else {
		if (document.documentElement.compareDocumentPosition) {
			c.contains = function (u, e) {
				return !!(u.compareDocumentPosition(e) & 16)
			}
		} else {
			c.contains = function () {
				return false
			}
		}
	}
	c.isXML = function (e) {
		var u = (e ? e.ownerDocument || e : 0).documentElement;
		return u ? u.nodeName !== "HTML" : false
	};
	var q = function (e, A) {
		var y, w = [], x = "", v = A.nodeType ? [A] : A;
		while ((y = i.match.PSEUDO.exec(e))) {
			x += y[0];
			e = e.replace(i.match.PSEUDO, "")
		}
		e = i.relative[e] ? e + "*" : e;
		for (var z = 0, u = v.length; z < u; z++) {
			c(e, v[z], w)
		}
		return c.filter(x, w)
	};
	window.Sizzle = c
})();
Prototype._original_property = window.Sizzle;
(function (c) {
	var d = Prototype.Selector.extendElements;

	function a(e, f) {
		return d(c(e, f || document))
	}

	function b(f, e) {
		return c.matches(e, [f]).length == 1
	}

	Prototype.Selector.engine = c;
	Prototype.Selector.select = a;
	Prototype.Selector.match = b
})(window.Sizzle);
window.Sizzle = Prototype._original_property;
delete Prototype._original_property;
var Form = {reset: function (a) {
	a = $(a);
	a.reset();
	return a
}, serializeElements: function (h, d) {
	if (typeof d != "object") {
		d = {hash: !!d}
	} else {
		if (Object.isUndefined(d.hash)) {
			d.hash = true
		}
	}
	var e, g, a = false, f = d.submit, b, c;
	if (d.hash) {
		c = {};
		b = function (i, j, k) {
			if (j in i) {
				if (!Object.isArray(i[j])) {
					i[j] = [i[j]]
				}
				i[j].push(k)
			} else {
				i[j] = k
			}
			return i
		}
	} else {
		c = "";
		b = function (i, j, k) {
			k = k.gsub(/(\r)?\n/, "\r\n");
			k = encodeURIComponent(k);
			k = k.gsub(/%20/, "+");
			return i + (i ? "&" : "") + encodeURIComponent(j) + "=" + k
		}
	}
	return h.inject(c, function (i, j) {
		if (!j.disabled && j.name) {
			e = j.name;
			g = $(j).getValue();
			if (g != null && j.type != "file" && (j.type != "submit" || (!a && f !== false && (!f || e == f) && (a = true)))) {
				i = b(i, e, g)
			}
		}
		return i
	})
}};
Form.Methods = {serialize: function (b, a) {
	return Form.serializeElements(Form.getElements(b), a)
}, getElements: function (e) {
	var f = $(e).getElementsByTagName("*");
	var d, c = [], b = Form.Element.Serializers;
	for (var a = 0; d = f[a]; a++) {
		if (b[d.tagName.toLowerCase()]) {
			c.push(Element.extend(d))
		}
	}
	return c
}, getInputs: function (g, c, d) {
	g = $(g);
	var a = g.getElementsByTagName("input");
	if (!c && !d) {
		return $A(a).map(Element.extend)
	}
	for (var e = 0, h = [], f = a.length; e < f; e++) {
		var b = a[e];
		if ((c && b.type != c) || (d && b.name != d)) {
			continue
		}
		h.push(Element.extend(b))
	}
	return h
}, disable: function (a) {
	a = $(a);
	Form.getElements(a).invoke("disable");
	return a
}, enable: function (a) {
	a = $(a);
	Form.getElements(a).invoke("enable");
	return a
}, findFirstElement: function (b) {
	var c = $(b).getElements().findAll(function (d) {
		return"hidden" != d.type && !d.disabled
	});
	var a = c.findAll(function (d) {
		return d.hasAttribute("tabIndex") && d.tabIndex >= 0
	}).sortBy(function (d) {
		return d.tabIndex
	}).first();
	return a ? a : c.find(function (d) {
		return/^(?:input|select|textarea)$/i.test(d.tagName)
	})
}, focusFirstElement: function (b) {
	b = $(b);
	var a = b.findFirstElement();
	if (a) {
		a.activate()
	}
	return b
}, request: function (b, a) {
	b = $(b), a = Object.clone(a || {});
	var d = a.parameters, c = b.readAttribute("action") || "";
	if (c.blank()) {
		c = window.location.href
	}
	a.parameters = b.serialize(true);
	if (d) {
		if (Object.isString(d)) {
			d = d.toQueryParams()
		}
		Object.extend(a.parameters, d)
	}
	if (b.hasAttribute("method") && !a.method) {
		a.method = b.method
	}
	return new Ajax.Request(c, a)
}};
Form.Element = {focus: function (a) {
	$(a).focus();
	return a
}, select: function (a) {
	$(a).select();
	return a
}};
Form.Element.Methods = {serialize: function (a) {
	a = $(a);
	if (!a.disabled && a.name) {
		var b = a.getValue();
		if (b != undefined) {
			var c = {};
			c[a.name] = b;
			return Object.toQueryString(c)
		}
	}
	return""
}, getValue: function (a) {
	a = $(a);
	var b = a.tagName.toLowerCase();
	return Form.Element.Serializers[b](a)
}, setValue: function (a, b) {
	a = $(a);
	var c = a.tagName.toLowerCase();
	Form.Element.Serializers[c](a, b);
	return a
}, clear: function (a) {
	$(a).value = "";
	return a
}, present: function (a) {
	return $(a).value != ""
}, activate: function (a) {
	a = $(a);
	try {
		a.focus();
		if (a.select && (a.tagName.toLowerCase() != "input" || !(/^(?:button|reset|submit)$/i.test(a.type)))) {
			a.select()
		}
	} catch (b) {
	}
	return a
}, disable: function (a) {
	a = $(a);
	a.disabled = true;
	return a
}, enable: function (a) {
	a = $(a);
	a.disabled = false;
	return a
}};
var Field = Form.Element;
var $F = Form.Element.Methods.getValue;
Form.Element.Serializers = (function () {
	function b(h, i) {
		switch (h.type.toLowerCase()) {
			case"checkbox":
			case"radio":
				return f(h, i);
			default:
				return e(h, i)
		}
	}

	function f(h, i) {
		if (Object.isUndefined(i)) {
			return h.checked ? h.value : null
		} else {
			h.checked = !!i
		}
	}

	function e(h, i) {
		if (Object.isUndefined(i)) {
			return h.value
		} else {
			h.value = i
		}
	}

	function a(k, n) {
		if (Object.isUndefined(n)) {
			return(k.type === "select-one" ? c : d)(k)
		}
		var j, l, o = !Object.isArray(n);
		for (var h = 0, m = k.length; h < m; h++) {
			j = k.options[h];
			l = this.optionValue(j);
			if (o) {
				if (l == n) {
					j.selected = true;
					return
				}
			} else {
				j.selected = n.include(l)
			}
		}
	}

	function c(i) {
		var h = i.selectedIndex;
		return h >= 0 ? g(i.options[h]) : null
	}

	function d(l) {
		var h, m = l.length;
		if (!m) {
			return null
		}
		for (var k = 0, h = []; k < m; k++) {
			var j = l.options[k];
			if (j.selected) {
				h.push(g(j))
			}
		}
		return h
	}

	function g(h) {
		return Element.hasAttribute(h, "value") ? h.value : h.text
	}

	return{input: b, inputSelector: f, textarea: e, select: a, selectOne: c, selectMany: d, optionValue: g, button: e}
})();
Abstract.TimedObserver = Class.create(PeriodicalExecuter, {initialize: function ($super, a, b, c) {
	$super(c, b);
	this.element = $(a);
	this.lastValue = this.getValue()
}, execute: function () {
	var a = this.getValue();
	if (Object.isString(this.lastValue) && Object.isString(a) ? this.lastValue != a : String(this.lastValue) != String(a)) {
		this.callback(this.element, a);
		this.lastValue = a
	}
}});
Form.Element.Observer = Class.create(Abstract.TimedObserver, {getValue: function () {
	return Form.Element.getValue(this.element)
}});
Form.Observer = Class.create(Abstract.TimedObserver, {getValue: function () {
	return Form.serialize(this.element)
}});
Abstract.EventObserver = Class.create({initialize: function (a, b) {
	this.element = $(a);
	this.callback = b;
	this.lastValue = this.getValue();
	if (this.element.tagName.toLowerCase() == "form") {
		this.registerFormCallbacks()
	} else {
		this.registerCallback(this.element)
	}
}, onElementEvent: function () {
	var a = this.getValue();
	if (this.lastValue != a) {
		this.callback(this.element, a);
		this.lastValue = a
	}
}, registerFormCallbacks: function () {
	Form.getElements(this.element).each(this.registerCallback, this)
}, registerCallback: function (a) {
	if (a.type) {
		switch (a.type.toLowerCase()) {
			case"checkbox":
			case"radio":
				Event.observe(a, "click", this.onElementEvent.bind(this));
				break;
			default:
				Event.observe(a, "change", this.onElementEvent.bind(this));
				break
		}
	}
}});
Form.Element.EventObserver = Class.create(Abstract.EventObserver, {getValue: function () {
	return Form.Element.getValue(this.element)
}});
Form.EventObserver = Class.create(Abstract.EventObserver, {getValue: function () {
	return Form.serialize(this.element)
}});
(function (D) {
	var u = document.createElement("div");
	var d = document.documentElement;
	var k = "onmouseenter" in d && "onmouseleave" in d;
	var L = {KEY_BACKSPACE: 8, KEY_TAB: 9, KEY_RETURN: 13, KEY_ESC: 27, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_DELETE: 46, KEY_HOME: 36, KEY_END: 35, KEY_PAGEUP: 33, KEY_PAGEDOWN: 34, KEY_INSERT: 45};
	var z = function (X) {
		return false
	};
	if (window.attachEvent) {
		if (window.addEventListener) {
			z = function (X) {
				return !(X instanceof window.Event)
			}
		} else {
			z = function (X) {
				return true
			}
		}
	}
	var O;

	function M(Y, X) {
		return Y.which ? (Y.which === X + 1) : (Y.button === X)
	}

	var W = {0: 1, 1: 4, 2: 2};

	function S(Y, X) {
		return Y.button === W[X]
	}

	function P(Y, X) {
		switch (X) {
			case 0:
				return Y.which == 1 && !Y.metaKey;
			case 1:
				return Y.which == 2 || (Y.which == 1 && Y.metaKey);
			case 2:
				return Y.which == 3;
			default:
				return false
		}
	}

	if (window.attachEvent) {
		if (!window.addEventListener) {
			O = S
		} else {
			O = function (Y, X) {
				return z(Y) ? S(Y, X) : M(Y, X)
			}
		}
	} else {
		if (Prototype.Browser.WebKit) {
			O = P
		} else {
			O = M
		}
	}
	function B(X) {
		return O(X, 0)
	}

	function i(X) {
		return O(X, 1)
	}

	function e(X) {
		return O(X, 2)
	}

	function o(X) {
		return Element.extend(K(X))
	}

	function K(Z) {
		Z = L.extend(Z);
		var Y = Z.target, X = Z.type, aa = Z.currentTarget;
		if (aa && aa.tagName) {
			if (X === "load" || X === "error" || (X === "click" && aa.tagName.toLowerCase() === "input" && aa.type === "radio")) {
				Y = aa
			}
		}
		if (Y.nodeType == Node.TEXT_NODE) {
			Y = Y.parentNode
		}
		return Element.extend(Y)
	}

	function j(Z, aa) {
		var Y = K(Z), X = Prototype.Selector.match;
		if (!aa) {
			return Element.extend(Y)
		}
		while (Y) {
			if (Object.isElement(Y) && X(Y, aa)) {
				return Element.extend(Y)
			}
			Y = Y.parentNode
		}
	}

	function t(X) {
		return{x: U(X), y: T(X)}
	}

	function U(Z) {
		var Y = document.documentElement, X = document.body || {scrollLeft: 0};
		return Z.pageX || (Z.clientX + (Y.scrollLeft || X.scrollLeft) - (Y.clientLeft || 0))
	}

	function T(Z) {
		var Y = document.documentElement, X = document.body || {scrollTop: 0};
		return Z.pageY || (Z.clientY + (Y.scrollTop || X.scrollTop) - (Y.clientTop || 0))
	}

	function r(X) {
		L.extend(X);
		X.preventDefault();
		X.stopPropagation();
		X.stopped = true
	}

	L.Methods = {isLeftClick: B, isMiddleClick: i, isRightClick: e, element: o, findElement: j, pointer: t, pointerX: U, pointerY: T, stop: r};
	var H = Object.keys(L.Methods).inject({}, function (X, Y) {
		X[Y] = L.Methods[Y].methodize();
		return X
	});
	if (window.attachEvent) {
		function V(Y) {
			var X;
			switch (Y.type) {
				case"mouseover":
				case"mouseenter":
					X = Y.fromElement;
					break;
				case"mouseout":
				case"mouseleave":
					X = Y.toElement;
					break;
				default:
					return null
			}
			return Element.extend(X)
		}

		var Q = {stopPropagation: function () {
			this.cancelBubble = true
		}, preventDefault: function () {
			this.returnValue = false
		}, inspect: function () {
			return"[object Event]"
		}};
		L.extend = function (Y, X) {
			if (!Y) {
				return false
			}
			if (!z(Y)) {
				return Y
			}
			if (Y._extendedByPrototype) {
				return Y
			}
			Y._extendedByPrototype = Prototype.emptyFunction;
			var Z = L.pointer(Y);
			Object.extend(Y, {target: Y.srcElement || X, relatedTarget: V(Y), pageX: Z.x, pageY: Z.y});
			Object.extend(Y, H);
			Object.extend(Y, Q);
			return Y
		}
	} else {
		L.extend = Prototype.K
	}
	if (window.addEventListener) {
		L.prototype = window.Event.prototype || document.createEvent("HTMLEvents").__proto__;
		Object.extend(L.prototype, H)
	}
	var v = {mouseenter: "mouseover", mouseleave: "mouseout"};

	function f(X) {
		return v[X] || X
	}

	if (k) {
		f = Prototype.K
	}
	function R(X) {
		if (X === window) {
			return 0
		}
		if (typeof X._prototypeUID === "undefined") {
			X._prototypeUID = Element.Storage.UID++
		}
		return X._prototypeUID
	}

	function I(X) {
		if (X === window) {
			return 0
		}
		if (X == document) {
			return 1
		}
		return X.uniqueID
	}

	if ("uniqueID" in u) {
		R = I
	}
	function x(X) {
		return X.include(":")
	}

	L._isCustomEvent = x;
	function A(Z, Y) {
		var X = D.Event.cache;
		if (Object.isUndefined(Y)) {
			Y = R(Z)
		}
		if (!X[Y]) {
			X[Y] = {element: Z}
		}
		return X[Y]
	}

	function E(Y, X) {
		if (Object.isUndefined(X)) {
			X = R(Y)
		}
		delete D.Event.cache[X]
	}

	function h(Z, ac, af) {
		var X = A(Z);
		if (!X[ac]) {
			X[ac] = []
		}
		var ab = X[ac];
		var aa = ab.length;
		while (aa--) {
			if (ab[aa].handler === af) {
				return null
			}
		}
		var ad = R(Z);
		var Y = D.Event._createResponder(ad, ac, af);
		var ae = {responder: Y, handler: af};
		ab.push(ae);
		return ae
	}

	function s(ac, Z, ad) {
		var Y = A(ac);
		var X = Y[Z];
		if (!X) {
			return
		}
		var ab = X.length, ae;
		while (ab--) {
			if (X[ab].handler === ad) {
				ae = X[ab];
				break
			}
		}
		if (!ae) {
			return
		}
		var aa = X.indexOf(ae);
		X.splice(aa, 1);
		return ae
	}

	function c(Z, Y, aa) {
		Z = $(Z);
		var ab = h(Z, Y, aa);
		if (ab === null) {
			return Z
		}
		var X = ab.responder;
		if (x(Y)) {
			p(Z, Y, X)
		} else {
			m(Z, Y, X)
		}
		return Z
	}

	function m(aa, Z, Y) {
		var X = f(Z);
		if (aa.addEventListener) {
			aa.addEventListener(X, Y, false)
		} else {
			aa.attachEvent("on" + X, Y)
		}
	}

	function p(Z, Y, X) {
		if (Z.addEventListener) {
			Z.addEventListener("dataavailable", X, false)
		} else {
			Z.attachEvent("ondataavailable", X);
			Z.attachEvent("onlosecapture", X)
		}
	}

	function J(Y, X, Z) {
		Y = $(Y);
		var ab = !Object.isUndefined(Z), ac = !Object.isUndefined(X);
		if (!ac && !ab) {
			y(Y);
			return Y
		}
		if (!ab) {
			G(Y, X);
			return Y
		}
		var aa = s(Y, X, Z);
		if (!aa) {
			return Y
		}
		a(Y, X, aa.responder);
		return Y
	}

	function C(aa, Z, Y) {
		var X = f(Z);
		if (aa.removeEventListener) {
			aa.removeEventListener(X, Y, false)
		} else {
			aa.detachEvent("on" + X, Y)
		}
	}

	function b(Z, Y, X) {
		if (Z.removeEventListener) {
			Z.removeEventListener("dataavailable", X, false)
		} else {
			Z.detachEvent("ondataavailable", X);
			Z.detachEvent("onlosecapture", X)
		}
	}

	function y(ac) {
		var ab = R(ac), Z = A(ac, ab);
		E(ac, ab);
		var X, aa;
		for (var Y in Z) {
			if (Y === "element") {
				continue
			}
			X = Z[Y];
			aa = X.length;
			while (aa--) {
				a(ac, Y, X[aa].responder)
			}
		}
	}

	function G(ab, Z) {
		var Y = A(ab);
		var X = Y[Z];
		if (!X) {
			return
		}
		delete Y[Z];
		var aa = X.length;
		while (aa--) {
			a(ab, Z, X[aa].responder)
		}
	}

	function a(Y, X, Z) {
		if (x(X)) {
			b(Y, X, Z)
		} else {
			C(Y, X, Z)
		}
	}

	function g(X) {
		if (X !== document) {
			return X
		}
		if (document.createEvent && !X.dispatchEvent) {
			return document.documentElement
		}
		return X
	}

	function w(aa, Z, Y, X) {
		aa = g($(aa));
		if (Object.isUndefined(X)) {
			X = true
		}
		Y = Y || {};
		var ab = N(aa, Z, Y, X);
		return L.extend(ab)
	}

	function l(aa, Z, Y, X) {
		var ab = document.createEvent("HTMLEvents");
		ab.initEvent("dataavailable", X, true);
		ab.eventName = Z;
		ab.memo = Y;
		aa.dispatchEvent(ab);
		return ab
	}

	function n(aa, Z, Y, X) {
		var ab = document.createEventObject();
		ab.eventType = X ? "ondataavailable" : "onlosecapture";
		ab.eventName = Z;
		ab.memo = Y;
		aa.fireEvent(ab.eventType, ab);
		return ab
	}

	var N = document.createEvent ? l : n;
	L.Handler = Class.create({initialize: function (Z, Y, X, aa) {
		this.element = $(Z);
		this.eventName = Y;
		this.selector = X;
		this.callback = aa;
		this.handler = this.handleEvent.bind(this)
	}, start: function () {
		L.observe(this.element, this.eventName, this.handler);
		return this
	}, stop: function () {
		L.stopObserving(this.element, this.eventName, this.handler);
		return this
	}, handleEvent: function (Y) {
		var X = L.findElement(Y, this.selector);
		if (X) {
			this.callback.call(this.element, Y, X)
		}
	}});
	function F(Z, Y, X, aa) {
		Z = $(Z);
		if (Object.isFunction(X) && Object.isUndefined(aa)) {
			aa = X, X = null
		}
		return new L.Handler(Z, Y, X, aa).start()
	}

	Object.extend(L, L.Methods);
	Object.extend(L, {fire: w, observe: c, stopObserving: J, on: F});
	Element.addMethods({fire: w, observe: c, stopObserving: J, on: F});
	Object.extend(document, {fire: w.methodize(), observe: c.methodize(), stopObserving: J.methodize(), on: F.methodize(), loaded: false});
	if (D.Event) {
		Object.extend(window.Event, L)
	} else {
		D.Event = L
	}
	D.Event.cache = {};
	function q() {
		D.Event.cache = null
	}

	if (window.attachEvent) {
		window.attachEvent("onunload", q)
	}
	u = null;
	d = null
})(this);
(function (c) {
	var g = document.documentElement;
	var b = "onmouseenter" in g && "onmouseleave" in g;

	function f(h) {
		return !b && (h === "mouseenter" || h === "mouseleave")
	}

	function d(i, h, j) {
		if (Event._isCustomEvent(h)) {
			return e(i, h, j)
		}
		if (f(h)) {
			return a(i, h, j)
		}
		return function (l) {
			var m = Event.cache[i];
			var k = m.element;
			Event.extend(l, k);
			j.call(k, l)
		}
	}

	function e(i, h, j) {
		return function (l) {
			var m = Event.cache[i], k = m.element;
			if (Object.isUndefined(l.eventName)) {
				return false
			}
			if (l.eventName !== h) {
				return false
			}
			Event.extend(l, k);
			j.call(k, l)
		}
	}

	function a(i, h, j) {
		return function (m) {
			var o = Event.cache[i], k = o.element;
			Event.extend(m, k);
			var l = m.relatedTarget;
			while (l && l !== k) {
				try {
					l = l.parentNode
				} catch (n) {
					l = k
				}
			}
			if (l === k) {
				return
			}
			j.call(k, m)
		}
	}

	c.Event._createResponder = d;
	g = null
})(this);
(function (a) {
	var e;

	function b() {
		if (document.loaded) {
			return
		}
		if (e) {
			window.clearTimeout(e)
		}
		document.loaded = true;
		document.fire("dom:loaded")
	}

	function d() {
		if (document.readyState === "complete") {
			document.detachEvent("onreadystatechange", d);
			b()
		}
	}

	function c() {
		try {
			document.documentElement.doScroll("left")
		} catch (f) {
			e = c.defer();
			return
		}
		b()
	}

	if (document.addEventListener) {
		document.addEventListener("DOMContentLoaded", b, false)
	} else {
		document.attachEvent("onreadystatechange", d);
		if (window == top) {
			e = c.defer()
		}
	}
	Event.observe(window, "load", b)
})(this);
Element.addMethods();
Hash.toQueryString = Object.toQueryString;
var Toggle = {display: Element.toggle};
Element.Methods.childOf = Element.Methods.descendantOf;
var Insertion = {Before: function (a, b) {
	return Element.insert(a, {before: b})
}, Top: function (a, b) {
	return Element.insert(a, {top: b})
}, Bottom: function (a, b) {
	return Element.insert(a, {bottom: b})
}, After: function (a, b) {
	return Element.insert(a, {after: b})
}};
var $continue = new Error('"throw $continue" is deprecated, use "return" instead');
var Position = {includeScrollOffsets: false, prepare: function () {
	this.deltaX = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
	this.deltaY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
}, within: function (b, a, c) {
	if (this.includeScrollOffsets) {
		return this.withinIncludingScrolloffsets(b, a, c)
	}
	this.xcomp = a;
	this.ycomp = c;
	this.offset = Element.cumulativeOffset(b);
	return(c >= this.offset[1] && c < this.offset[1] + b.offsetHeight && a >= this.offset[0] && a < this.offset[0] + b.offsetWidth)
}, withinIncludingScrolloffsets: function (b, a, d) {
	var c = Element.cumulativeScrollOffset(b);
	this.xcomp = a + c[0] - this.deltaX;
	this.ycomp = d + c[1] - this.deltaY;
	this.offset = Element.cumulativeOffset(b);
	return(this.ycomp >= this.offset[1] && this.ycomp < this.offset[1] + b.offsetHeight && this.xcomp >= this.offset[0] && this.xcomp < this.offset[0] + b.offsetWidth)
}, overlap: function (b, a) {
	if (!b) {
		return 0
	}
	if (b == "vertical") {
		return((this.offset[1] + a.offsetHeight) - this.ycomp) / a.offsetHeight
	}
	if (b == "horizontal") {
		return((this.offset[0] + a.offsetWidth) - this.xcomp) / a.offsetWidth
	}
}, cumulativeOffset: Element.Methods.cumulativeOffset, positionedOffset: Element.Methods.positionedOffset, absolutize: function (a) {
	Position.prepare();
	return Element.absolutize(a)
}, relativize: function (a) {
	Position.prepare();
	return Element.relativize(a)
}, realOffset: Element.Methods.cumulativeScrollOffset, offsetParent: Element.Methods.getOffsetParent, page: Element.Methods.viewportOffset, clone: function (b, c, a) {
	a = a || {};
	return Element.clonePosition(c, b, a)
}};
if (!document.getElementsByClassName) {
	document.getElementsByClassName = function (b) {
		function a(c) {
			return c.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + c + " ')]"
		}

		b.getElementsByClassName = Prototype.BrowserFeatures.XPath ? function (c, e) {
			e = e.toString().strip();
			var d = /\s/.test(e) ? $w(e).map(a).join("") : a(e);
			return d ? document._getElementsByXPath(".//*" + d, c) : []
		} : function (e, f) {
			f = f.toString().strip();
			var g = [], h = (/\s/.test(f) ? $w(f) : null);
			if (!h && !f) {
				return g
			}
			var c = $(e).getElementsByTagName("*");
			f = " " + f + " ";
			for (var d = 0, k, j; k = c[d]; d++) {
				if (k.className && (j = " " + k.className + " ") && (j.include(f) || (h && h.all(function (i) {
					return !i.toString().blank() && j.include(" " + i + " ")
				})))) {
					g.push(Element.extend(k))
				}
			}
			return g
		};
		return function (d, c) {
			return $(c || document.body).getElementsByClassName(d)
		}
	}(Element.Methods)
}
Element.ClassNames = Class.create();
Element.ClassNames.prototype = {initialize: function (a) {
	this.element = $(a)
}, _each: function (b, a) {
	this.element.className.split(/\s+/).select(function (c) {
		return c.length > 0
	})._each(b, a)
}, set: function (a) {
	this.element.className = a
}, add: function (a) {
	if (this.include(a)) {
		return
	}
	this.set($A(this).concat(a).join(" "))
}, remove: function (a) {
	if (!this.include(a)) {
		return
	}
	this.set($A(this).without(a).join(" "))
}, toString: function () {
	return $A(this).join(" ")
}};
Object.extend(Element.ClassNames.prototype, Enumerable);
var Selector = (function () {
	var a = Class.create({initialize: function (b) {
		this.expression = b.strip()
	}, findElements: function (b) {
		return Prototype.Selector.select(this.expression, b)
	}, match: function (b) {
		return Prototype.Selector.match(b, this.expression)
	}, toString: function () {
		return this.expression
	}, inspect: function () {
		return"#<Selector: " + this.expression + ">"
	}});
	Object.extend(a, {matchElements: function (g, h) {
		var b = Prototype.Selector.match, e = [];
		for (var d = 0, f = g.length; d < f; d++) {
			var c = g[d];
			if (b(c, h)) {
				e.push(Element.extend(c))
			}
		}
		return e
	}, findElement: function (g, h, c) {
		c = c || 0;
		var b = 0, e;
		for (var d = 0, f = g.length; d < f; d++) {
			e = g[d];
			if (Prototype.Selector.match(e, h) && c === b++) {
				return Element.extend(e)
			}
		}
	}, findChildElements: function (c, d) {
		var b = d.toArray().join(", ");
		return Prototype.Selector.select(b, c || document)
	}});
	return a
})();

/**
 * Created by soheil on 27/07/2016.
 */

$services = {

	localization:{
		//This list is generated from original Phenotips source code content
		//phenotips/components/widgets/api/src/main/resources/ApplicationResources.properties
		messages: {
			"phenotips.imageDisplayer.delete": "Delete",
			"phenotips.imageDisplayer.openImage": "Open {0}",
			"phenotips.imageDisplayer.acceptedFormats": "Accepted file formats:",
			"phenotips.imageDisplayer.uploadAndSelect": "Upload and select",
			"phenotips.imageDisplayer.uploadAndManage": "Upload and manage",
			"phenotips.imageDisplayer.AJAXnotSuportedMessage": "This feature works better in more advanced browsers (Mozilla Firefox 4.0+, Google Chrome). Please consider upgrading.",
			"phenotips.imageDisplayer.noneAvailable": "None available",
			"phenotips.imageDisplayer.error.invalidFile": "The selected file has an unsupported format.",
			"phenotips.imageDisplayer.error.general": "An error occurred while uploading the file.",
			"phenotips.imageDisplayer.error.abort": "The upload has been canceled by the user or the browser dropped the connection",
			"phenotips.imageDisplayer.error.size": "The selected file is too large. Please choose files under __maxSize__",
			"phenotips.imageDisplayer.done": "Done",
			"phenotips.imageDisplayer.noFiles": "No files available",
			"phenotips.tableMacros.delete": "Delete",
			"phenotips.tableMacros.newEntry": "New entry",
			"phenotips.tableMacros.newVariantEntry": "Add variant",
			"phenotips.tableMacros.noObjects": "None specified",
			"phenotips.tableMacros.rowDeleteConfirmation": "Are you sure you want to delete this row?",
			"phenotips.tableMacros.listNotFound": "Cannot find the list to update",
			"phenotips.tableMacros.typeNotFound": "Unable to add data of that type",
			"phenotips.tableMacros.variantAlreadyExist": "This variant has already been entered",
			"phenotips.widgets.helpButtons.xHelpButton.hint": "How to enter this information",
			"phenotips.widgets.helpButtons.phenotype.hint": "About this phenotype",
			"phenotips.widgets.helpButtons.phenotype.synonym": "Also known as",
			"phenotips.widgets.helpButtons.phenotype.typeOf": "Is a type of",
			"phenotips.widgets.helpButtons.phenotype.browseRelated": "Browse related terms...",
			"phenotips.widgets.helpButtons.phenotypeQualifier.hint": "About this phenotype qualifier",
			"phenotips.widgets.helpButtons.omimDisease.hint": "About this disease",
			"phenotips.widgets.helpButtons.omimDisease.symptoms": "This disorder is typically characterized by",
			"phenotips.widgets.helpButtons.omimDisease.notSymptoms": "This disorder does not typically cause",
			"phenotips.widgets.helpButtons.omimDisease.linkToOmim": "Read about it on OMIM.org...",
			"phenotips.widgets.helpButtons.gene.hint": "About this gene",
			"phenotips.widgets.helpButtons.gene.alias": "Aliases",
			"phenotips.widgets.helpButtons.gene.previousSymbols": "Previous symbols",
			"phenotips.widgets.helpButtons.gene.family": "Gene family",
			"phenotips.widgets.helpButtons.loading": "Loading...",
			"phenotips.widgets.helpButtons.failedToLoad": "Failed to retrieve information about __subject__",
			"phenotips.widgets.multiSuggest.clear.title": "Clear the list of selected suggestions",
			"phenotips.widgets.multiSuggest.clear": "Delete all",
			"phenotips.widgets.suggest.hideSuggestions": "hide suggestions",
			"phenotips.widgets.workgroupPicker.noResults": "Group not found",
			"phenotips.yesNoNAPicker.NA.title": "NA (irrelevant or unknown)",
			"phenotips.yesNoNAPicker.NA.unselectedTitle": "Unselect",
			"phenotips.yesNoNAPicker.yes.title": "YES (investigated and observed)",
			"phenotips.yesNoNAPicker.yes.unselectedTitle": "Select as present",
			"phenotips.yesNoNAPicker.yes.selectedTitle": "Unselect as present",
			"phenotips.yesNoNAPicker.no.title": "NO (investigated and NOT observed)",
			"phenotips.yesNoNAPicker.no.unselectedTitle": "Select as absent",
			"phenotips.yesNoNAPicker.no.selectedTitle": "Unselect as absent"
		},
		render: function (name) {
			var messgaeContent = this.messages[name];
			if(messgaeContent == undefined || messgaeContent == null){
				return "";
			}
			var arguments = arguments;
			for (var i = 1; i < arguments.length; i++) {
				var indexPointer = "{" + (i - 1).toString() + "}";
				if (messgaeContent.indexOf(indexPointer)) {
					messgaeContent = messgaeContent.replace(indexPointer, arguments[i]);
				}
			}
			return messgaeContent;
		}
	}
};
/**
 * Created by soheil on 02/08/2016.
 */

WebService = Class.create({

	initialize: function () {
		this._settings = new Settings();
		this._baseURL = this._settings.getSetting('codingDefinitionServiceEndpoint');
		//console.log("LLLSURL", CONSTANTS.LOOKUP_SERVICE_URL)
		this.baseURL = CONSTANTS.LOOKUP_SERVICE_URL;
	},

	getOmimLookupPath: function(){
		var endpoint = this._baseURL;
		return endpoint + "/codes-search/omim?";
	},

    getOrphanetLookupPath: function(){
        var endpoint = this._baseURL;
        return endpoint + "/codes-search/orphanet?";
    },


	getEthnicityLookupPath: function(){
		var endpoint = this._baseURL;
		return endpoint + "/codes-search/clinical_ethnicity?limit=50";
	},

	getHPOLookupPath: function(){
		var endpoint = this._baseURL;
		return endpoint + "/codes-search/hpo?";
	},

    getHPOModifierLookupPath: function(){
        var endpoint = this._baseURL;
        return endpoint + "/codes-search/hpo_modifier?";
    },

	getDiagramEndpointPath: function(){
		var config = this._settings.getSetting('diagramEndpoint');
		switch(config.service){
			case "mercury":
				var _this = this;
				var returnUrl =  _this.getUrlParameter("returnUrl", true);
				var participantId = this.getUrlParameter("participantId", true);
				var labkeyToken = this.getUrlParameter("labkeyToken", true);
				var labkeyEmail = this.getUrlParameter("labkeyEmail", true);
				var mercuryGetEndpoint =  config.mercuryPedigreeServiceEndpoint + "/" + participantId + "?accessPath=" + returnUrl + "&labkeyToken=" +
					labkeyToken + "&labkeyEmail="+labkeyEmail;
				return mercuryGetEndpoint;
				break;
			case "openclinica":
				var eventCRFId = this.getUrlParameter("eventCRFId", true);
				var status = this.getUrlParameter("status", true);
				var participantId = this.getUrlParameter("participantId", true);
				return "/openclinica/pedigree/get?eventCRFId=" + eventCRFId + "&status=" + status + "&participantId=" + participantId;
			case "local":
				return null;
		}
	},

	saveDiagramEndpointPath: function(){
		var config = this._settings.getSetting('diagramEndpoint');
		switch(config.service){
			case "mercury":
				var _this = this;
				var returnUrl =  _this.getUrlParameter("returnUrl", true);
				var participantId = this.getUrlParameter("participantId", true);
				var labkeyToken = this.getUrlParameter("labkeyToken", true);
				var labkeyEmail = this.getUrlParameter("labkeyEmail", true);
				var mercuryGetEndpoint =  config.mercuryPedigreeServiceEndpoint + "/" + participantId + "?accessPath=" + returnUrl + "&labkeyToken=" +
					labkeyToken + "&labkeyEmail="+labkeyEmail;
				return mercuryGetEndpoint;
				break;
			case "openclinica":
				var _this = this;
				var eventCRFId = _this.getUrlParameter("eventCRFId",true);
				var status = _this.getUrlParameter("status",true);
				var participantId = _this.getUrlParameter("participantId",true);
				return "/openclinica/pedigree/update?eventCRFId=" + eventCRFId + "&status=" + status + "&participantId=" + participantId;
			case "local":
				return null;
		}
	},
	

	getPathToEditorFiles: function(){
		var config = this._settings.getSetting('diagramEndpoint');
		switch(config.service){
			case "mercury":
				return Helpers.getSiteURL() + "/" + config.pathToEditorJSFiles;
				break;
			case "openclinica":
				return Helpers.getSiteURL() + "/" + config.pathToEditorJSFiles;
				break
			case "local":
				return Helpers.getSiteURL() + "/";
				break

		}
	},


	getUrlParameter: function getUrlParameter(sParam, doNotDecode) {

		var sPageURL = decodeURIComponent(window.location.search.substring(1));
		if(doNotDecode && doNotDecode == true){
			sPageURL = window.location.search.substring(1);
		}

		var	sURLVariables = sPageURL.split('&')
		var	sParameterName;
		var	i;

		for (i = 0; i < sURLVariables.length; i++) {
			sParameterName = sURLVariables[i].split('=');

			if (sParameterName[0].toLowerCase() === sParam.toLowerCase()) {
				return sParameterName[1] === undefined ? true : sParameterName[1];
			}
		}
	},

	getParticipantId: function(){
		var _this = this;
		var config = this._settings.getSetting('diagramEndpoint');
		switch(config.service){
			case "mercury":
			case "openclinica":
				var participantId = _this.getUrlParameter("participantId", true);
				return participantId;
				break;
			case "local":
				return null;
		}
	}
});
var XWiki = (function (a) {
	a.widgets = a.widgets || {};
	Object.extend(a, {constants: {anchorSeparator: "#", docextraCommentsAnchor: "Comments", docextraAttachmentsAnchor: "Attachments", docextraHistoryAnchor: "History", docextraInformationAnchor: "Information"}, resource: {get: function (e, h) {
		var d = "", j = ["Attachments"];
		var g = [a.EntityType.DOCUMENT];
		for (var f = 0; f < j.length; f++) {
			if (e.endsWith(a.constants.anchorSeparator + j[f])) {
				d = j[f];
				e = e.substr(0, e.length - (d.length + 1));
				h = h || g[f];
				break
			}
		}
		var b;
		if (h) {
			b = a.Model.resolve(e, h)
		} else {
			b = a.Model.resolve(e, a.EntityType.ATTACHMENT);
			if (!b.parent) {
				b = a.Model.resolve(e, a.EntityType.DOCUMENT);
				if (!b.parent) {
					var c = a.Model.resolve(e, a.EntityType.SPACE);
					if (c.parent) {
						b = c
					} else {
					}
				}
			}
		}
		return this.fromEntityReference(b, d)
	}, fromEntityReference: function (e, g) {
		var l = e.extractReference(a.EntityType.WIKI);
		l = (l && l.name) || a.currentWiki;
		var c = e.extractReference(a.EntityType.SPACE);
		c = (c && c.name) || a.currentSpace;
		var j = e.extractReference(a.EntityType.DOCUMENT);
		j = (j && j.name) || a.currentPage;
		var h = e.extractReference(a.EntityType.ATTACHMENT);
		h = (h && h.name) || "";
		var f = new a.DocumentReference(l, c, j);
		var d = a.Model.serialize(f.relativeTo(new a.WikiReference(l)));
		var b = a.Model.serialize(f.parent);
		var i = a.Model.serialize(f);
		return{wiki: l, space: c, prefixedSpace: b, fullName: d, prefixedFullName: i, name: j, attachment: h, anchor: g}
	}, asEntityReference: function (e) {
		var b;
		var d = [e.wiki, e.space, e.name, e.attachment];
		for (var c = 0; c < d.length; c++) {
			if (d[c]) {
				b = new a.EntityReference(d[c], c, b)
			}
		}
		return b
	}, serialize: function (c) {
		var b = a.Model.serialize(this.asEntityReference(c));
		if (c.anchor) {
			if (b.length > 0) {
				b += a.constants.anchorSeparator
			}
			b += c.anchor
		}
		return b
	}}, getResource: function (b) {
		return this.resource.get(b)
	}, displayDocExtra: function (b, c, e) {
		var d = function (f) {
			var g = document.getElementById(f + "tab");
			var h = document.getElementById(f + "pane");
			if (window.activeDocExtraTab != null) {
				window.activeDocExtraTab.className = "";
				window.activeDocExtraPane.className = "hidden"
			}
			window.activeDocExtraTab = g;
			window.activeDocExtraPane = h;
			window.activeDocExtraTab.className = "active";
			window.activeDocExtraPane.className = "";
			g.blur();
			document.fire("xwiki:docextra:activated", {id: f})
		};
		if ($(b + "pane").className.indexOf("empty") != -1) {
			if (window.activeDocExtraPane != null) {
				window.activeDocExtraPane.className = "invisible"
			}
			$("docextrapanes").className = "loading";
			new Ajax.Updater(b + "pane", window.docgeturl + "?xpage=xpart&vm=" + c, {method: "post", evalScripts: true, onComplete: function (f) {
				$("docextrapanes").className = "";
				document.fire("xwiki:docextra:loaded", {id: b, element: $(b + "pane")});
				d(b);
				if (e) {
					$(b + "anchor").id = b;
					location.href = "#" + b;
					$(b).id = b + "anchor"
				}
			}})
		} else {
			d(b);
			if (e) {
				$(b + "anchor").id = b;
				location.href = "#" + b;
				$(b).id = b + "anchor"
			}
		}
	}, makeRenderingErrorsExpandable: function (b) {
		$(b || document.getElementById(PedigreeEditorTool.divId)).select(".xwikirenderingerror").each(function (c) {
			if (c.next().innerHTML !== "" && c.next().hasClassName("xwikirenderingerrordescription")) {
				c.style.cursor = "pointer";
				c.title = "Read technical information related to this error";
				Event.observe(c, "click", function (d) {
					d.element().next().toggleClassName("hidden")
				})
			}
		})
	}, fixLinksTargetAttribute: function (g) {
		var f = $(g || document.getElementById(PedigreeEditorTool.divId)).select("a[rel]");
		for (var e = 0; e < f.length; e++) {
			var d = f[e];
			if (d.up(".xRichTextEditor")) {
				continue
			}
			if (d.getAttribute("href") && d.getAttribute("rel")) {
				var b = d.getAttribute("rel").split(" ");
				for (var c = 0; c < b.length; c++) {
					if (b[c].charAt(0) == "_") {
						d.target = b[c].substring(1);
						break
					} else {
						if (b[c] == "external") {
							d.target = "_blank";
							break
						}
					}
				}
			}
		}
	}, insertSectionEditLinks: function (b) {
		if (false && a.docsyntax != "xwiki/1.0" && a.contextaction == "view" && a.hasEdit) {
			var f = 1;
			b = $(b || document.getElementById(PedigreeEditorTool.divId));
			b = b.id == "xwikicontent" ? b : b.down("#xwikicontent");
			if (!b) {
				return
			}
			var c = b.childNodes;
			var e = new RegExp("H[1-" + 2 + "]");
			for (var d = 0; d < c.length; d++) {
				var h = $(c[d]);
				if (e.test(h.nodeName) && h.className.include("wikigeneratedheader") == false) {
					var g = document.createElement("SPAN");
					g.className = "edit_section";
					(!h.visible() || h.hasClassName("hidden")) && g.hide();
					var j;
					if (!a.hasRenderer) {
						j = document.createElement("SPAN");
						g.className = g.className + " disabled";
						j.title = "This document's syntax doesn't support section editing!"
					} else {
						j = document.createElement("A");
						j.href = window.docediturl + "?section=" + f;
						j.style.textDecoration = "none";
						j.innerHTML = "Edit"
					}
					g.appendChild(j);
					h.insert({after: g});
					f++
				}
			}
		}
	}, insertCreatePageFromTemplateModalBoxes: function (b) {
		if (a.docsyntax != "xwiki/1.0" && a.contextaction == "view" && a.hasEdit && a.widgets.ModalPopup) {
			a.widgets.CreatePagePopup = Class.create(a.widgets.ModalPopup, {initialize: function ($super, f) {
				var e = new Element("div", {"class": "modal-popup"});
				e.insert(f.content);
				$super(e, {show: {method: this.showDialog, keys: []}, close: {method: this.closeDialog, keys: ["Esc"]}}, {displayCloseButton: true, verticalPosition: "center", backgroundColor: "#FFF"});
				this.showDialog();
				this.setClass("createpage-modal-popup")
			}});
			var d = $(b || document.getElementById(PedigreeEditorTool.divId)).select("span.wikicreatelink");
			for (var c = 0; c < d.length; c++) {
				d[c].down("a").observe("click", function (e) {
					new Ajax.Request(e.findElement("a").href.replace(/#.*$/, ""), {method: "get", parameters: {xpage: "createinline", ajax: 1}, onSuccess: function (g) {
						var f = g.getHeader("redirect");
						if (f) {
							window.location = f
						} else {
							new a.widgets.CreatePagePopup({content: g.responseText})
						}
					}, onFailure: function () {
						new a.widgets.Notification("An error occurred, please refresh the page and try again", "error", {inactive: true}).show()
					}});
					e.stop()
				})
			}
		}
	}, watchlist: {actionsMap: {tmWatchDocument: "adddocument", tmUnwatchDocument: "removedocument", tmWatchSpace: "addspace", tmUnwatchSpace: "removespace", tmWatchWiki: "addwiki", tmUnwatchWiki: "removewiki"}, flowMap: {tmWatchDocument: "tmUnwatchDocument", tmUnwatchDocument: "tmWatchDocument", tmWatchSpace: "tmUnwatchSpace", tmUnwatchSpace: "tmWatchSpace", tmWatchWiki: "tmUnwatchWiki", tmUnwatchWiki: "tmWatchWiki"}, executeAction: function (b) {
		var d = window.docgeturl + "?xpage=watch&do=" + this.actionsMap[b.id];
		var c = new Ajax.Request(d, {method: "get", onComplete: function () {
			if (b.nodeName == "A") {
				b.up().toggleClassName("hidden");
				$(a.watchlist.flowMap[b.id]).up().toggleClassName("hidden")
			} else {
				b.toggleClassName("hidden");
				$(a.watchlist.flowMap[b.id]).toggleClassName("hidden")
			}
		}})
	}, initialize: function (b) {
		b = $(b || document.getElementById(PedigreeEditorTool.divId));
		for (button in a.watchlist.actionsMap) {
			var d = b.down("#" + button);
			if (d) {
				var c = this;
				if (d.nodeName != "A") {
					d = $(button).down("A")
				}
				d.stopObserving("click");
				d.observe("click", function (f) {
					Event.stop(f);
					var e = f.element();
					while (e.id == "") {
						e = e.up()
					}
					a.watchlist.executeAction(e)
				})
			}
		}
	}}, cookies: {create: function (d, e, f) {
		if (f) {
			var c = new Date();
			c.setTime(c.getTime() + (f * 24 * 60 * 60 * 1000));
			var b = "; expires=" + c.toGMTString()
		} else {
			var b = ""
		}
		document.cookie = d + "=" + e + b + "; path=/"
	}, read: function (d) {
		var f = d + "=";
		var b = document.cookie.split(";");
		for (var e = 0; e < b.length; e++) {
			var g = b[e];
			while (g.charAt(0) == " ") {
				g = g.substring(1, g.length)
			}
			if (g.indexOf(f) == 0) {
				return g.substring(f.length, g.length)
			}
		}
		return null
	}, erase: function (b) {
		a.cookies.create(b, "", -1)
	}}, togglePanelVisibility: function (b) {
		b = $(b);
		b.toggleClassName("collapsed")
	}, registerPanelToggle: function (b) {
		$(b || document.getElementById(PedigreeEditorTool.divId)).select(".panel .xwikipaneltitle").each(function (c) {
			c.observe("click", this.togglePanelVisibility.bind(this, c.up(".panel")))
		}.bind(this))
	}, extractFileName: function (c) {
		c = $(c);
		if (c.files && c.files.length > 0) {
			return c.files[0].name
		} else {
			if (c.value.substr(0, 12) == "C:\\fakepath\\") {
				return c.value.substr(12)
			} else {
				var b = c.value.lastIndexOf("/");
				if (b >= 0) {
					return c.value.substr(b + 1)
				}
				b = c.value.lastIndexOf("\\");
				if (b >= 0) {
					return c.value.substr(b + 1)
				}
				return c.value
			}
		}
	}, initialize: function () {
		if (typeof this.isInitialized == "undefined" || this.isInitialized == false) {
			if (typeof a.lastScriptLoaded == "undefined") {
				a.failedInit = true;
				return
			}
			this.isInitialized = true;
			document.fire("xwiki:dom:loading");
			document.observe("xwiki:dom:updated", function (b) {
				b.memo.elements.each(this._addBehaviour.bind(this))
			}.bindAsEventListener(this));
			this._addBehaviour();
			this.domIsLoaded = true;
			document.fire("xwiki:dom:loaded")
		}
	}, _addBehaviour: function (b) {
		b = b || $(document.getElementById(PedigreeEditorTool.divId));
		this.makeRenderingErrorsExpandable(b);
		this.fixLinksTargetAttribute(b);
		this.insertSectionEditLinks(b);
		this.insertCreatePageFromTemplateModalBoxes(b);
		this.watchlist.initialize(b);
		this.registerPanelToggle(b)
	}});
	return a
})(XWiki || {});
document.observe("dom:loaded", XWiki.initialize.bind(XWiki));
function showsubmenu(a) {
	if (a.lastChild.tagName.toLowerCase() == "span") {
		if (window.hidetimer) {
			if (window.hideelement == a.lastChild) {
				clearTimeout(window.hidetimer);
				window.hidetimer = null;
				window.hideelement = null
			} else {
				doHide()
			}
		}
		var b = Element.positionedOffset(a);
		a.lastChild.style.left = (b[0] - 10) + "px";
		a.lastChild.style.top = (b[1] + a.offsetHeight) + "px";
		a.lastChild.className = a.lastChild.className.replace("hidden", "visible")
	}
}
function hidesubmenu(a) {
	if (a.lastChild.tagName.toLowerCase() == "span") {
		window.hideelement = a.lastChild;
		window.hidetimer = setTimeout(doHide, 100)
	}
}
function doHide() {
	window.hideelement.className = window.hideelement.className.replace("visible", "hidden");
	clearTimeout(window.hidetimer);
	window.hidetimer = null;
	window.hideelement = null
}
function toggleClass(b, a) {
	if (!eltHasClass(b, a)) {
		b.className += " " + a
	} else {
		rmClass(b, a)
	}
}
function addClass(b, a) {
	if (!eltHasClass(b, a)) {
		b.className += " " + a
	}
}
function eltHasClass(b, a) {
	if (!b.className) {
		return false
	}
	return new RegExp("\\b" + a + "\\b").test(b.className)
}
function rmClass(b, a) {
	b.className = b.className.replace(new RegExp("\\s*\\b" + a + "\\b"), "")
}
function openURL(a) {
	win = open(a, "win", "titlebar=0,width=990,height=500,resizable,scrollbars");
	if (win) {
		win.focus()
	}
}
function openHelp() {
	win = open("http://platform.xwiki.org/xwiki/bin/view/Main/XWikiSyntax?xpage=print", "XWikiSyntax", "titlebar=0,width=750,height=480,resizable,scrollbars");
	if (win) {
		win.focus()
	}
}
function updateName(a, d, c) {
	var b = a.value;
	b = noaccent(b);
	if (c != false) {
		b = b.replace(/class$/gi, "")
	}
	if (d == null) {
		a.value = b
	} else {
		d.value = b
	}
	if (b == "") {
		return false
	}
	return true
}
function noaccent(a) {
	temp = a.replace(/[\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u01fa\u0200\u0202\u0226]/g, "A");
	temp = temp.replace(/[\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u01fb\u0201\u0203\u0227]/g, "a");
	temp = temp.replace(/[\u00c6\u01e2\u01fc]/g, "AE");
	temp = temp.replace(/[\u00e6\u01e3\u01fd]/g, "ae");
	temp = temp.replace(/[\u008c\u0152]/g, "OE");
	temp = temp.replace(/[\u009c\u0153]/g, "oe");
	temp = temp.replace(/[\u00c7\u0106\u0108\u010a\u010c]/g, "C");
	temp = temp.replace(/[\u00e7\u0107\u0109\u010b\u010d]/g, "c");
	temp = temp.replace(/[\u00d0\u010e\u0110]/g, "D");
	temp = temp.replace(/[\u00f0\u010f\u0111]/g, "d");
	temp = temp.replace(/[\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u0204\u0206\u0228]/g, "E");
	temp = temp.replace(/[\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u01dd\u0205\u0207\u0229]/g, "e");
	temp = temp.replace(/[\u011c\u011e\u0120\u0122\u01e4\u01e6\u01f4]/g, "G");
	temp = temp.replace(/[\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5]/g, "g");
	temp = temp.replace(/[\u0124\u0126\u021e]/g, "H");
	temp = temp.replace(/[\u0125\u0127\u021f]/g, "h");
	temp = temp.replace(/[\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u01cf\u0208\u020a]/g, "I");
	temp = temp.replace(/[\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u0131\u01d0\u0209\u020b]/g, "i");
	temp = temp.replace(/[\u0132]/g, "IJ");
	temp = temp.replace(/[\u0133]/g, "ij");
	temp = temp.replace(/[\u0134]/g, "J");
	temp = temp.replace(/[\u0135]/g, "j");
	temp = temp.replace(/[\u0136\u01e8]/g, "K");
	temp = temp.replace(/[\u0137\u0138\u01e9]/g, "k");
	temp = temp.replace(/[\u0139\u013b\u013d\u013f\u0141]/g, "L");
	temp = temp.replace(/[\u013a\u013c\u013e\u0140\u0142\u0234]/g, "l");
	temp = temp.replace(/[\u00d1\u0143\u0145\u0147\u014a\u01f8]/g, "N");
	temp = temp.replace(/[\u00f1\u0144\u0146\u0148\u0149\u014b\u01f9\u0235]/g, "n");
	temp = temp.replace(/[\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u01d1\u01ea\u01ec\u01fe\u020c\u020e\u022a\u022c\u022e\u0230]/g, "O");
	temp = temp.replace(/[\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01d2\u01eb\u01ed\u01ff\u020d\u020f\u022b\u022d\u022f\u0231]/g, "o");
	temp = temp.replace(/[\u0156\u0158\u0210\u0212]/g, "R");
	temp = temp.replace(/[\u0157\u0159\u0211\u0213]/g, "r");
	temp = temp.replace(/[\u015a\u015c\u015e\u0160\u0218]/g, "S");
	temp = temp.replace(/[\u015b\u015d\u015f\u0161\u0219]/g, "s");
	temp = temp.replace(/[\u00de\u0162\u0164\u0166\u021a]/g, "T");
	temp = temp.replace(/[\u00fe\u0163\u0165\u0167\u021b\u0236]/g, "t");
	temp = temp.replace(/[\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u0172\u01d3\u01d5\u01d7\u01d9\u01db\u0214\u0216]/g, "U");
	temp = temp.replace(/[\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01d4\u01d6\u01d8\u01da\u01dc\u0215\u0217]/g, "u");
	temp = temp.replace(/[\u0174]/g, "W");
	temp = temp.replace(/[\u0175]/g, "w");
	temp = temp.replace(/[\u00dd\u0176\u0178\u0232]/g, "Y");
	temp = temp.replace(/[\u00fd\u00ff\u0177\u0233]/g, "y");
	temp = temp.replace(/[\u0179\u017b\u017d]/g, "Z");
	temp = temp.replace(/[\u017a\u017c\u017e]/g, "z");
	temp = temp.replace(/[\u00df]/g, "SS");
	temp = temp.replace(/[^a-zA-Z0-9_]/g, "");
	return temp
}
function prepareName(b) {
	var d = b.register_first_name.value;
	var a = b.register_last_name.value;
	var c = b.xwikiname;
	if (d != "") {
		d = d.substring(0, 1).toUpperCase() + d.substring(1);
		d.replace(/ /g, "")
	}
	if (a != "") {
		a = a.substring(0, 1).toUpperCase() + a.substring(1);
		a.replace(/ /g, "")
	}
	if (c.value == "") {
		c.value = noaccent(d + a)
	}
}
function checkAdvancedContent(a) {
	result = false;
	if (!document.forms.edit) {
		return true
	}
	data = document.forms.edit.content.value;
	myRE = new RegExp("</?(html|body|img|a|i|b|embed|script|form|input|textarea|object|font|li|ul|ol|table|center|hr|br|p) ?([^>]*)>", "ig");
	results = data.match(myRE);
	if (results && results.length > 0) {
		result = true
	}
	myRE2 = new RegExp("(#(set|include|if|end|for)|#(#) Advanced content|public class|/* Advanced content */)", "ig");
	results = data.match(myRE2);
	if (results && results.length > 0) {
		result = true
	}
	if (result == true) {
		return confirm(a)
	}
	return true
}
shortcut = {all_shortcuts: {}, add: function (b, h, d) {
	var g = {type: "keydown", propagate: false, disable_in_input: false, target: document, keycode: false};
	if (!d) {
		d = g
	} else {
		for (var a in g) {
			if (typeof d[a] == "undefined") {
				d[a] = g[a]
			}
		}
	}
	var f = d.target;
	if (typeof d.target == "string") {
		f = document.getElementById(d.target)
	}
	var c = this;
	b = b.toLowerCase();
	var e = function (p) {
		p = p || window.event;
		if (d.disable_in_input) {
			var m;
			if (p.target) {
				m = p.target
			} else {
				if (p.srcElement) {
					m = p.srcElement
				}
			}
			if (m.nodeType == 3) {
				m = m.parentNode
			}
			if (m.tagName == "INPUT" || m.tagName == "TEXTAREA" || m.tagName == "SELECT") {
				return
			}
		}
		var j = 0;
		if (p.keyCode) {
			j = p.keyCode
		} else {
			if (p.which) {
				j = p.which
			}
		}
		var o = String.fromCharCode(j).toLowerCase();
		if (j == 188) {
			o = ","
		}
		if (j == 190) {
			o = "."
		}
		var t = b.split("+");
		var s = 0;
		var q = {"`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ":", "'": '"', ",": "<", ".": ">", "/": "?", "\\": "|"};
		var n = {esc: 27, escape: 27, tab: 9, space: 32, "return": 13, enter: 13, backspace: 8, scrolllock: 145, scroll_lock: 145, scroll: 145, capslock: 20, caps_lock: 20, caps: 20, numlock: 144, num_lock: 144, num: 144, pause: 19, "break": 19, insert: 45, home: 36, "delete": 46, end: 35, pageup: 33, page_up: 33, pu: 33, pagedown: 34, page_down: 34, pd: 34, left: 37, up: 38, right: 39, down: 40, f1: 112, f2: 113, f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123};
		var r = {shift: {wanted: false, pressed: false}, ctrl: {wanted: false, pressed: false}, alt: {wanted: false, pressed: false}, meta: {wanted: false, pressed: false}};
		if (p.ctrlKey) {
			r.ctrl.pressed = true
		}
		if (p.shiftKey) {
			r.shift.pressed = true
		}
		if (p.altKey) {
			r.alt.pressed = true
		}
		if (p.metaKey) {
			r.meta.pressed = true
		}
		for (var l = 0; k = t[l], l < t.length; l++) {
			if (k == "ctrl" || k == "control") {
				s++;
				r.ctrl.wanted = true
			} else {
				if (k == "shift") {
					s++;
					r.shift.wanted = true
				} else {
					if (k == "alt") {
						s++;
						r.alt.wanted = true
					} else {
						if (k == "meta") {
							s++;
							r.meta.wanted = true
						} else {
							if (k.length > 1) {
								if (n[k] == j) {
									s++
								}
							} else {
								if (d.keycode) {
									if (d.keycode == j) {
										s++
									}
								} else {
									if (o == k) {
										s++
									} else {
										if (q[o] && p.shiftKey) {
											o = q[o];
											if (o == k) {
												s++
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (s == t.length && r.ctrl.pressed == r.ctrl.wanted && r.shift.pressed == r.shift.wanted && r.alt.pressed == r.alt.wanted && r.meta.pressed == r.meta.wanted) {
			h(p);
			if (!d.propagate) {
				p.cancelBubble = true;
				p.returnValue = false;
				if (document.all && !window.opera && window.XMLHttpRequest) {
					p.keyCode = 0
				}
				if (p.stopPropagation) {
					p.stopPropagation();
					p.preventDefault()
				}
				return false
			}
		}
	};
	this.all_shortcuts[b] = {callback: e, target: f, event: d.type};
	if (f.addEventListener) {
		f.addEventListener(d.type, e, false)
	} else {
		if (f.attachEvent) {
			f.attachEvent("on" + d.type, e)
		} else {
			f["on" + d.type] = e
		}
	}
}, remove: function (a) {
	a = a.toLowerCase();
	var d = this.all_shortcuts[a];
	delete (this.all_shortcuts[a]);
	if (!d) {
		return
	}
	var b = d.event;
	var c = d.target;
	var e = d.callback;
	if (c.detachEvent) {
		c.detachEvent("on" + b, e)
	} else {
		if (c.removeEventListener) {
			c.removeEventListener(b, e, false)
		} else {
			c["on" + b] = false
		}
	}
}};
function BrowserDetect() {
	var b = navigator.userAgent.toLowerCase();
	this.isGecko = (b.indexOf("gecko") != -1 && b.indexOf("safari") == -1);
	this.isAppleWebKit = (b.indexOf("applewebkit") != -1);
	this.isKonqueror = (b.indexOf("konqueror") != -1);
	this.isSafari = (b.indexOf("safari") != -1);
	this.isOmniweb = (b.indexOf("omniweb") != -1);
	this.isOpera = (b.indexOf("opera") != -1);
	this.isIcab = (b.indexOf("icab") != -1);
	this.isAol = (b.indexOf("aol") != -1);
	this.isIE = (b.indexOf("msie") != -1 && !this.isOpera && (b.indexOf("webtv") == -1));
	this.isMozilla = (this.isGecko && b.indexOf("gecko/") + 14 == b.length);
	this.isFirefox = (b.indexOf("firefox/") != -1 || b.indexOf("firebird/") != -1);
	this.isNS = ((this.isGecko) ? (b.indexOf("netscape") != -1) : ((b.indexOf("mozilla") != -1) && !this.isOpera && !this.isSafari && (b.indexOf("spoofer") == -1) && (b.indexOf("compatible") == -1) && (b.indexOf("webtv") == -1) && (b.indexOf("hotjava") == -1)));
	this.isIECompatible = ((b.indexOf("msie") != -1) && !this.isIE);
	this.isNSCompatible = ((b.indexOf("mozilla") != -1) && !this.isNS && !this.isMozilla);
	this.geckoVersion = ((this.isGecko) ? b.substring((b.lastIndexOf("gecko/") + 6), (b.lastIndexOf("gecko/") + 14)) : -1);
	this.equivalentMozilla = ((this.isGecko) ? parseFloat(b.substring(b.indexOf("rv:") + 3)) : -1);
	this.appleWebKitVersion = ((this.isAppleWebKit) ? parseFloat(b.substring(b.indexOf("applewebkit/") + 12)) : -1);
	this.versionMinor = parseFloat(navigator.appVersion);
	if (this.isGecko && !this.isMozilla) {
		this.versionMinor = parseFloat(b.substring(b.indexOf("/", b.indexOf("gecko/") + 6) + 1))
	} else {
		if (this.isMozilla) {
			this.versionMinor = parseFloat(b.substring(b.indexOf("rv:") + 3))
		} else {
			if (this.isIE && this.versionMinor >= 4) {
				this.versionMinor = parseFloat(b.substring(b.indexOf("msie ") + 5))
			} else {
				if (this.isKonqueror) {
					this.versionMinor = parseFloat(b.substring(b.indexOf("konqueror/") + 10))
				} else {
					if (this.isSafari) {
						this.versionMinor = parseFloat(b.substring(b.lastIndexOf("safari/") + 7))
					} else {
						if (this.isOmniweb) {
							this.versionMinor = parseFloat(b.substring(b.lastIndexOf("omniweb/") + 8))
						} else {
							if (this.isOpera) {
								this.versionMinor = parseFloat(b.substring(b.indexOf("opera") + 6))
							} else {
								if (this.isIcab) {
									this.versionMinor = parseFloat(b.substring(b.indexOf("icab") + 5))
								}
							}
						}
					}
				}
			}
		}
	}
	this.versionMajor = parseInt(this.versionMinor);
	this.isDOM1 = (document.getElementById);
	this.isDOM2Event = (document.addEventListener && document.removeEventListener);
	this.mode = document.compatMode ? document.compatMode : "BackCompat";
	this.isWin = (b.indexOf("win") != -1);
	this.isWin32 = (this.isWin && (b.indexOf("95") != -1 || b.indexOf("98") != -1 || b.indexOf("nt") != -1 || b.indexOf("win32") != -1 || b.indexOf("32bit") != -1 || b.indexOf("xp") != -1));
	this.isMac = (b.indexOf("mac") != -1);
	this.isUnix = (b.indexOf("unix") != -1 || b.indexOf("sunos") != -1 || b.indexOf("bsd") != -1 || b.indexOf("x11") != -1);
	this.isLinux = (b.indexOf("linux") != -1);
	this.isNS4x = (this.isNS && this.versionMajor == 4);
	this.isNS40x = (this.isNS4x && this.versionMinor < 4.5);
	this.isNS47x = (this.isNS4x && this.versionMinor >= 4.7);
	this.isNS4up = (this.isNS && this.versionMinor >= 4);
	this.isNS6x = (this.isNS && this.versionMajor == 6);
	this.isNS6up = (this.isNS && this.versionMajor >= 6);
	this.isNS7x = (this.isNS && this.versionMajor == 7);
	this.isNS7up = (this.isNS && this.versionMajor >= 7);
	this.isIE4x = (this.isIE && this.versionMajor == 4);
	this.isIE4up = (this.isIE && this.versionMajor >= 4);
	this.isIE5x = (this.isIE && this.versionMajor == 5);
	this.isIE55 = (this.isIE && this.versionMinor == 5.5);
	this.isIE5up = (this.isIE && this.versionMajor >= 5);
	this.isIE6x = (this.isIE && this.versionMajor == 6);
	this.isIE6up = (this.isIE && this.versionMajor >= 6);
	this.isIE4xMac = (this.isIE4x && this.isMac);
	var a = /trident\/(\d+)/.exec(b);
	this.isIE11up = a && parseInt(a[1]) >= 7
}
var browser = new BrowserDetect();
XWiki.Document = Class.create({initialize: function (c, b, a) {
	this.page = c || XWiki.Document.currentPage;
	this.space = b || XWiki.Document.currentSpace;
	this.wiki = a || XWiki.Document.currentWiki
}, getURL: function (c, d, b) {
	c = c || "view";
	var a = XWiki.Document.URLTemplate;
	a = a.replace("__space__", encodeURIComponent(this.space));
	a = a.replace("__page__", (this.page == "WebHome") ? "" : encodeURIComponent(this.page));
	a = a.replace("__action__/", (c == "view") ? "" : (encodeURIComponent(c) + "/"));
	if (d) {
		a += "?" + d
	}
	if (b) {
		a += "#" + b
	}
	return a
}, getRestURL: function (a, c) {
	a = a || "";
	var b = XWiki.Document.RestURLTemplate;
	b = b.replace("__wiki__", this.wiki);
	b = b.replace("__space__", this.space);
	b = b.replace("__page__", this.page);
	if (a) {
		b += "/" + a
	}
	if (c) {
		b += "?" + c
	}
	return b
}});
var htmlElement = $(document.documentElement);
XWiki.Document.currentWiki = XWiki.currentWiki || "xwiki";
if (htmlElement.readAttribute("data-xwiki-wiki")) {
	XWiki.Document.currentWiki = htmlElement.readAttribute("data-xwiki-wiki")
} else {
	if ($$("meta[name=wiki]").length > 0) {
		XWiki.Document.currentWiki = $$("meta[name=wiki]")[0].content
	}
}
XWiki.Document.currentSpace = XWiki.currentSpace || "Main";
if (htmlElement.readAttribute("data-xwiki-space")) {
	XWiki.Document.currentSpace = htmlElement.readAttribute("data-xwiki-space")
} else {
	if ($$("meta[name=space]").length > 0) {
		XWiki.Document.currentSpace = $$("meta[name=space]")[0].content
	}
}
XWiki.Document.currentPage = XWiki.currentPage || "WebHome";
if (htmlElement.readAttribute("data-xwiki-page")) {
	XWiki.Document.currentPage = htmlElement.readAttribute("data-xwiki-page")
} else {
	if ($$("meta[name=page]").length > 0) {
		XWiki.Document.currentPage = $$("meta[name=page]")[0].content
	}
}
XWiki.Document.URLTemplate = "/__action__/__space__/__page__";
XWiki.Document.RestURLTemplate = "/rest/wikis/__wiki__/spaces/__space__/pages/__page__";
XWiki.Document.WikiSearchURLStub = "/rest/wikis/__wiki__/search";
XWiki.Document.SpaceSearchURLStub = "/rest/wikis/__wiki__/spaces/__space__/search";
XWiki.Document.getRestSearchURL = function (d, c, a) {
	a = a || XWiki.Document.currentWiki;
	var b;
	if (c) {
		b = XWiki.Document.SpaceSearchURLStub.replace("__wiki__", a).replace("__space__", c)
	} else {
		b = XWiki.Document.WikiSearchURLStub.replace("__wiki__", a)
	}
	if (d) {
		b += "?" + d
	}
	return b
};
XWiki.currentDocument = new XWiki.Document();
(function () {
	var b;
	if ("placeholder" in document.createElement("input")) {
		b = function (e) {
			var d = e.memo.element;
			if (d.placeholder === "") {
				if (d.hasClassName("useTitleAsTip")) {
					d.placeholder = d.title
				} else {
					d.placeholder = d.defaultValue;
					d.value = ""
				}
			}
		}
	} else {
		var a = function () {
			var d = this.hasClassName("empty");
			this.removeClassName("empty");
			if (d) {
				this.value = ""
			} else {
				this.select()
			}
		};
		var c = function () {
			if (this.value == "") {
				this.value = this.defaultValue;
				this.addClassName("empty")
			}
		};
		b = function (f) {
			var e = f.memo.element;
			var d = e.value;
			if (e.readAttribute("placeholder")) {
				e.defaultValue = e.readAttribute("placeholder")
			} else {
				if (e.hasClassName("useTitleAsTip")) {
					e.defaultValue = e.title
				}
			}
			e.value = d;
			if (e.value == e.defaultValue) {
				e.addClassName("empty")
			}
			e.observe("focus", a.bindAsEventListener(e));
			e.observe("blur", c.bindAsEventListener(e))
		}
	}
	document.observe("xwiki:addBehavior:withTip", b);
	document.observe("xwiki:dom:loaded", function () {
		$$("input.withTip", "textarea.withTip", "[placeholder]").each(function (d) {
			document.fire("xwiki:addBehavior:withTip", {element: d})
		})
	});
	document.observe("xwiki:dom:updated", function (d) {
		d.memo.elements.each(function (e) {
			e.select("input.withTip", "textarea.withTip", "[placeholder]").each(function (f) {
				document.fire("xwiki:addBehavior:withTip", {element: f})
			})
		})
	})
})();
document.observe("xwiki:dom:loaded", function () {
	var b = {documents: {script: XWiki.Document.getRestSearchURL("scope=name&number=10&"), varname: "q", icon: "resources/icons/silk/page_white_text.png", noresults: "Document not found", json: true, resultsParameter: "searchResults", resultId: "id", resultValue: "pageFullName", resultInfo: "pageFullName"}, spaces: {script: XWiki.Document.getRestSearchURL("scope=spaces&number=10&"), varname: "q", icon: "resources/icons/silk/folder.png", noresults: "Space not found", json: true, resultsParameter: "searchResults", resultId: "id", resultValue: "space", resultInfo: "space"}};
	var a = function (f) {
		if (typeof(XWiki.widgets.Suggest) != "undefined") {
			var e = Object.keys(b);
			for (var d = 0; d < e.length; d++) {
				var c = "input.suggest" + e[d].capitalize();
				f.each(function (g) {
					$(g).select(c).each(function (i) {
						if (!i.hasClassName("initialized")) {
							var h = {timeout: 30000};
							Object.extend(h, b[e[d]]);
							var j = new XWiki.widgets.Suggest(i, h);
							i.addClassName("initialized")
						}
					})
				})
			}
		}
	};
	a([$(document.documentElement)]);
	document.observe("xwiki:dom:updated", function (c) {
		a(c.memo.elements)
	})
});
["xwiki:dom:loaded", "xwiki:dom:updated"].each(function (a) {
	document.observe(a, function (b) {
		if (typeof(XWiki.widgets.Suggest) != "undefined") {
			var c = b.memo && b.memo.elements || [document.documentElement];
			c.each(function (d) {
				d.select(".suggested").each(function (e) {
					e.setAttribute("autocomplete", "off");
					if (typeof e.onfocus === "function") {
						e.onfocus();
						e.removeAttribute("onfocus")
					}
				})
			})
		}
	})
});
document.observe("xwiki:dom:loaded", function () {
	var h = $("hierarchy");
	var d = $("breadcrumbs");
	var f = $("editParentTrigger");
	var b = $("parentinput");
	var a = $("xwikidocparentinput");
	var g = $("xwikidoctitleinput");

	function e(j) {
		if (j) {
			j.stop()
		}
		b.removeClassName("active");
		f.addClassName("edit-parent");
		f.removeClassName("hide-edit-parent")
	}

	function i(j) {
		if (j) {
			j.stop()
		}
		b.addClassName("active");
		a.focus();
		f.removeClassName("edit-parent");
		f.addClassName("hide-edit-parent")
	}

	function c(j) {
		j.stop();
		j.element().blur();
		if (f.hasClassName("edit-parent")) {
			i()
		} else {
			e()
		}
	}

	if ($("hideEditParentTrigger")) {
		$("hideEditParentTrigger").style.display = "none"
	}
	if (f) {
		f.observe("click", c)
	}
	if (a) {
		if (h || d) {
			["blur", "change", "xwiki:suggest:selected"].each(function (j) {
				a.observe(j, function () {
					var l = {xpage: "xpart", vm: (h ? "hierarchy.vm" : "space.vm"), parent: a.value};
					if (g) {
						l.title = g.value
					}
					new Ajax.Request(XWiki.currentDocument.getURL("edit"), {parameters: l, onSuccess: function (m) {
						if (h) {
							h.replace(m.responseText);
							h = $("hierarchy")
						} else {
							var n = new Element("div");
							n.update(m.responseText);
							d.replace(n.down("[id=breadcrumbs]"));
							d = $("breadcrumbs")
						}
					}})
				})
			})
		}
		$(document.getElementById(PedigreeEditorTool.divId)).observe("click", function (j) {
			if (j.element().descendantOf && !j.element().descendantOf(b) && j.element() != b && j.element() != f) {
				e()
			}
		})
	}
});
document.observe("xwiki:dom:loaded", function () {
	if (!$(document.getElementById(PedigreeEditorTool.divId)).hasClassName("skin-colibri")) {
		return
	}
	var f = $("contentmenu") || $("editmenu");
	var d = $("mainContentArea") || $("mainEditArea");
	if (f && d) {
		e(f);
		Event.observe(window, "resize", function () {
			if (f.style.position == "fixed") {
				f.style.width = d.getWidth() + "px";
				if (typeof(f.__fm_extra) != "undefined") {
					if (f.__fm_extra.getStyle("padding-left").replace(/[^a-z]/g, "") == "px") {
						var g = f.__fm_extra.getStyle("border-left-width").replace(/[^0-9.]/g, "") - 0;
						g += f.__fm_extra.getStyle("padding-left").replace(/[^0-9.]/g, "") - 0;
						g += f.__fm_extra.getStyle("padding-right").replace(/[^0-9.]/g, "") - 0;
						g += f.__fm_extra.getStyle("border-right-width").replace(/[^0-9.]/g, "") - 0
					} else {
						g = 50
					}
					f.__fm_extra.style.width = (d.getWidth() - g) + "px"
				}
			}
		});
		if (!browser.isIE6x) {
			Event.observe(window, "scroll", b);
			document.observe("xwiki:annotations:settings:loaded", b)
		}
	}
	function b() {
		var h = $$(".annotationsettings");
		var g = 0;
		if (h && h.size() > 0) {
			f.__fm_extra = h[0];
			e(f.__fm_extra);
			g = f.__fm_extra.getHeight()
		}
		var m = f.getHeight();
		var l = d.cumulativeOffset().top - g;
		if (document.viewport.getScrollOffsets().top >= l) {
			var j = d.getWidth();
			var i = d.cumulativeOffset().left;
			c(f, 0, i, j);
			if (f.__fm_extra) {
				c(f.__fm_extra, m, i, (j - f.__fm_extra.getStyle("border-left-width").replace(/[^0-9]/g, "") - f.__fm_extra.getStyle("border-right-width").replace(/[^0-9]/g, "") - f.__fm_extra.getStyle("padding-right").replace(/[^0-9]/g, "") - f.__fm_extra.getStyle("padding-left").replace(/[^0-9]/g, "")))
			}
		} else {
			a(f);
			a(f.__fm_extra)
		}
	}

	function e(g) {
		if (typeof(g.__fm_ghost) == "undefined") {
			g.__fm_ghost = new Element("div");
			g.__fm_ghost.hide();
			g.insert({after: g.__fm_ghost})
		}
		g.__fm_ghost.clonePosition(g, {setWidth: false})
	}

	function c(g, j, i, h) {
		if (g) {
			g.addClassName("floating-menu");
			g.style.position = "fixed";
			g.style.top = j + "px";
			g.style.left = i + "px";
			g.style.width = h + "px";
			g.__fm_ghost.show()
		}
	}

	function a(g) {
		if (g) {
			g.removeClassName("floating-menu");
			g.style.position = "";
			g.style.top = "";
			g.style.left = "";
			g.style.width = "";
			g.__fm_ghost.hide()
		}
	}
});
var XWiki = (function (l) {
	var s = 0;
	l.EntityType = {WIKI: s++, SPACE: s++, DOCUMENT: s++, ATTACHMENT: s++, OBJECT: s++, OBJECT_PROPERTY: s++, CLASS_PROPERTY: s++};
	var d = [];
	for (var q in l.EntityType) {
		if (l.EntityType.hasOwnProperty(q)) {
			var f = l.EntityType[q];
			var p = q.toLowerCase().split("_");
			for (var u = 1; u < p.length; u++) {
				p[u] = p[u].substr(0, 1).toUpperCase() + p[u].substr(1)
			}
			d[f] = p.join("")
		}
	}
	l.EntityType.getName = function (i) {
		return d[i]
	};
	l.EntityType.byName = function (A) {
		for (var i = 0; i < d.length; i++) {
			if (d[i] === A) {
				return i
			}
		}
		return -1
	};
	l.EntityReference = Class.create({initialize: function (i, B, A) {
		this.name = i;
		this.type = B;
		this.parent = A
	}, extractReference: function (A) {
		var i = this;
		while (i && i.type != A) {
			i = i.parent
		}
		return i
	}, extractReferenceValue: function (A) {
		var i = this.extractReference(A);
		return i ? i.name : null
	}, relativeTo: function (C) {
		var B = this._extractComponents().reverse();
		var D = C ? C._extractComponents().reverse() : [];
		while (B.length > 0 && D.length > 0 && B[0].type != D[0].type) {
			B[0].type > D[0].type ? D.shift() : B.shift()
		}
		while (B.length > 0 && D.length > 0 && B[0].type == D[0].type && B[0].name == D[0].name) {
			B.shift();
			D.shift()
		}
		if (B.length == 0) {
			return new l.EntityReference("", this.type)
		} else {
			B = B.reverse();
			for (var A = 0; A < B.length; A++) {
				B[A] = new l.EntityReference(B[A].name, B[A].type);
				if (A > 0) {
					B[A - 1].parent = B[A]
				}
			}
			return B[0]
		}
	}, _extractComponents: function () {
		var A = [];
		var i = this;
		while (i) {
			A.push(i);
			i = i.parent
		}
		return A
	}});
	l.WikiReference = Class.create(l.EntityReference, {initialize: function ($super, i) {
		$super(i, l.EntityType.WIKI)
	}});
	l.SpaceReference = Class.create(l.EntityReference, {initialize: function ($super, A, i) {
		$super(i, l.EntityType.SPACE, new l.WikiReference(A))
	}});
	l.DocumentReference = Class.create(l.EntityReference, {initialize: function ($super, B, A, i) {
		$super(i, l.EntityType.DOCUMENT, new l.SpaceReference(B, A))
	}});
	l.AttachmentReference = Class.create(l.EntityReference, {initialize: function ($super, A, i) {
		$super(A, l.EntityType.ATTACHMENT, i)
	}});
	var r = "\\";
	var k = r + r;
	var m = ":";
	var x = ".";
	var h = "@";
	var b = "^";
	var y = x;
	var o = b;
	var n = [
		[],
		[x, m, r],
		[x, r],
		[h, r],
		[b, r],
		[y, r],
		[o, x, r]
	];
	var t = [
		[],
		[r + x, r + m, k],
		[r + x, k],
		[r + h, k],
		[r + b, k],
		[r + y, k],
		[r + o, r + x, k]
	];
	var v = [
		[],
		[m],
		[x, m],
		[h, x, m],
		[b, x, m],
		[y, b, x, m],
		[o, x, m]
	];
	var c = [
		[l.EntityType.WIKI],
		[l.EntityType.SPACE, l.EntityType.WIKI],
		[l.EntityType.DOCUMENT, l.EntityType.SPACE, l.EntityType.WIKI],
		[l.EntityType.ATTACHMENT, l.EntityType.DOCUMENT, l.EntityType.SPACE, l.EntityType.WIKI],
		[l.EntityType.OBJECT, l.EntityType.DOCUMENT, l.EntityType.SPACE, l.EntityType.WIKI],
		[l.EntityType.OBJECT_PROPERTY, l.EntityType.OBJECT, l.EntityType.DOCUMENT, l.EntityType.SPACE, l.EntityType.WIKI],
		[l.EntityType.CLASS_PROPERTY, l.EntityType.DOCUMENT, l.EntityType.SPACE, l.EntityType.WIKI]
	];
	var z = [k, r];
	var e = [r, ""];

	function j(E, A, B) {
		for (var D = 0; D < B.length; D++) {
			var C = A + D;
			if (C >= E.length || E.charAt(C) != B.charAt(D)) {
				return false
			}
		}
		return true
	}

	function a(F, E, D) {
		var A = "", C = -1;
		while (++C < F.length) {
			for (var B = 0; B < E.length; B++) {
				if (j(F, C, E[B])) {
					F = F.substr(0, C) + D[B] + F.substr(C + E[B].length);
					C += D[B].length - 1;
					break
				}
			}
		}
		return F
	}

	l.EntityReferenceResolver = Class.create({resolve: function (C, F) {
		C = C || "";
		F = parseInt(F);
		if (isNaN(F) || F < 0 || F >= v.length) {
			throw"No parsing definition found for Entity Type [" + F + "]"
		}
		var D;
		var B = v[F];
		var H = c[F];
		for (var G = 0; G < B.length && C != null; G++) {
			var E = this._splitAndUnescape(C, B[G]);
			C = E[0];
			var I = new l.EntityReference(E[1], H[G]);
			D = this._appendParent(D, I)
		}
		if (C != null) {
			var A = a(C, z, e);
			var I = new l.EntityReference(A, H[B.length]);
			D = this._appendParent(D, I)
		}
		return D
	}, _appendParent: function (i, B) {
		if (i) {
			var A = i;
			while (A.parent) {
				A = A.parent
			}
			A.parent = B;
			return i
		} else {
			return B
		}
	}, _splitAndUnescape: function (D, G) {
		var C = [];
		var E = D.length;
		while (--E >= 0) {
			var B = D.charAt(E);
			var A = E - 1;
			var H = 0;
			if (A >= 0) {
				H = D.charAt(A)
			}
			if (B == G) {
				var F = this._getNumberOfCharsBefore(r, D, A);
				if (F % 2 == 0) {
					break
				} else {
					--E
				}
			} else {
				if (H == r) {
					--E
				}
			}
			C.push(B)
		}
		return[E < 0 ? null : D.substring(0, E), C.reverse().join("")]
	}, _getNumberOfCharsBefore: function (C, A, B) {
		var i = B;
		while (i >= 0 && A.charAt(i) == C) {
			--i
		}
		return B - i
	}});
	l.EntityReferenceSerializer = Class.create({serialize: function (i) {
		return i ? this.serialize(i.parent) + this._serializeComponent(i) : ""
	}, _serializeComponent: function (B) {
		var i = "";
		var A = n[B.type];
		if (B.parent) {
			i += B.parent.type == l.EntityType.WIKI ? m : A[0]
		}
		if (A.length > 0) {
			i += a(B.name, A, t[B.type])
		} else {
			i += B.name.replace(r, k)
		}
		return i
	}});
	var g = new l.EntityReferenceResolver();
	var w = new l.EntityReferenceSerializer();
	l.Model = {serialize: function (i) {
		return w.serialize(i)
	}, resolve: function (i, A) {
		return g.resolve(i, A)
	}};
	return l
}(XWiki || {}));
var XWiki = (function (b) {
	var a = b.widgets = b.widgets || {};
	a.ModalPopup = Class.create({options: {globalDialog: true, title: "", displayCloseButton: true, extraClassName: false, screenColor: "", borderColor: "", titleColor: "", backgroundColor: "", screenOpacity: "0.5", verticalPosition: "center", horizontalPosition: "center", removeOnClose: false, onClose: Prototype.emptyFunction}, initialize: function (e, c, d) {
		this.shortcuts = {show: {method: this.showDialog, keys: ["Ctrl+G", "Meta+G"]}, close: {method: this.closeDialog, keys: ["Esc"]}}, this.content = e || "Hello world!";
		this.shortcuts = Object.extend(Object.clone(this.shortcuts), c || {});
		this.options = Object.extend(Object.clone(this.options), d || {});
		this.registerShortcuts("show")
	}, createDialog: function (e) {
		this.dialog = new Element("div", {"class": "xdialog-modal-container"});
		var d = new Element("div", {"class": "xdialog-screen"}).setStyle({opacity: this.options.screenOpacity, backgroundColor: this.options.screenColor});
		this.dialog.update(d);
		this.dialogBox = new Element("div", {"class": "xdialog-box"});
		if (this.options.extraClassName) {
			this.dialogBox.addClassName(this.options.extraClassName)
		}
		this.dialogBox._x_contentPlug = new Element("div", {"class": "xdialog-content"});
		this.dialogBox.update(this.dialogBox._x_contentPlug);
		this.dialogBox._x_contentPlug.update(this.content);
		if (this.options.title) {
			var f = new Element("div", {"class": "xdialog-title"}).update(this.options.title);
			f.setStyle({color: this.options.titleColor});
			this.dialogBox.insertBefore(f, this.dialogBox.firstChild)
		}
		if (this.options.displayCloseButton) {
			var c = new Element("div", {"class": "xdialog-close", title: "Close"}).update("&#215;");
			c.observe("click", this.closeDialog.bindAsEventListener(this));
			if (this.options.title) {
				f.insert({bottom: c});
				if (this.options.titleColor) {
					c.setStyle({color: this.options.titleColor})
				}
			} else {
				this.dialogBox.insertBefore(c, this.dialogBox.firstChild)
			}
		}
		this.dialog.appendChild(this.dialogBox);
		this.dialogBox.setStyle({textAlign: "left", borderColor: this.options.borderColor, backgroundColor: this.options.backgroundColor});
		switch (this.options.verticalPosition) {
			case"top":
				this.dialogBox.setStyle({top: "0"});
				break;
			case"bottom":
				this.dialogBox.setStyle({bottom: "0"});
				break;
			default:
				this.dialogBox.setStyle({top: "20%"});
				break
		}
		switch (this.options.horizontalPosition) {
			case"left":
				this.dialog.setStyle({textAlign: "left"});
				break;
			case"right":
				this.dialog.setStyle({textAlign: "right"});
				break;
			default:
				this.dialog.setStyle({textAlign: "center"});
				this.dialogBox.setStyle({margin: "auto"});
				break
		}
		$(document.getElementById(PedigreeEditorTool.divId)).appendChild(this.dialog);
		this.dialog.hide()
	}, setClass: function (c) {
		this.dialogBox.addClassName("xdialog-box-" + c)
	}, removeClass: function (c) {
		this.dialogBox.removeClassName("xdialog-box-" + c)
	}, setContent: function (c) {
		this.content = c;
		this.dialogBox._x_contentPlug.update(this.content)
	}, showDialog: function (c) {
		if (c) {
			Event.stop(c)
		}
		if (this.options.globalDialog) {
			if (a.ModalPopup.active) {
				return
			} else {
				a.ModalPopup.active = true
			}
		} else {
			if (this.active) {
				return
			} else {
				this.active = true
			}
		}
		if (!this.dialog) {
			this.createDialog()
		}
		this.attachKeyListeners();
		this.dialog.show()
	}, closeDialog: function (c) {
		if (c) {
			Event.stop(c)
		}
		this.options.onClose.call(this);
		this.dialog.hide();
		if (this.options.removeOnClose) {
			this.dialog.remove()
		}
		this.detachKeyListeners();
		if (this.options.globalDialog) {
			a.ModalPopup.active = false
		} else {
			this.active = false
		}
	}, attachKeyListeners: function () {
		for (var c in this.shortcuts) {
			if (c != "show") {
				this.registerShortcuts(c)
			}
		}
	}, detachKeyListeners: function () {
		for (var c in this.shortcuts) {
			if (c != "show") {
				this.unregisterShortcuts(c)
			}
		}
	}, registerShortcuts: function (f) {
		var c = this.shortcuts[f].keys;
		var g = this.shortcuts[f].method.bindAsEventListener(this, f);
		var d = this.shortcuts[f].options;
		for (var e = 0; e < c.size(); ++e) {
			shortcut.add(c[e], g, d)
		}
	}, unregisterShortcuts: function (d) {
		for (var c = 0; c < this.shortcuts[d].keys.size(); ++c) {
			shortcut.remove(this.shortcuts[d].keys[c])
		}
	}, createButton: function (d, f, e, i, h) {
		var g = new Element("span", {"class": "buttonwrapper"});
		var c = new Element("input", {type: d, "class": "button", value: f, title: e, id: i});
		if (h) {
			c.addClassName(h)
		}
		g.update(c);
		return g
	}});
	a.ModalPopup.active = false;
	return b
}(XWiki || {}));
var XWiki = (function (c) {
	var a = c.widgets = c.widgets || {};
	if (!c.widgets.ModalPopup) {
		if (console && console.warn) {
			console.warn("[JumpToPage widget] Required class missing: XWiki.widgets.ModalPopup")
		}
	} else {
		a.JumpToPage = Class.create(a.ModalPopup, {urlTemplate: "/__action__/__space__/__document__", initialize: function ($super) {
			var e = new Element("div");
			this.input = new Element("input", {type: "text", id: "jmp_target", title: "Space.Document"});
			e.appendChild(this.input);
			this.viewButton = this.createButton("button", "View", "View document (Enter, Meta+V)", "jmp_view");
			this.editButton = this.createButton("button", "Edit", "Edit document in the default editor (Meta+E)", "jmp_edit");
			var d = new Element("div", {"class": "buttons"});
			d.appendChild(this.viewButton);
			d.appendChild(this.editButton);
			e.appendChild(d);
			$super(e, {show: {method: this.showDialog, keys: ['Meta+G', 'Ctrl+G', 'Ctrl+/', 'Meta+/']}, view: {method: this.openDocument, keys: ['Enter', 'Meta+V'], options: {propagate: true}}, edit: {method: this.openDocument, keys: ['Meta+E']}}, {title: "Go to:", extraClassName: "jump-dialog", verticalPosition: "top"});
			this.shortcuts.close.options = {propagate: true};
			this.addQuickLinksEntry()
		}, createDialog: function ($super, d) {
			Event.observe(this.viewButton, "click", this.openDocument.bindAsEventListener(this, "view"));
			Event.observe(this.editButton, "click", this.openDocument.bindAsEventListener(this, "edit"));
			$super(d);
			if (typeof(c.widgets.Suggest) != "undefined") {
				new c.widgets.Suggest(this.input, {
					/*!*/
					script: "/rest/wikis/xwiki/search?scope=name&number=10&", varname: "q", noresults: "No documents found", icon: "resources/icons/silk/page_white_text.png", json: true, resultsParameter: "searchResults", resultId: "id", resultValue: "pageFullName", resultInfo: "pageFullName", timeout: 30000, parentContainer: this.dialogBox, propagateEventKeyCodes: [Event.KEY_RETURN]})
			}
		}, showDialog: function ($super) {
			$super();
			this.input.value = "";
			this.input.focus()
		}, closeDialog: function ($super, d) {
			if (!d.type.startsWith("key") || !this.dialogBox.down(".ajaxsuggest")) {
				$super();
				this.input.__x_suggest.clearSuggestions()
			}
		}, openDocument: function (e, f) {
			var g = this.dialogBox.down(".ajaxsuggest .xhighlight");
			if ((!g || g.hasClassName("noSuggestion")) && this.input.value != "") {
				Event.stop(e);
				var d = c.Model.resolve(this.input.value, c.EntityType.DOCUMENT);
				if (d.parent) {
					window.self.location = this.urlTemplate.replace("__space__", d.parent.name).replace("__document__", d.name).replace("__action__", f)
				} else {
					if (typeof(c.widgets.Suggest) != "undefined") {
						new c.widgets.Notification("Invalid page name. Valid names have the following format: Space.Page", "error")
					}
				}
			}
		}, addQuickLinksEntry: function () {
			$$(".panel.QuickLinks .xwikipanelcontents").each(function (e) {
				var d = new Element("span", {"class": "jmp-activator"});
				d.update("Jump to any page in the wiki (Meta+G)");
				Event.observe(d, "click", function (f) {
					this.showDialog(f)
				}.bindAsEventListener(this));
				e.appendChild(d)
			}.bind(this))
		}});
		function b() {
			return new a.JumpToPage()
		}

		(c.domIsLoaded && b()) || document.observe("xwiki:dom:loaded", b)
	}
	return c
}(XWiki || {}));
if (typeof(XWiki) == "undefined" || typeof(XWiki.widgets) == "undefined" || typeof(XWiki.widgets.ModalPopup) == "undefined") {
	if (typeof console != "undefined" && typeof console.warn == "function") {
		console.warn("[ConfirmationBox widget] Required class missing: XWiki.widgets.ModalPopup")
	}
} else {
	XWiki.widgets.ConfirmationBox = Class.create(XWiki.widgets.ModalPopup, {defaultInteractionParameters: {confirmationText: "Are you sure?", yesButtonText: "Yes", noButtonText: "No", cancelButtonText: "Cancel", showCancelButton: false}, initialize: function ($super, b, c) {
		this.interactionParameters = Object.extend(Object.clone(this.defaultInteractionParameters), c || {});
		var a = {show: {method: this.showDialog, keys: []}, yes: {method: this.onYes, keys: ["Enter", "Space", "y"]}, no: {method: this.onNo, keys: ["n"]}, close: {method: this.closeDialog, keys: ["c"]}};
		if (this.interactionParameters.showCancelButton) {
			a.close.keys.push("Esc")
		} else {
			a.no.keys.push("Esc")
		}
		$super(this.createContent(this.interactionParameters), a, {displayCloseButton: false, removeOnClose: true});
		this.showDialog();
		this.setClass("confirmation");
		this.behavior = b || {}
	}, createContent: function (e) {
		var b = new Element("div", {"class": "question"}).update(e.confirmationText);
		var d = new Element("div", {"class": "buttons"});
		var f = this.createButton("button", e.yesButtonText, "(Enter)", "");
		Event.observe(f, "click", this.onYes.bindAsEventListener(this));
		d.insert(f);
		var a = this.createButton("button", e.noButtonText, e.showCancelButton ? "(n)" : "(Esc)", "", "secondary");
		Event.observe(a, "click", this.onNo.bindAsEventListener(this));
		d.insert(a);
		if (e.showCancelButton) {
			var g = this.createButton("button", e.cancelButtonText, "(Esc)", "", "cancel secondary");
			Event.observe(g, "click", this.onCancel.bindAsEventListener(this));
			d.insert(g)
		}
		var c = new Element("div");
		c.insert(b).insert(d);
		return c
	}, onYes: function () {
		this.closeDialog();
		if (typeof(this.behavior.onYes) == "function") {
			this.behavior.onYes()
		}
	}, onNo: function () {
		this.closeDialog();
		if (typeof(this.behavior.onNo) == "function") {
			this.behavior.onNo()
		}
	}, onCancel: function () {
		this.closeDialog();
		if (typeof(this.behavior.onCancel) == "function") {
			this.behavior.onCancel()
		}
	}})
}
;
if (typeof(XWiki) == "undefined" || typeof(XWiki.widgets) == "undefined" || typeof(XWiki.widgets.ConfirmationBox) == "undefined") {
	if (typeof console != "undefined" && typeof console.warn == "function") {
		console.warn("[MessageBox widget] Required class missing: XWiki.widgets.ModalPopup")
	}
} else {
	XWiki.widgets.ConfirmedAjaxRequest = Class.create(XWiki.widgets.ConfirmationBox, {defaultAjaxRequestParameters: {on1223: function (a) {
		a.request.options.onSuccess(a)
	}, on0: function (a) {
		a.request.options.onFailure(a)
	}}, initialize: function ($super, b, a, c) {
		this.interactionParameters = Object.extend({displayProgressMessage: true, progressMessageText: "Sending request...", displaySuccessMessage: true, successMessageText: "Done!", displayFailureMessage: true, failureMessageText: "Failed: "}, c || {});
		this.requestUrl = b;
		this.ajaxRequestParameters = Object.extend(Object.clone(this.defaultAjaxRequestParameters), a || {});
		Object.extend(this.ajaxRequestParameters, {onSuccess: function () {
			if (this.interactionParameters.displaySuccessMessage) {
				if (this.progressNotification) {
					this.progressNotification.replace(new XWiki.widgets.Notification(this.interactionParameters.successMessageText, "done"))
				} else {
					new XWiki.widgets.Notification(this.interactionParameters.successMessageText, "done")
				}
			} else {
				if (this.progressNotification) {
					this.progressNotification.hide()
				}
			}
			if (a.onSuccess) {
				a.onSuccess.apply(this, arguments)
			}
		}.bind(this), onFailure: function (d) {
			if (this.interactionParameters.displayFailureMessage) {
				var e = d.statusText;
				if (d.statusText == "" || d.status == 12031) {
					e = "Server not responding"
				}
				if (this.progressNotification) {
					this.progressNotification.replace(new XWiki.widgets.Notification(this.interactionParameters.failureMessageText + e, "error"))
				} else {
					new XWiki.widgets.Notification(this.interactionParameters.failureMessageText + e, "error")
				}
			} else {
				if (this.progressNotification) {
					this.progressNotification.hide()
				}
			}
			if (a.onFailure) {
				a.onFailure.apply(this, arguments)
			}
		}.bind(this)});
		$super({onYes: function () {
			if (this.interactionParameters.displayProgressMessage) {
				this.progressNotification = new XWiki.widgets.Notification(this.interactionParameters.progressMessageText, "inprogress")
			}
			new Ajax.Request(this.requestUrl, this.ajaxRequestParameters)
		}.bind(this)}, this.interactionParameters)
	}})
}
;
var XWiki = (function (b) {
	var a = b.widgets = b.widgets || {};
	a.Notification = Class.create({text: "Hello world!", defaultOptions: {plain: {timeout: 5}, info: {timeout: 5}, warning: {timeout: 5}, error: {timeout: 10}, inprogress: {timeout: false}, done: {timeout: 2}}, initialize: function (e, d, c) {
		this.text = e || this.text;
		this.type = (typeof this.defaultOptions[d] != "undefined") ? d : "plain";
		this.options = Object.extend(Object.clone(this.defaultOptions[this.type]), c || {});
		this.createElement();
		if (!this.options.inactive) {
			this.show()
		}
	}, createElement: function () {
		if (!this.element) {
			this.element = new Element("div", {"class": "xnotification xnotification-" + this.type}).update(this.text);
			if (this.options.icon) {
				this.element.setStyle({backgroundImage: this.options.icon, paddingLeft: "22px"})
			}
			if (this.options.backgroundColor) {
				this.element.setStyle({backgroundColor: this.options.backgroundColor})
			}
			if (this.options.color) {
				this.element.setStyle({color: this.options.color})
			}
			this.element = this.element.wrap(new Element("div", {"class": "xnotification-wrapper"}));
			Event.observe(this.element, "click", this.hide.bindAsEventListener(this))
		}
	}, show: function () {
		if (!this.element.descendantOf(a.Notification.getContainer())) {
			a.Notification.getContainer().insert({top: this.element})
		}
		this.element.show();
		if (this.options.timeout) {
			this.timer = window.setTimeout(this.hide.bind(this), this.options.timeout * 1000)
		}
	}, hide: function () {
		this.element.hide();
		if (this.element.parentNode) {
			this.element.remove()
		}
		if (this.timer) {
			window.clearTimeout(this.timer);
			this.timer = null
		}
		(typeof this.options.onHide == "function") && this.options.onHide()
	}, replace: function (c) {
		if (this.element.parentNode) {
			this.element.replace(c.element)
		}
		if (this.timer) {
			window.clearTimeout(this.timer);
			this.timer = null
		}
		c.show()
	}});
	a.Notification.container = null;
	a.Notification.getContainer = function () {
		if (!a.Notification.container) {
			a.Notification.container = new Element("div", {"class": "xnotification-container"});
			$(document.getElementById(PedigreeEditorTool.divId)).insert(a.Notification.container)
		}
		return a.Notification.container
	};
	return b
}(XWiki || {}));
var XWiki = function (b) {
	var a = b.widgets = b.widgets || {};
	a.XList = Class.create({initialize: function (c, d) {
		this.items = c || [];
		this.options = d || {};
		this.listElement = new Element(this.options.ordered ? "ol" : "ul", {"class": "xlist" + (this.options.classes ? (" " + this.options.classes) : "")});
		if (this.items && this.items.length > 0) {
			for (var e = 0; e < this.items.length; e++) {
				this.addItem(this.items[e])
			}
		}
	}, addItem: function (c) {
		if (!c || !(c instanceof b.widgets.XListItem)) {
			c = new b.widgets.XListItem(c)
		}
		var d = c.getElement();
		if (this.options.itemClasses && !this.options.itemClasses.blank()) {
			d.addClassName(this.options.itemClasses)
		}
		this.listElement.insert(d);
		if (typeof this.options.eventListeners == "object") {
			c.bindEventListeners(this.options.eventListeners)
		}
		if (this.options.icon && !this.options.icon.blank()) {
			c.setIcon(this.options.icon, this.options.overrideItemIcon)
		}
		c.list = this
	}, getElement: function () {
		return this.listElement
	}});
	a.XListItem = Class.create({initialize: function (e, c) {
		this.options = c || {};
		var d = "xitem " + (this.options.noHighlight ? "" : "xhighlight ");
		d += this.options.classes ? this.options.classes : "";
		this.containerElement = new Element("div", {"class": "xitemcontainer"}).insert(e || "");
		this.containerElement.addClassName(this.options.containerClasses || "");
		this.containerElement.setStyle({textIndent: "0px"});
		if (this.options.value) {
			this.containerElement.insert(new Element("div", {"class": "hidden value"}).insert(this.options.value))
		}
		this.listItemElement = new Element("li", {"class": d}).update(this.containerElement);
		if (this.options.icon && !this.options.icon.blank()) {
			this.setIcon(this.options.icon);
			this.hasIcon = true
		}
		if (typeof this.options.eventListeners == "object") {
			this.bindEventListeners(this.options.eventListeners)
		}
	}, getElement: function () {
		return this.listItemElement
	}, setIcon: function (d, c) {
		if (!this.hasIcon || c) {
			this.iconImage = new Image();
			this.iconImage.onload = function () {
				this.listItemElement.setStyle({backgroundImage: "url(" + this.iconImage.src + ")", backgroundRepeat: "no-repeat", backgroundPosition: "3px 3px"});
				this.listItemElement.down(".xitemcontainer").setStyle({textIndent: (this.iconImage.width + 6) + "px"})
			}.bind(this);
			this.iconImage.src = d
		}
	}, bindEventListeners: function (e) {
		var d = Object.keys(e);
		for (var c = 0; c < d.length; c++) {
			this.listItemElement.observe(d[c], e[d[c]].bindAsEventListener(this.options.eventCallbackScope ? this.options.eventCallbackScope : this))
		}
	}});
	return b
}(XWiki || {});
var XWiki = (function (b) {
	var a = b.widgets = b.widgets || {};
	if (typeof a.XList == "undefined") {
		if (typeof console != "undefined" && typeof console.warn == "function") {
			console.warn("[Suggest widget] Required class missing: XWiki.widgets.XList")
		}
	} else {
		a.Suggest = Class.create({options: {minchars: 1, method: "get", varname: "input", className: "ajaxsuggest", timeout: 2500, delay: 500, offsety: 0, shownoresults: true, noresults: "No results!", maxheight: 250, cache: false, seps: "", icon: null, resultsParameter: "results", resultId: "id", resultValue: "value", resultInfo: "info", resultIcon: "icon", resultHint: "hint", resultType: "type", parentContainer: "pedigree-tool", highlight: true, fadeOnClear: true, hideButton: {positions: ["top"], text: "hide suggestions"}, insertBeforeSuggestions: null, displayValue: false, displayValueText: "Value: ", align: "left", unifiedLoader: false, loaderNode: null, propagateEventKeyCodes: []}, sInput: "", nInputChars: 0, aSuggestions: {}, iHighlighted: null, isActive: false, initialize: function (c, d) {
			if (!c) {
				return false
			}
			this.setInputField(c);
			this.options = Object.extend(Object.clone(this.options), d || {});
			if (typeof this.options.sources == "object") {
				this.isInMultiSourceMode = true;
				this.sources = this.options.sources
			} else {
				this.sources = this.options
			}
			this.sources = [this.sources].flatten().compact();
			if (this.sources.length == 0) {
				this.sources.push({script: function (e, f) {
					f([])
				}})
			}
			if (!$(this.options.parentContainer)) {
				this.options.parentContainer = $(document.getElementById(PedigreeEditorTool.divId))
			}
			if (this.options.seps) {
				this.seps = this.options.seps
			} else {
				this.seps = ""
			}
			this.latestRequest = 0
		}, setInputField: function (c) {
			this.detach();
			this.fld = $(c);
			if (this.fld.__x_suggest) {
				this.fld.__x_suggest.detach()
			}
			this.fld.__x_suggest = this;
			this.onKeyUp = this.onKeyUp.bindAsEventListener(this);
			this.fld.observe("keyup", this.onKeyUp);
			this.onKeyPress = this.onKeyPress.bindAsEventListener(this);
			if (Prototype.Browser.IE || Prototype.Browser.WebKit || browser.isIE11up) {
				this.fld.observe("keydown", this.onKeyPress)
			} else {
				this.fld.observe("keypress", this.onKeyPress)
			}
			this.fld.setAttribute("autocomplete", "off");
			this.fld.observe("blur", function (d) {
				this.latestRequest++
			}.bind(this))
		}, onKeyUp: function (f) {
			var d = f.keyCode;
			switch (d) {
				case Event.KEY_RETURN:
				case Event.KEY_ESC:
				case Event.KEY_UP:
				case Event.KEY_DOWN:
					break;
				default:
					if (this.seps) {
						var e = -1;
						for (var c = 0; c < this.seps.length; c++) {
							if (this.fld.value.lastIndexOf(this.seps.charAt(c)) > e) {
								e = this.fld.value.lastIndexOf(this.seps.charAt(c))
							}
						}
						if (e == -1) {
							this.getSuggestions(this.fld.value)
						} else {
							this.getSuggestions(this.fld.value.substring(e + 1))
						}
					} else {
						this.getSuggestions(this.fld.value)
					}
			}
		}, onKeyPress: function (d) {
			if (!$(this.isActive)) {
				return
			}
			var c = d.keyCode;
			var e = true;
			switch (c) {
				case Event.KEY_RETURN:
					if (!this.iHighlighted && (Object.keys(this.aSuggestions).length == 1 && this.aSuggestions[Object.keys(this.aSuggestions)[0]].length == 1)) {
						this.highlightFirst()
					}
					this.setHighlightedValue(d);
					break;
				case Event.KEY_ESC:
					this.clearSuggestions();
					break;
				case Event.KEY_UP:
					this.changeHighlight(c);
					break;
				case Event.KEY_DOWN:
					this.changeHighlight(c);
					break;
				default:
					e = false;
					break
			}
			if (e && this.options.propagateEventKeyCodes && this.options.propagateEventKeyCodes.indexOf(c) == -1) {
				Event.stop(d)
			}
		}, getSuggestions: function (g) {
			g = g.strip().toLowerCase();
			if (g == this.sInput) {
				return false
			}
			if (g.length < this.options.minchars) {
				this.sInput = "";
				this.clearSuggestions();
				return false
			}
			if (g.length > this.nInputChars && Object.keys(this.aSuggestions).length && this.options.cache) {
				var m = {};
				for (var l = 0; l < Object.keys(this.aSuggestions).length; l++) {
					var o = Object.keys(this.aSuggestions)[l];
					var h = [];
					for (var k = 0; k < this.aSuggestions[o].length; k++) {
						var e = this.aSuggestions[o][k];
						if (e.value.substr(0, g.length).toLowerCase() == g) {
							h.push(e)
						}
					}
					if (h.length) {
						m[o] = n
					}
				}
				this.sInput = g;
				this.nInputChars = g.length;
				this.aSuggestions = m;
				for (var l = 0; l < sources.length; l++) {
					var d = sources[l];
					var n = this.aSuggestions[d.id];
					if (n) {
						this.createList(n, d)
					}
				}
				return false
			} else {
				this.sInput = g;
				this.nInputChars = g.length;
				this.prepareContainer();
				this.latestRequest++;
				var c = this;
				var f = this.latestRequest;
				clearTimeout(this.ajID);
				this.container.select(".hide-button-wrapper").invoke("hide");
				this.ajID = setTimeout(function () {
					c.doAjaxRequests(f)
				}, this.options.delay)
			}
			return false
		}, doAjaxRequests: function (f, d) {
			if (this.fld.value.length < this.options.minchars) {
				return
			}
			for (var c = 0; c < this.sources.length; c++) {
				var e = this.sources[c];
				if (typeof e.script == "function") {
					this.fld.addClassName("loading");
					e.script(this.fld.value.strip(), function (g) {
						if (f == this.latestRequest) {
							this.aSuggestions[e.id] = g || [];
							g && this.createList(this.aSuggestions[e.id], e);
							this.fld.removeClassName("loading")
						}
					}.bind(this))
				} else {
					this.doAjaxRequest(e, f, d)
				}
			}
		}, doAjaxRequest: function (f, g, e) {
			var d = f.script + (f.script.indexOf("?") < 0 ? "?" : "&") + f.varname + "=" + encodeURIComponent(this.fld.value.strip());
			var i = f.method || "get";
			var h = {};
			if (f.json) {
				h.Accept = "application/json"
			} else {
				h.Accept = "application/xml"
			}
			var c = {method: i, requestHeaders: h, onCreate: this.fld.addClassName.bind(this.fld, "loading"), onSuccess: this.setSuggestions.bindAsEventListener(this, f, g), onFailure: function (j) {
				new b.widgets.Notification("Failed to retrieve suggestions: " + j.statusText, "error", {timeout: 5})
			}, onComplete: this.fld.removeClassName.bind(this.fld, "loading")};
			c.defaultValues = Object.clone(c);
			new Ajax.Request(d, Object.extend(c, e || {}))
		}, setSuggestions: function (d, e, f) {
			if (f < this.latestRequest) {
				return
			}
			var c = this.parseResponse(d, e);
			this.aSuggestions[e.id] = c || [];
			c && this.createList(this.aSuggestions[e.id], e)
		}, _getNestedProperty: function (e, d) {
			var c = d.split(".");
			while (c.length && (e = e[c.shift()])) {
			}
			return c.length > 0 ? null : e
		}, parseResponse: function (h, j) {
			var d = [];
			if (j.json) {
				var k = h.responseJSON;
				if (!k) {
					return null
				}
				if (Object.isArray(k)) {
					var g = k
				} else {
					var g = this._getNestedProperty(k, j.resultsParameter || this.options.resultsParameter)
				}
				for (var f = 0; f < g.length; f++) {
					var c = g[f];
					d.push({id: this._getNestedProperty(c, j.resultId || this.options.resultId), value: this._getNestedProperty(c, j.resultValue || this.options.resultValue), info: this._getNestedProperty(c, j.resultInfo || this.options.resultInfo), icon: this._getNestedProperty(c, j.resultIcon || this.options.resultIcon), hint: this._getNestedProperty(c, j.resultHint || this.options.resultHint), type: this._getNestedProperty(c, j.resultType || this.options.resultType)})
				}
			} else {
				var e = h.responseXML;
				var g = e.getElementsByTagName(j.resultsParameter || this.options.resultsParameter)[0].childNodes;
				for (var f = 0; f < g.length; f++) {
					if (g[f].hasChildNodes()) {
						d.push({id: g[f].getAttribute("id"), value: g[f].childNodes[0].nodeValue, info: g[f].getAttribute("info"), icon: g[f].getAttribute("icon"), hint: g[f].getAttribute("hint"), type: g[f].getAttribute("type")})
					}
				}
			}
			return d
		}, prepareContainer: function () {
			if (!$(this.options.parentContainer).down(".suggestItems")) {
				var m = new Element("div", {"class": "suggestItems " + this.options.className});
				var g = $(this.options.parentContainer).id.toLowerCase() == PedigreeEditorTool.divId.toLowerCase() ? this.fld.cumulativeOffset() : this.fld.positionedOffset();
				var j = this.fld.offsetWidth - 2;
				var l = this.options.width || j;
				var c = this.fld.viewportOffset().left;
				var e = $(document.getElementById(PedigreeEditorTool.divId)).getWidth();
				if (this.options.align == "left" || (this.options.align == "auto" && c + this.options.width < e)) {
					m.style.left = g.left + "px"
				} else {
					if (this.options.align == "center") {
						m.style.left = g.left + (j - l) / 2 + "px"
					} else {
						m.style.left = (g.left + j - l) + "px"
					}
				}
				m.style.top = (g.top + this.fld.offsetHeight + this.options.offsety) + "px";
				m.style[this.options.width ? "width" : "minWidth"] = l + "px";
				var p = this;
				m.onmouseover = function () {
					p.killTimeout()
				};
				m.onmouseout = function () {
					p.resetTimeout()
				};
				this.resultContainer = new Element("div", {"class": "resultContainer"});
				m.appendChild(this.resultContainer);
				$(this.options.parentContainer).insert(m);
				this.container = m;
				if (this.options.insertBeforeSuggestions) {
					this.resultContainer.insert(this.options.insertBeforeSuggestions)
				}
				document.fire("xwiki:suggest:containerCreated", {container: this.container, suggest: this})
			}
			if (this.isInMultiSourceMode) {
				for (var r = 0; r < this.sources.length; r++) {
					var o = this.sources[r];
					o.id = o.id || r;
					if (this.resultContainer.down(".results" + o.id)) {
						if (this.resultContainer.down(".results" + o.id).down("ul")) {
							this.resultContainer.down(".results" + o.id).down("ul").remove()
						}
						if (!this.options.unifiedLoader) {
							this.resultContainer.down(".results" + o.id).down(".sourceContent").addClassName("loading")
						} else {
							(this.options.loaderNode || this.fld).addClassName("loading");
							this.resultContainer.down(".results" + o.id).addClassName("hidden").addClassName("loading")
						}
					} else {
						var f = new Element("div", {"class": "results results" + o.id}), h = new Element("div", {"class": "sourceName"});
						if (this.options.unifiedLoader) {
							f.addClassName("hidden").addClassName("loading")
						}
						if (typeof o.icon != "undefined") {
							var d = new Image();
							d.onload = function () {
								this.sourceHeader.setStyle({backgroundImage: "url(" + this.iconImage.src + ")"});
								this.sourceHeader.setStyle({textIndent: (this.iconImage.width + 6) + "px"})
							}.bind({sourceHeader: h, iconImage: d});
							d.src = o.icon
						}
						h.insert(o.name);
						f.insert(h);
						var t = "sourceContent " + (this.options.unifiedLoader ? "" : "loading");
						f.insert(new Element("div", {"class": t}));
						if (typeof o.before !== "undefined") {
							this.resultContainer.insert(o.before)
						}
						this.resultContainer.insert(f);
						if (typeof o.after !== "undefined") {
							this.resultContainer.insert(o.after)
						}
					}
				}
			} else {
				if (this.resultContainer.down("ul")) {
					this.resultContainer.down("ul").remove()
				}
			}
			var n = typeof this.options.hideButton !== "undefined" && typeof this.options.hideButton.positions === "object" && this.options.hideButton.positions.length > 0;
			if (n && !this.container.down(".hide-button")) {
				var k = this.options.hideButton.positions;
				for (var r = 0; r < k.length; r++) {
					var u = new Element("span", {"class": "hide-button"}).update(this.options.hideButton.text), q = {};
					q[k[r]] = new Element("div", {"class": "hide-button-wrapper"}).update(u);
					u.observe("click", this.clearSuggestions.bindAsEventListener(this));
					this.container.insert(q)
				}
			}
			var s = this.container.fire("xwiki:suggest:containerPrepared", {container: this.container, suggest: this});
			return this.container
		}, createList: function (c, d) {
			this._createList(c, d);
			if (!this.isInMultiSourceMode || !this.resultContainer.down(".results.loading")) {
				document.fire("xwiki:suggest:updated", {container: this.container, suggest: this})
			}
		}, _createList: function (f, d) {
			this.isActive = true;
			var c = this;
			this.killTimeout();
			if (this.isInMultiSourceMode) {
				var j = this.resultContainer.down(".results" + d.id);
				j.removeClassName("loading");
				j.down(".sourceContent").removeClassName("loading");
				(f.length > 0 || this.options.shownoresults) && j.removeClassName("hidden");
				if (this.options.unifiedLoader && !this.resultContainer.down(".results.loading")) {
					(this.options.loaderNode || this.fld).removeClassName("loading")
				}
			} else {
				var j = this.resultContainer
			}
			if (f.length == 0 && !this.options.shownoresults) {
				return false
			}
			j.down("ul") && j.down("ul").remove();
			this.container.select(".hide-button-wrapper").invoke("show");
			var h = new b.widgets.XList([], {icon: this.options.icon, classes: "suggestList", eventListeners: {click: function (i) {
				c.setHighlightedValue(i);
				return false
			}, mouseover: function () {
				c.setHighlight(this.getElement())
			}}});
			for (var e = 0, g = f.length; e < g; e++) {
				var m = function (i) {
					return((i || "") + "").escapeHTML()
				};
				var k = new Element("div").insert(new Element("span", {"class": "suggestId"}).update(m(f[e].id))).insert(new Element("span", {"class": "suggestValue"}).update(m(f[e].value))).insert(new Element("span", {"class": "suggestInfo"}).update(m(f[e].info)));
				var l = new b.widgets.XListItem(this.createItemDisplay(f[e], d), {containerClasses: "suggestItem " + (f[e].type || ""), value: k, noHighlight: true});
				h.addItem(l)
			}
			if (f.length == 0) {
				h.addItem(new b.widgets.XListItem(this.options.noresults, {classes: "noSuggestion", noHighlight: true}))
			}
			j.appendChild(h.getElement());
			this.suggest = j;
			var c = this;
			if (this.options.timeout > 0) {
				this.toID = setTimeout(function () {
					c.clearSuggestions()
				}, this.options.timeout)
			}
		}, createItemDisplay: function (g, c) {
			var h = this.sInput ? this.sInput.escapeHTML() : this.sInput;
			var k = ((g.value || "") + "").escapeHTML();
			var e = c.highlight ? this.emphasizeMatches(h, k) : k;
			if (g.hint) {
				var d = (g.hint + "").escapeHTML();
				e += "<span class='hint'>" + d + "</span>"
			}
			if (!this.options.displayValue) {
				var j = new Element("span", {"class": "info"}).update(e)
			} else {
				var i = ((g.info || "") + "").escapeHTML();
				var j = new Element("div").insert(new Element("div", {"class": "value"}).update(e)).insert(new Element("div", {"class": "info"}).update("<span class='legend'>" + this.options.displayValueText + "</span>" + i))
			}
			if (g.icon) {
				if (g.icon.indexOf(".") >= 0 || g.icon.indexOf("/") >= 0) {
					var f = new Element("img", {src: g.icon, "class": "icon"})
				} else {
					var f = new Element("i", {"class": "icon " + g.icon})
				}
				j.insert({top: f})
			}
			return j
		}, emphasizeMatches: function (k, m) {
			if (!k) {
				return m
			}
			var c = m, i = k.split(" ").uniq().compact(), d = 0, g = {};
			for (var e = 0, n = i.length; e < n; e++) {
				var h = c.toLowerCase().indexOf(i[e].toLowerCase());
				while (h >= 0) {
					var f = c.substring(h, h + i[e].length), l = "";
					i[e].length.times(function () {
						l += " "
					});
					g[h] = f;
					c = c.substring(0, h) + l + c.substring(h + i[e].length);
					h = c.toLowerCase().indexOf(i[e].toLowerCase())
				}
			}
			Object.keys(g).sortBy(function (j) {
				return parseInt(j)
			}).each(function (j) {
				var o = c.substring(0, parseInt(j) + d);
				var p = c.substring(parseInt(j) + g[j].length + d);
				c = o + "<em>" + g[j] + "</em>" + p;
				d += 9
			});
			return c
		}, changeHighlight: function (c) {
			var f = this.resultContainer;
			if (!f) {
				return false
			}
			var g, d;
			if (this.iHighlighted) {
				if (c == Event.KEY_DOWN) {
					d = this.iHighlighted.next();
					if (!d && this.iHighlighted.up("div.results")) {
						var e = this.iHighlighted.up("div.results").next();
						while (e && !d) {
							d = e.down("li");
							e = e.next()
						}
					}
					if (!d) {
						d = f.down("li")
					}
				} else {
					if (c == Event.KEY_UP) {
						d = this.iHighlighted.previous();
						if (!d && this.iHighlighted.up("div.results")) {
							var e = this.iHighlighted.up("div.results").previous();
							while (e && !d) {
								d = e.down("li:last-child");
								e = e.previous()
							}
						}
						if (!d) {
							d = f.select("ul")[f.select("ul").length - 1].down("li:last-child")
						}
					}
				}
			} else {
				if (c == Event.KEY_DOWN) {
					if (f.down("div.results")) {
						d = f.down("div.results").down("li")
					} else {
						d = f.down("li")
					}
				} else {
					if (c == Event.KEY_UP) {
						if (f.select("li") > 0) {
							d = f.select("li")[f.select("li").length - 1]
						}
					}
				}
			}
			if (d) {
				this.setHighlight(d)
			}
		}, setHighlight: function (c) {
			if (this.iHighlighted) {
				this.clearHighlight()
			}
			c.addClassName("xhighlight");
			this.iHighlighted = c;
			this.killTimeout()
		}, clearHighlight: function () {
			if (this.iHighlighted) {
				this.iHighlighted.removeClassName("xhighlight");
				delete this.iHighlighted
			}
		}, highlightFirst: function () {
			if (this.suggest && this.suggest.down("ul")) {
				var c = this.suggest.down("ul").down("li");
				if (c) {
					this.setHighlight(c)
				}
			}
		}, hasActiveSelection: function () {
			return this.iHighlighted
		}, setHighlightedValue: function (c) {
			if (this.iHighlighted && !this.iHighlighted.hasClassName("noSuggestion")) {
				var m = function (i) {
					return i.textContent || i.innerText
				};
				var j = this.iHighlighted.down("img.icon");
				var f = {suggest: this, id: m(this.iHighlighted.down(".suggestId")), value: m(this.iHighlighted.down(".suggestValue")), info: m(this.iHighlighted.down(".suggestInfo")), icon: j ? j.src : "", originalEvent: c};
				var k, l;
				if (this.sInput == "" && this.fld.value == "") {
					k = l = f.value
				} else {
					if (this.seps) {
						var d = -1;
						for (var g = 0; g < this.seps.length; g++) {
							if (this.fld.value.lastIndexOf(this.seps.charAt(g)) > d) {
								d = this.fld.value.lastIndexOf(this.seps.charAt(g))
							}
						}
						if (d == -1) {
							k = l = f.value
						} else {
							l = this.fld.value.substring(0, d + 1) + f.value;
							k = l.substring(d + 1)
						}
					} else {
						k = l = f.value
					}
				}
				var c = Event.fire(this.fld, "xwiki:suggest:selected", Object.clone(f));
				if (!c.stopped) {
					this.sInput = k;
					this.fld.value = l;
					this.fld.focus();
					this.clearSuggestions();
					typeof this.options.callback == "function" && this.options.callback(Object.clone(f));
					if (this.fld.id.indexOf("_suggest") > 0) {
						var e = this.fld.id.substring(0, this.fld.id.indexOf("_suggest"));
						var h = $(e);
						if (h) {
							h.value = f.info
						}
					}
				}
			}
		}, killTimeout: function () {
			clearTimeout(this.toID)
		}, resetTimeout: function () {
			clearTimeout(this.toID);
			var c = this;
			this.toID = setTimeout(function () {
				c.clearSuggestions()
			}, 1000)
		}, clearSuggestions: function () {
			this.clearHighlight();
			this.killTimeout();
			this.isActive = false;
			var c = $(this.container);
			var e = this;
			if (c && c.parentNode) {
				if (this.options.fadeOnClear) {
					var d = new Effect.Fade(c, {duration: "0.25", afterFinish: function () {
						if ($(e.container)) {
							$(e.container).remove()
						}
					}})
				} else {
					$(this.container).remove()
				}
				document.fire("xwiki:suggest:clearSuggestions", {suggest: this})
			}
		}, detach: function () {
			if (this.fld) {
				Event.stopObserving(this.fld, "keyup", this.onKeyUp);
				if (Prototype.Browser.IE || Prototype.Browser.WebKit) {
					Event.stopObserving(this.fld, "keydown", this.onKeyPress)
				} else {
					Event.stopObserving(this.fld, "keypress", this.onKeyPress)
				}
				this.clearSuggestions();
				this.fld.__x_suggest = null;
				this.fld.setAttribute("autocomplete", "on")
			}
		}})
	}
	return b
})(XWiki || {});

var config = {
    "codingDefinitionServiceEndpoint": CONSTANTS.LOOKUP_SERVICE_URL + "",
    // "helpdesk": {
    //     "name": "Help Desk",
    //     "contact": {
    //         "phone": "0000000000",
    //         "email": "help.desk@help.com"
    //     }
    // },
    "diagramEndpoint": {
        "service": "local",
        "pathToEditorJSFiles": "/"

        //"service": "mercury",
        //"mercuryPedigreeServiceEndpoint": mercuryRemoteHost + "/gel/rare_diseases/pedigrees"
        //"pathToEditorJSFiles": "/"

        //"service": "openclinica",
        //"pathToEditorJSFiles":"/includes/pedigreeEditor/"
        //get path to pedigree directory like :
        //"http://localhost:8083/openclinica/includes/pedigreeEditor/" or
        //"https://gmc.genomicsengland.nhs.uk/rarediseases/demo/includes/pedigreeEditor/"
    },
    "saveAndExit": true
};

var version = 'v1.7.6';
String.prototype.parseColor = function () {
	var a = "#";
	if (this.slice(0, 4) == "rgb(") {
		var c = this.slice(4, this.length - 1).split(",");
		var b = 0;
		do {
			a += parseInt(c[b]).toColorPart()
		} while (++b < 3)
	} else {
		if (this.slice(0, 1) == "#") {
			if (this.length == 4) {
				for (var b = 1; b < 4; b++) {
					a += (this.charAt(b) + this.charAt(b)).toLowerCase()
				}
			}
			if (this.length == 7) {
				a = this.toLowerCase()
			}
		}
	}
	return(a.length == 7 ? a : (arguments[0] || this))
};
Element.collectTextNodes = function (a) {
	return $A($(a).childNodes).collect(function (b) {
		return(b.nodeType == 3 ? b.nodeValue : (b.hasChildNodes() ? Element.collectTextNodes(b) : ""))
	}).flatten().join("")
};
Element.collectTextNodesIgnoreClass = function (a, b) {
	return $A($(a).childNodes).collect(function (c) {
		return(c.nodeType == 3 ? c.nodeValue : ((c.hasChildNodes() && !Element.hasClassName(c, b)) ? Element.collectTextNodesIgnoreClass(c, b) : ""))
	}).flatten().join("")
};
Element.setContentZoom = function (a, b) {
	a = $(a);
	a.setStyle({fontSize: (b / 100) + "em"});
	if (Prototype.Browser.WebKit) {
		window.scrollBy(0, 0)
	}
	return a
};
Element.getInlineOpacity = function (a) {
	return $(a).style.opacity || ""
};
Element.forceRerendering = function (a) {
	try {
		a = $(a);
		var c = document.createTextNode(" ");
		a.appendChild(c);
		a.removeChild(c)
	} catch (b) {
	}
};
var Effect = {_elementDoesNotExistError: {name: "ElementDoesNotExistError", message: "The specified DOM element does not exist, but is required for this effect to operate"}, Transitions: {linear: Prototype.K, sinoidal: function (a) {
	return(-Math.cos(a * Math.PI) / 2) + 0.5
}, reverse: function (a) {
	return 1 - a
}, flicker: function (a) {
	var a = ((-Math.cos(a * Math.PI) / 4) + 0.75) + Math.random() / 4;
	return a > 1 ? 1 : a
}, wobble: function (a) {
	return(-Math.cos(a * Math.PI * (9 * a)) / 2) + 0.5
}, pulse: function (b, a) {
	return(-Math.cos((b * ((a || 5) - 0.5) * 2) * Math.PI) / 2) + 0.5
}, spring: function (a) {
	return 1 - (Math.cos(a * 4.5 * Math.PI) * Math.exp(-a * 6))
}, none: function (a) {
	return 0
}, full: function (a) {
	return 1
}}, DefaultOptions: {duration: 1, fps: 100, sync: false, from: 0, to: 1, delay: 0, queue: "parallel"}, tagifyText: function (a) {
	var b = "position:relative";
	if (Prototype.Browser.IE) {
		b += ";zoom:1"
	}
	a = $(a);
	$A(a.childNodes).each(function (c) {
		if (c.nodeType == 3) {
			c.nodeValue.toArray().each(function (d) {
				a.insertBefore(new Element("span", {style: b}).update(d == " " ? String.fromCharCode(160) : d), c)
			});
			Element.remove(c)
		}
	})
}, multiple: function (b, c) {
	var e;
	if (((typeof b == "object") || Object.isFunction(b)) && (b.length)) {
		e = b
	} else {
		e = $(b).childNodes
	}
	var a = Object.extend({speed: 0.1, delay: 0}, arguments[2] || {});
	var d = a.delay;
	$A(e).each(function (g, f) {
		new c(g, Object.extend(a, {delay: f * a.speed + d}))
	})
}, PAIRS: {slide: ["SlideDown", "SlideUp"], blind: ["BlindDown", "BlindUp"], appear: ["Appear", "Fade"]}, toggle: function (b, c, a) {
	b = $(b);
	c = (c || "appear").toLowerCase();
	return Effect[Effect.PAIRS[c][b.visible() ? 1 : 0]](b, Object.extend({queue: {position: "end", scope: (b.id || "global"), limit: 1}}, a || {}))
}};
Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;
Effect.ScopedQueue = Class.create(Enumerable, {initialize: function () {
	this.effects = [];
	this.interval = null
}, _each: function (a) {
	this.effects._each(a)
}, add: function (b) {
	var c = new Date().getTime();
	var a = Object.isString(b.options.queue) ? b.options.queue : b.options.queue.position;
	switch (a) {
		case"front":
			this.effects.findAll(function (d) {
				return d.state == "idle"
			}).each(function (d) {
				d.startOn += b.finishOn;
				d.finishOn += b.finishOn
			});
			break;
		case"with-last":
			c = this.effects.pluck("startOn").max() || c;
			break;
		case"end":
			c = this.effects.pluck("finishOn").max() || c;
			break
	}
	b.startOn += c;
	b.finishOn += c;
	if (!b.options.queue.limit || (this.effects.length < b.options.queue.limit)) {
		this.effects.push(b)
	}
	if (!this.interval) {
		this.interval = setInterval(this.loop.bind(this), 15)
	}
}, remove: function (a) {
	this.effects = this.effects.reject(function (b) {
		return b == a
	});
	if (this.effects.length == 0) {
		clearInterval(this.interval);
		this.interval = null
	}
}, loop: function () {
	var c = new Date().getTime();
	for (var b = 0, a = this.effects.length; b < a; b++) {
		this.effects[b] && this.effects[b].loop(c)
	}
}});
Effect.Queues = {instances: $H(), get: function (a) {
	if (!Object.isString(a)) {
		return a
	}
	return this.instances.get(a) || this.instances.set(a, new Effect.ScopedQueue())
}};
Effect.Queue = Effect.Queues.get("global");
Effect.Base = Class.create({position: null, start: function (a) {
	if (a && a.transition === false) {
		a.transition = Effect.Transitions.linear
	}
	this.options = Object.extend(Object.extend({}, Effect.DefaultOptions), a || {});
	this.currentFrame = 0;
	this.state = "idle";
	this.startOn = this.options.delay * 1000;
	this.finishOn = this.startOn + (this.options.duration * 1000);
	this.fromToDelta = this.options.to - this.options.from;
	this.totalTime = this.finishOn - this.startOn;
	this.totalFrames = this.options.fps * this.options.duration;
	this.render = (function () {
		function b(d, c) {
			if (d.options[c + "Internal"]) {
				d.options[c + "Internal"](d)
			}
			if (d.options[c]) {
				d.options[c](d)
			}
		}

		return function (c) {
			if (this.state === "idle") {
				this.state = "running";
				b(this, "beforeSetup");
				if (this.setup) {
					this.setup()
				}
				b(this, "afterSetup")
			}
			if (this.state === "running") {
				c = (this.options.transition(c) * this.fromToDelta) + this.options.from;
				this.position = c;
				b(this, "beforeUpdate");
				if (this.update) {
					this.update(c)
				}
				b(this, "afterUpdate")
			}
		}
	})();
	this.event("beforeStart");
	if (!this.options.sync) {
		Effect.Queues.get(Object.isString(this.options.queue) ? "global" : this.options.queue.scope).add(this)
	}
}, loop: function (c) {
	if (c >= this.startOn) {
		if (c >= this.finishOn) {
			this.render(1);
			this.cancel();
			this.event("beforeFinish");
			if (this.finish) {
				this.finish()
			}
			this.event("afterFinish");
			return
		}
		var b = (c - this.startOn) / this.totalTime, a = (b * this.totalFrames).round();
		if (a > this.currentFrame) {
			this.render(b);
			this.currentFrame = a
		}
	}
}, cancel: function () {
	if (!this.options.sync) {
		Effect.Queues.get(Object.isString(this.options.queue) ? "global" : this.options.queue.scope).remove(this)
	}
	this.state = "finished"
}, event: function (a) {
	if (this.options[a + "Internal"]) {
		this.options[a + "Internal"](this)
	}
	if (this.options[a]) {
		this.options[a](this)
	}
}, inspect: function () {
	var a = $H();
	for (property in this) {
		if (!Object.isFunction(this[property])) {
			a.set(property, this[property])
		}
	}
	return"#<Effect:" + a.inspect() + ",options:" + $H(this.options).inspect() + ">"
}});
Effect.Parallel = Class.create(Effect.Base, {initialize: function (a) {
	this.effects = a || [];
	this.start(arguments[1])
}, update: function (a) {
	this.effects.invoke("render", a)
}, finish: function (a) {
	this.effects.each(function (b) {
		b.render(1);
		b.cancel();
		b.event("beforeFinish");
		if (b.finish) {
			b.finish(a)
		}
		b.event("afterFinish")
	})
}});
Effect.Tween = Class.create(Effect.Base, {initialize: function (c, f, e) {
	c = Object.isString(c) ? $(c) : c;
	var b = $A(arguments), d = b.last(), a = b.length == 5 ? b[3] : null;
	this.method = Object.isFunction(d) ? d.bind(c) : Object.isFunction(c[d]) ? c[d].bind(c) : function (g) {
		c[d] = g
	};
	this.start(Object.extend({from: f, to: e}, a || {}))
}, update: function (a) {
	this.method(a)
}});
Effect.Event = Class.create(Effect.Base, {initialize: function () {
	this.start(Object.extend({duration: 0}, arguments[0] || {}))
}, update: Prototype.emptyFunction});
Effect.Opacity = Class.create(Effect.Base, {initialize: function (b) {
	this.element = $(b);
	if (!this.element) {
		throw (Effect._elementDoesNotExistError)
	}
	if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout)) {
		this.element.setStyle({zoom: 1})
	}
	var a = Object.extend({from: this.element.getOpacity() || 0, to: 1}, arguments[1] || {});
	a.from = parseFloat(a.from);
	a.to = parseFloat(a.to);
	this.start(a)
}, update: function (a) {
	this.element.setOpacity(a)
}});
Effect.Move = Class.create(Effect.Base, {initialize: function (b) {
	this.element = $(b);
	if (!this.element) {
		throw (Effect._elementDoesNotExistError)
	}
	var a = Object.extend({x: 0, y: 0, mode: "relative"}, arguments[1] || {});
	this.start(a)
}, setup: function () {
	this.element.makePositioned();
	this.originalLeft = parseFloat(this.element.getStyle("left") || "0");
	this.originalTop = parseFloat(this.element.getStyle("top") || "0");
	if (this.options.mode == "absolute") {
		this.options.x = this.options.x - this.originalLeft;
		this.options.y = this.options.y - this.originalTop
	}
}, update: function (a) {
	this.element.setStyle({left: (this.options.x * a + this.originalLeft).round() + "px", top: (this.options.y * a + this.originalTop).round() + "px"})
}});
Effect.MoveBy = function (b, a, c) {
	return new Effect.Move(b, Object.extend({x: c, y: a}, arguments[3] || {}))
};
Effect.Scale = Class.create(Effect.Base, {initialize: function (b, c) {
	this.element = $(b);
	if (!this.element) {
		throw (Effect._elementDoesNotExistError)
	}
	var a = Object.extend({scaleX: true, scaleY: true, scaleContent: true, scaleFromCenter: false, scaleMode: "box", scaleFrom: 100, scaleTo: c}, arguments[2] || {});
	this.start(a)
}, setup: function () {
	this.restoreAfterFinish = this.options.restoreAfterFinish || false;
	this.elementPositioning = this.element.getStyle("position");
	this.originalStyle = {};
	["top", "left", "width", "height", "fontSize"].each(function (b) {
		this.originalStyle[b] = this.element.style[b]
	}.bind(this));
	this.originalTop = this.element.offsetTop;
	this.originalLeft = this.element.offsetLeft;
	var a = this.element.getStyle("font-size") || "100%";
	["em", "px", "%", "pt"].each(function (b) {
		if (a.indexOf(b) > 0) {
			this.fontSize = parseFloat(a);
			this.fontSizeType = b
		}
	}.bind(this));
	this.factor = (this.options.scaleTo - this.options.scaleFrom) / 100;
	this.dims = null;
	if (this.options.scaleMode == "box") {
		this.dims = [this.element.offsetHeight, this.element.offsetWidth]
	}
	if (/^content/.test(this.options.scaleMode)) {
		this.dims = [this.element.scrollHeight, this.element.scrollWidth]
	}
	if (!this.dims) {
		this.dims = [this.options.scaleMode.originalHeight, this.options.scaleMode.originalWidth]
	}
}, update: function (a) {
	var b = (this.options.scaleFrom / 100) + (this.factor * a);
	if (this.options.scaleContent && this.fontSize) {
		this.element.setStyle({fontSize: this.fontSize * b + this.fontSizeType})
	}
	this.setDimensions(this.dims[0] * b, this.dims[1] * b)
}, finish: function (a) {
	if (this.restoreAfterFinish) {
		this.element.setStyle(this.originalStyle)
	}
}, setDimensions: function (a, e) {
	var f = {};
	if (this.options.scaleX) {
		f.width = e.round() + "px"
	}
	if (this.options.scaleY) {
		f.height = a.round() + "px"
	}
	if (this.options.scaleFromCenter) {
		var c = (a - this.dims[0]) / 2;
		var b = (e - this.dims[1]) / 2;
		if (this.elementPositioning == "absolute") {
			if (this.options.scaleY) {
				f.top = this.originalTop - c + "px"
			}
			if (this.options.scaleX) {
				f.left = this.originalLeft - b + "px"
			}
		} else {
			if (this.options.scaleY) {
				f.top = -c + "px"
			}
			if (this.options.scaleX) {
				f.left = -b + "px"
			}
		}
	}
	this.element.setStyle(f)
}});
Effect.Highlight = Class.create(Effect.Base, {initialize: function (b) {
	this.element = $(b);
	if (!this.element) {
		throw (Effect._elementDoesNotExistError)
	}
	var a = Object.extend({startcolor: "#ffff99"}, arguments[1] || {});
	this.start(a)
}, setup: function () {
	if (this.element.getStyle("display") == "none") {
		this.cancel();
		return
	}
	this.oldStyle = {};
	if (!this.options.keepBackgroundImage) {
		this.oldStyle.backgroundImage = this.element.getStyle("background-image");
		this.element.setStyle({backgroundImage: "none"})
	}
	if (!this.options.endcolor) {
		this.options.endcolor = this.element.getStyle("background-color").parseColor("#ffffff")
	}
	if (!this.options.restorecolor) {
		this.options.restorecolor = this.element.getStyle("background-color")
	}
	this._base = $R(0, 2).map(function (a) {
		return parseInt(this.options.startcolor.slice(a * 2 + 1, a * 2 + 3), 16)
	}.bind(this));
	this._delta = $R(0, 2).map(function (a) {
		return parseInt(this.options.endcolor.slice(a * 2 + 1, a * 2 + 3), 16) - this._base[a]
	}.bind(this))
}, update: function (a) {
	this.element.setStyle({backgroundColor: $R(0, 2).inject("#", function (b, c, d) {
		return b + ((this._base[d] + (this._delta[d] * a)).round().toColorPart())
	}.bind(this))})
}, finish: function () {
	this.element.setStyle(Object.extend(this.oldStyle, {backgroundColor: this.options.restorecolor}))
}});
Effect.ScrollTo = function (c) {
	var b = arguments[1] || {}, a = document.viewport.getScrollOffsets(), d = $(c).cumulativeOffset();
	if (b.offset) {
		d[1] += b.offset
	}
	return new Effect.Tween(null, a.top, d[1], b, function (e) {
		scrollTo(a.left, e.round())
	})
};
Effect.Fade = function (c) {
	c = $(c);
	var a = c.getInlineOpacity();
	var b = Object.extend({from: c.getOpacity() || 1, to: 0, afterFinishInternal: function (d) {
		if (d.options.to != 0) {
			return
		}
		d.element.hide().setStyle({opacity: a})
	}}, arguments[1] || {});
	return new Effect.Opacity(c, b)
};
Effect.Appear = function (b) {
	b = $(b);
	var a = Object.extend({from: (b.getStyle("display") == "none" ? 0 : b.getOpacity() || 0), to: 1, afterFinishInternal: function (c) {
		c.element.forceRerendering()
	}, beforeSetup: function (c) {
		c.element.setOpacity(c.options.from).show()
	}}, arguments[1] || {});
	return new Effect.Opacity(b, a)
};
Effect.Puff = function (b) {
	b = $(b);
	var a = {opacity: b.getInlineOpacity(), position: b.getStyle("position"), top: b.style.top, left: b.style.left, width: b.style.width, height: b.style.height};
	return new Effect.Parallel([new Effect.Scale(b, 200, {sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true}), new Effect.Opacity(b, {sync: true, to: 0})], Object.extend({duration: 1, beforeSetupInternal: function (c) {
		Position.absolutize(c.effects[0].element)
	}, afterFinishInternal: function (c) {
		c.effects[0].element.hide().setStyle(a)
	}}, arguments[1] || {}))
};
Effect.BlindUp = function (a) {
	a = $(a);
	a.makeClipping();
	return new Effect.Scale(a, 0, Object.extend({scaleContent: false, scaleX: false, restoreAfterFinish: true, afterFinishInternal: function (b) {
		b.element.hide().undoClipping()
	}}, arguments[1] || {}))
};
Effect.BlindDown = function (b) {
	b = $(b);
	var a = b.getDimensions();
	return new Effect.Scale(b, 100, Object.extend({scaleContent: false, scaleX: false, scaleFrom: 0, scaleMode: {originalHeight: a.height, originalWidth: a.width}, restoreAfterFinish: true, afterSetup: function (c) {
		c.element.makeClipping().setStyle({height: "0px"}).show()
	}, afterFinishInternal: function (c) {
		c.element.undoClipping()
	}}, arguments[1] || {}))
};
Effect.SwitchOff = function (b) {
	b = $(b);
	var a = b.getInlineOpacity();
	return new Effect.Appear(b, Object.extend({duration: 0.4, from: 0, transition: Effect.Transitions.flicker, afterFinishInternal: function (c) {
		new Effect.Scale(c.element, 1, {duration: 0.3, scaleFromCenter: true, scaleX: false, scaleContent: false, restoreAfterFinish: true, beforeSetup: function (d) {
			d.element.makePositioned().makeClipping()
		}, afterFinishInternal: function (d) {
			d.element.hide().undoClipping().undoPositioned().setStyle({opacity: a})
		}})
	}}, arguments[1] || {}))
};
Effect.DropOut = function (b) {
	b = $(b);
	var a = {top: b.getStyle("top"), left: b.getStyle("left"), opacity: b.getInlineOpacity()};
	return new Effect.Parallel([new Effect.Move(b, {x: 0, y: 100, sync: true}), new Effect.Opacity(b, {sync: true, to: 0})], Object.extend({duration: 0.5, beforeSetup: function (c) {
		c.effects[0].element.makePositioned()
	}, afterFinishInternal: function (c) {
		c.effects[0].element.hide().undoPositioned().setStyle(a)
	}}, arguments[1] || {}))
};
Effect.Shake = function (d) {
	d = $(d);
	var b = Object.extend({distance: 20, duration: 0.5}, arguments[1] || {});
	var e = parseFloat(b.distance);
	var c = parseFloat(b.duration) / 10;
	var a = {top: d.getStyle("top"), left: d.getStyle("left")};
	return new Effect.Move(d, {x: e, y: 0, duration: c, afterFinishInternal: function (f) {
		new Effect.Move(f.element, {x: -e * 2, y: 0, duration: c * 2, afterFinishInternal: function (g) {
			new Effect.Move(g.element, {x: e * 2, y: 0, duration: c * 2, afterFinishInternal: function (h) {
				new Effect.Move(h.element, {x: -e * 2, y: 0, duration: c * 2, afterFinishInternal: function (i) {
					new Effect.Move(i.element, {x: e * 2, y: 0, duration: c * 2, afterFinishInternal: function (j) {
						new Effect.Move(j.element, {x: -e, y: 0, duration: c, afterFinishInternal: function (k) {
							k.element.undoPositioned().setStyle(a)
						}})
					}})
				}})
			}})
		}})
	}})
};
Effect.SlideDown = function (c) {
	c = $(c).cleanWhitespace();
	var a = c.down().getStyle("bottom");
	var b = c.getDimensions();
	return new Effect.Scale(c, 100, Object.extend({scaleContent: false, scaleX: false, scaleFrom: window.opera ? 0 : 1, scaleMode: {originalHeight: b.height, originalWidth: b.width}, restoreAfterFinish: true, afterSetup: function (d) {
		d.element.makePositioned();
		d.element.down().makePositioned();
		if (window.opera) {
			d.element.setStyle({top: ""})
		}
		d.element.makeClipping().setStyle({height: "0px"}).show()
	}, afterUpdateInternal: function (d) {
		d.element.down().setStyle({bottom: (d.dims[0] - d.element.clientHeight) + "px"})
	}, afterFinishInternal: function (d) {
		d.element.undoClipping().undoPositioned();
		d.element.down().undoPositioned().setStyle({bottom: a})
	}}, arguments[1] || {}))
};
Effect.SlideUp = function (c) {
	c = $(c).cleanWhitespace();
	var a = c.down().getStyle("bottom");
	var b = c.getDimensions();
	return new Effect.Scale(c, window.opera ? 0 : 1, Object.extend({scaleContent: false, scaleX: false, scaleMode: "box", scaleFrom: 100, scaleMode: {originalHeight: b.height, originalWidth: b.width}, restoreAfterFinish: true, afterSetup: function (d) {
		d.element.makePositioned();
		d.element.down().makePositioned();
		if (window.opera) {
			d.element.setStyle({top: ""})
		}
		d.element.makeClipping().show()
	}, afterUpdateInternal: function (d) {
		d.element.down().setStyle({bottom: (d.dims[0] - d.element.clientHeight) + "px"})
	}, afterFinishInternal: function (d) {
		d.element.hide().undoClipping().undoPositioned();
		d.element.down().undoPositioned().setStyle({bottom: a})
	}}, arguments[1] || {}))
};
Effect.Squish = function (a) {
	return new Effect.Scale(a, window.opera ? 1 : 0, {restoreAfterFinish: true, beforeSetup: function (b) {
		b.element.makeClipping()
	}, afterFinishInternal: function (b) {
		b.element.hide().undoClipping()
	}})
};
Effect.Grow = function (c) {
	c = $(c);
	var b = Object.extend({direction: "center", moveTransition: Effect.Transitions.sinoidal, scaleTransition: Effect.Transitions.sinoidal, opacityTransition: Effect.Transitions.full}, arguments[1] || {});
	var a = {top: c.style.top, left: c.style.left, height: c.style.height, width: c.style.width, opacity: c.getInlineOpacity()};
	var g = c.getDimensions();
	var h, f;
	var e, d;
	switch (b.direction) {
		case"top-left":
			h = f = e = d = 0;
			break;
		case"top-right":
			h = g.width;
			f = d = 0;
			e = -g.width;
			break;
		case"bottom-left":
			h = e = 0;
			f = g.height;
			d = -g.height;
			break;
		case"bottom-right":
			h = g.width;
			f = g.height;
			e = -g.width;
			d = -g.height;
			break;
		case"center":
			h = g.width / 2;
			f = g.height / 2;
			e = -g.width / 2;
			d = -g.height / 2;
			break
	}
	return new Effect.Move(c, {x: h, y: f, duration: 0.01, beforeSetup: function (i) {
		i.element.hide().makeClipping().makePositioned()
	}, afterFinishInternal: function (i) {
		new Effect.Parallel([new Effect.Opacity(i.element, {sync: true, to: 1, from: 0, transition: b.opacityTransition}), new Effect.Move(i.element, {x: e, y: d, sync: true, transition: b.moveTransition}), new Effect.Scale(i.element, 100, {scaleMode: {originalHeight: g.height, originalWidth: g.width}, sync: true, scaleFrom: window.opera ? 1 : 0, transition: b.scaleTransition, restoreAfterFinish: true})], Object.extend({beforeSetup: function (j) {
			j.effects[0].element.setStyle({height: "0px"}).show()
		}, afterFinishInternal: function (j) {
			j.effects[0].element.undoClipping().undoPositioned().setStyle(a)
		}}, b))
	}})
};
Effect.Shrink = function (c) {
	c = $(c);
	var b = Object.extend({direction: "center", moveTransition: Effect.Transitions.sinoidal, scaleTransition: Effect.Transitions.sinoidal, opacityTransition: Effect.Transitions.none}, arguments[1] || {});
	var a = {top: c.style.top, left: c.style.left, height: c.style.height, width: c.style.width, opacity: c.getInlineOpacity()};
	var f = c.getDimensions();
	var e, d;
	switch (b.direction) {
		case"top-left":
			e = d = 0;
			break;
		case"top-right":
			e = f.width;
			d = 0;
			break;
		case"bottom-left":
			e = 0;
			d = f.height;
			break;
		case"bottom-right":
			e = f.width;
			d = f.height;
			break;
		case"center":
			e = f.width / 2;
			d = f.height / 2;
			break
	}
	return new Effect.Parallel([new Effect.Opacity(c, {sync: true, to: 0, from: 1, transition: b.opacityTransition}), new Effect.Scale(c, window.opera ? 1 : 0, {sync: true, transition: b.scaleTransition, restoreAfterFinish: true}), new Effect.Move(c, {x: e, y: d, sync: true, transition: b.moveTransition})], Object.extend({beforeStartInternal: function (g) {
		g.effects[0].element.makePositioned().makeClipping()
	}, afterFinishInternal: function (g) {
		g.effects[0].element.hide().undoClipping().undoPositioned().setStyle(a)
	}}, b))
};
Effect.Pulsate = function (c) {
	c = $(c);
	var b = arguments[1] || {}, a = c.getInlineOpacity(), e = b.transition || Effect.Transitions.linear, d = function (f) {
		return 1 - e((-Math.cos((f * (b.pulses || 5) * 2) * Math.PI) / 2) + 0.5)
	};
	return new Effect.Opacity(c, Object.extend(Object.extend({duration: 2, from: 0, afterFinishInternal: function (f) {
		f.element.setStyle({opacity: a})
	}}, b), {transition: d}))
};
Effect.Fold = function (b) {
	b = $(b);
	var a = {top: b.style.top, left: b.style.left, width: b.style.width, height: b.style.height};
	b.makeClipping();
	return new Effect.Scale(b, 5, Object.extend({scaleContent: false, scaleX: false, afterFinishInternal: function (c) {
		new Effect.Scale(b, 1, {scaleContent: false, scaleY: false, afterFinishInternal: function (d) {
			d.element.hide().undoClipping().setStyle(a)
		}})
	}}, arguments[1] || {}))
};
Effect.Morph = Class.create(Effect.Base, {initialize: function (c) {
	this.element = $(c);
	if (!this.element) {
		throw (Effect._elementDoesNotExistError)
	}
	var a = Object.extend({style: {}}, arguments[1] || {});
	if (!Object.isString(a.style)) {
		this.style = $H(a.style)
	} else {
		if (a.style.include(":")) {
			this.style = a.style.parseStyle()
		} else {
			this.element.addClassName(a.style);
			this.style = $H(this.element.getStyles());
			this.element.removeClassName(a.style);
			var b = this.element.getStyles();
			this.style = this.style.reject(function (d) {
				return d.value == b[d.key]
			});
			a.afterFinishInternal = function (d) {
				d.element.addClassName(d.options.style);
				d.transforms.each(function (e) {
					d.element.style[e.style] = ""
				})
			}
		}
	}
	this.start(a)
}, setup: function () {
	function a(b) {
		if (!b || ["rgba(0, 0, 0, 0)", "transparent"].include(b)) {
			b = "#ffffff"
		}
		b = b.parseColor();
		return $R(0, 2).map(function (c) {
			return parseInt(b.slice(c * 2 + 1, c * 2 + 3), 16)
		})
	}

	this.transforms = this.style.map(function (g) {
		var f = g[0], e = g[1], d = null;
		if (e.parseColor("#zzzzzz") != "#zzzzzz") {
			e = e.parseColor();
			d = "color"
		} else {
			if (f == "opacity") {
				e = parseFloat(e);
				if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout)) {
					this.element.setStyle({zoom: 1})
				}
			} else {
				if (Element.CSS_LENGTH.test(e)) {
					var c = e.match(/^([\+\-]?[0-9\.]+)(.*)$/);
					e = parseFloat(c[1]);
					d = (c.length == 3) ? c[2] : null
				}
			}
		}
		var b = this.element.getStyle(f);
		return{style: f.camelize(), originalValue: d == "color" ? a(b) : parseFloat(b || 0), targetValue: d == "color" ? a(e) : e, unit: d}
	}.bind(this)).reject(function (b) {
		return((b.originalValue == b.targetValue) || (b.unit != "color" && (isNaN(b.originalValue) || isNaN(b.targetValue))))
	})
}, update: function (a) {
	var d = {}, b, c = this.transforms.length;
	while (c--) {
		d[(b = this.transforms[c]).style] = b.unit == "color" ? "#" + (Math.round(b.originalValue[0] + (b.targetValue[0] - b.originalValue[0]) * a)).toColorPart() + (Math.round(b.originalValue[1] + (b.targetValue[1] - b.originalValue[1]) * a)).toColorPart() + (Math.round(b.originalValue[2] + (b.targetValue[2] - b.originalValue[2]) * a)).toColorPart() : (b.originalValue + (b.targetValue - b.originalValue) * a).toFixed(3) + (b.unit === null ? "" : b.unit)
	}
	this.element.setStyle(d, true)
}});
Effect.Transform = Class.create({initialize: function (a) {
	this.tracks = [];
	this.options = arguments[1] || {};
	this.addTracks(a)
}, addTracks: function (a) {
	a.each(function (b) {
		b = $H(b);
		var c = b.values().first();
		this.tracks.push($H({ids: b.keys().first(), effect: Effect.Morph, options: {style: c}}))
	}.bind(this));
	return this
}, play: function () {
	return new Effect.Parallel(this.tracks.map(function (a) {
		var d = a.get("ids"), c = a.get("effect"), b = a.get("options");
		var e = [$(d) || $$(d)].flatten();
		return e.map(function (f) {
			return new c(f, Object.extend({sync: true}, b))
		})
	}).flatten(), this.options)
}});
Element.CSS_PROPERTIES = $w("backgroundColor backgroundPosition borderBottomColor borderBottomStyle borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderSpacing borderTopColor borderTopStyle borderTopWidth bottom clip color fontSize fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop markerOffset maxHeight maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft paddingRight paddingTop right textIndent top width wordSpacing zIndex");
Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;
String.__parseStyleElement = document.createElement("div");
String.prototype.parseStyle = function () {
	var b, a = $H();
	if (Prototype.Browser.WebKit) {
		b = new Element("div", {style: this}).style
	} else {
		String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
		b = String.__parseStyleElement.childNodes[0].style
	}
	Element.CSS_PROPERTIES.each(function (c) {
		if (b[c]) {
			a.set(c, b[c])
		}
	});
	if (Prototype.Browser.IE && this.include("opacity")) {
		a.set("opacity", this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1])
	}
	return a
};
if (document.defaultView && document.defaultView.getComputedStyle) {
	Element.getStyles = function (b) {
		var a = document.defaultView.getComputedStyle($(b), null);
		return Element.CSS_PROPERTIES.inject({}, function (c, d) {
			c[d] = a[d];
			return c
		})
	}
} else {
	Element.getStyles = function (b) {
		b = $(b);
		var a = b.currentStyle, c;
		c = Element.CSS_PROPERTIES.inject({}, function (d, e) {
			d[e] = a[e];
			return d
		});
		if (!c.opacity) {
			c.opacity = b.getOpacity()
		}
		return c
	}
}
Effect.Methods = {morph: function (a, b) {
	a = $(a);
	new Effect.Morph(a, Object.extend({style: b}, arguments[2] || {}));
	return a
}, visualEffect: function (c, e, b) {
	c = $(c);
	var d = e.dasherize().camelize(), a = d.charAt(0).toUpperCase() + d.substring(1);
	new Effect[a](c, b);
	return c
}, highlight: function (b, a) {
	b = $(b);
	new Effect.Highlight(b, a);
	return b
}};
$w("fade appear grow shrink fold blindUp blindDown slideUp slideDown pulsate shake puff squish switchOff dropOut").each(function (a) {
	Effect.Methods[a] = function (c, b) {
		c = $(c);
		Effect[a.charAt(0).toUpperCase() + a.substring(1)](c, b);
		return c
	}
});
$w("getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles").each(function (a) {
	Effect.Methods[a] = Element[a]
});
Element.addMethods(Effect.Methods);
Date.CultureInfo = {name: "en-US", englishName: "English (United States)", nativeName: "English (United States)", dayNames: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], abbreviatedDayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], shortestDayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], firstLetterDayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], amDesignator: "AM", pmDesignator: "PM", firstDayOfWeek: 0, dateElementOrder: "mdy", formatPatterns: {shortDate: "M/d/yyyy", longDate: "dddd, MMMM dd, yyyy", shortTime: "h:mm tt", longTime: "h:mm:ss tt", fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt", sortableDateTime: "yyyy-MM-ddTHH:mm:ss", universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ", rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT", monthDay: "MMMM dd", yearMonth: "MMMM, yyyy"}, regexPatterns: {jan: /^(January)|(Jan)/i, feb: /^(February)|(Feb)/i, mar: /^(March)|(Mar)/i, apr: /^(April)|(Apr)/i, may: /^(May)|(May)/i, jun: /^(June)|(Jun)/i, jul: /^(July)|(Jul)/i, aug: /^(August)|(Aug)/i, sep: /^(September)|(Sep)/i, oct: /^(October)|(Oct)/i, nov: /^(November)|(Nov)/i, dec: /^(December)|(Dec)/i, sun: /^(Monday)|(Mon)|(Mon)|(Mon)/i, mon: /^(Tuesday)|(Tue)|(Tue)|(Tue)/i, tue: /^(Wednesday)|(Wed)|(Wed)|(Wed)/i, wed: /^(Thursday)|(Thu)|(Thu)|(Thu)/i, thu: /^(Friday)|(Fri)|(Fri)|(Fri)/i, fri: /^(Saturday)|(Sat)|(Sat)|(Sat)/i, sat: /^(Sunday)|(Sun)|(Sun)|(Sun)/i, future: /^next/i, past: /^last|past|prev(ious)?/i, add: /^(\+|aft(er)?|from|hence)/i, subtract: /^(\-|bef(ore)?|ago)/i, yesterday: /^yes(terday)?/i, today: /^t(od(ay)?)?/i, tomorrow: /^tom(orrow)?/i, now: /^n(ow)?/i, millisecond: /^ms|milli(second)?s?/i, second: /^sec(ond)?s?/i, minute: /^mn|min(ute)?s?/i, hour: /^h(our)?s?/i, week: /^w(eek)?s?/i, month: /^m(onth)?s?/i, day: /^d(ay)?s?/i, year: /^y(ear)?s?/i, shortMeridian: /^(a|p)/i, longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i, timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i, ordinalSuffix: /^\s*(st|nd|rd|th)/i, timeContext: /^\s*(\:|a(?!u|p)|p)/i}, timezones: [
	{name: "UTC", offset: "-000"},
	{name: "GMT", offset: "-000"},
	{name: "EST", offset: "-0500"},
	{name: "EDT", offset: "-0400"},
	{name: "CST", offset: "-0600"},
	{name: "CDT", offset: "-0500"},
	{name: "MST", offset: "-0700"},
	{name: "MDT", offset: "-0600"},
	{name: "PST", offset: "-0800"},
	{name: "PDT", offset: "-0700"}
]};
_translations = {OK: "OK", Now: "Now", Today: "Today", Clear: "Clear"};
Date.getMonthNumberFromName = function (b) {
	var e = Date.CultureInfo.monthNames, a = Date.CultureInfo.abbreviatedMonthNames, d = b.toLowerCase();
	for (var c = 0; c < e.length; c++) {
		if (e[c].toLowerCase() == d || a[c].toLowerCase() == d) {
			return c
		}
	}
	return -1
};
Date.getDayNumberFromName = function (b) {
	var f = Date.CultureInfo.dayNames, a = Date.CultureInfo.abbreviatedDayNames, e = Date.CultureInfo.shortestDayNames, d = b.toLowerCase();
	for (var c = 0; c < f.length; c++) {
		if (f[c].toLowerCase() == d || a[c].toLowerCase() == d) {
			return c
		}
	}
	return -1
};
Date.isLeapYear = function (a) {
	return(((a % 4 === 0) && (a % 100 !== 0)) || (a % 400 === 0))
};
Date.getDaysInMonth = function (a, b) {
	return[31, (Date.isLeapYear(a) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][b]
};
Date.getTimezoneOffset = function (a, b) {
	return(b || false) ? Date.CultureInfo.abbreviatedTimeZoneDST[a.toUpperCase()] : Date.CultureInfo.abbreviatedTimeZoneStandard[a.toUpperCase()]
};
Date.getTimezoneAbbreviation = function (b, d) {
	var c = (d || false) ? Date.CultureInfo.abbreviatedTimeZoneDST : Date.CultureInfo.abbreviatedTimeZoneStandard, a;
	for (a in c) {
		if (c[a] === b) {
			return a
		}
	}
	return null
};
Date.prototype.clone = function () {
	return new Date(this.getTime())
};
Date.prototype.compareTo = function (a) {
	if (isNaN(this)) {
		throw new Error(this)
	}
	if (a instanceof Date && !isNaN(a)) {
		return(this > a) ? 1 : (this < a) ? -1 : 0
	} else {
		throw new TypeError(a)
	}
};
Date.prototype.equals = function (a) {
	return(this.compareTo(a) === 0)
};
Date.prototype.between = function (c, a) {
	var b = this.getTime();
	return b >= c.getTime() && b <= a.getTime()
};
Date.prototype.addMilliseconds = function (a) {
	this.setMilliseconds(this.getMilliseconds() + a);
	return this
};
Date.prototype.addSeconds = function (a) {
	return this.addMilliseconds(a * 1000)
};
Date.prototype.addMinutes = function (a) {
	return this.addMilliseconds(a * 60000)
};
Date.prototype.addHours = function (a) {
	return this.addMilliseconds(a * 3600000)
};
Date.prototype.addDays = function (a) {
	return this.addMilliseconds(a * 86400000)
};
Date.prototype.addWeeks = function (a) {
	return this.addMilliseconds(a * 604800000)
};
Date.prototype.addMonths = function (a) {
	var b = this.getDate();
	this.setDate(1);
	this.setMonth(this.getMonth() + a);
	this.setDate(Math.min(b, this.getDaysInMonth()));
	return this
};
Date.prototype.addYears = function (a) {
	return this.addMonths(a * 12)
};
Date.prototype.add = function (b) {
	if (typeof b == "number") {
		this._orient = b;
		return this
	}
	var a = b;
	if (a.millisecond || a.milliseconds) {
		this.addMilliseconds(a.millisecond || a.milliseconds)
	}
	if (a.second || a.seconds) {
		this.addSeconds(a.second || a.seconds)
	}
	if (a.minute || a.minutes) {
		this.addMinutes(a.minute || a.minutes)
	}
	if (a.hour || a.hours) {
		this.addHours(a.hour || a.hours)
	}
	if (a.month || a.months) {
		this.addMonths(a.month || a.months)
	}
	if (a.year || a.years) {
		this.addYears(a.year || a.years)
	}
	if (a.day || a.days) {
		this.addDays(a.day || a.days)
	}
	return this
};
Date._validate = function (d, c, a, b) {
	if (typeof d != "number") {
		throw new TypeError(d + " is not a Number.")
	} else {
		if (d < c || d > a) {
			throw new RangeError(d + " is not a valid value for " + b + ".")
		}
	}
	return true
};
Date.validateMillisecond = function (a) {
	return Date._validate(a, 0, 999, "milliseconds")
};
Date.validateSecond = function (a) {
	return Date._validate(a, 0, 59, "seconds")
};
Date.validateMinute = function (a) {
	return Date._validate(a, 0, 59, "minutes")
};
Date.validateHour = function (a) {
	return Date._validate(a, 0, 23, "hours")
};
Date.validateDay = function (c, a, b) {
	return Date._validate(c, 1, Date.getDaysInMonth(a, b), "days")
};
Date.validateMonth = function (a) {
	return Date._validate(a, 0, 11, "months")
};
Date.validateYear = function (a) {
	return Date._validate(a, 1, 9999, "seconds")
};
Date.prototype.set = function (b) {
	var a = b;
	if (!a.millisecond && a.millisecond !== 0) {
		a.millisecond = -1
	}
	if (!a.second && a.second !== 0) {
		a.second = -1
	}
	if (!a.minute && a.minute !== 0) {
		a.minute = -1
	}
	if (!a.hour && a.hour !== 0) {
		a.hour = -1
	}
	if (!a.day && a.day !== 0) {
		a.day = -1
	}
	if (!a.month && a.month !== 0) {
		a.month = -1
	}
	if (!a.year && a.year !== 0) {
		a.year = -1
	}
	if (a.millisecond != -1 && Date.validateMillisecond(a.millisecond)) {
		this.addMilliseconds(a.millisecond - this.getMilliseconds())
	}
	if (a.second != -1 && Date.validateSecond(a.second)) {
		this.addSeconds(a.second - this.getSeconds())
	}
	if (a.minute != -1 && Date.validateMinute(a.minute)) {
		this.addMinutes(a.minute - this.getMinutes())
	}
	if (a.hour != -1 && Date.validateHour(a.hour)) {
		this.addHours(a.hour - this.getHours())
	}
	if (a.month !== -1 && Date.validateMonth(a.month)) {
		this.addMonths(a.month - this.getMonth())
	}
	if (a.year != -1 && Date.validateYear(a.year)) {
		this.addYears(a.year - this.getFullYear())
	}
	if (a.day != -1 && Date.validateDay(a.day, this.getFullYear(), this.getMonth())) {
		this.addDays(a.day - this.getDate())
	}
	if (a.timezone) {
		this.setTimezone(a.timezone)
	}
	if (a.timezoneOffset) {
		this.setTimezoneOffset(a.timezoneOffset)
	}
	return this
};
Date.prototype.clearTime = function () {
	this.setHours(0);
	this.setMinutes(0);
	this.setSeconds(0);
	this.setMilliseconds(0);
	return this
};
Date.prototype.isLeapYear = function () {
	var a = this.getFullYear();
	return(((a % 4 === 0) && (a % 100 !== 0)) || (a % 400 === 0))
};
Date.prototype.isWeekday = function () {
	return !(this.is().sat() || this.is().sun())
};
Date.prototype.getDaysInMonth = function () {
	return Date.getDaysInMonth(this.getFullYear(), this.getMonth())
};
Date.prototype.moveToFirstDayOfMonth = function () {
	return this.set({day: 1})
};
Date.prototype.moveToLastDayOfMonth = function () {
	return this.set({day: this.getDaysInMonth()})
};
Date.prototype.moveToDayOfWeek = function (a, b) {
	var c = (a - this.getDay() + 7 * (b || +1)) % 7;
	return this.addDays((c === 0) ? c += 7 * (b || +1) : c)
};
Date.prototype.moveToMonth = function (c, a) {
	var b = (c - this.getMonth() + 12 * (a || +1)) % 12;
	return this.addMonths((b === 0) ? b += 12 * (a || +1) : b)
};
Date.prototype.getDayOfYear = function () {
	return Math.floor((this - new Date(this.getFullYear(), 0, 1)) / 86400000)
};
Date.prototype.getWeekOfYear = function (a) {
	var i = this.getFullYear(), c = this.getMonth(), f = this.getDate();
	var k = a || Date.CultureInfo.firstDayOfWeek;
	var e = 7 + 1 - new Date(i, 0, 1).getDay();
	if (e == 8) {
		e = 1
	}
	var b = ((Date.UTC(i, c, f, 0, 0, 0) - Date.UTC(i, 0, 1, 0, 0, 0)) / 86400000) + 1;
	var j = Math.floor((b - e + 7) / 7);
	if (j === k) {
		i--;
		var g = 7 + 1 - new Date(i, 0, 1).getDay();
		if (g == 2 || g == 8) {
			j = 53
		} else {
			j = 52
		}
	}
	return j
};
Date.prototype.isDST = function () {
	console.log("isDST");
	return this.toString().match(/(E|C|M|P)(S|D)T/)[2] == "D"
};
Date.prototype.getTimezone = function () {
	return Date.getTimezoneAbbreviation(this.getUTCOffset, this.isDST())
};
Date.prototype.setTimezoneOffset = function (b) {
	var a = this.getTimezoneOffset(), c = Number(b) * -6 / 10;
	this.addMinutes(c - a);
	return this
};
Date.prototype.setTimezone = function (a) {
	return this.setTimezoneOffset(Date.getTimezoneOffset(a))
};
Date.prototype.getUTCOffset = function () {
	var b = this.getTimezoneOffset() * -10 / 6, a;
	if (b < 0) {
		a = (b - 10000).toString();
		return a[0] + a.substr(2)
	} else {
		a = (b + 10000).toString();
		return"+" + a.substr(1)
	}
};
Date.prototype.getDayName = function (a) {
	return a ? Date.CultureInfo.abbreviatedDayNames[this.getDay()] : Date.CultureInfo.dayNames[this.getDay()]
};
Date.prototype.getMonthName = function (a) {
	return a ? Date.CultureInfo.abbreviatedMonthNames[this.getMonth()] : Date.CultureInfo.monthNames[this.getMonth()]
};
// Issue with conflict with other date libraries
// Date.prototype._toString = Date.prototype.toString;
if(Date.prototype._toString==undefined) {Date.prototype._toString=Date.prototype.toString;}

Date.prototype.toString = function (c) {
	var a = this.toUTC();
	var b = function b(d) {
		return(d.toString().length == 1) ? "0" + d : d
	};
	return c ? c.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g, function (d) {
		switch (d) {
			case"hh":
				return b(a.getHours() < 13 ? a.getHours() : (a.getHours() - 12));
			case"h":
				return a.getHours() < 13 ? a.getHours() : (a.getHours() - 12);
			case"HH":
				return b(a.getHours());
			case"H":
				return a.getHours();
			case"mm":
				return b(a.getMinutes());
			case"m":
				return a.getMinutes();
			case"ss":
				return b(a.getSeconds());
			case"s":
				return a.getSeconds();
			case"yyyy":
				return a.getFullYear();
			case"yy":
				return a.getFullYear().toString().substring(2, 4);
			case"dddd":
				return a.getDayName();
			case"ddd":
				return a.getDayName(true);
			case"dd":
				return b(a.getDate());
			case"d":
				return a.getDate().toString();
			case"MMMM":
				return a.getMonthName();
			case"MMM":
				return a.getMonthName(true);
			case"MM":
				return b((a.getMonth() + 1));
			case"M":
				return a.getMonth() + 1;
			case"t":
				return a.getHours() < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) : Date.CultureInfo.pmDesignator.substring(0, 1);
			case"tt":
				return a.getHours() < 12 ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
			case"zzz":
			case"zz":
			case"z":
				return"Z"
		}
	}) : this._toString()
};
TimeSpan = function (f, a, d, e, c) {
	this.days = 0;
	this.hours = 0;
	this.minutes = 0;
	this.seconds = 0;
	this.milliseconds = 0;
	if (arguments.length == 5) {
		this.days = f;
		this.hours = a;
		this.minutes = d;
		this.seconds = e;
		this.milliseconds = c
	} else {
		if (arguments.length == 1 && typeof f == "number") {
			var b = (f < 0) ? -1 : +1;
			this.milliseconds = Math.abs(f);
			this.days = Math.floor(this.milliseconds / (24 * 60 * 60 * 1000)) * b;
			this.milliseconds = this.milliseconds % (24 * 60 * 60 * 1000);
			this.hours = Math.floor(this.milliseconds / (60 * 60 * 1000)) * b;
			this.milliseconds = this.milliseconds % (60 * 60 * 1000);
			this.minutes = Math.floor(this.milliseconds / (60 * 1000)) * b;
			this.milliseconds = this.milliseconds % (60 * 1000);
			this.seconds = Math.floor(this.milliseconds / 1000) * b;
			this.milliseconds = this.milliseconds % 1000;
			this.milliseconds = this.milliseconds * b;
			return this
		} else {
			return null
		}
	}
};
TimeSpan.prototype.compare = function (c) {
	var b = new Date(1970, 1, 1, this.hours(), this.minutes(), this.seconds()), a;
	if (c === null) {
		a = new Date(1970, 1, 1, 0, 0, 0)
	} else {
		a = new Date(1970, 1, 1, c.hours(), c.minutes(), c.seconds())
	}
	return(b > a) ? 1 : (b < a) ? -1 : 0
};
TimeSpan.prototype.add = function (a) {
	return(a === null) ? this : this.addSeconds(a.getTotalMilliseconds() / 1000)
};
TimeSpan.prototype.subtract = function (a) {
	return(a === null) ? this : this.addSeconds(-a.getTotalMilliseconds() / 1000)
};
TimeSpan.prototype.addDays = function (a) {
	return new TimeSpan(this.getTotalMilliseconds() + (a * 24 * 60 * 60 * 1000))
};
TimeSpan.prototype.addHours = function (a) {
	return new TimeSpan(this.getTotalMilliseconds() + (a * 60 * 60 * 1000))
};
TimeSpan.prototype.addMinutes = function (a) {
	return new TimeSpan(this.getTotalMilliseconds() + (a * 60 * 1000))
};
TimeSpan.prototype.addSeconds = function (a) {
	return new TimeSpan(this.getTotalMilliseconds() + (a * 1000))
};
TimeSpan.prototype.addMilliseconds = function (a) {
	return new TimeSpan(this.getTotalMilliseconds() + a)
};
TimeSpan.prototype.getTotalMilliseconds = function () {
	return(this.days() * (24 * 60 * 60 * 1000)) + (this.hours() * (60 * 60 * 1000)) + (this.minutes() * (60 * 1000)) + (this.seconds() * (1000))
};
TimeSpan.prototype.get12HourHour = function () {
	return((h = this.hours() % 12) ? h : 12)
};
TimeSpan.prototype.getDesignator = function () {
	return(this.hours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator
};
TimeSpan.prototype.toString = function (c) {
	function d() {
		if (this.days() !== null && this.days() > 0) {
			return this.days() + "." + this.hours() + ":" + b(this.minutes()) + ":" + b(this.seconds())
		} else {
			return this.hours() + ":" + b(this.minutes()) + ":" + b(this.seconds())
		}
	}

	function b(e) {
		return(e.toString().length < 2) ? "0" + e : e
	}

	var a = this;
	return c ? c.replace(/d|dd|HH|H|hh|h|mm|m|ss|s|tt|t/g, function (e) {
		switch (e) {
			case"d":
				return a.days();
			case"dd":
				return b(a.days());
			case"H":
				return a.hours();
			case"HH":
				return b(a.hours());
			case"h":
				return a.get12HourHour();
			case"hh":
				return b(a.get12HourHour());
			case"m":
				return a.minutes();
			case"mm":
				return b(a.minutes());
			case"s":
				return a.seconds();
			case"ss":
				return b(a.seconds());
			case"t":
				return((this.hours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator).substring(0, 1);
			case"tt":
				return(this.hours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator
		}
	}) : this._toString()
};
var TimePeriod = function (e, a, m, g, c, j, b) {
	this.years = 0;
	this.months = 0;
	this.days = 0;
	this.hours = 0;
	this.minutes = 0;
	this.seconds = 0;
	this.milliseconds = 0;
	if (arguments.length == 2 && arguments[0] instanceof Date && arguments[1] instanceof Date) {
		var n = e.clone();
		var l = a.clone();
		var k = n.clone();
		var d = (n > l) ? -1 : +1;
		this.years = l.getFullYear() - n.getFullYear();
		k.addYears(this.years);
		if (d == +1) {
			if (k > l) {
				if (this.years !== 0) {
					this.years--
				}
			}
		} else {
			if (k < l) {
				if (this.years !== 0) {
					this.years++
				}
			}
		}
		n.addYears(this.years);
		if (d == +1) {
			while (n < l && n.clone().addDays(n.getDaysInMonth()) < l) {
				n.addMonths(1);
				this.months++
			}
		} else {
			while (n > l && n.clone().addDays(-n.getDaysInMonth()) > l) {
				n.addMonths(-1);
				this.months--
			}
		}
		var i = l - n;
		if (i !== 0) {
			var f = new TimeSpan(i);
			this.days = f.days;
			this.hours = f.hours;
			this.minutes = f.minutes;
			this.seconds = f.seconds;
			this.milliseconds = f.milliseconds
		}
		return this
	}
};
Date.now = function () {
	return new Date()
};
Date.today = function () {
	return Date.now().clearTime()
};
Date.prototype._orient = +1;
Date.prototype.next = function () {
	this._orient = +1;
	return this
};
Date.prototype.last = Date.prototype.prev = Date.prototype.previous = function () {
	this._orient = -1;
	return this
};
Date.prototype._is = false;
Date.prototype.is = function () {
	this._is = true;
	return this
};
Number.prototype._dateElement = "day";
Number.prototype.fromNow = function () {
	var a = {};
	a[this._dateElement] = this;
	return Date.now().add(a)
};
Number.prototype.ago = function () {
	var a = {};
	a[this._dateElement] = this * -1;
	return Date.now().add(a)
};
(function () {
	var g = Date.prototype, a = Number.prototype;
	var q = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/), p = ("january february march april may june july august september october november december").split(/\s/), o = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/), n;
	var m = function (i) {
		return function () {
			if (this._is) {
				this._is = false;
				return this.getDay() == i
			}
			return this.moveToDayOfWeek(i, this._orient)
		}
	};
	for (var f = 0; f < q.length; f++) {
		g[q[f]] = g[q[f].substring(0, 3)] = m(f)
	}
	var l = function (i) {
		return function () {
			if (this._is) {
				this._is = false;
				return this.getMonth() === i
			}
			return this.moveToMonth(i, this._orient)
		}
	};
	for (var d = 0; d < p.length; d++) {
		g[p[d]] = g[p[d].substring(0, 3)] = l(d)
	}
	var e = function (i) {
		return function () {
			if (i.substring(i.length - 1) != "s") {
				i += "s"
			}
			return this["add" + i](this._orient)
		}
	};
	var b = function (i) {
		return function () {
			this._dateElement = i;
			return this
		}
	};
	for (var c = 0; c < o.length; c++) {
		n = o[c].toLowerCase();
		g[n] = g[n + "s"] = e(o[c]);
		a[n] = a[n + "s"] = b(n)
	}
}());
Date.prototype.toJSONString = function () {
	return this.toString("yyyy-MM-ddThh:mm:ssZ")
};
Date.prototype.toShortDateString = function () {
	return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern)
};
Date.prototype.toLongDateString = function () {
	return this.toString(Date.CultureInfo.formatPatterns.longDatePattern)
};
Date.prototype.toShortTimeString = function () {
	return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern)
};
Date.prototype.toLongTimeString = function () {
	return this.toString(Date.CultureInfo.formatPatterns.longTimePattern)
};
Date.prototype.getOrdinal = function () {
	switch (this.getDate()) {
		case 1:
		case 21:
		case 31:
			return"st";
		case 2:
		case 22:
			return"nd";
		case 3:
		case 23:
			return"rd";
		default:
			return"th"
	}
};
Date.ISO8601Format = "yyyy-MM-ddTHH:mm:ssZ";
Date.prototype.toISO8601 = function () {
	var a = this.toString(Date.ISO8601Format);
	if (a.indexOf("NaN") > -1) {
		a = ""
	}
	return a
};
Date.prototype.toUTC = function () {
	return new Date(this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), 0, 0)
};
Date.prototype.setAsUTC = function () {
	var b = this.getDate();
	var e = this.getMonth();
	var d = this.getFullYear();
	var a = this.getHours();
	var c = this.getMinutes();
	this.setUTCDate(b);
	this.setUTCMonth(e);
	this.setUTCFullYear(d);
	this.setUTCHours(a);
	this.setUTCMinutes(c)
};
Date.prototype.toFormattedString = function (e) {
	var c, f;
	var b = e.format_mask;
	var d = e.convert_to_UTC ? this.toUTC() : this;
	var a = new SimpleDateFormat(b);
	f = a.format(d);
	return f
};
Date.parseISO_8601 = function (a) {
	var b = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(([+-](\d{2})([:]?(\d{2}))?)|Z)$/.exec(a);
	if (b) {
		if (b[8] == "Z") {
			return new Date(Date.UTC(parseInt(b[1], 10), parseInt(b[2], 10) - 1, parseInt(b[3], 10), parseInt(b[4], 10), parseInt(b[5], 10), parseInt(b[6], 10)))
		} else {
			return new Date(parseInt(b[1], 10), parseInt(b[2], 10) - 1, parseInt(b[3], 10), parseInt(b[4], 10), parseInt(b[5], 10), parseInt(b[6], 10))
		}
	}
};
if (typeof Prototype == "undefined") {
	alert("CalendarDateSelect Error: Prototype could not be found. Please make sure that your application's layout includes prototype.js *before* it includes calendar_date_select.js")
}
if (Prototype.Version < "1.6") {
	alert("Prototype > 1.6.0 is required.")
}
DateUtils = Class.create({weekdays: [], months: $A(Date.CultureInfo.monthNames), firstDayOfWeek: Date.CultureInfo.firstDayOfWeek, msecondsInOneDay: 24 * 60 * 60 * 1000, initialize: function () {
	var c = $A(Date.CultureInfo.firstLetterDayNames);
	this.weekdays = [];
	var b = (this.firstDayOfWeek + 6) % 7;
	for (var a = b; a >= 0 && a < c.length; ++a) {
		this.weekdays.push(c[a])
	}
	for (var a = 0; a < c.length && a < b; ++a) {
		this.weekdays.push(c[a])
	}
}, daysDistance: function (b, a) {
	return Math.round((a - b) / this.msecondsInOneDay)
}, getAMPMHour: function (b) {
	var a = b.getHours();
	return(a == 0) ? 12 : (a > 12 ? a - 12 : a)
}, getAMPM: function () {
	return(this.getHours() < 12) ? "AM" : "PM"
}});
SelectBox = Class.create({initialize: function (d, c, b, a) {
	this.element = new Element("select", {"class": b || ""});
	this.populate(c);
	Element.insert(d, this.element);
	this.element.observe("change", a)
}, populate: function (b) {
	var a = this.element;
	a.update("");
	$A(b).each(function (c) {
		if (typeof(c) != "object") {
			c = [c, c]
		}
		a.insert(new Element("option", {value: c[1]}).update(c[0]))
	})
}, setValue: function (b) {
	var c = this.element;
	var a = false;
	$R(0, c.options.length - 1).each(function (d) {
		if (c.options[d].value == b.toString()) {
			c.selectedIndex = d;
			a = true
		}
	});
	return a
}, getValue: function () {
	return $F(this.element)
}});
CalendarDateSelect = Class.create({options: {hour_format_12: false, default_format_mask: "dd/MM/yyyy", format_mask: null, convert_to_UTC: false, embedded: false, popup: null, time: false, buttons: true, clear_button: true, year_range: 10, close_on_click: null, minute_interval: 5, month_year: "dropdowns", valid_date_check: null}, initialize: function (c, b) {
	this.target_element = $(c);
	if (!this.target_element) {
		alert("Target element " + c + " not found!");
		return false
	}
	if (this.target_element.tagName != "INPUT") {
		this.target_element = this.target_element.down("INPUT")
	}
	this.target_element.calendar_date_select = this;
	this.last_click_at = 0;
	this.options = Object.extend(Object.clone(this.options), b || {});
	this.options.popup_by = this.target_element, this.options.onchange = this.options.onchange || this.target_element.onchange;
	var a = this.target_element.title || this.options.format_mask || this.options.default_format_mask;
	if (this.options.time && !a.toLowerCase().include("h") && !a.include("m") && !a.include("a")) {
		if (this.options.hour_format_12) {
			this.options.format_mask = a + " hh:mm tt"
		} else {
			this.options.format_mask = a + " HH:mm"
		}
	} else {
		this.options.format_mask = a
	}
	this.dateUtils = new DateUtils();
	this.use_time = this.options.time;
	this.parseDate();
	this.callback("before_show");
	this.initCalendarDiv();
	if (!this.options.embedded) {
		this.positionCalendarDiv();
		Event.observe(document, "mousedown", this.closeIfClickedOut_handler = this.closeIfClickedOut.bindAsEventListener(this));
		Event.observe(document, "keypress", this.keyPress_handler = this.keyPress.bindAsEventListener(this))
	}
	this.callback("after_show")
}, newElement: function (d, b) {
	b = b || {};
	var c = new Element(d, b.attrs || {}).update(b.content || "");
	if (b.style) {
		c.setStyle(b.style)
	}
	if (b.parent) {
		Element.insert(b.parent, c)
	}
	if (b.events) {
		for (var a in b.events) {
			Event.observe(c, a, b.events[a])
		}
	}
	if (b.customData) {
		for (var e in b.customData) {
			c[e] = b.customData[e]
		}
	}
	return c
}, positionCalendarDiv: function () {
	var n = false;
	var j = this.calendar_div.cumulativeOffset(), l = j[0], i = j[1], c = this.calendar_div.getDimensions(), o = c.height, b = c.width;
	var m = document.viewport.getScrollOffsets().top, d = document.viewport.getHeight();
	var p = $(this.options.popup_by).cumulativeOffset(), f = p[1], q = p[0], g = $(this.options.popup_by).getDimensions().height, k = f + g;
	if (((k + o) > (m + d)) && (k - o > m)) {
		n = true
	}
	var a = q.toString() + "px", e = (n ? (f - o) : (f + g)).toString() + "px";
	this.calendar_div.style.left = a;
	this.calendar_div.style.top = e;
	this.calendar_div.setStyle({visibility: ""});
	if (navigator.appName == "Microsoft Internet Explorer") {
		this.iframe = this.newElement("iframe", {parent: $(document.body), attrs: {src: "javascript:false", "class": "ie6_blocker"}, style: {left: a, top: e, height: o.toString() + "px", width: b.toString() + "px", border: "0px"}})
	}
}, initCalendarDiv: function () {
	if (this.options.embedded) {
		var parent = this.target_element.parentNode;
		var style = {}
	} else {
		var parent = document.body;
		var style = {position: "absolute", visibility: "hidden", left: 0, top: 0}
	}
	this.calendar_div = this.newElement("div", {parent: $(parent), attrs: {"class": "calendar_date_select"}, style: style});
	var context = this;
	$w("top header body buttons footer bottom").each(function (name) {
		eval("context." + name + "_div = context.newElement('div', {parent : context.calendar_div, attrs : { 'class': 'cds_part cds_" + name + "' } }); ")
	});
	this.initHeaderDiv();
	this.initButtonsDiv();
	this.initCalendarGrid();
	this.updateFooter("&#160;");
	this.refresh();
	this.setUseTime(this.use_time)
}, initHeaderDiv: function () {
	this.close_button = this.newElement("a", {attrs: {href: "#", "class": "close"}, content: "x", parent: this.header_div, events: {click: function (b) {
		b.stop();
		this.close()
	}.bindAsEventListener(this)}});
	this.next_month_button = this.newElement("a", {attrs: {href: "#", "class": "next"}, content: "&raquo;", parent: this.header_div, events: {click: function (b) {
		b.stop();
		this.navMonth(b, this.date.getMonth() + 1)
	}.bindAsEventListener(this)}});
	this.prev_month_button = this.newElement("a", {attrs: {href: "#", "class": "prev"}, content: "&laquo;", parent: this.header_div, events: {click: function (b) {
		b.stop();
		this.navMonth(b, this.date.getMonth() - 1)
	}.bindAsEventListener(this)}});
	var a = this.dateUtils;
	if (this.options.month_year == "dropdowns") {
		this.month_select = new SelectBox(this.header_div, $R(0, 11).map(function (b) {
			return[a.months[b], b]
		}), "month", this.navMonth.bindAsEventListener(this));
		this.year_select = new SelectBox(this.header_div, [], "year", this.navYear.bindAsEventListener(this));
		this.populateYearRange()
	} else {
		this.month_year_label = this.newElement("span", {parent: this.header_div})
	}
}, initCalendarGrid: function () {
	var a = this.body_div;
	this.calendar_day_grid = [];
	var i = this.newElement("table", {parent: a});
	var b = this.newElement("tr", {parent: this.newElement("thead", {parent: i})});

	function d(k) {
		var j = k.charCodeAt(0);
		if (64 <= j && j <= 7929) {
			return true
		}
		return false
	}

	this.dateUtils.weekdays.each(function (j) {
		Element.insert(b, new Element("th").update(d(j) ? j.substring(0, 2) : j))
	});
	var f = this.newElement("tbody", {parent: i});
	var c = 0, e;
	for (var g = 0; g < 42; g++) {
		e = (g) % 7;
		if (g % 7 == 0) {
			days_row = this.newElement("tr", {parent: f, attrs: {"class": "row_" + c++}})
		}
		this.calendar_day_grid[g] = this.newElement("td", {content: new Element("div"), parent: days_row, attrs: {"class": ((e == (7 - this.dateUtils.firstDayOfWeek) % 7) || (e == (13 - this.dateUtils.firstDayOfWeek) % 7)) ? "weekend" : ""}, events: {mouseover: function () {
			this.calendar_date_select.dayHover(this)
		}, mouseout: function () {
			this.calendar_date_select.dayHoverOut(this)
		}, click: function () {
			this.calendar_date_select.updateSelectedDate(this, true)
		}}, customData: {calendar_date_select: this}})
	}
}, initButtonsDiv: function () {
	var i = function (k) {
		var j = parseInt(k, 10);
		if (k < 10) {
			j = "0" + j
		}
		return j
	};
	var g = this.buttons_div;
	var e = this.newElement("div", {parent: g, attrs: {"class": "timediv"}});
	if (this.options.time) {
		var d = $A(this.options.time == "mixed" ? [
			[" - ", ""]
		] : []);
		e.update(new Element("span", {"class": "at_sign"}).update("@"));
		if (this.options.hour_format_12) {
			var c = new Date();
			d = d.concat($R(0, 23).map(function (j) {
				c.setHours(j);
				return $A([this.dateUtils.getAMPMHour(c) + " " + this.dateUtils.getAMPM(c), j])
			}))
		} else {
			d = d.concat($R(0, 23).map(function (j) {
				return $A([i(j), j])
			}))
		}
		this.hour_select = new SelectBox(e, d, "hour", this.calendar_date_select.updateSelectedDate.bind(this, {hour: this.value}));
		this.hour_select.calendar_date_select = this;
		e.insert(new Element("span", {"class": "separator"}).update(":"));
		var b = this;
		d = $A([]);
		this.minute_select = new SelectBox(e, d.concat($R(0, 59).select(function (j) {
			return(j % b.options.minute_interval == 0)
		}).map(function (j) {
			return $A([i(j), j])
		})), "minute", this.calendar_date_select.updateSelectedDate.bind(this, {minute: this.value}));
		this.minute_select.calendar_date_select = this
	} else {
		if (!this.options.buttons) {
			g.remove()
		}
	}
	if (this.options.buttons) {
		var a = function (k, l, j) {
			this.newElement("a", {parent: k, content: _translations[l], attrs: {href: "#"}, events: {click: j}})
		}.bind(this);
		var f = function (j) {
			this.newElement("span", {parent: j, content: "&#160;|&#160;", attrs: {"class": "button_separator"}})
		}.bind(this);
		this.newElement("span", {parent: g, content: "&#160;"});
		if (this.options.time == "mixed" || !this.options.time) {
			a(g, "Today", function (j) {
				this.today(false);
				j.stop();
				return false
			}.bindAsEventListener(this))
		}
		if (this.options.time == "mixed") {
			f(g)
		}
		if (this.options.time) {
			a(g, "Now", function (j) {
				this.today(true);
				j.stop();
				return false
			}.bindAsEventListener(this))
		}
		if (!this.options.embedded && !this.closeOnClick()) {
			f(g);
			a(g, "OK", function (j) {
				this.close();
				j.stop();
				return false
			}.bindAsEventListener(this))
		}
		if (this.options.clear_button) {
			f(g);
			a(g, "Clear", function (j) {
				this.clearDate();
				if (!this.options.embedded) {
					this.close()
				}
				j.stop();
				return false
			}.bindAsEventListener(this))
		}
	}
}, refresh: function () {
	this.refreshMonthYear();
	this.refreshCalendarGrid();
	this.setSelectedClass();
	this.updateFooter()
}, refreshCalendarGrid: function () {
	this.beginning_date = new Date(this.date).clearTime();
	this.beginning_date.setDate(1);
	this.beginning_date.setHours(12);
	var b = this.beginning_date.getDay();
	if (b < 3) {
		b += 7
	}
	this.beginning_date.setDate(1 - b + this.dateUtils.firstDayOfWeek);
	var d = new Date(this.beginning_date);
	var a = new Date().clearTime();
	var c = this.date.getMonth();
	vdc = this.options.valid_date_check;
	for (var e = 0; e < 42; e++) {
		day = d.getDate();
		month = d.getMonth();
		cell = this.calendar_day_grid[e];
		cell.update(new Element("div", {"class": (month != c) ? "other" : ""}).update(day));
		cell.day = day;
		cell.month = month;
		cell.year = d.getFullYear();
		if (vdc) {
			if (vdc(d.clearTime())) {
				cell.removeClassName("disabled")
			} else {
				cell.addClassName("disabled")
			}
		}
		d.setDate(day + 1)
	}
	if (this.today_cell) {
		this.today_cell.removeClassName("today")
	}
	if ($R(0, 41).include(days_until = this.dateUtils.daysDistance(this.beginning_date.clearTime(), (a)))) {
		this.today_cell = this.calendar_day_grid[days_until];
		this.today_cell.addClassName("today")
	}
}, refreshMonthYear: function () {
	var a = this.date.getMonth();
	var c = this.date.getFullYear();
	if (this.options.month_year == "dropdowns") {
		this.month_select.setValue(a, false);
		var b = this.year_select.element;
		if (this.flexibleYearRange() && (!(this.year_select.setValue(c, false)) || b.selectedIndex <= 1 || b.selectedIndex >= b.options.length - 2)) {
			this.populateYearRange()
		}
		this.year_select.setValue(c)
	} else {
		this.month_year_label.update(this.dateUtils.months[a] + " " + c.toString())
	}
}, populateYearRange: function () {
	this.year_select.populate(this.yearRange().toArray())
}, yearRange: function () {
	if (!this.flexibleYearRange()) {
		return $R(this.options.year_range[0], this.options.year_range[1])
	}
	var a = this.date.getFullYear();
	return $R(a - this.options.year_range, a + this.options.year_range)
}, flexibleYearRange: function () {
	return(typeof(this.options.year_range) == "number")
}, validYear: function (a) {
	if (this.flexibleYearRange()) {
		return true
	} else {
		return this.yearRange().include(a)
	}
}, dayHover: function (a) {
	var b = new Date(this.selected_date);
	b.setFullYear(a.year, a.month, a.day);
	this.updateFooter(b.toFormattedString(this.options))
}, dayHoverOut: function (a) {
	this.updateFooter()
}, clearSelectedClass: function () {
	if (this.selected_cell) {
		this.selected_cell.removeClassName("selected")
	}
}, setSelectedClass: function () {
	if (!this.selection_made) {
		return
	}
	this.clearSelectedClass();
	if ($R(0, 42).include(days_until = this.dateUtils.daysDistance(this.beginning_date.clearTime(), this.selected_date.clearTime()))) {
		this.selected_cell = this.calendar_day_grid[days_until];
		this.selected_cell.addClassName("selected")
	}
}, reparse: function () {
	this.parseDate();
	this.refresh()
}, dateString: function () {
	return(this.selection_made) ? this.selected_date.toFormattedString(this.options) : "&#160;"
}, parseDate: function () {
	var b = this.target_element.readAttribute("alt").strip();
	var a = this.options.default_time;
	this.selection_made = (b != "" || a);
	this.date = b == "" ? NaN : Date.parseISO_8601(b);
	if (isNaN(this.date) && !a) {
		this.date = new Date()
	} else {
		if (isNaN(this.date) && a) {
			this.date = (Object.prototype.toString.apply(a) === "[object Function]") ? a() : a
		}
	}
	if (!this.validYear(this.date.getFullYear())) {
		this.date.setYear((this.date.getFullYear() < this.yearRange().start) ? this.yearRange().start : this.yearRange().end)
	}
	this.selected_date = new Date(this.date);
	this.use_time = /[0-9]:[0-9]{2}/.exec(b) ? true : false;
	this.date.setDate(1)
}, updateFooter: function (a) {
	this.footer_div.update(new Element("span").update(a || this.dateString()))
}, clearDate: function () {
	if ((this.target_element.disabled || this.target_element.readOnly) && this.options.popup != "force") {
		return false
	}
	var a = this.target_element.value;
	this.target_element.value = "";
	this.target_element.writeAttribute("alt", "");
	this.clearSelectedClass();
	this.updateFooter("&#160;");
	if (a != this.target_element.value) {
		this.callback("onchange")
	}
}, updateSelectedDate: function (b, a) {
	var e = $H(b);
	if ((this.target_element.disabled || this.target_element.readOnly) && this.options.popup != "force") {
		return false
	}
	if (e.get("day")) {
		var d = this.selected_date, c = this.options.valid_date_check;
		d.setFullYear(e.get("year"), e.get("month"), e.get("day"));
		if (c && !c(d.clearTime())) {
			return false
		}
		this.selected_date = d;
		this.selection_made = true
	}
	if (!isNaN(e.get("hour"))) {
		this.selected_date.setHours(e.get("hour"))
	}
	if (!isNaN(e.get("minute"))) {
		this.selected_date.setMinutes(this.alignMinutesToInterval(e.get("minute")))
	}
	if (e.get("hour") === "" || e.get("minute") === "") {
		this.setUseTime(false)
	} else {
		if (!isNaN(e.get("hour")) || !isNaN(e.get("minute"))) {
			this.setUseTime(true)
		}
	}
	this.updateFooter();
	this.setSelectedClass();
	if (this.selection_made) {
		this.updateValue()
	}
	if (a && this.closeOnClick()) {
		this.close()
	}
	if (a && !this.options.embedded) {
		if ((new Date() - this.last_click_at) < 333) {
			this.close()
		}
		this.last_click_at = new Date()
	}
}, closeOnClick: function () {
	if (this.options.embedded) {
		return false
	}
	if (this.options.close_on_click === null) {
		return(this.options.time) ? false : true
	} else {
		return(this.options.close_on_click)
	}
}, navMonth: function (a, b) {
	(target_date = new Date(this.date)).setMonth(typeof(b) == "number" ? b : this.month_select.getValue());
	return(this.navTo(target_date))
}, navYear: function (b, a) {
	(target_date = new Date(this.date)).setYear(typeof(a) == "number" ? a : this.year_select.getValue());
	return(this.navTo(target_date))
}, navTo: function (a) {
	if (!this.validYear(a.getFullYear())) {
		return false
	}
	this.date = a;
	this.date.setDate(1);
	this.refresh();
	this.callback("after_navigate", this.date);
	return true
}, alignMinutesToInterval: function (b) {
	var a = this.options.minute_interval;
	return Math.floor(b / a) * a
}, setUseTime: function (b) {
	this.use_time = this.options.time && (this.options.time == "mixed" ? b : true);
	if (this.use_time && this.selected_date) {
		var c = this.alignMinutesToInterval(this.selected_date.getMinutes());
		var a = this.selected_date.getHours();
		this.hour_select.setValue(a);
		this.minute_select.setValue(c)
	} else {
		if (this.options.time == "mixed") {
			this.hour_select.setValue("");
			this.minute_select.setValue("")
		}
	}
}, updateValue: function () {
	var a = this.target_element.value;
	this.target_element.value = this.dateString();
	this.target_element.writeAttribute("alt", this.selected_date.toISO8601());
	if (a != this.target_element.value) {
		this.callback("onchange")
	}
}, today: function (a) {
	var c = new Date();
	this.date = new Date();
	var b = $H({day: c.getDate(), month: c.getMonth(), year: c.getFullYear(), hour: c.getHours(), minute: c.getMinutes()});
	if (!a) {
		b = b.merge({hour: "", minute: ""})
	}
	this.updateSelectedDate(b, true);
	this.refresh()
}, close: function () {
	if (this.closed) {
		return false
	}
	this.callback("before_close");
	this.target_element.calendar_date_select = null;
	Event.stopObserving(document, "mousedown", this.closeIfClickedOut_handler);
	Event.stopObserving(document, "keypress", this.keyPress_handler);
	this.calendar_div.remove();
	this.closed = true;
	if (this.iframe) {
		this.iframe.remove()
	}
	if (this.target_element.type != "hidden" && !this.target_element.disabled) {
		this.target_element.focus()
	}
	this.callback("after_close")
}, closeIfClickedOut: function (a) {
	if (!($(Event.element(a)).descendantOf && $(Event.element(a)).descendantOf(this.calendar_div))) {
		this.close()
	}
}, keyPress: function (a) {
	if (a.keyCode == Event.KEY_ESC) {
		this.close()
	}
}, callback: function (a, b) {
	if (this.options[a]) {
		this.options[a].bind(this.target_element)(b)
	}
}});
var XWiki = (function (b) {
	var a = b.widgets = b.widgets || {};
	a.DateTimePicker = Class.create({selector: "input.xwiki-date:not(.initialized)", options: {year_range: 10, time: false, convert_to_UTC: false, hour_format_12: false, minute_interval: 1, popup: "force"}, initialize: function (c) {
		this.options = Object.extend(Object.clone(this.options), c || {});
		this.attachPickers();
		document.observe("xwiki:dom:updated", function (d) {
			this.attachPickers(d.memo.elements && d.memo.elements[0])
		}.bindAsEventListener(this))
	}, attachPickers: function (c) {
		var d = c && c.select(this.selector) || $$(this.selector);
		d.invoke("observe", "click", this.onClick.bindAsEventListener(this));
		d.each(function (e) {
			e.readOnly = true;
			e.addClassName("initialized")
		})
	}, onClick: function (c) {
		this.showCalendar(c.element())
	}, showCalendar: function (d) {
		var c = Object.clone(this.options);
		c.time = c.time || d.hasClassName("withTime");
		c.convert_to_UTC = c.convert_to_UTC || d.hasClassName("withUTC");
		c.onchange = function () {
			Event.fire(d, "xwiki:date:changed");
			Event.fire(d, "xwiki:form:field-value-changed")
		};
		d._selector = new CalendarDateSelect(d, c)
	}});
	return b
}(XWiki || {}));
document.observe("xwiki:dom:loaded", function () {
	var a = new Date().getFullYear();
	window.dateTimePicker = new XWiki.widgets.DateTimePicker({year_range: [a - 99, a + 1]})
});
var SimpleDateFormat;
(function () {
	function g(q) {
		return typeof q == "undefined"
	}

	var p = /('[^']*')|(G+|y+|M+|w+|W+|D+|d+|F+|E+|a+|H+|k+|K+|h+|m+|s+|S+|Z+)|([a-zA-Z]+)|([^a-zA-Z']+)/;
	var k = Date.CultureInfo.monthNames;
	var c = Date.CultureInfo.dayNames;
	var j = 0, i = 1, f = 2, m = 3, e = 4, n = 5;
	var l = {G: j, y: m, M: e, w: f, W: f, D: f, d: f, F: f, E: i, a: j, H: f, k: f, K: f, h: f, m: f, s: f, S: f, Z: n};
	var d = 24 * 60 * 60 * 1000;
	var a = 7 * d;
	var b = 1;
	var o = function (r, s, q) {
		var t = new Date(r, s, q, 0, 0, 0);
		t.setMilliseconds(0);
		return t
	};
	Date.prototype.getDifference = function (q) {
		return this.getTime() - q.getTime()
	};
	Date.prototype.isBefore = function (q) {
		return this.getTime() < q.getTime()
	};
	Date.prototype.getUTCTime = function () {
		return Date.UTC(this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds())
	};
	Date.prototype.getTimeSince = function (q) {
		return this.getUTCTime() - q.getUTCTime()
	};
	Date.prototype.getPreviousSunday = function () {
		var r = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 12, 0, 0);
		var q = new Date(r.getTime() - this.getDay() * d);
		return o(q.getFullYear(), q.getMonth(), q.getDate())
	};
	Date.prototype.getWeekInYear = function (v) {
		if (g(this.minimalDaysInFirstWeek)) {
			v = b
		}
		var t = this.getPreviousSunday();
		var r = o(this.getFullYear(), 0, 1);
		var u = t.isBefore(r) ? 0 : 1 + Math.floor(t.getTimeSince(r) / a);
		var q = 7 - r.getDay();
		var s = u;
		if (q < v) {
			s--
		}
		return s
	};
	Date.prototype.getWeekInMonth = function (v) {
		if (g(this.minimalDaysInFirstWeek)) {
			v = b
		}
		var r = this.getPreviousSunday();
		var u = o(this.getFullYear(), this.getMonth(), 1);
		var t = r.isBefore(u) ? 0 : 1 + Math.floor((r.getTimeSince(u)) / a);
		var q = 7 - u.getDay();
		var s = t;
		if (q >= v) {
			s++
		}
		return s
	};
	Date.prototype.getDayInYear = function () {
		var q = o(this.getFullYear(), 0, 1);
		return 1 + Math.floor(this.getTimeSince(q) / d)
	};
	SimpleDateFormat = function (q) {
		this.formatString = q
	};
	SimpleDateFormat.prototype.setMinimalDaysInFirstWeek = function (q) {
		this.minimalDaysInFirstWeek = q
	};
	SimpleDateFormat.prototype.getMinimalDaysInFirstWeek = function (q) {
		return g(this.minimalDaysInFirstWeek) ? b : this.minimalDaysInFirstWeek
	};
	SimpleDateFormat.prototype.format = function (J) {
		if (J == "Invalid Date") {
			return""
		}
		var q = "";
		var A;
		var u = function (M, L) {
			while (M.length < L) {
				M = "0" + M
			}
			return M
		};
		var s = function (N, M, L) {
			return(M >= 4) ? N : N.substr(0, Math.max(L, M))
		};
		var y = function (N, M) {
			var L = "" + N;
			return u(L, M)
		};
		var x = this.formatString;
		while ((A = p.exec(x))) {
			var E = A[0];
			var z = A[1];
			var B = A[2];
			var w = A[3];
			var v = A[4];
			if (z) {
				if (z == "''") {
					q += "'"
				} else {
					q += z.substring(1, z.length - 1)
				}
			} else {
				if (w) {
				} else {
					if (v) {
						q += v
					} else {
						if (B) {
							var r = B.charAt(0);
							var K = B.length;
							var C = "";
							switch (r) {
								case"G":
									C = "AD";
									break;
								case"y":
									C = J.getFullYear();
									break;
								case"M":
									C = J.getMonth();
									break;
								case"w":
									C = J.getWeekInYear(this.getMinimalDaysInFirstWeek());
									break;
								case"W":
									C = J.getWeekInMonth(this.getMinimalDaysInFirstWeek());
									break;
								case"D":
									C = J.getDayInYear();
									break;
								case"d":
									C = J.getDate();
									break;
								case"F":
									C = 1 + Math.floor((J.getDate() - 1) / 7);
									break;
								case"E":
									C = c[J.getDay()];
									break;
								case"a":
									C = (J.getHours() >= 12) ? "PM" : "AM";
									break;
								case"H":
									C = J.getHours();
									break;
								case"k":
									C = J.getHours() || 24;
									break;
								case"K":
									C = J.getHours() % 12;
									break;
								case"h":
									C = (J.getHours() % 12) || 12;
									break;
								case"m":
									C = J.getMinutes();
									break;
								case"s":
									C = J.getSeconds();
									break;
								case"S":
									C = J.getMilliseconds();
									break;
								case"Z":
									C = J.getTimezoneOffset();
									break
							}
							switch (l[r]) {
								case j:
									q += s(C, K, 2);
									break;
								case i:
									q += s(C, K, 3);
									break;
								case f:
									q += y(C, K);
									break;
								case m:
									if (K <= 3) {
										var t = "" + C;
										q += t.substr(2, 2)
									} else {
										q += y(C, K)
									}
									break;
								case e:
									if (K >= 3) {
										q += s(k[C], K, K)
									} else {
										q += y(C + 1, K)
									}
									break;
								case n:
									var I = (C > 0);
									var F = I ? "-" : "+";
									var H = Math.abs(C);
									var G = "" + Math.floor(H / 60);
									G = u(G, 2);
									var D = "" + (H % 60);
									D = u(D, 2);
									q += F + G + D;
									break
							}
						}
					}
				}
			}
			x = x.substr(A.index + A[0].length)
		}
		return q
	}
})();
var PedigreeFuzzyDatePickerDropdown = Class.create({
	initialize: function (options) {
		this.span = new Element('span');
		this.options = options;
		this.callback = null;
	},

	populate: function (values) {
		var selectedIndex = this.dropdown ? (this.dropdown.selectedIndex || this._tmpSelectedIndex) : 0;

		// using raw HTML for performance reasons: generating many years takes a noticeable time using
		// more proper methods (e.g. new Element()...)
		// (Note: using span around select because IE9 does not allow setting innerHTML of <select>-s)
		var optionsHTML = '<select name="' + this.options.name +
			'" class="' + (this.options.cssClass || this.options.name || '') +
			'" placeholder="' + (this.options.hint || this.options.name || '') +
			'" title="' + (this.options.hint || this.options.name || '') + '">';

		optionsHTML += '<option value="" class="empty"></option>';
		var _this = this;
		values.each(function (item) {
			optionsHTML += '<option value="' + item.value + '"';
			if (item.cssClass) {
				optionsHTML += ' class="' + item.cssClass + '"';
			}
			optionsHTML += '>' + (item.text || item.value || '') + '</option>';
		});
		optionsHTML += "</select>";
		this.span.innerHTML = optionsHTML;
		this.dropdown = this.span.firstChild;
		this.callback && this.onSelect(this.callback);
		if (this.dropdown.selectedIndex <= 0 && selectedIndex >= 0 && selectedIndex < this.dropdown.options.length) {
			this.dropdown.selectedIndex = selectedIndex;
		}
	},

	enable: function () {
		if (!this.options.alwaysEnabled) {
			this.dropdown.enable();
			if (this.dropdown.selectedIndex <= 0 && this._tmpSelectedIndex < this.dropdown.options.length) {
				this.dropdown.selectedIndex = this._tmpSelectedIndex;
				return (this._tmpSelectedIndex > 0);
			}
		}
		return false;
	},

	disable: function () {
		if (!this.options.alwaysEnabled) {
			this.dropdown.disable();
			this._tmpSelectedIndex = this.dropdown.selectedIndex;
			this.dropdown.selectedIndex = 0;
		}
	},

	getElement: function () {
		return this.span;
	},

	onSelect: function (callback) {
		var _this = this;
		this.callback = callback;
		var events = ['change'];
		browser.isGecko && events.push('keyup');
		events.each(function (eventName) {
			_this.dropdown.observe(eventName, function () {
				callback();
				if (this.inputFormat == "YMD") {
					_this._tmpSelectedIndex = _this.dropdown.selectedIndex;
				}
			});
		});
	},

	onFocus: function (callback) {
		var _this = this;
		this.dropdown.observe('focus', function () {
			callback();
			if (_this.dropdown.selectedIndex == -1 && _this._tmpSelectedIndex < _this.dropdown.options.size()) {
				_this.dropdown.selectedIndex = _this._tmpSelectedIndex;
			}
		});
	},
	onBlur: function (callback) {
		this.dropdown.observe('blur', callback);
	},

	getSelectedValue: function () {
		return (this.dropdown.selectedIndex >= 0) ? this.dropdown.options[this.dropdown.selectedIndex].value : '';
	},

	getSelectedOption: function () {
		return (this.dropdown.selectedIndex >= 0) ? this.dropdown.options[this.dropdown.selectedIndex].innerHTML : '';
	}
});

var PedigreeFuzzyDatePicker = Class.create({
	initialize: function (input, inputFormat) {
		this.inputFormat = inputFormat ? inputFormat : "YMD";

		if (!input) {
			return
		}
		;
		this.__input = input;
		this.__input.hide();
		this.__name = input.name;

		this.container = new Element('div', {'class': 'fuzzy-date-picker'});
		this.__input.insert({after: this.container});

		if (this.inputFormat == "DMY" || this.inputFormat == "MY") {
			var hideDay = (this.inputFormat == "MY")
			this.container.insert(this.createDayDropdown(hideDay));
			this.container.insert(this.createMonthDropdown());
			this.container.insert(this.createYearDropdown());
		} else {
			this.container.insert(this.createYearDropdown());
			this.container.insert(this.createMonthDropdown());
			this.container.insert(this.createDayDropdown());
		}

		// TODO: yearSelector's (and month's & day's) .onSelect() does not seem to fire
		//       upon programmatic update if a substitute is found can remove these hackish events

		this.container.observe("datepicker:date:changed", this.onProgrammaticUpdate.bind(this));
	},

	onProgrammaticUpdate: function () {
		this.yearSelected(true);
		this.monthSelected(true);
		this.updateDate(true);
	},

	createYearDropdown: function () {
		//var timer = new Helpers.Timer();
		this.yearSelector = new PedigreeFuzzyDatePickerDropdown({name: "year", alwaysEnabled: (this.inputFormat != "YMD")});

		var today = new Date();
		var crtYear = today.getYear() + 1900;
		var startYear = 1850;

		var values = [];
        //console.log("thisss22",this)
        if(this.__input.name == 'estimatedDateOfDelivery') {
            values.push({"value": crtYear+1});
        }
		for (var y = crtYear; y >= startYear; --y) {
			values.push({"value": y});
			if (y % 10 == 0) {
				values.push({"value": (y + "s"), "cssClass": "decade", "text": (y + 's')});
			}
		}
		values.push({"value": "1800s", "cssClass": "decade"});
		values.push({"value": "1700s", "cssClass": "decade"});
		values.push({"value": "1600s", "cssClass": "decade"});

		this.yearSelector.populate(values);
		this.yearSelector.onSelect(this.yearSelected.bind(this));

		//console.log( "=== Generate year dropdown time: " + timer.report() + "ms ==========" );
		return this.yearSelector.getElement();
	},

	yearSelected: function (doNotNotifyOnChange) {
		if (this.yearSelector.getSelectedValue() > 0) {
			if (this.__name != 'date_of_birth' && this.__name != 'date_of_death') {
				this.monthSelector.enable();
			} else {
				console.log("HEY WHAT");
			}
			this.monthSelected(doNotNotifyOnChange);
		} else {
			this.monthSelector.disable();
			this.daySelector.disable();
		}
		this.updateDate(doNotNotifyOnChange);
	},

	createMonthDropdown: function () {
		this.monthSelector = new PedigreeFuzzyDatePickerDropdown({name: "month", alwaysEnabled: (this.inputFormat != "YMD")});
		this.monthSelector.populate(this.getZeroPaddedValueRange(1, 12));
		this.monthSelector.disable();
		this.monthSelector.onSelect(this.monthSelected.bind(this));
		return this.monthSelector.getElement();
	},

	monthSelected: function (doNotNotifyOnChange) {
		if (this.monthSelector.getSelectedValue() > 0) {
			this.daySelector.populate(this.getAvailableDays());
			if (this.__name != 'date_of_birth' || this.__name != 'date_of_death')
				this.daySelector.enable();
		} else {
			if (this.inputFormat == "DMY") {
				// in "DMY" mode let user pick any day if no month is selected
				this.daySelector.populate(this.getZeroPaddedValueRange(1, 31));
			} else {
				this.daySelector.disable();
			}
		}
		this.updateDate(doNotNotifyOnChange);
	},

	createDayDropdown: function (hide) {
		this.daySelector = new PedigreeFuzzyDatePickerDropdown({name: "day", alwaysEnabled: (this.inputFormat != "YMD")});
		this.daySelector.populate(this.getZeroPaddedValueRange(1, 31));
		this.daySelector.disable();
		this.daySelector.onSelect(this.updateDate.bind(this));
		if (hide) {
			this.daySelector.getElement().hide();
		}
		return this.daySelector.getElement();
	},

	getAvailableDays: function () {
		var year = this.yearSelector.getSelectedValue() * 1;
		var month = this.monthSelector.getSelectedValue() * 1;
		var lastDayOfMonth = 0;
		if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) >= 0) {
			lastDayOfMonth = 31;
		} else if ([4, 6, 9, 11].indexOf(month) >= 0) {
			lastDayOfMonth = 30
		} else if (month == 2) {
			if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
				lastDayOfMonth = 29;
			} else {
				lastDayOfMonth = 28;
			}
		}
		return this.getZeroPaddedValueRange(1, lastDayOfMonth);
	},

	getZeroPaddedValueRange: function (start, end) {
		var values = [];
		if (start <= end) {
			for (var v = start; v <= end; ++v) {
				values.push({'value': v, 'text': ("0" + v).slice(-2)});
			}
		} else {
			for (var v = end; v <= start; --v) {
				values.push({'value': v, 'text': ("0" + v).slice(-2)});
			}
		}
		return values;
	},

	updateDate: function (doNotFireEventOnChange) {
		var dateObject = {};

		var y = this.yearSelector.getSelectedValue();
		if (y.match(/\d\d\d\ds$/)) {
			dateObject["decade"] = y;
		} else {
			if (y != "") {
				dateObject["year"] = y;
			}
		}

		if (y > 0 || this.inputFormat == "DMY") {
			var m = this.monthSelector.getSelectedValue();
			if (m > 0) {
				dateObject["month"] = this.monthSelector.getSelectedOption();
			}

			if (m > 0 || this.inputFormat == "DMY") {
				var d = this.daySelector.getSelectedValue();
				if (d > 0) {
					dateObject["day"] = this.daySelector.getSelectedOption();
				}
			}
		}

		var newValue = JSON.stringify(dateObject);
		if (newValue != this.__input.value) {
			this.__input.value = JSON.stringify(dateObject);
			if (!doNotFireEventOnChange) {
				this.__input.fire("xwiki:date:changed");
			}
		}
	}
});

var XWiki = (function (XWiki) {

	/**
	 * The search suggest hooks itself on the search input and provide live results as the user types.
	 * Search form validation is not affected (user can still type enter and get to the regular search result page)
	 */
	XWiki.SearchSuggest = Class.create({

		/**
		 * Constructor. Prepares a light modal container on the same model as the modalPopup
		 * and registers event listerners.
		 */
		initialize: function (searchInput, sources) {

			this.sources = sources;

			this.searchInput = $(searchInput);
			if (!this.searchInput) {
				return;
			}

			document.observe("xwiki:suggest:clearSuggestions", this.onClearSuggestions.bindAsEventListener(this));
			document.observe("xwiki:suggest:containerCreated", this.onSuggestContainerCreated.bindAsEventListener(this));
			document.observe("xwiki:suggest:containerPrepared", this.onSuggestContainerPrepared.bindAsEventListener(this));
			document.observe("xwiki:suggest:updated", this.onSuggestUpdated.bindAsEventListener(this));
			document.observe("xwiki:suggest:selected", this.onSuggestionSelected.bindAsEventListener(this));

			this.createSuggest();
		},

		/**
		 * Callback triggered when the original suggest clears its suggestions.
		 */
		onClearSuggestions: function (event) {
			if (event.memo.suggest == this.suggest) {
				// Restore bottom border style
				this.searchInput.setStyle({'borderBottomStyle': this.searchInputBorderBottomSavedStyle});
			}
		},

		/**
		 * Callback triggered when the original suggest has created its results container.
		 */
		onSuggestContainerCreated: function (event) {
			if (event.memo.suggest == this.suggest) {
				// Save the style of the bottom border of the input field so that we can restore it later on
				this.searchInputBorderBottomSavedStyle = this.searchInput.getStyle('borderBottomStyle');
				// Hide bottom border of input field to not double the container border just under the field
				this.searchInput.setStyle({'borderBottomStyle': 'none'});
			}
		},

		/**
		 * Callback triggered just before the suggest sends a new set of requests to fetch the suggestions from all the
		 * configured sources. At this point the list of suggestions is empty and all sources are marked as loading.
		 */
		onSuggestContainerPrepared: function (event) {
			// Hide the "No results!" message.
			this.noResultsMessage.addClassName('hidden');
		},

		/**
		 * Callback triggered after the suggest receives the list of suggestions from all configured sources (even if the
		 * list of suggestions from one source is empty).
		 */
		onSuggestUpdated: function (event) {
			// Check if there are any suggestions, taking into account that there is at least one suggestion used to link the
			// search page.
			if (event.memo.container.select('.suggestItem').length == 1) {
				// Show the "No results!" message.
				this.noResultsMessage.removeClassName('hidden').setStyle({'float': 'left'});
			}
		},

		/**
		 * Callback triggered when a suggestion is selected.
		 * Submits the form or go to a selected page according to selection.
		 */
		onSuggestionSelected: function (event) {
			if (event.memo.suggest == this.suggest) {
				event.stop();
				// Also stop the browser event that triggered the custom "xwiki:suggest:selected" event.
				if (event.memo.originalEvent) {
					Event.stop(event.memo.originalEvent);
				}
				if (!event.memo.id) {
					// Submit form
					this.searchInput.up('form').submit();
				}
				else {
					// Go to page
					window.location = event.memo.id;
					;
				}
			}
		},

		/**
		 * Creates the underlaying suggest widget.
		 */
		createSuggest: function () {
			// Create dummy suggestion node to hold the "Go to search page..." option.
			var valueNode = new Element('div')
				.insert(new Element('span', {'class': 'suggestId'}))
				.insert(new Element('span', {'class': 'suggestValue'}))
				.insert(new Element('span', {'class': 'suggestInfo'}));
			this.noResultsMessage = new Element('div', {'class': 'hidden'})
				.update("No results!".escapeHTML());
			var gotoSearchPageMessage = new Element('div')
				.update("Go to search page\u2026"
					.escapeHTML());
			var content = new Element('div').insert(this.noResultsMessage).insert(gotoSearchPageMessage)
				.insert(new Element('div', {'class': 'clearfloats'}));
			var allResultsNode = new XWiki.widgets.XList([
					new XWiki.widgets.XListItem(content, {
						'containerClasses': 'suggestItem',
						'classes': 'showAllResults',
						'eventCallbackScope': this,
						'noHighlight': true,
						'value': valueNode
					}),
				],
				{
					'classes': 'suggestList',
					'eventListeners': {
						'click': function (event) {
							this.searchInput.up('form').submit();
						},
						'mouseover': function (event) {
							this.suggest.clearHighlight();
							this.suggest.iHighlighted = event.element();
							event.element().addClassName('xhighlight');
						}
					}
				});
			var allResults = allResultsNode.getElement();
			this.suggest = new XWiki.widgets.Suggest(this.searchInput, {
				parentContainer: $('searchSuggest'),
				className: 'searchSuggest horizontalLayout',
				fadeOnClear: false,
				align: "auto",
				minchars: 1,
				sources: this.sources,
				insertBeforeSuggestions: new Element("div", {'class': 'results'}).update(allResults),
				displayValue: true,
				displayValueText: "in ",
				timeout: 0,
				width: 500,
				unifiedLoader: true,
				loaderNode: allResults.down("li"),
				shownoresults: false,
				propagateEventKeyCodes: [ Event.KEY_RETURN ]
			});
		}

	});

	var init = function () {
		/*
		 */
		var sources = [
			{"name": "Matching patients", "varname": "input", "script": "/get/PhenoTips/SuggestPatientsService?outputSyntax=plain&permission=view&query=__INPUT__&nb=5", "icon": "resources/icons/silk/user.png", "highlight": false}
		];
		new XWiki.SearchSuggest($('headerglobalsearchinput'), sources);
		return true;
	};

	// When the document is loaded, install search suggestions
	(XWiki.isInitialized && init())
	|| document.observe('xwiki:dom:loading', init);

	return XWiki;

})(XWiki);
var XWiki = (function (c) {
	var a = function (f) {
		if (!f) {
			return c.currentDocument
		} else {
			if (typeof f == "string") {
				var e = c.Model.resolve(f, c.EntityType.DOCUMENT);
				var d = e.name;
				var g = e.extractReferenceValue(c.EntityType.SPACE);
				var h = e.extractReferenceValue(c.EntityType.WIKI);
				return new c.Document(d, g, h)
			}
		}
		return f
	};
	c.DocumentLock = Class.create({initialize: function (e) {
		this._document = a(e);
		var g = this.unlock.bind(this);
		Event.observe(window, "unload", g);
		Event.observe(window, "pagehide", g);
		$("tmLogout") && $("tmLogout").down("a") && $("tmLogout").down("a").observe("click", g);
		var f = this.setLocked.bind(this, false);
		$$("form.withLock").each(function (h) {
			h.observe("submit", f)
		});
		var d = new c.DocumentReference(this._document.wiki, this._document.space, this._document.page);
		c.DocumentLock._instances[c.Model.serialize(d)] = this
	}, lock: function () {
		if (!this._locked) {
			this._locked = true;
			//new Ajax.Request(this._getURL("lock"), {method: "get"})
		}
	}, unlock: function () {
		if (this._locked) {
			this._locked = false;
			//new Ajax.Request(this._getURL("cancel"), {method: "get", asynchronous: false})
		}
	}, setLocked: function (d) {
		this._locked = !!d
	}, isLocked: function () {
		return this._locked
	}, _getURL: function (d) {
		return this._document.getURL(d, "ajax=1&action=" + c.contextaction + "&" + (c.docvariant || ""))
	}});
	c.DocumentLock._instances = {};
	c.DocumentLock.get = function (e) {
		e = a(e);
		var d = new c.DocumentReference(e.wiki, e.space, e.page);
		return c.DocumentLock._instances[c.Model.serialize(d)]
	};
	var b = function () {
		c.EditLock = new c.DocumentLock();
		c.EditLock.lock();
		return true
	};
	(c.domIsLoaded && b()) || document.observe("xwiki:dom:loaded", b);
	return c
}(XWiki || {}));
var LiveValidation = Class.create();
Object.extend(LiveValidation, {VERSION: "1.3 prototype", TEXTAREA: 1, TEXT: 2, PASSWORD: 3, CHECKBOX: 4, SELECT: 5, FILE: 6, massValidate: function (c) {
	var d = true;
	for (var b = 0, a = c.length; b < a; ++b) {
		var e = c[b].validate();
		if (d) {
			d = e
		}
	}
	return d
}});
LiveValidation.prototype = {validClass: "LV_valid", invalidClass: "LV_invalid", messageClass: "LV_validation_message", validFieldClass: "LV_valid_field", invalidFieldClass: "LV_invalid_field", initialize: function (b, a) {
	if (!b) {
		throw new Error("LiveValidation::initialize - No element reference or element id has been provided!")
	}
	this.element = $(b);
	if (!this.element) {
		throw new Error("LiveValidation::initialize - No element with reference or id of '" + b + "' exists!")
	}
	this.elementType = this.getElementType();
	this.validations = [];
	this.form = this.element.form;
	this.options = Object.extend({validMessage: "Thankyou!", onValid: function () {
		this.insertMessage(this.createMessageSpan());
		this.addFieldClass()
	}, onInvalid: function () {
		this.insertMessage(this.createMessageSpan());
		this.addFieldClass()
	}, insertAfterWhatNode: this.element, onlyOnBlur: false, wait: 0, onlyOnSubmit: false}, a || {});
	var c = this.options.insertAfterWhatNode || this.element;
	this.options.insertAfterWhatNode = $(c);
	Object.extend(this, this.options);
	if (this.form) {
		this.formObj = LiveValidationForm.getInstance(this.form);
		this.formObj.addField(this)
	}
	this.boundFocus = this.doOnFocus.bindAsEventListener(this);
	Event.observe(this.element, "focus", this.boundFocus);
	if (!this.onlyOnSubmit) {
		switch (this.elementType) {
			case LiveValidation.CHECKBOX:
				this.boundClick = this.validate.bindAsEventListener(this);
				Event.observe(this.element, "click", this.boundClick);
			case LiveValidation.SELECT:
			case LiveValidation.FILE:
				this.boundChange = this.validate.bindAsEventListener(this);
				Event.observe(this.element, "change", this.boundChange);
				break;
			default:
				if (!this.onlyOnBlur) {
					this.boundKeyup = this.deferValidation.bindAsEventListener(this);
					Event.observe(this.element, "keyup", this.boundKeyup)
				}
				this.boundBlur = this.validate.bindAsEventListener(this);
				Event.observe(this.element, "blur", this.boundBlur)
		}
	}
}, destroy: function () {
	if (this.formObj) {
		this.formObj.removeField(this);
		this.formObj.destroy()
	}
	Event.stopObserving(this.element, "focus", this.boundFocus);
	if (!this.onlyOnSubmit) {
		switch (this.elementType) {
			case LiveValidation.CHECKBOX:
				Event.stopObserving(this.element, "click", this.boundClick);
			case LiveValidation.SELECT:
			case LiveValidation.FILE:
				Event.stopObserving(this.element, "change", this.boundChange);
				break;
			default:
				if (!this.onlyOnBlur) {
					Event.stopObserving(this.element, "keyup", this.boundKeyup)
				}
				Event.stopObserving(this.element, "blur", this.boundBlur)
		}
	}
	this.validations = [];
	this.removeMessageAndFieldClass()
}, add: function (a, b) {
	this.validations.push({type: a, params: b || {}});
	return this
}, remove: function (a, b) {
	this.validations = this.validations.reject(function (c) {
		return(c.type == a && c.params == b)
	});
	return this
}, deferValidation: function (a) {
	if (this.wait >= 300) {
		this.removeMessageAndFieldClass()
	}
	if (this.timeout) {
		clearTimeout(this.timeout)
	}
	this.timeout = setTimeout(this.validate.bind(this), this.wait)
}, doOnBlur: function () {
	this.focused = false;
	this.validate()
}, doOnFocus: function () {
	this.focused = true;
	this.removeMessageAndFieldClass()
}, getElementType: function () {
	switch (true) {
		case (this.element.nodeName.toUpperCase() == "TEXTAREA"):
			return LiveValidation.TEXTAREA;
		case (this.element.nodeName.toUpperCase() == "INPUT" && this.element.type.toUpperCase() == "TEXT"):
			return LiveValidation.TEXT;
		case (this.element.nodeName.toUpperCase() == "INPUT" && this.element.type.toUpperCase() == "PASSWORD"):
			return LiveValidation.PASSWORD;
		case (this.element.nodeName.toUpperCase() == "INPUT" && this.element.type.toUpperCase() == "CHECKBOX"):
			return LiveValidation.CHECKBOX;
		case (this.element.nodeName.toUpperCase() == "INPUT" && this.element.type.toUpperCase() == "FILE"):
			return LiveValidation.FILE;
		case (this.element.nodeName.toUpperCase() == "SELECT"):
			return LiveValidation.SELECT;
		case (this.element.nodeName.toUpperCase() == "INPUT"):
			throw new Error("LiveValidation::getElementType - Cannot use LiveValidation on an " + this.element.type + " input!");
		default:
			throw new Error("LiveValidation::getElementType - Element must be an input, select, or textarea!")
	}
}, doValidations: function () {
	this.validationFailed = false;
	for (var c = 0, a = this.validations.length; c < a; ++c) {
		var b = this.validations[c];
		switch (b.type) {
			case Validate.Presence:
			case Validate.Confirmation:
			case Validate.Acceptance:
				this.displayMessageWhenEmpty = true;
				this.validationFailed = !this.validateElement(b.type, b.params);
				break;
			default:
				this.validationFailed = !this.validateElement(b.type, b.params);
				break
		}
		if (this.validationFailed) {
			return false
		}
	}
	this.message = this.validMessage;
	return true
}, validateElement: function (a, c) {
	var d = (this.elementType == LiveValidation.SELECT) ? this.element.options[this.element.selectedIndex].value : this.element.value;
	if (a == Validate.Acceptance) {
		if (this.elementType != LiveValidation.CHECKBOX) {
			throw new Error("LiveValidation::validateElement - Element to validate acceptance must be a checkbox!")
		}
		d = this.element.checked
	}
	var e = true;
	try {
		a(d, c)
	} catch (b) {
		if (b instanceof Validate.Error) {
			if (d !== "" || (d === "" && this.displayMessageWhenEmpty)) {
				this.validationFailed = true;
				this.message = b.message;
				e = false
			}
		} else {
			throw b
		}
	} finally {
		return e
	}
}, validate: function () {
	if (!this.element.disabled) {
		var a = this.doValidations();
		if (a) {
			this.onValid();
			return true
		} else {
			this.onInvalid();
			return false
		}
	} else {
		return true
	}
}, enable: function () {
	this.element.disabled = false;
	return this
}, disable: function () {
	this.element.disabled = true;
	this.removeMessageAndFieldClass();
	return this
}, createMessageSpan: function () {
	var a = document.createElement("span");
	var b = document.createTextNode(this.message);
	a.appendChild(b);
	return a
}, insertMessage: function (b) {
	this.removeMessage();
	var a = this.validationFailed ? this.invalidClass : this.validClass;
	if ((this.displayMessageWhenEmpty && (this.elementType == LiveValidation.CHECKBOX || this.element.value == "")) || this.element.value != "") {
		$(b).addClassName(this.messageClass + (" " + a));
		if (nxtSibling = this.insertAfterWhatNode.nextSibling) {
			this.insertAfterWhatNode.parentNode.insertBefore(b, nxtSibling)
		} else {
			this.insertAfterWhatNode.parentNode.appendChild(b)
		}
	}
}, addFieldClass: function () {
	this.removeFieldClass();
	if (!this.validationFailed) {
		if (this.displayMessageWhenEmpty || this.element.value != "") {
			if (!this.element.hasClassName(this.validFieldClass)) {
				this.element.addClassName(this.validFieldClass)
			}
		}
	} else {
		if (!this.element.hasClassName(this.invalidFieldClass)) {
			this.element.addClassName(this.invalidFieldClass)
		}
	}
}, removeMessage: function () {
	if (nxtEl = this.insertAfterWhatNode.next("." + this.messageClass)) {
		nxtEl.remove()
	}
}, removeFieldClass: function () {
	this.element.removeClassName(this.invalidFieldClass);
	this.element.removeClassName(this.validFieldClass)
}, removeMessageAndFieldClass: function () {
	this.removeMessage();
	this.removeFieldClass()
}};
var LiveValidationForm = Class.create();
Object.extend(LiveValidationForm, {instances: {}, getInstance: function (a) {
	var b = Math.random() * Math.random();
	if (!a.id) {
		a.id = "formId_" + b.toString().replace(/\./, "") + new Date().valueOf()
	}
	if (!LiveValidationForm.instances[a.id]) {
		LiveValidationForm.instances[a.id] = new LiveValidationForm(a)
	}
	return LiveValidationForm.instances[a.id]
}});
LiveValidationForm.prototype = {initialize: function (a) {
	this.element = $(a);
	this.fields = [];
	this.oldOnSubmit = this.element.onsubmit || function () {
	};
	this.element.onsubmit = function (c) {
		var b = (LiveValidation.massValidate(this.fields)) ? this.oldOnSubmit.call(this.element, c) !== false : false;
		if (!b) {
			Event.stop(c)
		}
	}.bindAsEventListener(this)
}, addField: function (a) {
	this.fields.push(a)
}, removeField: function (a) {
	this.fields = this.fields.without(a)
}, destroy: function (a) {
	if (this.fields.length != 0 && !a) {
		return false
	}
	this.element.onsubmit = this.oldOnSubmit;
	LiveValidationForm.instances[this.element.id] = null;
	return true
}};
var Validate = {Presence: function (a, b) {
	var c = Object.extend({failureMessage: "Can't be empty!"}, b || {});
	if (a === "" || a === null || a === undefined) {
		Validate.fail(c.failureMessage)
	}
	return true
}, Numericality: function (b, c) {
	var a = b;
	var b = Number(b);
	var c = c || {};
	var d = {notANumberMessage: c.notANumberMessage || "Must be a number!", notAnIntegerMessage: c.notAnIntegerMessage || "Must be an integer!", wrongNumberMessage: c.wrongNumberMessage || "Must be " + c.is + "!", tooLowMessage: c.tooLowMessage || "Must not be less than " + c.minimum + "!", tooHighMessage: c.tooHighMessage || "Must not be more than " + c.maximum + "!", is: ((c.is) || (c.is == 0)) ? c.is : null, minimum: ((c.minimum) || (c.minimum == 0)) ? c.minimum : null, maximum: ((c.maximum) || (c.maximum == 0)) ? c.maximum : null, onlyInteger: c.onlyInteger || false};
	if (!isFinite(b)) {
		Validate.fail(d.notANumberMessage)
	}
	if (d.onlyInteger && ((/\.0+$|\.$/.test(String(a))) || (b != parseInt(b)))) {
		Validate.fail(d.notAnIntegerMessage)
	}
	switch (true) {
		case (d.is !== null):
			if (b != Number(d.is)) {
				Validate.fail(d.wrongNumberMessage)
			}
			break;
		case (d.minimum !== null && d.maximum !== null):
			Validate.Numericality(b, {tooLowMessage: d.tooLowMessage, minimum: d.minimum});
			Validate.Numericality(b, {tooHighMessage: d.tooHighMessage, maximum: d.maximum});
			break;
		case (d.minimum !== null):
			if (b < Number(d.minimum)) {
				Validate.fail(d.tooLowMessage)
			}
			break;
		case (d.maximum !== null):
			if (b > Number(d.maximum)) {
				Validate.fail(d.tooHighMessage)
			}
			break
	}
	return true
}, Format: function (a, b) {
	var a = String(a);
	var c = Object.extend({failureMessage: "Not valid!", pattern: /./, negate: false}, b || {});
	if (!c.negate && !c.pattern.test(a)) {
		Validate.fail(c.failureMessage)
	}
	if (c.negate && c.pattern.test(a)) {
		Validate.fail(c.failureMessage)
	}
	return true
}, Email: function (a, b) {
	var c = Object.extend({failureMessage: "Must be a valid email address!"}, b || {});
	Validate.Format(a, {failureMessage: c.failureMessage, pattern: /^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i});
	return true
}, Length: function (a, b) {
	var a = String(a);
	var b = b || {};
	var c = {wrongLengthMessage: b.wrongLengthMessage || "Must be " + b.is + " characters long!", tooShortMessage: b.tooShortMessage || "Must not be less than " + b.minimum + " characters long!", tooLongMessage: b.tooLongMessage || "Must not be more than " + b.maximum + " characters long!", is: ((b.is) || (b.is == 0)) ? b.is : null, minimum: ((b.minimum) || (b.minimum == 0)) ? b.minimum : null, maximum: ((b.maximum) || (b.maximum == 0)) ? b.maximum : null};
	switch (true) {
		case (c.is !== null):
			if (a.length != Number(c.is)) {
				Validate.fail(c.wrongLengthMessage)
			}
			break;
		case (c.minimum !== null && c.maximum !== null):
			Validate.Length(a, {tooShortMessage: c.tooShortMessage, minimum: c.minimum});
			Validate.Length(a, {tooLongMessage: c.tooLongMessage, maximum: c.maximum});
			break;
		case (c.minimum !== null):
			if (a.length < Number(c.minimum)) {
				Validate.fail(c.tooShortMessage)
			}
			break;
		case (c.maximum !== null):
			if (a.length > Number(c.maximum)) {
				Validate.fail(c.tooLongMessage)
			}
			break;
		default:
			throw new Error("Validate::Length - Length(s) to validate against must be provided!")
	}
	return true
}, Inclusion: function (c, d) {
	var e = Object.extend({failureMessage: "Must be included in the list!", within: [], allowNull: false, partialMatch: false, caseSensitive: true, negate: false}, d || {});
	if (e.allowNull && c == null) {
		return true
	}
	if (!e.allowNull && c == null) {
		Validate.fail(e.failureMessage)
	}
	if (!e.caseSensitive) {
		var a = [];
		e.within.each(function (f) {
			if (typeof f == "string") {
				f = f.toLowerCase()
			}
			a.push(f)
		});
		e.within = a;
		if (typeof c == "string") {
			c = c.toLowerCase()
		}
	}
	var b = (e.within.indexOf(c) == -1) ? false : true;
	if (e.partialMatch) {
		b = false;
		e.within.each(function (f) {
			if (c.indexOf(f) != -1) {
				b = true
			}
		})
	}
	if ((!e.negate && !b) || (e.negate && b)) {
		Validate.fail(e.failureMessage)
	}
	return true
}, Exclusion: function (a, b) {
	var c = Object.extend({failureMessage: "Must not be included in the list!", within: [], allowNull: false, partialMatch: false, caseSensitive: true}, b || {});
	c.negate = true;
	Validate.Inclusion(a, c);
	return true
}, Confirmation: function (a, b) {
	if (!b.match) {
		throw new Error("Validate::Confirmation - Error validating confirmation: Id of element to match must be provided!")
	}
	var c = Object.extend({failureMessage: "Does not match!", match: null}, b || {});
	c.match = $(b.match);
	if (!c.match) {
		throw new Error("Validate::Confirmation - There is no reference with name of, or element with id of '" + c.match + "'!")
	}
	if (a != c.match.value) {
		Validate.fail(c.failureMessage)
	}
	return true
}, Acceptance: function (a, b) {
	var c = Object.extend({failureMessage: "Must be accepted!"}, b || {});
	if (!a) {
		Validate.fail(c.failureMessage)
	}
	return true
}, Custom: function (a, b) {
	var c = Object.extend({against: function () {
		return true
	}, args: {}, failureMessage: "Not valid!"}, b || {});
	if (!c.against(a, c.args)) {
		Validate.fail(c.failureMessage)
	}
	return true
}, now: function (a, d, c) {
	if (!a) {
		throw new Error("Validate::now - Validation function must be provided!")
	}
	var e = true;
	try {
		a(d, c || {})
	} catch (b) {
		if (b instanceof Validate.Error) {
			e = false
		} else {
			throw b
		}
	} finally {
		return e
	}
}, Error: function (a) {
	this.message = a;
	this.name = "ValidationError"
}, fail: function (a) {
	throw new Validate.Error(a)
}};
var XWiki = (function (XWiki) {
// Start XWiki augmentation.
	var widgets = XWiki.widgets = XWiki.widgets || {};
	/**
	 * Full screen editing for textareas or maximizable elements.
	 *
	 * TODO Revisit once the new WYSIWYG supports inline editing.
	 */
	widgets.FullScreen = Class.create({
		// Some layout settings, to be customized for other skins
		/** Maximized element margins */
		margin: 0,
		/** Full screen activator / deactivator button size */
		buttonSize: 16,
		editFullScreenLabel: "GEL_$jsontool.serialize($services.localization.render('core.editors.fullscreen.editFullScreen'))_GEL",
		exitFullScreenLabel: "GEL_$jsontool.serialize($services.localization.render('core.editors.fullscreen.exitFullScreen'))_GEL",
		/**
		 * Full screen control initialization
		 * Identifies the elements that must be visible in full screen: the textarea or the rich text editor, along with their
		 * toolbar and the form buttons.
		 * Creates two buttons for closing the fullscreen: one (image) to insert in the toolbar, and one (plain form button)
		 * to add next to the form's action buttons.
		 * Finally, the textareas and rich text editors in the form are equipped with their own fullscreen activators,
		 * inserted in the corresponding toolbar, if there is any, or simply next to the textarea in the document
		 * (see the {@link #addBehavior} function),
		 */
		initialize: function () {
			// The action buttons need to be visible in full screen
			this.buttons = $(document.body).down(".bottombuttons");
			// If there are no buttons, at least the Exit FS button should be visible, so create an empty button container
			if (!this.buttons) {
				this.buttons = new Element("div", {"class": "bottombuttons"}).update(new Element("div", {"class": "buttons"}));
				this.buttons._x_isCustom = true;
				// It doesn't matter where the container is, it will only be needed in fullScreen.
				document.body.appendChild(this.buttons.hide());
			}
			// When the full screen is activated, the buttons will be brought in the fullscreen, thus removed from their parent
			// element, where they are replaced by a placeholder, so that we know exactly where to put them back.
			this.buttonsPlaceholder = new Element("span");
			// Placeholder for the toolbar, see above.
			this.toolbarPlaceholder = new Element("span");
			// The controls that will close the fullscreen
			this.createCloseButtons();
			// Prepare textareas / maximizable elements for full screen editing
			$$('textarea', '.maximizable').each(function (element) {
				this.addBehavior(element);
			}.bind(this));
			document.observe('xwiki:dom:updated', function (event) {
				event.memo.elements.each(function (element) {
					element.select('textarea', '.maximizable').each(function (element) {
						this.addBehavior(element);
					}.bind(this));
				}.bind(this));
			}.bind(this));
			// The GWT editor removes the textarea from the document, thus should be treated separately
			$$('.xRichTextEditor').each(function (item) {
				this.addBehavior(item);
			}.bind(this));
			// WYSIWYGR sends events when a new editor is created.
			this.addWysiwygListeners();
			// When comming back from preview, check if the user was in full screen before hitting preview, and if so restore
			// that full screen
			this.maximizedReference = $(document.body).down("input[name='x-maximized']");
			if (this.maximizedReference && this.maximizedReference.value != "") {
				var matches = $$(this.maximizedReference.value);
				if (matches && matches.length > 0) {
					this.makeFullScreen(matches[0]);
				}
			}
			// Cleanup before the window unloads.
			this.unloadHandler = this.cleanup.bind(this);
			Event.observe(window, 'unload', this.unloadHandler);
		},
		/** According to the type of each element being maximized, a button in created and attached to it. */
		addBehavior: function (item) {
			if (this.isWysiwyg20Content(item)) {
				this.addWysiwyg20ContentButton(item);
			} else if (this.isWysiwyg10Content(item)) {
				this.addWysiwyg10ContentButton(item);
			} else if (this.isWikiContent(item)) {
				this.addWikiContentButton(item);
			} else if (this.isWysiwyg20Field(item)) {
				this.addWysiwyg20FieldButton(item);
			} else if (this.isWikiField(item)) {
				this.addWikiFieldButton(item);
			} else if (this.isWysiwyg10Field(item)) {
				this.addWysiwyg10FieldButton(item);
			} else {
				// a div element with class maximazable
				this.addElementButton(item);
			}
		},
		addWysiwygListeners: function () {
			document.observe('xwiki:wysiwyg:created', this.wysiwyg20Created.bindAsEventListener(this));
			document.observe('xwiki:tinymce:created', this.wysiwyg10Created.bindAsEventListener(this));
		},
		wysiwyg10Created: function (event) {
			var item = $(event.memo.instance);
			this.removeTextareaLink(item);
			this.addBehavior(item);
		},
		wysiwyg20Created: function (event) {
			var item = $(event.memo.instance.getRichTextArea()).up(".xRichTextEditor");
			this.removeTextareaLink(item);
			this.addBehavior(item);
		},
		/* Remove the old maximize link inserted for the plain textarea before the WYSIWYG was loaded. */
		removeTextareaLink: function (item) {
			while (true) {
				if (!item) {
					return;
				} else if (item.previous(".fullScreenEditLinkContainer")) {
					item.previous(".fullScreenEditLinkContainer").remove();
					return;
				}
				item = item.up();
			}
		},
		// Some simple functions that help deciding what kind of editor is the target element
		isWikiContent: function (textarea) {
			// If the textarea is not visible, then the WYSIWYG editor is active.
			return textarea.name == 'content' && textarea.visible();
		},
		isWysiwyg10Content: function (textarea) {
			// If the textarea is not visible, then the WYSIWYG editor is active.
			// In IE, the WYSIWYG is placed before its textarea.
			return textarea.name == 'content' && (Prototype.Browser.IE ? textarea.previous(".mceEditorContainer") : textarea.next(".mceEditorContainer"));
		},
		isWysiwyg20Content: function (item) {
			return item.hasClassName("xRichTextEditor") && item.up("div[id^=content_container]");
		},
		isWikiField: function (textarea) {
			// If the textarea is not visible, then the WYSIWYG editor is active.
			return textarea.visible();
		},
		isWysiwyg10Field: function (textarea) {
			return !textarea.visible() && textarea.name != 'content' && (Prototype.Browser.IE ? textarea.previous(".mceEditorContainer") : textarea.next(".mceEditorContainer"));
		},
		isWysiwyg20Field: function (item) {
			return item.hasClassName("xRichTextEditor") && !item.up("div[id^=content_container]");
		},
		/** Adds the fullscreen button in the Wiki editor toolbar. */
		addWikiContentButton: function (textarea) {
			textarea._toolbar = $(document.body).down(".leftmenu2");
			// Normally there should be a simple toolbar with basic actions
			if (textarea._toolbar) {
				textarea._toolbar.insert({top: this.createOpenButton(textarea)});
			} else {
				this.addWikiFieldButton(textarea);
			}
		},
		/** Adds the fullscreen button in the TinyMCE WYSIWYG editor toolbar. */
		addWysiwyg10ContentButton: function (item) {
			var container = (Prototype.Browser.IE ? item.previous(".mceEditorContainer") : item.next(".mceEditorContainer"));
			if (!container) {
				return false;
			}
			var toolbar = container.down(".mceToolbar");
			if (!toolbar) {
				return false;
			}
			// Create a tinymce-like internal toolbar to contain the fullscreen button
			var newToolbar = new Element('span', {'class': 'mce_editor_fullscreentoolbar'});
			var link = new Element('a', {'class': 'mceButtonNormal'});
			// Separator
			newToolbar.insert(new Element('img', {
				'class': 'mceSeparatorLine',
				height: 15,
				width: 1,
				src: toolbar.down('img.mceSeparatorLine').src
			}));
			newToolbar.insert(link.insert(this.createOpenButton(container)));
			toolbar.insert(newToolbar);
			container._toolbar = toolbar;
			return true;
		},
		/** Adds the fullscreen button in the GWT WYSIWYGR editor menu. */
		addWysiwyg20ContentButton: function (item) {
			var toolbar = item.down(".gwt-MenuBar");
			// Sometimes the toolbar isn't loaded when this method executes (in IE). Schedule a periodical reatempt.
			if (!toolbar) {
				// Only schedule once
				if (!item._x_fullScreenLoader) {
					item._x_fullScreenLoader_iterations = 0;
					item._x_fullScreenLoader = new PeriodicalExecuter(function (item) {
						// Give up after 20 seconds
						if (item._x_fullScreenLoader_iteration > 100) {
							item._x_fullScreenLoader.stop();
							item._x_fullScreenLoader = false;
							return;
						}
						item._x_fullScreenLoader_iteration++;
						this.addWysiwyg20ContentButton(item);
					}.bind(this, item), 0.2);
				}
				return false;
			}
			toolbar.insert({"top": this.createOpenButton(item)});
			item._toolbar = toolbar;
			if (item._x_fullScreenLoader) {
				item._x_fullScreenLoader.stop();
				item._x_fullScreenLoader = false;
			}
			return true;
		},
		addElementButton: function (element) {
			Element.insert(element, {before: this.createOpenLink(element)});
		},
		addWikiFieldButton: function (textarea) {
			Element.insert(textarea, {before: this.createOpenLink(textarea)});
		},
		addWysiwyg10FieldButton: function (textarea) {
			this.addWysiwyg10ContentButton(textarea);
		},
		addWysiwyg20FieldButton: function (textarea) {
			this.addWysiwyg20ContentButton(textarea);
		},
		/** Creates a full screen activator button for the given element. */
		createOpenButton: function (targetElement) {
			// Create HTML element
			var fullScreenActivator = new Element('img', {
				'class': 'fullScreenEditButton',
				title: this.editFullScreenLabel,
				alt: this.editFullScreenLabel,
				src: "resources/icons/silk/arrow_out.png" //@@"$jsontool.serialize($xwiki.getSkinFile('icons/silk/arrow_out.png'))"
			});
			// Add functionality
			fullScreenActivator.observe('click', this.makeFullScreen.bind(this, targetElement));
			fullScreenActivator.observe('mousedown', this.preventDrag.bindAsEventListener(this));
			// Remember the button associated with each maximizable element
			targetElement._x_fullScreenActivator = fullScreenActivator;
			fullScreenActivator._x_maximizedElement = targetElement;
			return fullScreenActivator;
		},
		createOpenLink: function (targetElement) {
			// Create HTML element
			var fullScreenActivatorContainer = new Element('div', {
				'class': 'fullScreenEditLinkContainer'
			});
			var fullScreenActivator = new Element('a', {
				'class': 'fullScreenEditLink',
				title: this.editFullScreenLabel
			}).update(this.editFullScreenLabel + ' &raquo;');
			// Add functionality
			fullScreenActivator.observe('click', this.makeFullScreen.bind(this, targetElement));
			// Add it to the container
			fullScreenActivatorContainer.update(fullScreenActivator);
			// Remember the button associated with each maximizable element
			targetElement._x_fullScreenActivator = fullScreenActivator;
			fullScreenActivator._x_maximizedElement = targetElement;
			return fullScreenActivatorContainer;
		},
		/**
		 * Creates the full screen close buttons (which are generic, not attached to the maximized elements like the activators)
		 */
		createCloseButtons: function () {
			// Toolbar image button
			// Create HTML element
			this.closeButton = new Element('img', {
				'class': 'fullScreenCloseButton',
				title: this.exitFullScreenLabel,
				alt: this.exitFullScreenLabel,
				src: "resources/icons/silk/arrow_in.png" //@@@"GEL_$jsontool.serialize($xwiki.getSkinFile('icons/silk/arrow_in.png'))_GEL"
			});
			// Add functionality
			this.closeButton.observe('click', this.closeFullScreen.bind(this));
			this.closeButton.observe('mousedown', this.preventDrag.bindAsEventListener(this));
			// Hide by default
			this.closeButton.hide();

			// Edit actions button
			// Create HTML element
			this.actionCloseButton = new Element('input', {
				type: 'button',
				'class': 'button',
				value: this.exitFullScreenLabel
			});
			this.actionCloseButtonWrapper = new Element('span', {
				'class': 'buttonwrapper'
			});
			this.actionCloseButtonWrapper.update(this.actionCloseButton);
			// Add functionality
			this.actionCloseButton.observe('click', this.closeFullScreen.bind(this));
			// Hide by default
			this.actionCloseButtonWrapper.hide();
			// Add it in the action bar
			this.buttons.down(".buttons").insert({top: this.actionCloseButtonWrapper});
		},

		/**
		 * How this works:
		 * - All the elements between the targetElement and the root element are maximized, and all the other nodes are hidden
		 * - The parent element becomes a wrapper around the targetElement
		 * - Move the toolbar (if it exists) and the action buttons in the wrapper
		 * - Hide the overflows of the body element, so that a scrollbar doesn't appear
		 * - All the initial styles of the altered elements are remembered, so that they can be restored when exiting fullscreen
		 */
		makeFullScreen: function (targetElement) {
			document.fire("xwiki:fullscreen:enter", { "target": targetElement });
			// Store the selector of the target element in the form, in the hidden input called 'x-maximized'.
			// This is needed so that the full screen can be reactivated when comming back from preview, if it was activate before
			// the user hit the preview button.
			if (this.maximizedReference) {
				if (targetElement.id) {
					// Using #ID fails since the IDs for the textareas in inline editing contain the '.' character, which marks a classname
					this.maximizedReference.value = targetElement.tagName + "[id='" + targetElement.id + "']";
				} else if (targetElement.name) {
					this.maximizedReference.value = targetElement.tagName + "[name='" + targetElement.name + "']";
				} else if (targetElement.className) {
					// No id, no name. This must be the GWT editor...
					this.maximizedReference.value = targetElement.tagName + "." + targetElement.className;
				}
			}
			// Remember the maximized element
			this.maximized = targetElement;
			// Remember the cursor position and scroll offset (needed for circumventing https://bugzilla.mozilla.org/show_bug.cgi?id=633789 )
			if (typeof targetElement.setSelectionRange == 'function') {
				var selectionStart = targetElement.selectionStart;
				var selectionEnd = targetElement.selectionEnd;
				var scrollTop = targetElement.scrollTop;
			}
			// Remember the original dimensions of the maximized element
			targetElement._originalStyle = {
				'width': targetElement.style['width'],
				'height': targetElement.style['height']
			};
			if (targetElement.hasClassName("xRichTextEditor")) {
				var iframe = targetElement.down(".gwt-RichTextArea");
				// We store the original style of the rich text area on the editor element because the in-line frame used to
				// implement the rich text area is renewed each time the rich text area is reloaded (e.g. when adding or editing a
				// macro) to prevent the browser from adding a new history entry. The WYSIWYG editor could copy the JavaScript
				// object properties whenever the in-line frame is cloned but it would have to filter some internal properties
				// specific to GWT. Let's keep the hack here, for the moment. The code is not generic anyway.
				targetElement._richTextAreaOriginalStyle = {
					'width': iframe.style['width'],
					'height': iframe.style['height']
				};
			} else if (targetElement.hasClassName("mceEditorContainer")) {
				var iframe = targetElement.down(".mceEditorIframe");
				iframe._originalStyle = {
					'width': iframe.style['width'],
					'height': iframe.style['height']
				};
				var tframe = targetElement.down(".mceEditorSource");
				tframe._originalStyle = {
					'width': tframe.style['width'],
					'height': tframe.style['height']
				};
			}
			// All the elements between the targetElement and the root element are set to position: static, so that the offset
			// parent of the targetElement will be the window. Remember the previous settings in order to be able to restore the
			// layout when exiting fullscreen.
			var wrapper = targetElement.up();
			wrapper.addClassName("fullScreenWrapper");
			if (targetElement._toolbar) {
				// The wiki editor has the toolbar outside the textarea element, unlike the other editors, which have it as a descendant
				if (targetElement._toolbar.hasClassName("leftmenu2")) {
					wrapper.insert({"top": targetElement._toolbar.replace(this.toolbarPlaceholder)});
				}
				// Replace the Maximize button in the toolbar with the Restore one
				targetElement._x_fullScreenActivator.replace(this.closeButton);
			}
			wrapper.insert(this.buttons.replace(this.buttonsPlaceholder).show());
			var parent = targetElement.up();
			targetElement._x_fullScreenActivator.hide();
			while (parent != document.body) {
				parent._originalStyle = {
					'overflow': parent.style['overflow'],
					'position': parent.style['position'],
					'width': parent.style['width'],
					'height': parent.style['height'],
					'left': parent.style['left'],
					'right': parent.style['right'],
					'top': parent.style['top'],
					'bottom': parent.style['bottom'],
					'padding': parent.style['padding'],
					'margin': parent.style['margin']
				};
				parent.setStyle({'overflow': "visible", 'position': "absolute", width: "100%", height: "100%", left: 0, top: 0, right: 0, bottom: 0, padding: 0, margin: 0});
				parent.siblings().each(function (item) {
					item._originalDisplay = item.style['display'];
					item.setStyle({display: "none"});
					// We tag this element to know that we have hidden it, and that we should rollback the original style when we
					// close the fullscreen mode.
					// We have introduced this variable because _originalDisplay can be null so we cannot rely on this variable
					// to know if either or not we have hidden the element.
					item._fullscreenHidden = true;
				});
				parent = parent.up();
			}
			document.body._originalStyle = {
				'overflow': parent.style['overflow'],
				'width': parent.style['width'],
				'height': parent.style['height']
			};
			var root = $(document.body).up();
			root._originalStyle = {
				'overflow': root.style['overflow'],
				'width': root.style['width'],
				'height': root.style['height']
			};
			$(document.body).setStyle({'overflow': 'hidden', 'width': '100%', 'height': '100%'});
			root.setStyle({'overflow': "hidden", 'width': "100%", 'height': "100%"});

			// Make sure to resize the targetElement when the window dimensions are changed. Both document and window are monitored,
			// since different browsers send events to different elements.
			this.resizeListener = this.resizeTextArea.bind(this, targetElement);
			Event.observe(window, 'resize', this.resizeListener);
			// Show the exit buttons
			this.closeButton.show();
			this.actionCloseButtonWrapper.show();
			// Maximize the targetElement
			this.resizeTextArea(targetElement);
			// IE6 has yet another bug, if we don't call this, then sometimes the toolbar will be invisible. Don't ask why.
			if (targetElement._toolbar) {
				targetElement._toolbar.viewportOffset();
			}
			// Reset the cursor and scroll offset
			if (typeof targetElement.setSelectionRange == 'function') {
				// This is approximate, since the textarea width changes, and more lines can fit in the same vertical space
				targetElement.scrollTop = scrollTop;
				targetElement.selectionStart = selectionStart;
				targetElement.selectionEnd = selectionEnd;
			}
			document.fire("xwiki:fullscreen:entered", { "target": targetElement });
		},
		/** Restore the layout. */
		closeFullScreen: function () {
			var targetElement = this.maximized;
			document.fire("xwiki:fullscreen:exit", { "target": targetElement });
			// Remember the cursor position and scroll offset (needed for circumventing https://bugzilla.mozilla.org/show_bug.cgi?id=633789 )
			if (typeof targetElement.setSelectionRange == 'function') {
				var selectionStart = targetElement.selectionStart;
				var selectionEnd = targetElement.selectionEnd;
				var scrollTop = targetElement.scrollTop;
			}
			// Hide the exit buttons
			this.closeButton.hide();
			this.actionCloseButtonWrapper.hide();
			// We're no longer interested in resize events
			Event.stopObserving(window, 'resize', this.resizeListener);
			// Restore the parent element (the wrapper)
			targetElement.up().removeClassName("fullScreenWrapper");
			// Restore the WYSIWYGs
			if (targetElement.hasClassName("xRichTextEditor")) {
				var iframe = targetElement.down(".gwt-RichTextArea");
				iframe.setStyle(targetElement._richTextAreaOriginalStyle);
			} else if (targetElement.hasClassName("mceEditorContainer")) {
				var iframe = targetElement.down(".mceEditorIframe");
				iframe.setStyle(iframe._originalStyle);
				var tframe = targetElement.down(".mceEditorSource");
				tframe.setStyle(tframe._originalStyle);
			}

			// Restore the previous layout
			// NOTE: We restore the previous layout in reverse order (from the document body down to the target element) to
			// overcome a IE7 bug (see http://jira.xwiki.org/jira/browse/XWIKI-4346 ).
			var parent = targetElement.up();
			var parents = [];
			while (parent != document.body) {
				parents.push(parent);
				parent = parent.up();
			}
			var i = parents.length;
			while (i--) {
				parent = parents[i];
				parent.setStyle(parent._originalStyle);
				parent.siblings().each(function (item) {
					// if the element has been hidden by us, we should rollback its style
					if (item._fullscreenHidden) {
						// IE8 does not like null values. Default to "" (specific to each element's type) for elements that were added
						// while in full screen mode (like the Save & Continue notifications) and which don't have the _originalDisplay set.
						item.style['display'] = item._originalDisplay || "";
					}
				});
			}
			document.body.setStyle(document.body._originalStyle);
			$(document.body).up().setStyle($(document.body).up()._originalStyle);
			// Restore the toolbar and action buttons to their initial position
			this.buttonsPlaceholder.replace(this.buttons);
			if (this.buttons._x_isCustom) {
				this.buttons.hide();
			}
			if (targetElement._toolbar) {
				if (targetElement._toolbar.hasClassName("leftmenu2")) {
					this.toolbarPlaceholder.replace(targetElement._toolbar);
				}
				// Replace the Restore button in the toolbar with the Maximize one
				this.closeButton.replace(targetElement._x_fullScreenActivator);
			}
			if (Prototype.Browser.IE) {
				// IE crashes if we try to resize this without a bit of delay.
				setTimeout(function () {
					targetElement._x_fullScreenActivator.show();
					this.setStyle(this._originalStyle);
				}.bind(targetElement), 500);
			} else {
				targetElement._x_fullScreenActivator.show();
				targetElement.setStyle(targetElement._originalStyle);
			}
			// No element is maximized anymore
			delete this.maximized;
			if (this.maximizedReference) {
				this.maximizedReference.value = '';
			}
			// Reset the cursor and scroll offset
			if (typeof targetElement.setSelectionRange == 'function') {
				// This is approximate, since the textarea width changes, and more lines can fit in the same vertical space
				targetElement.scrollTop = scrollTop;
				targetElement.selectionStart = selectionStart;
				targetElement.selectionEnd = selectionEnd;
			}
			document.fire("xwiki:fullscreen:exited", { "target": targetElement });
		},
		/** In full screen, when the containers's dimensions change, the maximized element must be resized accordingly. */
		resizeTextArea: function (targetElement) {
			if (!this.maximized) {
				return;
			}
			// Compute the maximum space available for the textarea:
			var newHeight = document.viewport.getHeight();
			var newWidth = document.viewport.getWidth();
			// Prototype fails to return the right viewport in IE6. This works:
			if (newWidth <= 0) {
				newWidth = document.body.clientWidth;
				newHeight = document.body.clientHeight;
			}
			// Window width - styling padding
			newWidth = newWidth - this.margin;
			// Window height - margin (for the toolbar) - styling padding - buttons
			newHeight = newHeight - targetElement.positionedOffset().top - this.margin - this.buttons.getHeight();
			targetElement.setStyle({'width': newWidth + 'px', 'height': newHeight + 'px'});
			// Resize the WYSIWYGs
			if (targetElement.hasClassName("xRichTextEditor")) {
				targetElement.down(".gwt-RichTextArea").setStyle({'width': newWidth + 'px', 'height': newHeight - targetElement.down(".xToolbar").getHeight() - targetElement.down(".gwt-MenuBar").getHeight() + 'px'});
			} else if (targetElement.hasClassName("mceEditorContainer")) {
				targetElement.down(".mceEditorIframe").setStyle({'width': newWidth + 'px', 'height': newHeight - targetElement._toolbar.getHeight() + 'px'});
				targetElement.down(".mceEditorSource").setStyle({'width': newWidth + 'px', 'height': newHeight - targetElement._toolbar.getHeight() + 'px'});
			}
			document.fire("xwiki:fullscreen:resized", { "target": targetElement });
		},
		/** onMouseDown handler that prevents dragging the button. */
		preventDrag: function (event) {
			event.stop();
		},
		/** Cleans up the DOM tree when the user leaves the current page. */
		cleanup: function () {
			Event.stopObserving(window, 'unload', this.unloadHandler);
			// Remove the "Exit full screen" action button because it can interfere with the browser's back-forward cache.
			// This can throw an exception in certain browsers (IE9 for one), since the DOM may be already cleaned
			try {
				this.actionCloseButtonWrapper.remove();
			} catch (ex) {
				// Not important, just ignore
			}
		}
	});

	function init() {
		return new widgets.FullScreen();
	}

// When the document is loaded, enable the fullscreen behavior.
	(XWiki.domIsLoaded && init())
	|| document.observe("xwiki:dom:loaded", init);
// End XWiki augmentation.
	return XWiki;
}(XWiki || {}));


if (!Control) {
	var Control = {}
}
Control.Slider = Class.create({initialize: function (d, a, b) {
	var c = this;
	if (Object.isArray(d)) {
		this.handles = d.collect(function (f) {
			return $(f)
		})
	} else {
		this.handles = [$(d)]
	}
	this.track = $(a);
	this.options = b || {};
	this.axis = this.options.axis || "horizontal";
	this.increment = this.options.increment || 1;
	this.step = parseInt(this.options.step || "1");
	this.range = this.options.range || $R(0, 1);
	this.value = 0;
	this.values = this.handles.map(function () {
		return 0
	});
	this.spans = this.options.spans ? this.options.spans.map(function (e) {
		return $(e)
	}) : false;
	this.options.startSpan = $(this.options.startSpan || null);
	this.options.endSpan = $(this.options.endSpan || null);
	this.restricted = this.options.restricted || false;
	this.maximum = this.options.maximum || this.range.end;
	this.minimum = this.options.minimum || this.range.start;
	this.alignX = parseInt(this.options.alignX || "0");
	this.alignY = parseInt(this.options.alignY || "0");
	this.trackLength = this.maximumOffset() - this.minimumOffset();
	this.handleLength = this.isVertical() ? (this.handles[0].offsetHeight != 0 ? this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/, "")) : (this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth : this.handles[0].style.width.replace(/px$/, ""));
	this.active = false;
	this.dragging = false;
	this.disabled = false;
	if (this.options.disabled) {
		this.setDisabled()
	}
	this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
	if (this.allowedValues) {
		this.minimum = this.allowedValues.min();
		this.maximum = this.allowedValues.max()
	}
	this.eventMouseDown = this.startDrag.bindAsEventListener(this);
	this.eventMouseUp = this.endDrag.bindAsEventListener(this);
	this.eventMouseMove = this.update.bindAsEventListener(this);
	this.handles.each(function (f, e) {
		e = c.handles.length - 1 - e;
		c.setValue(parseFloat((Object.isArray(c.options.sliderValue) ? c.options.sliderValue[e] : c.options.sliderValue) || c.range.start), e);
		f.makePositioned().observe("mousedown", c.eventMouseDown)
	});
	this.track.observe("mousedown", this.eventMouseDown);
	document.observe("mouseup", this.eventMouseUp);
	document.observe("mousemove", this.eventMouseMove);
	this.initialized = true
}, dispose: function () {
	var a = this;
	Event.stopObserving(this.track, "mousedown", this.eventMouseDown);
	Event.stopObserving(document, "mouseup", this.eventMouseUp);
	Event.stopObserving(document, "mousemove", this.eventMouseMove);
	this.handles.each(function (b) {
		Event.stopObserving(b, "mousedown", a.eventMouseDown)
	})
}, setDisabled: function () {
	this.disabled = true
}, setEnabled: function () {
	this.disabled = false
}, getNearestValue: function (a) {
	if (this.allowedValues) {
		if (a >= this.allowedValues.max()) {
			return(this.allowedValues.max())
		}
		if (a <= this.allowedValues.min()) {
			return(this.allowedValues.min())
		}
		var c = Math.abs(this.allowedValues[0] - a);
		var b = this.allowedValues[0];
		this.allowedValues.each(function (d) {
			var e = Math.abs(d - a);
			if (e <= c) {
				b = d;
				c = e
			}
		});
		return b
	}
	if (a > this.range.end) {
		return this.range.end
	}
	if (a < this.range.start) {
		return this.range.start
	}
	return a
}, setValue: function (b, a) {
	if (!this.active) {
		this.activeHandleIdx = a || 0;
		this.activeHandle = this.handles[this.activeHandleIdx];
		this.updateStyles()
	}
	a = a || this.activeHandleIdx || 0;
	if (this.initialized && this.restricted) {
		if ((a > 0) && (b < this.values[a - 1])) {
			b = this.values[a - 1]
		}
		if ((a < (this.handles.length - 1)) && (b > this.values[a + 1])) {
			b = this.values[a + 1]
		}
	}
	b = this.getNearestValue(b);
	this.values[a] = b;
	this.value = this.values[0];
	this.handles[a].style[this.isVertical() ? "top" : "left"] = this.translateToPx(b);
	this.drawSpans();
	if (!this.dragging || !this.event) {
		this.updateFinished()
	}
}, setValueBy: function (b, a) {
	this.setValue(this.values[a || this.activeHandleIdx || 0] + b, a || this.activeHandleIdx || 0)
}, translateToPx: function (a) {
	return Math.round(((this.trackLength - this.handleLength) / (this.range.end - this.range.start)) * (a - this.range.start)) + "px"
}, translateToValue: function (a) {
	return((a / (this.trackLength - this.handleLength) * (this.range.end - this.range.start)) + this.range.start)
}, getRange: function (b) {
	var a = this.values.sortBy(Prototype.K);
	b = b || 0;
	return $R(a[b], a[b + 1])
}, minimumOffset: function () {
	return(this.isVertical() ? this.alignY : this.alignX)
}, maximumOffset: function () {
	return(this.isVertical() ? (this.track.offsetHeight != 0 ? this.track.offsetHeight : this.track.style.height.replace(/px$/, "")) - this.alignY : (this.track.offsetWidth != 0 ? this.track.offsetWidth : this.track.style.width.replace(/px$/, "")) - this.alignX)
}, isVertical: function () {
	return(this.axis == "vertical")
}, drawSpans: function () {
	var a = this;
	if (this.spans) {
		$R(0, this.spans.length - 1).each(function (b) {
			a.setSpan(a.spans[b], a.getRange(b))
		})
	}
	if (this.options.startSpan) {
		this.setSpan(this.options.startSpan, $R(0, this.values.length > 1 ? this.getRange(0).min() : this.value))
	}
	if (this.options.endSpan) {
		this.setSpan(this.options.endSpan, $R(this.values.length > 1 ? this.getRange(this.spans.length - 1).max() : this.value, this.maximum))
	}
}, setSpan: function (b, a) {
	if (this.isVertical()) {
		b.style.top = this.translateToPx(a.start);
		b.style.height = this.translateToPx(a.end - a.start + this.range.start)
	} else {
		b.style.left = this.translateToPx(a.start);
		b.style.width = this.translateToPx(a.end - a.start + this.range.start)
	}
}, updateStyles: function () {
	this.handles.each(function (a) {
		Element.removeClassName(a, "selected")
	});
	Element.addClassName(this.activeHandle, "selected")
}, startDrag: function (c) {
	if (Event.isLeftClick(c)) {
		if (!this.disabled) {
			this.active = true;
			var d = Event.element(c);
			var e = [Event.pointerX(c), Event.pointerY(c)];
			var a = d;
			if (a == this.track) {
				var b = this.track.cumulativeOffset();
				this.event = c;
				this.setValue(this.translateToValue((this.isVertical() ? e[1] - b[1] : e[0] - b[0]) - (this.handleLength / 2)));
				var b = this.activeHandle.cumulativeOffset();
				this.offsetX = (e[0] - b[0]);
				this.offsetY = (e[1] - b[1])
			} else {
				while ((this.handles.indexOf(d) == -1) && d.parentNode) {
					d = d.parentNode
				}
				if (this.handles.indexOf(d) != -1) {
					this.activeHandle = d;
					this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
					this.updateStyles();
					var b = this.activeHandle.cumulativeOffset();
					this.offsetX = (e[0] - b[0]);
					this.offsetY = (e[1] - b[1])
				}
			}
		}
		Event.stop(c)
	}
}, update: function (a) {
	if (this.active) {
		if (!this.dragging) {
			this.dragging = true
		}
		this.draw(a);
		if (Prototype.Browser.WebKit) {
			window.scrollBy(0, 0)
		}
		Event.stop(a)
	}
}, draw: function (b) {
	var c = [Event.pointerX(b), Event.pointerY(b)];
	var a = this.track.cumulativeOffset();
	c[0] -= this.offsetX + a[0];
	c[1] -= this.offsetY + a[1];
	this.event = b;
	this.setValue(this.translateToValue(this.isVertical() ? c[1] : c[0]));
	if (this.initialized && this.options.onSlide) {
		this.options.onSlide(this.values.length > 1 ? this.values : this.value, this)
	}
}, endDrag: function (a) {
	if (this.active && this.dragging) {
		this.finishDrag(a, true);
		Event.stop(a)
	}
	this.active = false;
	this.dragging = false
}, finishDrag: function (a, b) {
	this.active = false;
	this.dragging = false;
	this.updateFinished()
}, updateFinished: function () {
	if (this.initialized && this.options.onChange) {
		this.options.onChange(this.values.length > 1 ? this.values : this.value, this)
	}
	this.event = null
}});
// script.aculo.us dragdrop.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

if (Object.isUndefined(Effect))
	throw("dragdrop.js requires including script.aculo.us' effects.js library");

var Droppables = {
	drops: [],

	remove: function (element) {
		this.drops = this.drops.reject(function (d) {
			return d.element == $(element)
		});
	},

	add: function (element) {
		element = $(element);
		var options = Object.extend({
			greedy: true,
			hoverclass: null,
			tree: false
		}, arguments[1] || { });

		// cache containers
		if (options.containment) {
			options._containers = [];
			var containment = options.containment;
			if (Object.isArray(containment)) {
				containment.each(function (c) {
					options._containers.push($(c))
				});
			} else {
				options._containers.push($(containment));
			}
		}

		if (options.accept) options.accept = [options.accept].flatten();

		Element.makePositioned(element); // fix IE
		options.element = element;

		this.drops.push(options);
	},

	findDeepestChild: function (drops) {
		deepest = drops[0];

		for (i = 1; i < drops.length; ++i)
			if (Element.isParent(drops[i].element, deepest.element))
				deepest = drops[i];

		return deepest;
	},

	isContained: function (element, drop) {
		var containmentNode;
		if (drop.tree) {
			containmentNode = element.treeNode;
		} else {
			containmentNode = element.parentNode;
		}
		return drop._containers.detect(function (c) {
			return containmentNode == c
		});
	},

	isAffected: function (point, element, drop) {
		return (
			(drop.element != element) &&
			((!drop._containers) ||
				this.isContained(element, drop)) &&
			((!drop.accept) ||
				(Element.classNames(element).detect(
					function (v) {
						return drop.accept.include(v)
					}) )) &&
			Position.within(drop.element, point[0], point[1]) );
	},

	deactivate: function (drop) {
		if (drop.hoverclass)
			Element.removeClassName(drop.element, drop.hoverclass);
		this.last_active = null;
	},

	activate: function (drop) {
		if (drop.hoverclass)
			Element.addClassName(drop.element, drop.hoverclass);
		this.last_active = drop;
	},

	show: function (point, element, event) {
		if (!this.drops.length) return;
		var drop, affected = [];

		this.drops.each(function (drop) {
			if (Droppables.isAffected(point, element, drop))
				affected.push(drop);
		});

		if (affected.length > 0)
			drop = Droppables.findDeepestChild(affected);

		if (this.last_active && this.last_active != drop) this.deactivate(this.last_active);
		if (drop) {
			Position.within(drop.element, point[0], point[1]);
			if (drop.onHover)
				drop.onHover(element, drop.element, Position.overlap(drop.overlap, drop.element), event);

			if (drop != this.last_active) Droppables.activate(drop);
		}
	},

	fire: function (event, element) {
		if (!this.last_active) return;
		Position.prepare();

		if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active))
			if (this.last_active.onDrop) {
				this.last_active.onDrop(element, this.last_active.element, event);
				return true;
			}
	},

	reset: function () {
		if (this.last_active)
			this.deactivate(this.last_active);
	}
};

var Draggables = {
	drags: [],
	observers: [],

	register: function (draggable) {
		if (this.drags.length == 0) {
			this.eventMouseUp = this.endDrag.bindAsEventListener(this);
			this.eventMouseMove = this.updateDrag.bindAsEventListener(this);
			this.eventKeypress = this.keyPress.bindAsEventListener(this);

			Event.observe(document, "mouseup", this.eventMouseUp);
			Event.observe(document, "mousemove", this.eventMouseMove);
			Event.observe(document, "keypress", this.eventKeypress);
		}
		this.drags.push(draggable);
	},

	unregister: function (draggable) {
		this.drags = this.drags.reject(function (d) {
			return d == draggable
		});
		if (this.drags.length == 0) {
			Event.stopObserving(document, "mouseup", this.eventMouseUp);
			Event.stopObserving(document, "mousemove", this.eventMouseMove);
			Event.stopObserving(document, "keypress", this.eventKeypress);
		}
	},

	activate: function (draggable) {
		if (draggable.options.delay) {
			this._timeout = setTimeout(function () {
				Draggables._timeout = null;
				window.focus();
				Draggables.activeDraggable = draggable;
			}.bind(this), draggable.options.delay);
		} else {
			window.focus(); // allows keypress events if window isn't currently focused, fails for Safari
			this.activeDraggable = draggable;
		}
	},

	deactivate: function () {
		this.activeDraggable = null;
	},

	updateDrag: function (event) {
		if (!this.activeDraggable) return;
		var pointer = [Event.pointerX(event), Event.pointerY(event)];
		// Mozilla-based browsers fire successive mousemove events with
		// the same coordinates, prevent needless redrawing (moz bug?)
		if (this._lastPointer && (this._lastPointer.inspect() == pointer.inspect())) return;
		this._lastPointer = pointer;

		this.activeDraggable.updateDrag(event, pointer);
	},

	endDrag: function (event) {
		if (this._timeout) {
			clearTimeout(this._timeout);
			this._timeout = null;
		}
		if (!this.activeDraggable) return;
		this._lastPointer = null;
		this.activeDraggable.endDrag(event);
		this.activeDraggable = null;
	},

	keyPress: function (event) {
		if (this.activeDraggable)
			this.activeDraggable.keyPress(event);
	},

	addObserver: function (observer) {
		this.observers.push(observer);
		this._cacheObserverCallbacks();
	},

	removeObserver: function (element) {  // element instead of observer fixes mem leaks
		this.observers = this.observers.reject(function (o) {
			return o.element == element
		});
		this._cacheObserverCallbacks();
	},

	notify: function (eventName, draggable, event) {  // 'onStart', 'onEnd', 'onDrag'
		if (this[eventName + 'Count'] > 0)
			this.observers.each(function (o) {
				if (o[eventName]) o[eventName](eventName, draggable, event);
			});
		if (draggable.options[eventName]) draggable.options[eventName](draggable, event);
	},

	_cacheObserverCallbacks: function () {
		['onStart', 'onEnd', 'onDrag'].each(function (eventName) {
			Draggables[eventName + 'Count'] = Draggables.observers.select(
				function (o) {
					return o[eventName];
				}
			).length;
		});
	}
};

/*--------------------------------------------------------------------------*/

var Draggable = Class.create({
	initialize: function (element) {
		var defaults = {
			handle: false,
			reverteffect: function (element, top_offset, left_offset) {
				var dur = Math.sqrt(Math.abs(top_offset ^ 2) + Math.abs(left_offset ^ 2)) * 0.02;
				new Effect.Move(element, { x: -left_offset, y: -top_offset, duration: dur,
					queue: {scope: '_draggable', position: 'end'}
				});
			},
			endeffect: function (element) {
				var toOpacity = Object.isNumber(element._opacity) ? element._opacity : 1.0;
				new Effect.Opacity(element, {duration: 0.2, from: 0.7, to: toOpacity,
					queue: {scope: '_draggable', position: 'end'},
					afterFinish: function () {
						Draggable._dragging[element] = false
					}
				});
			},
			zindex: 1000,
			revert: false,
			quiet: false,
			scroll: false,
			scrollSensitivity: 20,
			scrollSpeed: 15,
			snap: false,  // false, or xy or [x,y] or function(x,y){ return [x,y] }
			delay: 0
		};

		if (!arguments[1] || Object.isUndefined(arguments[1].endeffect))
			Object.extend(defaults, {
				starteffect: function (element) {
					element._opacity = Element.getOpacity(element);
					Draggable._dragging[element] = true;
					new Effect.Opacity(element, {duration: 0.2, from: element._opacity, to: 0.7});
				}
			});

		var options = Object.extend(defaults, arguments[1] || { });

		this.element = $(element);

		if (options.handle && Object.isString(options.handle))
			this.handle = this.element.down('.' + options.handle, 0);

		if (!this.handle) this.handle = $(options.handle);
		if (!this.handle) this.handle = this.element;

		if (options.scroll && !options.scroll.scrollTo && !options.scroll.outerHTML) {
			options.scroll = $(options.scroll);
			this._isScrollChild = Element.childOf(this.element, options.scroll);
		}

		Element.makePositioned(this.element); // fix IE

		this.options = options;
		this.dragging = false;

		this.eventMouseDown = this.initDrag.bindAsEventListener(this);
		Event.observe(this.handle, "mousedown", this.eventMouseDown);

		Draggables.register(this);
	},

	destroy: function () {
		Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
		Draggables.unregister(this);
	},

	currentDelta: function () {
		return([
			parseInt(Element.getStyle(this.element, 'left') || '0'),
			parseInt(Element.getStyle(this.element, 'top') || '0')]);
	},

	initDrag: function (event) {
		if (!Object.isUndefined(Draggable._dragging[this.element]) &&
			Draggable._dragging[this.element]) return;
		if (Event.isLeftClick(event)) {
			// abort on form elements, fixes a Firefox issue
			var src = Event.element(event);
			if ((tag_name = src.tagName.toUpperCase()) && (
				tag_name == 'INPUT' ||
				tag_name == 'SELECT' ||
				tag_name == 'OPTION' ||
				tag_name == 'BUTTON' ||
				tag_name == 'TEXTAREA')) return;

			var pointer = [Event.pointerX(event), Event.pointerY(event)];
			var pos = this.element.cumulativeOffset();
			this.offset = [0, 1].map(function (i) {
				return (pointer[i] - pos[i])
			});

			Draggables.activate(this);
			Event.stop(event);
		}
	},

	startDrag: function (event) {
		this.dragging = true;
		if (!this.delta)
			this.delta = this.currentDelta();

		if (this.options.zindex) {
			this.originalZ = parseInt(Element.getStyle(this.element, 'z-index') || 0);
			this.element.style.zIndex = this.options.zindex;
		}

		if (this.options.ghosting) {
			this._clone = this.element.cloneNode(true);
			this._originallyAbsolute = (this.element.getStyle('position') == 'absolute');
			if (!this._originallyAbsolute)
				Position.absolutize(this.element);
			this.element.parentNode.insertBefore(this._clone, this.element);
		}

		if (this.options.scroll) {
			if (this.options.scroll == window) {
				var where = this._getWindowScroll(this.options.scroll);
				this.originalScrollLeft = where.left;
				this.originalScrollTop = where.top;
			} else {
				this.originalScrollLeft = this.options.scroll.scrollLeft;
				this.originalScrollTop = this.options.scroll.scrollTop;
			}
		}

		Draggables.notify('onStart', this, event);

		if (this.options.starteffect) this.options.starteffect(this.element);
	},

	updateDrag: function (event, pointer) {
		if (!this.dragging) this.startDrag(event);

		if (!this.options.quiet) {
			Position.prepare();
			Droppables.show(pointer, this.element, event);
		}

		Draggables.notify('onDrag', this, event);

		this.draw(pointer);
		if (this.options.change) this.options.change(this);

		if (this.options.scroll) {
			this.stopScrolling();

			var p;
			if (this.options.scroll == window) {
				with (this._getWindowScroll(this.options.scroll)) {
					p = [ left, top, left + width, top + height ];
				}
			} else {
				p = Position.page(this.options.scroll).toArray();
				p[0] += this.options.scroll.scrollLeft + Position.deltaX;
				p[1] += this.options.scroll.scrollTop + Position.deltaY;
				p.push(p[0] + this.options.scroll.offsetWidth);
				p.push(p[1] + this.options.scroll.offsetHeight);
			}
			var speed = [0, 0];
			if (pointer[0] < (p[0] + this.options.scrollSensitivity)) speed[0] = pointer[0] - (p[0] + this.options.scrollSensitivity);
			if (pointer[1] < (p[1] + this.options.scrollSensitivity)) speed[1] = pointer[1] - (p[1] + this.options.scrollSensitivity);
			if (pointer[0] > (p[2] - this.options.scrollSensitivity)) speed[0] = pointer[0] - (p[2] - this.options.scrollSensitivity);
			if (pointer[1] > (p[3] - this.options.scrollSensitivity)) speed[1] = pointer[1] - (p[3] - this.options.scrollSensitivity);
			this.startScrolling(speed);
		}

		// fix AppleWebKit rendering
		if (Prototype.Browser.WebKit) window.scrollBy(0, 0);

		Event.stop(event);
	},

	finishDrag: function (event, success) {
		this.dragging = false;

		if (this.options.quiet) {
			Position.prepare();
			var pointer = [Event.pointerX(event), Event.pointerY(event)];
			Droppables.show(pointer, this.element, event);
		}

		if (this.options.ghosting) {
			if (!this._originallyAbsolute)
				Position.relativize(this.element);
			delete this._originallyAbsolute;
			Element.remove(this._clone);
			this._clone = null;
		}

		var dropped = false;
		if (success) {
			dropped = Droppables.fire(event, this.element);
			if (!dropped) dropped = false;
		}
		if (dropped && this.options.onDropped) this.options.onDropped(this.element);
		Draggables.notify('onEnd', this, event);

		var revert = this.options.revert;
		if (revert && Object.isFunction(revert)) revert = revert(this.element);

		var d = this.currentDelta();
		if (revert && this.options.reverteffect) {
			if (dropped == 0 || revert != 'failure')
				this.options.reverteffect(this.element,
						d[1] - this.delta[1], d[0] - this.delta[0]);
		} else {
			this.delta = d;
		}

		if (this.options.zindex)
			this.element.style.zIndex = this.originalZ;

		if (this.options.endeffect)
			this.options.endeffect(this.element);

		Draggables.deactivate(this);
		Droppables.reset();
	},

	keyPress: function (event) {
		if (event.keyCode != Event.KEY_ESC) return;
		this.finishDrag(event, false);
		Event.stop(event);
	},

	endDrag: function (event) {
		if (!this.dragging) return;
		this.stopScrolling();
		this.finishDrag(event, true);
		Event.stop(event);
	},

	draw: function (point) {
		var pos = this.element.cumulativeOffset();
		if (this.options.ghosting) {
			var r = Position.realOffset(this.element);
			pos[0] += r[0] - Position.deltaX;
			pos[1] += r[1] - Position.deltaY;
		}

		var d = this.currentDelta();
		pos[0] -= d[0];
		pos[1] -= d[1];

		if (this.options.scroll && (this.options.scroll != window && this._isScrollChild)) {
			pos[0] -= this.options.scroll.scrollLeft - this.originalScrollLeft;
			pos[1] -= this.options.scroll.scrollTop - this.originalScrollTop;
		}

		var p = [0, 1].map(function (i) {
			return (point[i] - pos[i] - this.offset[i])
		}.bind(this));

		if (this.options.snap) {
			if (Object.isFunction(this.options.snap)) {
				p = this.options.snap(p[0], p[1], this);
			} else {
				if (Object.isArray(this.options.snap)) {
					p = p.map(function (v, i) {
						return (v / this.options.snap[i]).round() * this.options.snap[i]
					}.bind(this));
				} else {
					p = p.map(function (v) {
						return (v / this.options.snap).round() * this.options.snap
					}.bind(this));
				}
			}
		}

		var style = this.element.style;
		if ((!this.options.constraint) || (this.options.constraint == 'horizontal'))
			style.left = p[0] + "px";
		if ((!this.options.constraint) || (this.options.constraint == 'vertical'))
			style.top = p[1] + "px";

		if (style.visibility == "hidden") style.visibility = ""; // fix gecko rendering
	},

	stopScrolling: function () {
		if (this.scrollInterval) {
			clearInterval(this.scrollInterval);
			this.scrollInterval = null;
			Draggables._lastScrollPointer = null;
		}
	},

	startScrolling: function (speed) {
		if (!(speed[0] || speed[1])) return;
		this.scrollSpeed = [speed[0] * this.options.scrollSpeed, speed[1] * this.options.scrollSpeed];
		this.lastScrolled = new Date();
		this.scrollInterval = setInterval(this.scroll.bind(this), 10);
	},

	scroll: function () {
		var current = new Date();
		var delta = current - this.lastScrolled;
		this.lastScrolled = current;
		if (this.options.scroll == window) {
			with (this._getWindowScroll(this.options.scroll)) {
				if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
					var d = delta / 1000;
					this.options.scroll.scrollTo(left + d * this.scrollSpeed[0], top + d * this.scrollSpeed[1]);
				}
			}
		} else {
			this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;
			this.options.scroll.scrollTop += this.scrollSpeed[1] * delta / 1000;
		}

		Position.prepare();
		Droppables.show(Draggables._lastPointer, this.element, null);
		Draggables.notify('onDrag', this);
		if (this._isScrollChild) {
			Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
			Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;
			Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;
			if (Draggables._lastScrollPointer[0] < 0)
				Draggables._lastScrollPointer[0] = 0;
			if (Draggables._lastScrollPointer[1] < 0)
				Draggables._lastScrollPointer[1] = 0;
			this.draw(Draggables._lastScrollPointer);
		}

		if (this.options.change) this.options.change(this);
	},

	_getWindowScroll: function (w) {
		var T, L, W, H;
		with (w.document) {
			if (w.document.documentElement && documentElement.scrollTop) {
				T = documentElement.scrollTop;
				L = documentElement.scrollLeft;
			} else if (w.document.body) {
				T = body.scrollTop;
				L = body.scrollLeft;
			}
			if (w.innerWidth) {
				W = w.innerWidth;
				H = w.innerHeight;
			} else if (w.document.documentElement && documentElement.clientWidth) {
				W = documentElement.clientWidth;
				H = documentElement.clientHeight;
			} else {
				W = body.offsetWidth;
				H = body.offsetHeight;
			}
		}
		return { top: T, left: L, width: W, height: H };
	}
});

Draggable._dragging = { };

/*--------------------------------------------------------------------------*/

var SortableObserver = Class.create({
	initialize: function (element, observer) {
		this.element = $(element);
		this.observer = observer;
		this.lastValue = Sortable.serialize(this.element);
	},

	onStart: function () {
		this.lastValue = Sortable.serialize(this.element);
	},

	onEnd: function () {
		Sortable.unmark();
		if (this.lastValue != Sortable.serialize(this.element))
			this.observer(this.element)
	}
});

var Sortable = {
	SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,

	sortables: { },

	_findRootElement: function (element) {
		while (element.tagName.toUpperCase() != "BODY") {
			if (element.id && Sortable.sortables[element.id]) return element;
			element = element.parentNode;
		}
	},

	options: function (element) {
		element = Sortable._findRootElement($(element));
		if (!element) return;
		return Sortable.sortables[element.id];
	},

	destroy: function (element) {
		element = $(element);
		var s = Sortable.sortables[element.id];

		if (s) {
			Draggables.removeObserver(s.element);
			s.droppables.each(function (d) {
				Droppables.remove(d)
			});
			s.draggables.invoke('destroy');

			delete Sortable.sortables[s.element.id];
		}
	},

	create: function (element) {
		element = $(element);
		var options = Object.extend({
			element: element,
			tag: 'li',       // assumes li children, override with tag: 'tagname'
			dropOnEmpty: false,
			tree: false,
			treeTag: 'ul',
			overlap: 'vertical', // one of 'vertical', 'horizontal'
			constraint: 'vertical', // one of 'vertical', 'horizontal', false
			containment: element,    // also takes array of elements (or id's); or false
			handle: false,      // or a CSS class
			only: false,
			delay: 0,
			hoverclass: null,
			ghosting: false,
			quiet: false,
			scroll: false,
			scrollSensitivity: 20,
			scrollSpeed: 15,
			format: this.SERIALIZE_RULE,

			// these take arrays of elements or ids and can be
			// used for better initialization performance
			elements: false,
			handles: false,

			onChange: Prototype.emptyFunction,
			onUpdate: Prototype.emptyFunction
		}, arguments[1] || { });

		// clear any old sortable with same element
		this.destroy(element);

		// build options for the draggables
		var options_for_draggable = {
			revert: true,
			quiet: options.quiet,
			scroll: options.scroll,
			scrollSpeed: options.scrollSpeed,
			scrollSensitivity: options.scrollSensitivity,
			delay: options.delay,
			ghosting: options.ghosting,
			constraint: options.constraint,
			handle: options.handle };

		if (options.starteffect)
			options_for_draggable.starteffect = options.starteffect;

		if (options.reverteffect)
			options_for_draggable.reverteffect = options.reverteffect;
		else if (options.ghosting) options_for_draggable.reverteffect = function (element) {
			element.style.top = 0;
			element.style.left = 0;
		};

		if (options.endeffect)
			options_for_draggable.endeffect = options.endeffect;

		if (options.zindex)
			options_for_draggable.zindex = options.zindex;

		// build options for the droppables
		var options_for_droppable = {
			overlap: options.overlap,
			containment: options.containment,
			tree: options.tree,
			hoverclass: options.hoverclass,
			onHover: Sortable.onHover
		};

		var options_for_tree = {
			onHover: Sortable.onEmptyHover,
			overlap: options.overlap,
			containment: options.containment,
			hoverclass: options.hoverclass
		};

		// fix for gecko engine
		Element.cleanWhitespace(element);

		options.draggables = [];
		options.droppables = [];

		// drop on empty handling
		if (options.dropOnEmpty || options.tree) {
			Droppables.add(element, options_for_tree);
			options.droppables.push(element);
		}

		(options.elements || this.findElements(element, options) || []).each(function (e, i) {
			var handle = options.handles ? $(options.handles[i]) :
				(options.handle ? $(e).select('.' + options.handle)[0] : e);
			options.draggables.push(
				new Draggable(e, Object.extend(options_for_draggable, { handle: handle })));
			Droppables.add(e, options_for_droppable);
			if (options.tree) e.treeNode = element;
			options.droppables.push(e);
		});

		if (options.tree) {
			(Sortable.findTreeElements(element, options) || []).each(function (e) {
				Droppables.add(e, options_for_tree);
				e.treeNode = element;
				options.droppables.push(e);
			});
		}

		// keep reference
		this.sortables[element.identify()] = options;

		// for onupdate
		Draggables.addObserver(new SortableObserver(element, options.onUpdate));

	},

	// return all suitable-for-sortable elements in a guaranteed order
	findElements: function (element, options) {
		return Element.findChildren(
			element, options.only, options.tree ? true : false, options.tag);
	},

	findTreeElements: function (element, options) {
		return Element.findChildren(
			element, options.only, options.tree ? true : false, options.treeTag);
	},

	onHover: function (element, dropon, overlap, event) {
		if (Element.isParent(dropon, element)) return;

		if (overlap > .33 && overlap < .66 && Sortable.options(dropon).tree) {
			return;
		} else if (overlap > 0.5) {
			Sortable.mark(dropon, 'before');
			if (dropon.previousSibling != element) {
				var oldParentNode = element.parentNode;
				element.style.visibility = "hidden"; // fix gecko rendering
				dropon.parentNode.insertBefore(element, dropon);
				if (dropon.parentNode != oldParentNode)
					Sortable.options(oldParentNode).onChange(element);
				Sortable.options(dropon.parentNode).onChange(element);
			}
		} else {
			Sortable.mark(dropon, 'after');
			var nextElement = dropon.nextSibling || null;
			if (nextElement != element) {
				var oldParentNode = element.parentNode;
				element.style.visibility = "hidden"; // fix gecko rendering
				dropon.parentNode.insertBefore(element, nextElement);
				if (dropon.parentNode != oldParentNode)
					Sortable.options(oldParentNode).onChange(element);
				Sortable.options(dropon.parentNode).onChange(element);
			}
		}
	},

	onEmptyHover: function (element, dropon, overlap) {
		var oldParentNode = element.parentNode;
		var droponOptions = Sortable.options(dropon);

		if (!Element.isParent(dropon, element)) {
			var index;

			var children = Sortable.findElements(dropon, {tag: droponOptions.tag, only: droponOptions.only});
			var child = null;

			if (children) {
				var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1.0 - overlap);

				for (index = 0; index < children.length; index += 1) {
					if (offset - Element.offsetSize(children[index], droponOptions.overlap) >= 0) {
						offset -= Element.offsetSize(children[index], droponOptions.overlap);
					} else if (offset - (Element.offsetSize(children[index], droponOptions.overlap) / 2) >= 0) {
						child = index + 1 < children.length ? children[index + 1] : null;
						break;
					} else {
						child = children[index];
						break;
					}
				}
			}

			dropon.insertBefore(element, child);

			Sortable.options(oldParentNode).onChange(element);
			droponOptions.onChange(element);
		}
	},

	unmark: function () {
		if (Sortable._marker) Sortable._marker.hide();
	},

	mark: function (dropon, position) {
		// mark on ghosting only
		var sortable = Sortable.options(dropon.parentNode);
		if (sortable && !sortable.ghosting) return;

		if (!Sortable._marker) {
			Sortable._marker =
				($('dropmarker') || Element.extend(document.createElement('DIV'))).
					hide().addClassName('dropmarker').setStyle({position: 'absolute'});
           document.getElementById(PedigreeEditorTool.divId).item(0).appendChild(Sortable._marker);
		}
		var offsets = dropon.cumulativeOffset();
		Sortable._marker.setStyle({left: offsets[0] + 'px', top: offsets[1] + 'px'});

		if (position == 'after')
			if (sortable.overlap == 'horizontal')
				Sortable._marker.setStyle({left: (offsets[0] + dropon.clientWidth) + 'px'});
			else
				Sortable._marker.setStyle({top: (offsets[1] + dropon.clientHeight) + 'px'});

		Sortable._marker.show();
	},

	_tree: function (element, options, parent) {
		var children = Sortable.findElements(element, options) || [];

		for (var i = 0; i < children.length; ++i) {
			var match = children[i].id.match(options.format);

			if (!match) continue;

			var child = {
				id: encodeURIComponent(match ? match[1] : null),
				element: element,
				parent: parent,
				children: [],
				position: parent.children.length,
				container: $(children[i]).down(options.treeTag)
			};

			/* Get the element containing the children and recurse over it */
			if (child.container)
				this._tree(child.container, options, child);

			parent.children.push(child);
		}

		return parent;
	},

	tree: function (element) {
		element = $(element);
		var sortableOptions = this.options(element);
		var options = Object.extend({
			tag: sortableOptions.tag,
			treeTag: sortableOptions.treeTag,
			only: sortableOptions.only,
			name: element.id,
			format: sortableOptions.format
		}, arguments[1] || { });

		var root = {
			id: null,
			parent: null,
			children: [],
			container: element,
			position: 0
		};

		return Sortable._tree(element, options, root);
	},

	/* Construct a [i] index for a particular node */
	_constructIndex: function (node) {
		var index = '';
		do {
			if (node.id) index = '[' + node.position + ']' + index;
		} while ((node = node.parent) != null);
		return index;
	},

	sequence: function (element) {
		element = $(element);
		var options = Object.extend(this.options(element), arguments[1] || { });

		return $(this.findElements(element, options) || []).map(function (item) {
			return item.id.match(options.format) ? item.id.match(options.format)[1] : '';
		});
	},

	setSequence: function (element, new_sequence) {
		element = $(element);
		var options = Object.extend(this.options(element), arguments[2] || { });

		var nodeMap = { };
		this.findElements(element, options).each(function (n) {
			if (n.id.match(options.format))
				nodeMap[n.id.match(options.format)[1]] = [n, n.parentNode];
			n.parentNode.removeChild(n);
		});

		new_sequence.each(function (ident) {
			var n = nodeMap[ident];
			if (n) {
				n[1].appendChild(n[0]);
				delete nodeMap[ident];
			}
		});
	},

	serialize: function (element) {
		element = $(element);
		var options = Object.extend(Sortable.options(element), arguments[1] || { });
		var name = encodeURIComponent(
			(arguments[1] && arguments[1].name) ? arguments[1].name : element.id);

		if (options.tree) {
			return Sortable.tree(element, arguments[1]).children.map(function (item) {
				return [name + Sortable._constructIndex(item) + "[id]=" +
					encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));
			}).flatten().join('&');
		} else {
			return Sortable.sequence(element, arguments[1]).map(function (item) {
				return name + "[]=" + encodeURIComponent(item);
			}).join('&');
		}
	}
};

// Returns true if child is contained within element
Element.isParent = function (child, element) {
	if (!child.parentNode || child == element) return false;
	if (child.parentNode == element) return true;
	return Element.isParent(child.parentNode, element);
};

Element.findChildren = function (element, only, recursive, tagName) {
	if (!element.hasChildNodes()) return null;
	tagName = tagName.toUpperCase();
	if (only) only = [only].flatten();
	var elements = [];
	$A(element.childNodes).each(function (e) {
		if (e.tagName && e.tagName.toUpperCase() == tagName &&
			(!only || (Element.classNames(e).detect(function (v) {
				return only.include(v)
			}))))
			elements.push(e);
		if (recursive) {
			var grandchildren = Element.findChildren(e, only, recursive, tagName);
			if (grandchildren) elements.push(grandchildren);
		}
	});

	return (elements.length > 0 ? elements.flatten() : []);
};

Element.offsetSize = function (element, type) {
	return element['offset' + ((type == 'vertical' || type == 'height') ? 'Height' : 'Width')];
};
// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.0 - JavaScript Vector Library                          │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

// ┌──────────────────────────────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.3.4 - JavaScript Events Library                                                │ \\
// ├──────────────────────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)          │ \\
// │ Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license. │ \\
// └──────────────────────────────────────────────────────────────────────────────────────┘ \\

(function (glob) {
	var version = "0.3.4",
		has = "hasOwnProperty",
		separator = /[\.\/]/,
		wildcard = "*",
		fun = function () {
		},
		numsort = function (a, b) {
			return a - b;
		},
		current_event,
		stop,
		events = {n: {}},

		eve = function (name, scope) {
			var e = events,
				oldstop = stop,
				args = Array.prototype.slice.call(arguments, 2),
				listeners = eve.listeners(name),
				z = 0,
				f = false,
				l,
				indexed = [],
				queue = {},
				out = [],
				ce = current_event,
				errors = [];
			current_event = name;
			stop = 0;
			for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
				indexed.push(listeners[i].zIndex);
				if (listeners[i].zIndex < 0) {
					queue[listeners[i].zIndex] = listeners[i];
				}
			}
			indexed.sort(numsort);
			while (indexed[z] < 0) {
				l = queue[indexed[z++]];
				out.push(l.apply(scope, args));
				if (stop) {
					stop = oldstop;
					return out;
				}
			}
			for (i = 0; i < ii; i++) {
				l = listeners[i];
				if ("zIndex" in l) {
					if (l.zIndex == indexed[z]) {
						out.push(l.apply(scope, args));
						if (stop) {
							break;
						}
						do {
							z++;
							l = queue[indexed[z]];
							l && out.push(l.apply(scope, args));
							if (stop) {
								break;
							}
						} while (l)
					} else {
						queue[l.zIndex] = l;
					}
				} else {
					out.push(l.apply(scope, args));
					if (stop) {
						break;
					}
				}
			}
			stop = oldstop;
			current_event = ce;
			return out.length ? out : null;
		};

	eve.listeners = function (name) {
		var names = name.split(separator),
			e = events,
			item,
			items,
			k,
			i,
			ii,
			j,
			jj,
			nes,
			es = [e],
			out = [];
		for (i = 0, ii = names.length; i < ii; i++) {
			nes = [];
			for (j = 0, jj = es.length; j < jj; j++) {
				e = es[j].n;
				items = [e[names[i]], e[wildcard]];
				k = 2;
				while (k--) {
					item = items[k];
					if (item) {
						nes.push(item);
						out = out.concat(item.f || []);
					}
				}
			}
			es = nes;
		}
		return out;
	};


	eve.on = function (name, f) {
		var names = name.split(separator),
			e = events;
		for (var i = 0, ii = names.length; i < ii; i++) {
			e = e.n;
			!e[names[i]] && (e[names[i]] = {n: {}});
			e = e[names[i]];
		}
		e.f = e.f || [];
		for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
			return fun;
		}
		e.f.push(f);
		return function (zIndex) {
			if (+zIndex == +zIndex) {
				f.zIndex = +zIndex;
			}
		};
	};

	eve.stop = function () {
		stop = 1;
	};

	eve.nt = function (subname) {
		if (subname) {
			return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
		}
		return current_event;
	};


	eve.off = eve.unbind = function (name, f) {
		var names = name.split(separator),
			e,
			key,
			splice,
			i, ii, j, jj,
			cur = [events];
		for (i = 0, ii = names.length; i < ii; i++) {
			for (j = 0; j < cur.length; j += splice.length - 2) {
				splice = [j, 1];
				e = cur[j].n;
				if (names[i] != wildcard) {
					if (e[names[i]]) {
						splice.push(e[names[i]]);
					}
				} else {
					for (key in e) if (e[has](key)) {
						splice.push(e[key]);
					}
				}
				cur.splice.apply(cur, splice);
			}
		}
		for (i = 0, ii = cur.length; i < ii; i++) {
			e = cur[i];
			while (e.n) {
				if (f) {
					if (e.f) {
						for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
							e.f.splice(j, 1);
							break;
						}
						!e.f.length && delete e.f;
					}
					for (key in e.n) if (e.n[has](key) && e.n[key].f) {
						var funcs = e.n[key].f;
						for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
							funcs.splice(j, 1);
							break;
						}
						!funcs.length && delete e.n[key].f;
					}
				} else {
					delete e.f;
					for (key in e.n) if (e.n[has](key) && e.n[key].f) {
						delete e.n[key].f;
					}
				}
				e = e.n;
			}
		}
	};

	eve.once = function (name, f) {
		var f2 = function () {
			var res = f.apply(this, arguments);
			eve.unbind(name, f2);
			return res;
		};
		return eve.on(name, f2);
	};

	eve.version = version;
	eve.toString = function () {
		return "You are running Eve " + version;
	};
	(typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function () {
		return eve;
	})) : (glob.eve = eve));
	glob.eve = eve;
})(this);


// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ "Raphaël 2.1.0" - JavaScript Vector Library                         │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
(function () {

	function R(first) {
		if (R.is(first, "function")) {
			return loaded ? first() : eve.on("raphael.DOMload", first);
		} else if (R.is(first, array)) {
			return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
		} else {
			var args = Array.prototype.slice.call(arguments, 0);
			if (R.is(args[args.length - 1], "function")) {
				var f = args.pop();
				return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
					f.call(R._engine.create[apply](R, args));
				});
			} else {
				return R._engine.create[apply](R, arguments);
			}
		}
	}

	R.version = "2.1.0";
	R.eve = eve;
	var loaded,
		separator = /[, ]+/,
		elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
		formatrg = /\{(\d+)\}/g,
		proto = "prototype",
		has = "hasOwnProperty",
		g = {
			doc: document,
			win: window
		},
		oldRaphael = {
			was: Object.prototype[has].call(g.win, "Raphael"),
			is: g.win.Raphael
		},
		Paper = function () {


			this.ca = this.customAttributes = {};
		},
		paperproto,
		appendChild = "appendChild",
		apply = "apply",
		concat = "concat",
		supportsTouch = false, //"createTouch" in g.doc,
		E = "",
		S = " ",
		Str = String,
		split = "split",
		events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
		touchMap = {
			mousedown: "touchstart",
			mousemove: "touchmove",
			mouseup: "touchend"
		},
		lowerCase = Str.prototype.toLowerCase,
		math = Math,
		mmax = math.max,
		mmin = math.min,
		abs = math.abs,
		pow = math.pow,
		PI = math.PI,
		nu = "number",
		string = "string",
		array = "array",
		toString = "toString",
		fillString = "fill",
		objectToString = Object.prototype.toString,
		paper = {},
		push = "push",
		ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
		colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
		isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
		bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
		round = math.round,
		setAttribute = "setAttribute",
		toFloat = parseFloat,
		toInt = parseInt,
		upperCase = Str.prototype.toUpperCase,
		availableAttrs = R._availableAttrs = {
			"arrow-end": "none",
			"arrow-start": "none",
			blur: 0,
			"clip-rect": "0 0 1e9 1e9",
			cursor: "default",
			cx: 0,
			cy: 0,
			fill: "#fff",
			"fill-opacity": 1,
			"font-family": '"Arial"',
			"font-size": "10",
			"font-style": "normal",
			"font-weight": 400,
			gradient: 0,
			height: 0,
			href: "http://raphaeljs.com/",
			"letter-spacing": 0,
			opacity: 1,
			path: "M0,0",
			r: 0,
			rx: 0,
			ry: 0,
			src: "",
			stroke: "#000",
			"stroke-dasharray": "",
			"stroke-linecap": "butt",
			"stroke-linejoin": "butt",
			"stroke-miterlimit": 0,
			"stroke-opacity": 1,
			"stroke-width": 1,
			target: "_blank",
			"text-anchor": "middle",
			title: "Raphael",
			transform: "",
			width: 0,
			x: 0,
			y: 0
		},
		availableAnimAttrs = R._availableAnimAttrs = {
			blur: nu,
			"clip-rect": "csv",
			cx: nu,
			cy: nu,
			fill: "colour",
			"fill-opacity": nu,
			"font-size": nu,
			height: nu,
			opacity: nu,
			path: "path",
			r: nu,
			rx: nu,
			ry: nu,
			stroke: "colour",
			"stroke-opacity": nu,
			"stroke-width": nu,
			transform: "transform",
			width: nu,
			x: nu,
			y: nu
		},
		whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
		commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
		hsrg = {hs: 1, rg: 1},
		p2s = /,?([achlmqrstvxz]),?/gi,
		pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
		tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
		pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
		radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
		eldata = {},
		sortByKey = function (a, b) {
			return a.key - b.key;
		},
		sortByNumber = function (a, b) {
			return toFloat(a) - toFloat(b);
		},
		fun = function () {
		},
		pipe = function (x) {
			return x;
		},
		rectPath = R._rectPath = function (x, y, w, h, r) {
			if (r) {
				return [
					["M", x + r, y],
					["l", w - r * 2, 0],
					["a", r, r, 0, 0, 1, r, r],
					["l", 0, h - r * 2],
					["a", r, r, 0, 0, 1, -r, r],
					["l", r * 2 - w, 0],
					["a", r, r, 0, 0, 1, -r, -r],
					["l", 0, r * 2 - h],
					["a", r, r, 0, 0, 1, r, -r],
					["z"]
				];
			}
			return [
				["M", x, y],
				["l", w, 0],
				["l", 0, h],
				["l", -w, 0],
				["z"]
			];
		},
		ellipsePath = function (x, y, rx, ry) {
			if (ry == null) {
				ry = rx;
			}
			return [
				["M", x, y],
				["m", 0, -ry],
				["a", rx, ry, 0, 1, 1, 0, 2 * ry],
				["a", rx, ry, 0, 1, 1, 0, -2 * ry],
				["z"]
			];
		},
		getPath = R._getPath = {
			path: function (el) {
				return el.attr("path");
			},
			circle: function (el) {
				var a = el.attrs;
				return ellipsePath(a.cx, a.cy, a.r);
			},
			ellipse: function (el) {
				var a = el.attrs;
				return ellipsePath(a.cx, a.cy, a.rx, a.ry);
			},
			rect: function (el) {
				var a = el.attrs;
				return rectPath(a.x, a.y, a.width, a.height, a.r);
			},
			image: function (el) {
				var a = el.attrs;
				return rectPath(a.x, a.y, a.width, a.height);
			},
			text: function (el) {
				var bbox = el._getBBox();
				return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
			}
		},

		mapPath = R.mapPath = function (path, matrix) {
			if (!matrix) {
				return path;
			}
			var x, y, i, j, ii, jj, pathi;
			path = path2curve(path);
			for (i = 0, ii = path.length; i < ii; i++) {
				pathi = path[i];
				for (j = 1, jj = pathi.length; j < jj; j += 2) {
					x = matrix.x(pathi[j], pathi[j + 1]);
					y = matrix.y(pathi[j], pathi[j + 1]);
					pathi[j] = x;
					pathi[j + 1] = y;
				}
			}
			return path;
		};

	R._g = g;

	R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
	if (R.type == "VML") {
		var d = g.doc.createElement("div"),
			b;
		d.innerHTML = '<v:shape adj="1"/>';
		b = d.firstChild;
		b.style.behavior = "url(#default#VML)";
		if (!(b && typeof b.adj == "object")) {
			return (R.type = E);
		}
		d = null;
	}


	R.svg = !(R.vml = R.type == "VML");
	R._Paper = Paper;

	R.fn = paperproto = Paper.prototype = R.prototype;
	R._id = 0;
	R._oid = 0;

	R.is = function (o, type) {
		type = lowerCase.call(type);
		if (type == "finite") {
			return !isnan[has](+o);
		}
		if (type == "array") {
			return o instanceof Array;
		}
		return  (type == "null" && o === null) ||
			(type == typeof o && o !== null) ||
			(type == "object" && o === Object(o)) ||
			(type == "array" && Array.isArray && Array.isArray(o)) ||
			objectToString.call(o).slice(8, -1).toLowerCase() == type;
	};

	function clone(obj) {
		if (Object(obj) !== obj || typeof obj === 'function') {
			return obj;
		}
		var res = new obj.constructor;
		for (var key in obj) if (obj[has](key)) {
			if (typeof obj[key] === 'object')
				res[key] = clone(obj[key]);
			else
				res[key] = obj[key];
		}
		return res;
	}


	R.angle = function (x1, y1, x2, y2, x3, y3) {
		if (x3 == null) {
			var x = x1 - x2,
				y = y1 - y2;
			if (!x && !y) {
				return 0;
			}
			return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
		} else {
			return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
		}
	};

	R.rad = function (deg) {
		return deg % 360 * PI / 180;
	};

	R.deg = function (rad) {
		return rad * 180 / PI % 360;
	};

	R.snapTo = function (values, value, tolerance) {
		tolerance = R.is(tolerance, "finite") ? tolerance : 10;
		if (R.is(values, array)) {
			var i = values.length;
			while (i--) if (abs(values[i] - value) <= tolerance) {
				return values[i];
			}
		} else {
			values = +values;
			var rem = value % values;
			if (rem < tolerance) {
				return value - rem;
			}
			if (rem > values - tolerance) {
				return value - rem + values;
			}
		}
		return value;
	};


	var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
		return function () {
			return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
		};
	})(/[xy]/g, function (c) {
		var r = math.random() * 16 | 0,
			v = c == "x" ? r : (r & 3 | 8);
		return v.toString(16);
	});


	R.setWindow = function (newwin) {
		eve("raphael.setWindow", R, g.win, newwin);
		g.win = newwin;
		g.doc = g.win.document;
		if (R._engine.initWin) {
			R._engine.initWin(g.win);
		}
	};
	var toHex = function (color) {
			if (R.vml) {
				// http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
				var trim = /^\s+|\s+$/g;
				var bod;
				try {
					var docum = new ActiveXObject("htmlfile");
					docum.write("<body>");
					docum.close();
					bod = docum.body;
				} catch (e) {
					bod = createPopup().document.body;
				}
				var range = bod.createTextRange();
				toHex = cacher(function (color) {
					try {
						bod.style.color = Str(color).replace(trim, E);
						var value = range.queryCommandValue("ForeColor");
						value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
						return "#" + ("000000" + value.toString(16)).slice(-6);
					} catch (e) {
						return "none";
					}
				});
			} else {
				var i = g.doc.createElement("i");
				i.title = "Rapha\xebl Colour Picker";
				i.style.display = "none";
				g.doc.body.appendChild(i);
				toHex = cacher(function (color) {
					i.style.color = color;
					return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
				});
			}
			return toHex(color);
		},
		hsbtoString = function () {
			return "hsb(" + [this.h, this.s, this.b] + ")";
		},
		hsltoString = function () {
			return "hsl(" + [this.h, this.s, this.l] + ")";
		},
		rgbtoString = function () {
			return this.hex;
		},
		prepareRGB = function (r, g, b) {
			if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
				b = r.b;
				g = r.g;
				r = r.r;
			}
			if (g == null && R.is(r, string)) {
				var clr = R.getRGB(r);
				r = clr.r;
				g = clr.g;
				b = clr.b;
			}
			if (r > 1 || g > 1 || b > 1) {
				r /= 255;
				g /= 255;
				b /= 255;
			}

			return [r, g, b];
		},
		packageRGB = function (r, g, b, o) {
			r *= 255;
			g *= 255;
			b *= 255;
			var rgb = {
				r: r,
				g: g,
				b: b,
				hex: R.rgb(r, g, b),
				toString: rgbtoString
			};
			R.is(o, "finite") && (rgb.opacity = o);
			return rgb;
		};


	R.color = function (clr) {
		var rgb;
		if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
			rgb = R.hsb2rgb(clr);
			clr.r = rgb.r;
			clr.g = rgb.g;
			clr.b = rgb.b;
			clr.hex = rgb.hex;
		} else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
			rgb = R.hsl2rgb(clr);
			clr.r = rgb.r;
			clr.g = rgb.g;
			clr.b = rgb.b;
			clr.hex = rgb.hex;
		} else {
			if (R.is(clr, "string")) {
				clr = R.getRGB(clr);
			}
			if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
				rgb = R.rgb2hsl(clr);
				clr.h = rgb.h;
				clr.s = rgb.s;
				clr.l = rgb.l;
				rgb = R.rgb2hsb(clr);
				clr.v = rgb.b;
			} else {
				clr = {hex: "none"};
				clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
			}
		}
		clr.toString = rgbtoString;
		return clr;
	};

	R.hsb2rgb = function (h, s, v, o) {
		if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
			v = h.b;
			s = h.s;
			h = h.h;
			o = h.o;
		}
		h *= 360;
		var R, G, B, X, C;
		h = (h % 360) / 60;
		C = v * s;
		X = C * (1 - abs(h % 2 - 1));
		R = G = B = v - C;

		h = ~~h;
		R += [C, X, 0, 0, X, C][h];
		G += [X, C, C, X, 0, 0][h];
		B += [0, 0, X, C, C, X][h];
		return packageRGB(R, G, B, o);
	};

	R.hsl2rgb = function (h, s, l, o) {
		if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
			l = h.l;
			s = h.s;
			h = h.h;
		}
		if (h > 1 || s > 1 || l > 1) {
			h /= 360;
			s /= 100;
			l /= 100;
		}
		h *= 360;
		var R, G, B, X, C;
		h = (h % 360) / 60;
		C = 2 * s * (l < .5 ? l : 1 - l);
		X = C * (1 - abs(h % 2 - 1));
		R = G = B = l - C / 2;

		h = ~~h;
		R += [C, X, 0, 0, X, C][h];
		G += [X, C, C, X, 0, 0][h];
		B += [0, 0, X, C, C, X][h];
		return packageRGB(R, G, B, o);
	};

	R.rgb2hsb = function (r, g, b) {
		b = prepareRGB(r, g, b);
		r = b[0];
		g = b[1];
		b = b[2];

		var H, S, V, C;
		V = mmax(r, g, b);
		C = V - mmin(r, g, b);
		H = (C == 0 ? null :
				V == r ? (g - b) / C :
				V == g ? (b - r) / C + 2 :
			(r - g) / C + 4
			);
		H = ((H + 360) % 6) * 60 / 360;
		S = C == 0 ? 0 : C / V;
		return {h: H, s: S, b: V, toString: hsbtoString};
	};

	R.rgb2hsl = function (r, g, b) {
		b = prepareRGB(r, g, b);
		r = b[0];
		g = b[1];
		b = b[2];

		var H, S, L, M, m, C;
		M = mmax(r, g, b);
		m = mmin(r, g, b);
		C = M - m;
		H = (C == 0 ? null :
				M == r ? (g - b) / C :
				M == g ? (b - r) / C + 2 :
			(r - g) / C + 4);
		H = ((H + 360) % 6) * 60 / 360;
		L = (M + m) / 2;
		S = (C == 0 ? 0 :
				L < .5 ? C / (2 * L) :
			C / (2 - 2 * L));
		return {h: H, s: S, l: L, toString: hsltoString};
	};
	R._path2string = function () {
		return this.join(",").replace(p2s, "$1");
	};
	function repush(array, item) {
		for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
			return array.push(array.splice(i, 1)[0]);
		}
	}

	function cacher(f, scope, postprocessor) {
		function newf() {
			var arg = Array.prototype.slice.call(arguments, 0),
				args = arg.join("\u2400"),
				cache = newf.cache = newf.cache || {},
				count = newf.count = newf.count || [];
			if (cache[has](args)) {
				repush(count, args);
				return postprocessor ? postprocessor(cache[args]) : cache[args];
			}
			count.length >= 1e3 && delete cache[count.shift()];
			count.push(args);
			cache[args] = f[apply](scope, arg);
			return postprocessor ? postprocessor(cache[args]) : cache[args];
		}

		return newf;
	}

	var preload = R._preload = function (src, f) {
		var img = g.doc.createElement("img");
		img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
		img.onload = function () {
			f.call(this);
			this.onload = null;
			g.doc.body.removeChild(this);
		};
		img.onerror = function () {
			g.doc.body.removeChild(this);
		};
		g.doc.body.appendChild(img);
		img.src = src;
	};

	function clrToString() {
		return this.hex;
	}


	R.getRGB = cacher(function (colour) {
		if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
			return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
		}
		if (colour == "none") {
			return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
		}
		!(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
		var res,
			red,
			green,
			blue,
			opacity,
			t,
			values,
			rgb = colour.match(colourRegExp);
		if (rgb) {
			if (rgb[2]) {
				blue = toInt(rgb[2].substring(5), 16);
				green = toInt(rgb[2].substring(3, 5), 16);
				red = toInt(rgb[2].substring(1, 3), 16);
			}
			if (rgb[3]) {
				blue = toInt((t = rgb[3].charAt(3)) + t, 16);
				green = toInt((t = rgb[3].charAt(2)) + t, 16);
				red = toInt((t = rgb[3].charAt(1)) + t, 16);
			}
			if (rgb[4]) {
				values = rgb[4][split](commaSpaces);
				red = toFloat(values[0]);
				values[0].slice(-1) == "%" && (red *= 2.55);
				green = toFloat(values[1]);
				values[1].slice(-1) == "%" && (green *= 2.55);
				blue = toFloat(values[2]);
				values[2].slice(-1) == "%" && (blue *= 2.55);
				rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
				values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
			}
			if (rgb[5]) {
				values = rgb[5][split](commaSpaces);
				red = toFloat(values[0]);
				values[0].slice(-1) == "%" && (red *= 2.55);
				green = toFloat(values[1]);
				values[1].slice(-1) == "%" && (green *= 2.55);
				blue = toFloat(values[2]);
				values[2].slice(-1) == "%" && (blue *= 2.55);
				(values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
				rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
				values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
				return R.hsb2rgb(red, green, blue, opacity);
			}
			if (rgb[6]) {
				values = rgb[6][split](commaSpaces);
				red = toFloat(values[0]);
				values[0].slice(-1) == "%" && (red *= 2.55);
				green = toFloat(values[1]);
				values[1].slice(-1) == "%" && (green *= 2.55);
				blue = toFloat(values[2]);
				values[2].slice(-1) == "%" && (blue *= 2.55);
				(values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
				rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
				values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
				return R.hsl2rgb(red, green, blue, opacity);
			}
			rgb = {r: red, g: green, b: blue, toString: clrToString};
			rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
			R.is(opacity, "finite") && (rgb.opacity = opacity);
			return rgb;
		}
		return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
	}, R);

	R.hsb = cacher(function (h, s, b) {
		return R.hsb2rgb(h, s, b).hex;
	});

	R.hsl = cacher(function (h, s, l) {
		return R.hsl2rgb(h, s, l).hex;
	});

	R.rgb = cacher(function (r, g, b) {
		return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
	});

	R.getColor = function (value) {
		var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
			rgb = this.hsb2rgb(start.h, start.s, start.b);
		start.h += .075;
		if (start.h > 1) {
			start.h = 0;
			start.s -= .2;
			start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
		}
		return rgb.hex;
	};

	R.getColor.reset = function () {
		delete this.start;
	};

	// http://schepers.cc/getting-to-the-point
	function catmullRom2bezier(crp, z) {
		var d = [];
		for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
			var p = [
				{x: +crp[i - 2], y: +crp[i - 1]},
				{x: +crp[i], y: +crp[i + 1]},
				{x: +crp[i + 2], y: +crp[i + 3]},
				{x: +crp[i + 4], y: +crp[i + 5]}
			];
			if (z) {
				if (!i) {
					p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
				} else if (iLen - 4 == i) {
					p[3] = {x: +crp[0], y: +crp[1]};
				} else if (iLen - 2 == i) {
					p[2] = {x: +crp[0], y: +crp[1]};
					p[3] = {x: +crp[2], y: +crp[3]};
				}
			} else {
				if (iLen - 4 == i) {
					p[3] = p[2];
				} else if (!i) {
					p[0] = {x: +crp[i], y: +crp[i + 1]};
				}
			}
			d.push(["C",
					(-p[0].x + 6 * p[1].x + p[2].x) / 6,
					(-p[0].y + 6 * p[1].y + p[2].y) / 6,
					(p[1].x + 6 * p[2].x - p[3].x) / 6,
					(p[1].y + 6 * p[2].y - p[3].y) / 6,
				p[2].x,
				p[2].y
			]);
		}

		return d;
	}

	R.parsePathString = function (pathString) {
		if (!pathString) {
			return null;
		}
		var pth = paths(pathString);
		if (pth.arr) {
			return pathClone(pth.arr);
		}

		var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
			data = [];
		if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
			data = pathClone(pathString);
		}
		if (!data.length) {
			Str(pathString).replace(pathCommand, function (a, b, c) {
				var params = [],
					name = b.toLowerCase();
				c.replace(pathValues, function (a, b) {
					b && params.push(+b);
				});
				if (name == "m" && params.length > 2) {
					data.push([b][concat](params.splice(0, 2)));
					name = "l";
					b = b == "m" ? "l" : "L";
				}
				if (name == "r") {
					data.push([b][concat](params));
				} else while (params.length >= paramCounts[name]) {
					data.push([b][concat](params.splice(0, paramCounts[name])));
					if (!paramCounts[name]) {
						break;
					}
				}
			});
		}
		data.toString = R._path2string;
		pth.arr = pathClone(data);
		return data;
	};

	R.parseTransformString = cacher(function (TString) {
		if (!TString) {
			return null;
		}
		var paramCounts = {r: 3, s: 4, t: 2, m: 6},
			data = [];
		if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
			data = pathClone(TString);
		}
		if (!data.length) {
			Str(TString).replace(tCommand, function (a, b, c) {
				var params = [],
					name = lowerCase.call(b);
				c.replace(pathValues, function (a, b) {
					b && params.push(+b);
				});
				data.push([b][concat](params));
			});
		}
		data.toString = R._path2string;
		return data;
	});
	// PATHS
	var paths = function (ps) {
		var p = paths.ps = paths.ps || {};
		if (p[ps]) {
			p[ps].sleep = 100;
		} else {
			p[ps] = {
				sleep: 100
			};
		}
		setTimeout(function () {
			for (var key in p) if (p[has](key) && key != ps) {
				p[key].sleep--;
				!p[key].sleep && delete p[key];
			}
		});
		return p[ps];
	};

	R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
		var t1 = 1 - t,
			t13 = pow(t1, 3),
			t12 = pow(t1, 2),
			t2 = t * t,
			t3 = t2 * t,
			x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
			y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
			mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
			my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
			nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
			ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
			ax = t1 * p1x + t * c1x,
			ay = t1 * p1y + t * c1y,
			cx = t1 * c2x + t * p2x,
			cy = t1 * c2y + t * p2y,
			alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
		(mx > nx || my < ny) && (alpha += 180);
		return {
			x: x,
			y: y,
			m: {x: mx, y: my},
			n: {x: nx, y: ny},
			start: {x: ax, y: ay},
			end: {x: cx, y: cy},
			alpha: alpha
		};
	};

	R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
		if (!R.is(p1x, "array")) {
			p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
		}
		var bbox = curveDim.apply(null, p1x);
		return {
			x: bbox.min.x,
			y: bbox.min.y,
			x2: bbox.max.x,
			y2: bbox.max.y,
			width: bbox.max.x - bbox.min.x,
			height: bbox.max.y - bbox.min.y
		};
	};

	R.isPointInsideBBox = function (bbox, x, y) {
		return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
	};

	R.isBBoxIntersect = function (bbox1, bbox2) {
		var i = R.isPointInsideBBox;
		return i(bbox2, bbox1.x, bbox1.y)
			|| i(bbox2, bbox1.x2, bbox1.y)
			|| i(bbox2, bbox1.x, bbox1.y2)
			|| i(bbox2, bbox1.x2, bbox1.y2)
			|| i(bbox1, bbox2.x, bbox2.y)
			|| i(bbox1, bbox2.x2, bbox2.y)
			|| i(bbox1, bbox2.x, bbox2.y2)
			|| i(bbox1, bbox2.x2, bbox2.y2)
			|| (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
			&& (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
	};
	function base3(t, p1, p2, p3, p4) {
		var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
			t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
		return t * t2 - 3 * p1 + 3 * p2;
	}

	function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
		if (z == null) {
			z = 1;
		}
		z = z > 1 ? 1 : z < 0 ? 0 : z;
		var z2 = z / 2,
			n = 12,
			Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
			Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
			sum = 0;
		for (var i = 0; i < n; i++) {
			var ct = z2 * Tvalues[i] + z2,
				xbase = base3(ct, x1, x2, x3, x4),
				ybase = base3(ct, y1, y2, y3, y4),
				comb = xbase * xbase + ybase * ybase;
			sum += Cvalues[i] * math.sqrt(comb);
		}
		return z2 * sum;
	}

	function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
		if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
			return;
		}
		var t = 1,
			step = t / 2,
			t2 = t - step,
			l,
			e = .01;
		l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
		while (abs(l - ll) > e) {
			step /= 2;
			t2 += (l < ll ? 1 : -1) * step;
			l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
		}
		return t2;
	}

	function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
		if (
			mmax(x1, x2) < mmin(x3, x4) ||
			mmin(x1, x2) > mmax(x3, x4) ||
			mmax(y1, y2) < mmin(y3, y4) ||
			mmin(y1, y2) > mmax(y3, y4)
			) {
			return;
		}
		var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
			ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
			denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

		if (!denominator) {
			return;
		}
		var px = nx / denominator,
			py = ny / denominator,
			px2 = +px.toFixed(2),
			py2 = +py.toFixed(2);
		if (
			px2 < +mmin(x1, x2).toFixed(2) ||
			px2 > +mmax(x1, x2).toFixed(2) ||
			px2 < +mmin(x3, x4).toFixed(2) ||
			px2 > +mmax(x3, x4).toFixed(2) ||
			py2 < +mmin(y1, y2).toFixed(2) ||
			py2 > +mmax(y1, y2).toFixed(2) ||
			py2 < +mmin(y3, y4).toFixed(2) ||
			py2 > +mmax(y3, y4).toFixed(2)
			) {
			return;
		}
		return {x: px, y: py};
	}

	function inter(bez1, bez2) {
		return interHelper(bez1, bez2);
	}

	function interCount(bez1, bez2) {
		return interHelper(bez1, bez2, 1);
	}

	function interHelper(bez1, bez2, justCount) {
		var bbox1 = R.bezierBBox(bez1),
			bbox2 = R.bezierBBox(bez2);
		if (!R.isBBoxIntersect(bbox1, bbox2)) {
			return justCount ? 0 : [];
		}
		var l1 = bezlen.apply(0, bez1),
			l2 = bezlen.apply(0, bez2),
			n1 = ~~(l1 / 5),
			n2 = ~~(l2 / 5),
			dots1 = [],
			dots2 = [],
			xy = {},
			res = justCount ? 0 : [];
		for (var i = 0; i < n1 + 1; i++) {
			var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
			dots1.push({x: p.x, y: p.y, t: i / n1});
		}
		for (i = 0; i < n2 + 1; i++) {
			p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
			dots2.push({x: p.x, y: p.y, t: i / n2});
		}
		for (i = 0; i < n1; i++) {
			for (var j = 0; j < n2; j++) {
				var di = dots1[i],
					di1 = dots1[i + 1],
					dj = dots2[j],
					dj1 = dots2[j + 1],
					ci = abs(di1.x - di.x) < .001 ? "y" : "x",
					cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
					is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
				if (is) {
					if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
						continue;
					}
					xy[is.x.toFixed(4)] = is.y.toFixed(4);
					var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
						t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
					if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
						if (justCount) {
							res++;
						} else {
							res.push({
								x: is.x,
								y: is.y,
								t1: t1,
								t2: t2
							});
						}
					}
				}
			}
		}
		return res;
	}

	R.pathIntersection = function (path1, path2) {
		return interPathHelper(path1, path2);
	};
	R.pathIntersectionNumber = function (path1, path2) {
		return interPathHelper(path1, path2, 1);
	};
	function interPathHelper(path1, path2, justCount) {
		path1 = R._path2curve(path1);
		path2 = R._path2curve(path2);
		var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
			res = justCount ? 0 : [];
		for (var i = 0, ii = path1.length; i < ii; i++) {
			var pi = path1[i];
			if (pi[0] == "M") {
				x1 = x1m = pi[1];
				y1 = y1m = pi[2];
			} else {
				if (pi[0] == "C") {
					bez1 = [x1, y1].concat(pi.slice(1));
					x1 = bez1[6];
					y1 = bez1[7];
				} else {
					bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
					x1 = x1m;
					y1 = y1m;
				}
				for (var j = 0, jj = path2.length; j < jj; j++) {
					var pj = path2[j];
					if (pj[0] == "M") {
						x2 = x2m = pj[1];
						y2 = y2m = pj[2];
					} else {
						if (pj[0] == "C") {
							bez2 = [x2, y2].concat(pj.slice(1));
							x2 = bez2[6];
							y2 = bez2[7];
						} else {
							bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
							x2 = x2m;
							y2 = y2m;
						}
						var intr = interHelper(bez1, bez2, justCount);
						if (justCount) {
							res += intr;
						} else {
							for (var k = 0, kk = intr.length; k < kk; k++) {
								intr[k].segment1 = i;
								intr[k].segment2 = j;
								intr[k].bez1 = bez1;
								intr[k].bez2 = bez2;
							}
							res = res.concat(intr);
						}
					}
				}
			}
		}
		return res;
	}

	R.isPointInsidePath = function (path, x, y) {
		var bbox = R.pathBBox(path);
		return R.isPointInsideBBox(bbox, x, y) &&
			interPathHelper(path, [
				["M", x, y],
				["H", bbox.x2 + 10]
			], 1) % 2 == 1;
	};
	R._removedFactory = function (methodname) {
		return function () {
			eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
		};
	};

	var pathDimensions = R.pathBBox = function (path) {
			var pth = paths(path);
			if (pth.bbox) {
				return pth.bbox;
			}
			if (!path) {
				return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
			}
			path = path2curve(path);
			var x = 0,
				y = 0,
				X = [],
				Y = [],
				p;
			for (var i = 0, ii = path.length; i < ii; i++) {
				p = path[i];
				if (p[0] == "M") {
					x = p[1];
					y = p[2];
					X.push(x);
					Y.push(y);
				} else {
					var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
					X = X[concat](dim.min.x, dim.max.x);
					Y = Y[concat](dim.min.y, dim.max.y);
					x = p[5];
					y = p[6];
				}
			}
			var xmin = mmin[apply](0, X),
				ymin = mmin[apply](0, Y),
				xmax = mmax[apply](0, X),
				ymax = mmax[apply](0, Y),
				bb = {
					x: xmin,
					y: ymin,
					x2: xmax,
					y2: ymax,
					width: xmax - xmin,
					height: ymax - ymin
				};
			pth.bbox = clone(bb);
			return bb;
		},
		pathClone = function (pathArray) {
			var res = clone(pathArray);
			res.toString = R._path2string;
			return res;
		},
		pathToRelative = R._pathToRelative = function (pathArray) {
			var pth = paths(pathArray);
			if (pth.rel) {
				return pathClone(pth.rel);
			}
			if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
				pathArray = R.parsePathString(pathArray);
			}
			var res = [],
				x = 0,
				y = 0,
				mx = 0,
				my = 0,
				start = 0;
			if (pathArray[0][0] == "M") {
				x = pathArray[0][1];
				y = pathArray[0][2];
				mx = x;
				my = y;
				start++;
				res.push(["M", x, y]);
			}
			for (var i = start, ii = pathArray.length; i < ii; i++) {
				var r = res[i] = [],
					pa = pathArray[i];
				if (pa[0] != lowerCase.call(pa[0])) {
					r[0] = lowerCase.call(pa[0]);
					switch (r[0]) {
						case "a":
							r[1] = pa[1];
							r[2] = pa[2];
							r[3] = pa[3];
							r[4] = pa[4];
							r[5] = pa[5];
							r[6] = +(pa[6] - x).toFixed(3);
							r[7] = +(pa[7] - y).toFixed(3);
							break;
						case "v":
							r[1] = +(pa[1] - y).toFixed(3);
							break;
						case "m":
							mx = pa[1];
							my = pa[2];
						default:
							for (var j = 1, jj = pa.length; j < jj; j++) {
								r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
							}
					}
				} else {
					r = res[i] = [];
					if (pa[0] == "m") {
						mx = pa[1] + x;
						my = pa[2] + y;
					}
					for (var k = 0, kk = pa.length; k < kk; k++) {
						res[i][k] = pa[k];
					}
				}
				var len = res[i].length;
				switch (res[i][0]) {
					case "z":
						x = mx;
						y = my;
						break;
					case "h":
						x += +res[i][len - 1];
						break;
					case "v":
						y += +res[i][len - 1];
						break;
					default:
						x += +res[i][len - 2];
						y += +res[i][len - 1];
				}
			}
			res.toString = R._path2string;
			pth.rel = pathClone(res);
			return res;
		},
		pathToAbsolute = R._pathToAbsolute = function (pathArray) {
			var pth = paths(pathArray);
			if (pth.abs) {
				return pathClone(pth.abs);
			}
			if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
				pathArray = R.parsePathString(pathArray);
			}
			if (!pathArray || !pathArray.length) {
				return [
					["M", 0, 0]
				];
			}
			var res = [],
				x = 0,
				y = 0,
				mx = 0,
				my = 0,
				start = 0;
			if (pathArray[0][0] == "M") {
				x = +pathArray[0][1];
				y = +pathArray[0][2];
				mx = x;
				my = y;
				start++;
				res[0] = ["M", x, y];
			}
			var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
			for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
				res.push(r = []);
				pa = pathArray[i];
				if (pa[0] != upperCase.call(pa[0])) {
					r[0] = upperCase.call(pa[0]);
					switch (r[0]) {
						case "A":
							r[1] = pa[1];
							r[2] = pa[2];
							r[3] = pa[3];
							r[4] = pa[4];
							r[5] = pa[5];
							r[6] = +(pa[6] + x);
							r[7] = +(pa[7] + y);
							break;
						case "V":
							r[1] = +pa[1] + y;
							break;
						case "H":
							r[1] = +pa[1] + x;
							break;
						case "R":
							var dots = [x, y][concat](pa.slice(1));
							for (var j = 2, jj = dots.length; j < jj; j++) {
								dots[j] = +dots[j] + x;
								dots[++j] = +dots[j] + y;
							}
							res.pop();
							res = res[concat](catmullRom2bezier(dots, crz));
							break;
						case "M":
							mx = +pa[1] + x;
							my = +pa[2] + y;
						default:
							for (j = 1, jj = pa.length; j < jj; j++) {
								r[j] = +pa[j] + ((j % 2) ? x : y);
							}
					}
				} else if (pa[0] == "R") {
					dots = [x, y][concat](pa.slice(1));
					res.pop();
					res = res[concat](catmullRom2bezier(dots, crz));
					r = ["R"][concat](pa.slice(-2));
				} else {
					for (var k = 0, kk = pa.length; k < kk; k++) {
						r[k] = pa[k];
					}
				}
				switch (r[0]) {
					case "Z":
						x = mx;
						y = my;
						break;
					case "H":
						x = r[1];
						break;
					case "V":
						y = r[1];
						break;
					case "M":
						mx = r[r.length - 2];
						my = r[r.length - 1];
					default:
						x = r[r.length - 2];
						y = r[r.length - 1];
				}
			}
			res.toString = R._path2string;
			pth.abs = pathClone(res);
			return res;
		},
		l2c = function (x1, y1, x2, y2) {
			return [x1, y1, x2, y2, x2, y2];
		},
		q2c = function (x1, y1, ax, ay, x2, y2) {
			var _13 = 1 / 3,
				_23 = 2 / 3;
			return [
					_13 * x1 + _23 * ax,
					_13 * y1 + _23 * ay,
					_13 * x2 + _23 * ax,
					_13 * y2 + _23 * ay,
				x2,
				y2
			];
		},
		a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
			// for more information of where this math came from visit:
			// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
			var _120 = PI * 120 / 180,
				rad = PI / 180 * (+angle || 0),
				res = [],
				xy,
				rotate = cacher(function (x, y, rad) {
					var X = x * math.cos(rad) - y * math.sin(rad),
						Y = x * math.sin(rad) + y * math.cos(rad);
					return {x: X, y: Y};
				});
			if (!recursive) {
				xy = rotate(x1, y1, -rad);
				x1 = xy.x;
				y1 = xy.y;
				xy = rotate(x2, y2, -rad);
				x2 = xy.x;
				y2 = xy.y;
				var cos = math.cos(PI / 180 * angle),
					sin = math.sin(PI / 180 * angle),
					x = (x1 - x2) / 2,
					y = (y1 - y2) / 2;
				var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
				if (h > 1) {
					h = math.sqrt(h);
					rx = h * rx;
					ry = h * ry;
				}
				var rx2 = rx * rx,
					ry2 = ry * ry,
					k = (large_arc_flag == sweep_flag ? -1 : 1) *
						math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
					cx = k * rx * y / ry + (x1 + x2) / 2,
					cy = k * -ry * x / rx + (y1 + y2) / 2,
					f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
					f2 = math.asin(((y2 - cy) / ry).toFixed(9));

				f1 = x1 < cx ? PI - f1 : f1;
				f2 = x2 < cx ? PI - f2 : f2;
				f1 < 0 && (f1 = PI * 2 + f1);
				f2 < 0 && (f2 = PI * 2 + f2);
				if (sweep_flag && f1 > f2) {
					f1 = f1 - PI * 2;
				}
				if (!sweep_flag && f2 > f1) {
					f2 = f2 - PI * 2;
				}
			} else {
				f1 = recursive[0];
				f2 = recursive[1];
				cx = recursive[2];
				cy = recursive[3];
			}
			var df = f2 - f1;
			if (abs(df) > _120) {
				var f2old = f2,
					x2old = x2,
					y2old = y2;
				f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
				x2 = cx + rx * math.cos(f2);
				y2 = cy + ry * math.sin(f2);
				res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
			}
			df = f2 - f1;
			var c1 = math.cos(f1),
				s1 = math.sin(f1),
				c2 = math.cos(f2),
				s2 = math.sin(f2),
				t = math.tan(df / 4),
				hx = 4 / 3 * rx * t,
				hy = 4 / 3 * ry * t,
				m1 = [x1, y1],
				m2 = [x1 + hx * s1, y1 - hy * c1],
				m3 = [x2 + hx * s2, y2 - hy * c2],
				m4 = [x2, y2];
			m2[0] = 2 * m1[0] - m2[0];
			m2[1] = 2 * m1[1] - m2[1];
			if (recursive) {
				return [m2, m3, m4][concat](res);
			} else {
				res = [m2, m3, m4][concat](res).join()[split](",");
				var newres = [];
				for (var i = 0, ii = res.length; i < ii; i++) {
					newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
				}
				return newres;
			}
		},
		findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
			var t1 = 1 - t;
			return {
				x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
				y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
			};
		},
		curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
			var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
				b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
				c = p1x - c1x,
				t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
				t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
				y = [p1y, p2y],
				x = [p1x, p2x],
				dot;
			abs(t1) > "1e12" && (t1 = .5);
			abs(t2) > "1e12" && (t2 = .5);
			if (t1 > 0 && t1 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
				x.push(dot.x);
				y.push(dot.y);
			}
			if (t2 > 0 && t2 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
				x.push(dot.x);
				y.push(dot.y);
			}
			a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
			b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
			c = p1y - c1y;
			t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
			t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
			abs(t1) > "1e12" && (t1 = .5);
			abs(t2) > "1e12" && (t2 = .5);
			if (t1 > 0 && t1 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
				x.push(dot.x);
				y.push(dot.y);
			}
			if (t2 > 0 && t2 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
				x.push(dot.x);
				y.push(dot.y);
			}
			return {
				min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
				max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
			};
		}),
		path2curve = R._path2curve = cacher(function (path, path2) {
			var pth = !path2 && paths(path);
			if (!path2 && pth.curve) {
				return pathClone(pth.curve);
			}
			var p = pathToAbsolute(path),
				p2 = path2 && pathToAbsolute(path2),
				attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
				attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
				processPath = function (path, d) {
					var nx, ny;
					if (!path) {
						return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
					}
					!(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
					switch (path[0]) {
						case "M":
							d.X = path[1];
							d.Y = path[2];
							break;
						case "A":
							path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
							break;
						case "S":
							nx = d.x + (d.x - (d.bx || d.x));
							ny = d.y + (d.y - (d.by || d.y));
							path = ["C", nx, ny][concat](path.slice(1));
							break;
						case "T":
							d.qx = d.x + (d.x - (d.qx || d.x));
							d.qy = d.y + (d.y - (d.qy || d.y));
							path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
							break;
						case "Q":
							d.qx = path[1];
							d.qy = path[2];
							path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
							break;
						case "L":
							path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
							break;
						case "H":
							path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
							break;
						case "V":
							path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
							break;
						case "Z":
							path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
							break;
					}
					return path;
				},
				fixArc = function (pp, i) {
					if (pp[i].length > 7) {
						pp[i].shift();
						var pi = pp[i];
						while (pi.length) {
							pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
						}
						pp.splice(i, 1);
						ii = mmax(p.length, p2 && p2.length || 0);
					}
				},
				fixM = function (path1, path2, a1, a2, i) {
					if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
						path2.splice(i, 0, ["M", a2.x, a2.y]);
						a1.bx = 0;
						a1.by = 0;
						a1.x = path1[i][1];
						a1.y = path1[i][2];
						ii = mmax(p.length, p2 && p2.length || 0);
					}
				};
			for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
				p[i] = processPath(p[i], attrs);
				fixArc(p, i);
				p2 && (p2[i] = processPath(p2[i], attrs2));
				p2 && fixArc(p2, i);
				fixM(p, p2, attrs, attrs2, i);
				fixM(p2, p, attrs2, attrs, i);
				var seg = p[i],
					seg2 = p2 && p2[i],
					seglen = seg.length,
					seg2len = p2 && seg2.length;
				attrs.x = seg[seglen - 2];
				attrs.y = seg[seglen - 1];
				attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
				attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
				attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
				attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
				attrs2.x = p2 && seg2[seg2len - 2];
				attrs2.y = p2 && seg2[seg2len - 1];
			}
			if (!p2) {
				pth.curve = pathClone(p);
			}
			return p2 ? [p, p2] : p;
		}, null, pathClone),
		parseDots = R._parseDots = cacher(function (gradient) {
			var dots = [];
			for (var i = 0, ii = gradient.length; i < ii; i++) {
				var dot = {},
					par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
				dot.color = R.getRGB(par[1]);
				if (dot.color.error) {
					return null;
				}
				dot.color = dot.color.hex;
				par[2] && (dot.offset = par[2] + "%");
				dots.push(dot);
			}
			for (i = 1, ii = dots.length - 1; i < ii; i++) {
				if (!dots[i].offset) {
					var start = toFloat(dots[i - 1].offset || 0),
						end = 0;
					for (var j = i + 1; j < ii; j++) {
						if (dots[j].offset) {
							end = dots[j].offset;
							break;
						}
					}
					if (!end) {
						end = 100;
						j = ii;
					}
					end = toFloat(end);
					var d = (end - start) / (j - i + 1);
					for (; i < j; i++) {
						start += d;
						dots[i].offset = start + "%";
					}
				}
			}
			return dots;
		}),
		tear = R._tear = function (el, paper) {
			el == paper.top && (paper.top = el.prev);
			el == paper.bottom && (paper.bottom = el.next);
			el.next && (el.next.prev = el.prev);
			el.prev && (el.prev.next = el.next);
		},
		tofront = R._tofront = function (el, paper) {
			if (paper.top === el) {
				return;
			}
			tear(el, paper);
			el.next = null;
			el.prev = paper.top;
			paper.top.next = el;
			paper.top = el;
		},
		toback = R._toback = function (el, paper) {
			if (paper.bottom === el) {
				return;
			}
			tear(el, paper);
			el.next = paper.bottom;
			el.prev = null;
			paper.bottom.prev = el;
			paper.bottom = el;
		},
		insertafter = R._insertafter = function (el, el2, paper) {
			tear(el, paper);
			el2 == paper.top && (paper.top = el);
			el2.next && (el2.next.prev = el);
			el.next = el2.next;
			el.prev = el2;
			el2.next = el;
		},
		insertbefore = R._insertbefore = function (el, el2, paper) {
			tear(el, paper);
			el2 == paper.bottom && (paper.bottom = el);
			el2.prev && (el2.prev.next = el);
			el.prev = el2.prev;
			el2.prev = el;
			el.next = el2;
		},

		toMatrix = R.toMatrix = function (path, transform) {
			var bb = pathDimensions(path),
				el = {
					_: {
						transform: E
					},
					getBBox: function () {
						return bb;
					}
				};
			extractTransform(el, transform);
			return el.matrix;
		},

		transformPath = R.transformPath = function (path, transform) {
			return mapPath(path, toMatrix(path, transform));
		},
		extractTransform = R._extractTransform = function (el, tstr) {
			if (tstr == null) {
				return el._.transform;
			}
			tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
			var tdata = R.parseTransformString(tstr),
				deg = 0,
				dx = 0,
				dy = 0,
				sx = 1,
				sy = 1,
				_ = el._,
				m = new Matrix;
			_.transform = tdata || [];
			if (tdata) {
				for (var i = 0, ii = tdata.length; i < ii; i++) {
					var t = tdata[i],
						tlen = t.length,
						command = Str(t[0]).toLowerCase(),
						absolute = t[0] != command,
						inver = absolute ? m.invert() : 0,
						x1,
						y1,
						x2,
						y2,
						bb;
					if (command == "t" && tlen == 3) {
						if (absolute) {
							x1 = inver.x(0, 0);
							y1 = inver.y(0, 0);
							x2 = inver.x(t[1], t[2]);
							y2 = inver.y(t[1], t[2]);
							m.translate(x2 - x1, y2 - y1);
						} else {
							m.translate(t[1], t[2]);
						}
					} else if (command == "r") {
						if (tlen == 2) {
							bb = bb || el.getBBox(1);
							m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
							deg += t[1];
						} else if (tlen == 4) {
							if (absolute) {
								x2 = inver.x(t[2], t[3]);
								y2 = inver.y(t[2], t[3]);
								m.rotate(t[1], x2, y2);
							} else {
								m.rotate(t[1], t[2], t[3]);
							}
							deg += t[1];
						}
					} else if (command == "s") {
						if (tlen == 2 || tlen == 3) {
							bb = bb || el.getBBox(1);
							m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
							sx *= t[1];
							sy *= t[tlen - 1];
						} else if (tlen == 5) {
							if (absolute) {
								x2 = inver.x(t[3], t[4]);
								y2 = inver.y(t[3], t[4]);
								m.scale(t[1], t[2], x2, y2);
							} else {
								m.scale(t[1], t[2], t[3], t[4]);
							}
							sx *= t[1];
							sy *= t[2];
						}
					} else if (command == "m" && tlen == 7) {
						m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
					}
					_.dirtyT = 1;
					el.matrix = m;
				}
			}


			el.matrix = m;

			_.sx = sx;
			_.sy = sy;
			_.deg = deg;
			_.dx = dx = m.e;
			_.dy = dy = m.f;

			if (sx == 1 && sy == 1 && !deg && _.bbox) {
				_.bbox.x += +dx;
				_.bbox.y += +dy;
			} else {
				_.dirtyT = 1;
			}
		},
		getEmpty = function (item) {
			var l = item[0];
			switch (l.toLowerCase()) {
				case "t":
					return [l, 0, 0];
				case "m":
					return [l, 1, 0, 0, 1, 0, 0];
				case "r":
					if (item.length == 4) {
						return [l, 0, item[2], item[3]];
					} else {
						return [l, 0];
					}
				case "s":
					if (item.length == 5) {
						return [l, 1, 1, item[3], item[4]];
					} else if (item.length == 3) {
						return [l, 1, 1];
					} else {
						return [l, 1];
					}
			}
		},
		equaliseTransform = R._equaliseTransform = function (t1, t2) {
			t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
			t1 = R.parseTransformString(t1) || [];
			t2 = R.parseTransformString(t2) || [];
			var maxlength = mmax(t1.length, t2.length),
				from = [],
				to = [],
				i = 0, j, jj,
				tt1, tt2;
			for (; i < maxlength; i++) {
				tt1 = t1[i] || getEmpty(t2[i]);
				tt2 = t2[i] || getEmpty(tt1);
				if ((tt1[0] != tt2[0]) ||
					(tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
					(tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
					) {
					return;
				}
				from[i] = [];
				to[i] = [];
				for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
					j in tt1 && (from[i][j] = tt1[j]);
					j in tt2 && (to[i][j] = tt2[j]);
				}
			}
			return {
				from: from,
				to: to
			};
		};
	R._getContainer = function (x, y, w, h) {
		var container;
		container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
		if (container == null) {
			return;
		}
		if (container.tagName) {
			if (y == null) {
				return {
					container: container,
					width: container.style.pixelWidth || container.offsetWidth,
					height: container.style.pixelHeight || container.offsetHeight
				};
			} else {
				return {
					container: container,
					width: y,
					height: w
				};
			}
		}
		return {
			container: 1,
			x: x,
			y: y,
			width: w,
			height: h
		};
	};

	R.pathToRelative = pathToRelative;
	R._engine = {};

	R.path2curve = path2curve;

	R.matrix = function (a, b, c, d, e, f) {
		return new Matrix(a, b, c, d, e, f);
	};
	function Matrix(a, b, c, d, e, f) {
		if (a != null) {
			this.a = +a;
			this.b = +b;
			this.c = +c;
			this.d = +d;
			this.e = +e;
			this.f = +f;
		} else {
			this.a = 1;
			this.b = 0;
			this.c = 0;
			this.d = 1;
			this.e = 0;
			this.f = 0;
		}
	}

	(function (matrixproto) {

		matrixproto.add = function (a, b, c, d, e, f) {
			var out = [
					[],
					[],
					[]
				],
				m = [
					[this.a, this.c, this.e],
					[this.b, this.d, this.f],
					[0, 0, 1]
				],
				matrix = [
					[a, c, e],
					[b, d, f],
					[0, 0, 1]
				],
				x, y, z, res;

			if (a && a instanceof Matrix) {
				matrix = [
					[a.a, a.c, a.e],
					[a.b, a.d, a.f],
					[0, 0, 1]
				];
			}

			for (x = 0; x < 3; x++) {
				for (y = 0; y < 3; y++) {
					res = 0;
					for (z = 0; z < 3; z++) {
						res += m[x][z] * matrix[z][y];
					}
					out[x][y] = res;
				}
			}
			this.a = out[0][0];
			this.b = out[1][0];
			this.c = out[0][1];
			this.d = out[1][1];
			this.e = out[0][2];
			this.f = out[1][2];
		};

		matrixproto.invert = function () {
			var me = this,
				x = me.a * me.d - me.b * me.c;
			return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
		};

		matrixproto.clone = function () {
			return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
		};

		matrixproto.translate = function (x, y) {
			this.add(1, 0, 0, 1, x, y);
		};

		matrixproto.scale = function (x, y, cx, cy) {
			y == null && (y = x);
			(cx || cy) && this.add(1, 0, 0, 1, cx, cy);
			this.add(x, 0, 0, y, 0, 0);
			(cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
		};

		matrixproto.rotate = function (a, x, y) {
			a = R.rad(a);
			x = x || 0;
			y = y || 0;
			var cos = +math.cos(a).toFixed(9),
				sin = +math.sin(a).toFixed(9);
			this.add(cos, sin, -sin, cos, x, y);
			this.add(1, 0, 0, 1, -x, -y);
		};

		matrixproto.x = function (x, y) {
			return x * this.a + y * this.c + this.e;
		};

		matrixproto.y = function (x, y) {
			return x * this.b + y * this.d + this.f;
		};
		matrixproto.get = function (i) {
			return +this[Str.fromCharCode(97 + i)].toFixed(4);
		};
		matrixproto.toString = function () {
			return R.svg ?
				"matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
				[this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
		};
		matrixproto.toFilter = function () {
			return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
				", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
				", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
		};
		matrixproto.offset = function () {
			return [this.e.toFixed(4), this.f.toFixed(4)];
		};
		function norm(a) {
			return a[0] * a[0] + a[1] * a[1];
		}

		function normalize(a) {
			var mag = math.sqrt(norm(a));
			a[0] && (a[0] /= mag);
			a[1] && (a[1] /= mag);
		}

		matrixproto.split = function () {
			var out = {};
			// translation
			out.dx = this.e;
			out.dy = this.f;

			// scale and shear
			var row = [
				[this.a, this.c],
				[this.b, this.d]
			];
			out.scalex = math.sqrt(norm(row[0]));
			normalize(row[0]);

			out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
			row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

			out.scaley = math.sqrt(norm(row[1]));
			normalize(row[1]);
			out.shear /= out.scaley;

			// rotation
			var sin = -row[0][1],
				cos = row[1][1];
			if (cos < 0) {
				out.rotate = R.deg(math.acos(cos));
				if (sin < 0) {
					out.rotate = 360 - out.rotate;
				}
			} else {
				out.rotate = R.deg(math.asin(sin));
			}

			out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
			out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
			out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
			return out;
		};

		matrixproto.toTransformString = function (shorter) {
			var s = shorter || this[split]();
			if (s.isSimple) {
				s.scalex = +s.scalex.toFixed(4);
				s.scaley = +s.scaley.toFixed(4);
				s.rotate = +s.rotate.toFixed(4);
				return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
					(s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
					(s.rotate ? "r" + [s.rotate, 0, 0] : E);
			} else {
				return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
			}
		};
	})(Matrix.prototype);

	// WebKit rendering bug workaround method
	var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
	if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
		(navigator.vendor == "Google Inc." && version && version[1] < 8)) {

		paperproto.safari = function () {
			var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
			setTimeout(function () {
				rect.remove();
			});
		};
	} else {
		paperproto.safari = fun;
	}

	var preventDefault = function () {
			this.returnValue = false;
		},
		preventTouch = function () {
			return this.originalEvent.preventDefault();
		},
		stopPropagation = function () {
			this.cancelBubble = true;
		},
		stopTouch = function () {
			return this.originalEvent.stopPropagation();
		},
		addEvent = (function () {
			if (g.doc.addEventListener) {
				return function (obj, type, fn, element) {
					var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
						f = function (e) {
							var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
								scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
								x = e.clientX + scrollX,
								y = e.clientY + scrollY;
							if (supportsTouch && touchMap[has](type)) {
								for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
									if (e.targetTouches[i].target == obj) {
										var olde = e;
										e = e.targetTouches[i];
										e.originalEvent = olde;
										e.preventDefault = preventTouch;
										e.stopPropagation = stopTouch;
										break;
									}
								}
							}
							return fn.call(element, e, x, y);
						};
					obj.addEventListener(realName, f, false);
					return function () {
						obj.removeEventListener(realName, f, false);
						return true;
					};
				};
			} else if (g.doc.attachEvent) {
				return function (obj, type, fn, element) {
					var f = function (e) {
						e = e || g.win.event;
						var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
							scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
							x = e.clientX + scrollX,
							y = e.clientY + scrollY;
						e.preventDefault = e.preventDefault || preventDefault;
						e.stopPropagation = e.stopPropagation || stopPropagation;
						return fn.call(element, e, x, y);
					};
					obj.attachEvent("on" + type, f);
					var detacher = function () {
						obj.detachEvent("on" + type, f);
						return true;
					};
					return detacher;
				};
			}
		})(),
		drag = [],
		dragMove = function (e) {
			var x = e.clientX,
				y = e.clientY,
				scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
				scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
				dragi,
				j = drag.length;
			while (j--) {
				dragi = drag[j];
				if (supportsTouch) {
					var i = e.touches.length,
						touch;
					while (i--) {
						touch = e.touches[i];
						if (touch.identifier == dragi.el._drag.id) {
							x = touch.clientX;
							y = touch.clientY;
							(e.originalEvent ? e.originalEvent : e).preventDefault();
							break;
						}
					}
				} else {
					e.preventDefault();
				}
				var node = dragi.el.node,
					o,
					next = node.nextSibling,
					parent = node.parentNode,
					display = node.style.display;
				g.win.opera && parent.removeChild(node);
				node.style.display = "none";
				o = dragi.el.paper.getElementByPoint(x, y);
				node.style.display = display;
				g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
				o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
				x += scrollX;
				y += scrollY;
				eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
			}
		},
		dragUp = function (e) {
			R.unmousemove(dragMove).unmouseup(dragUp);
			var i = drag.length,
				dragi;
			while (i--) {
				dragi = drag[i];
				dragi.el._drag = {};
				eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
			}
			drag = [];
		},

		elproto = R.el = {};


	for (var i = events.length; i--;) {
		(function (eventName) {
			R[eventName] = elproto[eventName] = function (fn, scope) {
				if (R.is(fn, "function")) {
					this.events = this.events || [];
					this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
				}
				return this;
			};
			R["un" + eventName] = elproto["un" + eventName] = function (fn) {
				var events = this.events || [],
					l = events.length;
				while (l--) if (events[l].name == eventName && events[l].f == fn) {
					events[l].unbind();
					events.splice(l, 1);
					!events.length && delete this.events;
					return this;
				}
				return this;
			};
		})(events[i]);
	}


	elproto.data = function (key, value) {
		var data = eldata[this.id] = eldata[this.id] || {};
		if (arguments.length == 1) {
			if (R.is(key, "object")) {
				for (var i in key) if (key[has](i)) {
					this.data(i, key[i]);
				}
				return this;
			}
			eve("raphael.data.get." + this.id, this, data[key], key);
			return data[key];
		}
		data[key] = value;
		eve("raphael.data.set." + this.id, this, value, key);
		return this;
	};

	elproto.removeData = function (key) {
		if (key == null) {
			eldata[this.id] = {};
		} else {
			eldata[this.id] && delete eldata[this.id][key];
		}
		return this;
	};

	elproto.hover = function (f_in, f_out, scope_in, scope_out) {
		return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
	};

	elproto.unhover = function (f_in, f_out) {
		return this.unmouseover(f_in).unmouseout(f_out);
	};
	var draggable = [];

	elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
		function start(e) {
			(e.originalEvent || e).preventDefault();
			var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
				scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
			this._drag.x = e.clientX + scrollX;
			this._drag.y = e.clientY + scrollY;
			this._drag.id = e.identifier;
			!drag.length && R.mousemove(dragMove).mouseup(dragUp);
			drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
			onstart && eve.on("raphael.drag.start." + this.id, onstart);
			onmove && eve.on("raphael.drag.move." + this.id, onmove);
			onend && eve.on("raphael.drag.end." + this.id, onend);
			eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
		}

		this._drag = {};
		draggable.push({el: this, start: start});
		this.mousedown(start);
		return this;
	};

	elproto.onDragOver = function (f) {
		f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
	};

	elproto.undrag = function () {
		var i = draggable.length;
		while (i--) if (draggable[i].el == this) {
			this.unmousedown(draggable[i].start);
			draggable.splice(i, 1);
			eve.unbind("raphael.drag.*." + this.id);
		}
		!draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
	};

	paperproto.circle = function (x, y, r) {
		var out = R._engine.circle(this, x || 0, y || 0, r || 0);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.rect = function (x, y, w, h, r) {
		var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.ellipse = function (x, y, rx, ry) {
		var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.path = function (pathString) {
		pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
		var out = R._engine.path(R.format[apply](R, arguments), this);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.image = function (src, x, y, w, h) {
		var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.text = function (x, y, text) {
		var out = R._engine.text(this, x || 0, y || 0, Str(text));
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.set = function (itemsArray) {
		!R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
		var out = new Set(itemsArray);
		this.__set__ && this.__set__.push(out);
		return out;
	};

	paperproto.setStart = function (set) {
		this.__set__ = set || this.set();
	};

	paperproto.setFinish = function (set) {
		var out = this.__set__;
		delete this.__set__;
		return out;
	};

	paperproto.setSize = function (width, height) {
		return R._engine.setSize.call(this, width, height);
	};

	paperproto.setViewBox = function (x, y, w, h, fit) {
		return R._engine.setViewBox.call(this, x, y, w, h, fit);
	};


	paperproto.top = paperproto.bottom = null;

	paperproto.raphael = R;
	var getOffset = function (elem) {
		var box = elem.getBoundingClientRect(),
			doc = elem.ownerDocument,
			body = doc.body,
			docElem = doc.documentElement,
			clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
			top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
			left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
		return {
			y: top,
			x: left
		};
	};

	paperproto.getElementByPoint = function (x, y) {
		var paper = this,
			svg = paper.canvas,
			target = g.doc.elementFromPoint(x, y);
		if (g.win.opera && target.tagName == "svg") {
			var so = getOffset(svg),
				sr = svg.createSVGRect();
			sr.x = x - so.x;
			sr.y = y - so.y;
			sr.width = sr.height = 1;
			var hits = svg.getIntersectionList(sr, null);
			if (hits.length) {
				target = hits[hits.length - 1];
			}
		}
		if (!target) {
			return null;
		}
		while (target.parentNode && target != svg.parentNode && !target.raphael) {
			target = target.parentNode;
		}
		target == paper.canvas.parentNode && (target = svg);
		target = target && target.raphael ? paper.getById(target.raphaelid) : null;
		return target;
	};

	paperproto.getById = function (id) {
		var bot = this.bottom;
		while (bot) {
			if (bot.id == id) {
				return bot;
			}
			bot = bot.next;
		}
		return null;
	};

	paperproto.forEach = function (callback, thisArg) {
		var bot = this.bottom;
		while (bot) {
			if (callback.call(thisArg, bot) === false) {
				return this;
			}
			bot = bot.next;
		}
		return this;
	};

	paperproto.getElementsByPoint = function (x, y) {
		var set = this.set();
		this.forEach(function (el) {
			if (el.isPointInside(x, y)) {
				set.push(el);
			}
		});
		return set;
	};
	function x_y() {
		return this.x + S + this.y;
	}

	function x_y_w_h() {
		return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
	}

	elproto.isPointInside = function (x, y) {
		var rp = this.realPath = this.realPath || getPath[this.type](this);
		return R.isPointInsidePath(rp, x, y);
	};

	elproto.getBBox = function (isWithoutTransform) {
		if (this.removed) {
			return {};
		}
		var _ = this._;
		if (isWithoutTransform) {
			if (_.dirty || !_.bboxwt) {
				this.realPath = getPath[this.type](this);
				_.bboxwt = pathDimensions(this.realPath);
				_.bboxwt.toString = x_y_w_h;
				_.dirty = 0;
			}
			return _.bboxwt;
		}
		if (_.dirty || _.dirtyT || !_.bbox) {
			if (_.dirty || !this.realPath) {
				_.bboxwt = 0;
				this.realPath = getPath[this.type](this);
			}
			_.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
			_.bbox.toString = x_y_w_h;
			_.dirty = _.dirtyT = 0;
		}
		return _.bbox;
	};

	elproto.clone = function () {
		if (this.removed) {
			return null;
		}
		var out = this.paper[this.type]().attr(this.attr());
		this.__set__ && this.__set__.push(out);
		return out;
	};

	elproto.glow = function (glow) {
		if (this.type == "text") {
			return null;
		}
		glow = glow || {};
		var s = {
				width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
				fill: glow.fill || false,
				opacity: glow.opacity || .5,
				offsetx: glow.offsetx || 0,
				offsety: glow.offsety || 0,
				color: glow.color || "#000"
			},
			c = s.width / 2,
			r = this.paper,
			out = r.set(),
			path = this.realPath || getPath[this.type](this);
		path = this.matrix ? mapPath(path, this.matrix) : path;
		for (var i = 1; i < c + 1; i++) {
			out.push(r.path(path).attr({
				stroke: s.color,
				fill: s.fill ? s.color : "none",
				"stroke-linejoin": "round",
				"stroke-linecap": "round",
				"stroke-width": +(s.width / c * i).toFixed(3),
				opacity: +(s.opacity / c).toFixed(3)
			}));
		}
		return out.insertBefore(this).translate(s.offsetx, s.offsety);
	};
	var curveslengths = {},
		getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
			if (length == null) {
				return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
			} else {
				return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
			}
		},
		getLengthFactory = function (istotal, subpath) {
			return function (path, length, onlystart) {
				path = path2curve(path);
				var x, y, p, l, sp = "", subpaths = {}, point,
					len = 0;
				for (var i = 0, ii = path.length; i < ii; i++) {
					p = path[i];
					if (p[0] == "M") {
						x = +p[1];
						y = +p[2];
					} else {
						l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
						if (len + l > length) {
							if (subpath && !subpaths.start) {
								point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
								sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
								if (onlystart) {
									return sp;
								}
								subpaths.start = sp;
								sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
								len += l;
								x = +p[5];
								y = +p[6];
								continue;
							}
							if (!istotal && !subpath) {
								point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
								return {x: point.x, y: point.y, alpha: point.alpha};
							}
						}
						len += l;
						x = +p[5];
						y = +p[6];
					}
					sp += p.shift() + p;
				}
				subpaths.end = sp;
				point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
				point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
				return point;
			};
		};
	var getTotalLength = getLengthFactory(1),
		getPointAtLength = getLengthFactory(),
		getSubpathsAtLength = getLengthFactory(0, 1);

	R.getTotalLength = getTotalLength;

	R.getPointAtLength = getPointAtLength;

	R.getSubpath = function (path, from, to) {
		if (this.getTotalLength(path) - to < 1e-6) {
			return getSubpathsAtLength(path, from).end;
		}
		var a = getSubpathsAtLength(path, to, 1);
		return from ? getSubpathsAtLength(a, from).end : a;
	};

	elproto.getTotalLength = function () {
		if (this.type != "path") {
			return;
		}
		if (this.node.getTotalLength) {
			return this.node.getTotalLength();
		}
		return getTotalLength(this.attrs.path);
	};

	elproto.getPointAtLength = function (length) {
		if (this.type != "path") {
			return;
		}
		return getPointAtLength(this.attrs.path, length);
	};

	elproto.getSubpath = function (from, to) {
		if (this.type != "path") {
			return;
		}
		return R.getSubpath(this.attrs.path, from, to);
	};

	var ef = R.easing_formulas = {
		linear: function (n) {
			return n;
		},
		"<": function (n) {
			return pow(n, 1.7);
		},
		">": function (n) {
			return pow(n, .48);
		},
		"<>": function (n) {
			var q = .48 - n / 1.04,
				Q = math.sqrt(.1734 + q * q),
				x = Q - q,
				X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
				y = -Q - q,
				Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
				t = X + Y + .5;
			return (1 - t) * 3 * t * t + t * t * t;
		},
		backIn: function (n) {
			var s = 1.70158;
			return n * n * ((s + 1) * n - s);
		},
		backOut: function (n) {
			n = n - 1;
			var s = 1.70158;
			return n * n * ((s + 1) * n + s) + 1;
		},
		elastic: function (n) {
			if (n == !!n) {
				return n;
			}
			return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
		},
		bounce: function (n) {
			var s = 7.5625,
				p = 2.75,
				l;
			if (n < (1 / p)) {
				l = s * n * n;
			} else {
				if (n < (2 / p)) {
					n -= (1.5 / p);
					l = s * n * n + .75;
				} else {
					if (n < (2.5 / p)) {
						n -= (2.25 / p);
						l = s * n * n + .9375;
					} else {
						n -= (2.625 / p);
						l = s * n * n + .984375;
					}
				}
			}
			return l;
		}
	};
	ef.easeIn = ef["ease-in"] = ef["<"];
	ef.easeOut = ef["ease-out"] = ef[">"];
	ef.easeInOut = ef["ease-in-out"] = ef["<>"];
	ef["back-in"] = ef.backIn;
	ef["back-out"] = ef.backOut;

	var animationElements = [],
		requestAnimFrame = window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function (callback) {
				setTimeout(callback, 16);
			},
		animation = function () {
			var Now = +new Date,
				l = 0;
			for (; l < animationElements.length; l++) {
				var e = animationElements[l];
				if (e.el.removed || e.paused) {
					continue;
				}
				var time = Now - e.start,
					ms = e.ms,
					easing = e.easing,
					from = e.from,
					diff = e.diff,
					to = e.to,
					t = e.t,
					that = e.el,
					set = {},
					now,
					init = {},
					key;
				if (e.initstatus) {
					time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
					e.status = e.initstatus;
					delete e.initstatus;
					e.stop && animationElements.splice(l--, 1);
				} else {
					e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
				}
				if (time < 0) {
					continue;
				}
				if (time < ms) {
					var pos = easing(time / ms);
					for (var attr in from) if (from[has](attr)) {
						switch (availableAnimAttrs[attr]) {
							case nu:
								now = +from[attr] + pos * ms * diff[attr];
								break;
							case "colour":
								now = "rgb(" + [
									upto255(round(from[attr].r + pos * ms * diff[attr].r)),
									upto255(round(from[attr].g + pos * ms * diff[attr].g)),
									upto255(round(from[attr].b + pos * ms * diff[attr].b))
								].join(",") + ")";
								break;
							case "path":
								now = [];
								for (var i = 0, ii = from[attr].length; i < ii; i++) {
									now[i] = [from[attr][i][0]];
									for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
										now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
									}
									now[i] = now[i].join(S);
								}
								now = now.join(S);
								break;
							case "transform":
								if (diff[attr].real) {
									now = [];
									for (i = 0, ii = from[attr].length; i < ii; i++) {
										now[i] = [from[attr][i][0]];
										for (j = 1, jj = from[attr][i].length; j < jj; j++) {
											now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
										}
									}
								} else {
									var get = function (i) {
										return +from[attr][i] + pos * ms * diff[attr][i];
									};
									// now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
									now = [
										["m", get(0), get(1), get(2), get(3), get(4), get(5)]
									];
								}
								break;
							case "csv":
								if (attr == "clip-rect") {
									now = [];
									i = 4;
									while (i--) {
										now[i] = +from[attr][i] + pos * ms * diff[attr][i];
									}
								}
								break;
							default:
								var from2 = [][concat](from[attr]);
								now = [];
								i = that.paper.customAttributes[attr].length;
								while (i--) {
									now[i] = +from2[i] + pos * ms * diff[attr][i];
								}
								break;
						}
						set[attr] = now;
					}
					that.attr(set);
					(function (id, that, anim) {
						setTimeout(function () {
							eve("raphael.anim.frame." + id, that, anim);
						});
					})(that.id, that, e.anim);
				} else {
					(function (f, el, a) {
						setTimeout(function () {
							eve("raphael.anim.frame." + el.id, el, a);
							eve("raphael.anim.finish." + el.id, el, a);
							R.is(f, "function") && f.call(el);
						});
					})(e.callback, that, e.anim);
					that.attr(to);
					animationElements.splice(l--, 1);
					if (e.repeat > 1 && !e.next) {
						for (key in to) if (to[has](key)) {
							init[key] = e.totalOrigin[key];
						}
						e.el.attr(init);
						runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
					}
					if (e.next && !e.stop) {
						runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
					}
				}
			}
			R.svg && that && that.paper && that.paper.safari();
			animationElements.length && requestAnimFrame(animation);
		},
		upto255 = function (color) {
			return color > 255 ? 255 : color < 0 ? 0 : color;
		};

	elproto.animateWith = function (el, anim, params, ms, easing, callback) {
		var element = this;
		if (element.removed) {
			callback && callback.call(element);
			return element;
		}
		var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
			x, y;
		runAnimation(a, element, a.percents[0], null, element.attr());
		for (var i = 0, ii = animationElements.length; i < ii; i++) {
			if (animationElements[i].anim == anim && animationElements[i].el == el) {
				animationElements[ii - 1].start = animationElements[i].start;
				break;
			}
		}
		return element;
		// 
		// 
		// var a = params ? R.animation(params, ms, easing, callback) : anim,
		//     status = element.status(anim);
		// return this.animate(a).status(a, status * anim.ms / a.ms);
	};
	function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
		var cx = 3 * p1x,
			bx = 3 * (p2x - p1x) - cx,
			ax = 1 - cx - bx,
			cy = 3 * p1y,
			by = 3 * (p2y - p1y) - cy,
			ay = 1 - cy - by;

		function sampleCurveX(t) {
			return ((ax * t + bx) * t + cx) * t;
		}

		function solve(x, epsilon) {
			var t = solveCurveX(x, epsilon);
			return ((ay * t + by) * t + cy) * t;
		}

		function solveCurveX(x, epsilon) {
			var t0, t1, t2, x2, d2, i;
			for (t2 = x, i = 0; i < 8; i++) {
				x2 = sampleCurveX(t2) - x;
				if (abs(x2) < epsilon) {
					return t2;
				}
				d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
				if (abs(d2) < 1e-6) {
					break;
				}
				t2 = t2 - x2 / d2;
			}
			t0 = 0;
			t1 = 1;
			t2 = x;
			if (t2 < t0) {
				return t0;
			}
			if (t2 > t1) {
				return t1;
			}
			while (t0 < t1) {
				x2 = sampleCurveX(t2);
				if (abs(x2 - x) < epsilon) {
					return t2;
				}
				if (x > x2) {
					t0 = t2;
				} else {
					t1 = t2;
				}
				t2 = (t1 - t0) / 2 + t0;
			}
			return t2;
		}

		return solve(t, 1 / (200 * duration));
	}

	elproto.onAnimation = function (f) {
		f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
		return this;
	};
	function Animation(anim, ms) {
		var percents = [],
			newAnim = {};
		this.ms = ms;
		this.times = 1;
		if (anim) {
			for (var attr in anim) if (anim[has](attr)) {
				newAnim[toFloat(attr)] = anim[attr];
				percents.push(toFloat(attr));
			}
			percents.sort(sortByNumber);
		}
		this.anim = newAnim;
		this.top = percents[percents.length - 1];
		this.percents = percents;
	}

	Animation.prototype.delay = function (delay) {
		var a = new Animation(this.anim, this.ms);
		a.times = this.times;
		a.del = +delay || 0;
		return a;
	};

	Animation.prototype.repeat = function (times) {
		var a = new Animation(this.anim, this.ms);
		a.del = this.del;
		a.times = math.floor(mmax(times, 0)) || 1;
		return a;
	};
	function runAnimation(anim, element, percent, status, totalOrigin, times) {
		percent = toFloat(percent);
		var params,
			isInAnim,
			isInAnimSet,
			percents = [],
			next,
			prev,
			timestamp,
			ms = anim.ms,
			from = {},
			to = {},
			diff = {};
		if (status) {
			for (i = 0, ii = animationElements.length; i < ii; i++) {
				var e = animationElements[i];
				if (e.el.id == element.id && e.anim == anim) {
					if (e.percent != percent) {
						animationElements.splice(i, 1);
						isInAnimSet = 1;
					} else {
						isInAnim = e;
					}
					element.attr(e.totalOrigin);
					break;
				}
			}
		} else {
			status = +to; // NaN
		}
		for (var i = 0, ii = anim.percents.length; i < ii; i++) {
			if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
				percent = anim.percents[i];
				prev = anim.percents[i - 1] || 0;
				ms = ms / anim.top * (percent - prev);
				next = anim.percents[i + 1];
				params = anim.anim[percent];
				break;
			} else if (status) {
				element.attr(anim.anim[anim.percents[i]]);
			}
		}
		if (!params) {
			return;
		}
		if (!isInAnim) {
			for (var attr in params) if (params[has](attr)) {
				if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
					from[attr] = element.attr(attr);
					(from[attr] == null) && (from[attr] = availableAttrs[attr]);
					to[attr] = params[attr];
					switch (availableAnimAttrs[attr]) {
						case nu:
							diff[attr] = (to[attr] - from[attr]) / ms;
							break;
						case "colour":
							from[attr] = R.getRGB(from[attr]);
							var toColour = R.getRGB(to[attr]);
							diff[attr] = {
								r: (toColour.r - from[attr].r) / ms,
								g: (toColour.g - from[attr].g) / ms,
								b: (toColour.b - from[attr].b) / ms
							};
							break;
						case "path":
							var pathes = path2curve(from[attr], to[attr]),
								toPath = pathes[1];
							from[attr] = pathes[0];
							diff[attr] = [];
							for (i = 0, ii = from[attr].length; i < ii; i++) {
								diff[attr][i] = [0];
								for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
									diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
								}
							}
							break;
						case "transform":
							var _ = element._,
								eq = equaliseTransform(_[attr], to[attr]);
							if (eq) {
								from[attr] = eq.from;
								to[attr] = eq.to;
								diff[attr] = [];
								diff[attr].real = true;
								for (i = 0, ii = from[attr].length; i < ii; i++) {
									diff[attr][i] = [from[attr][i][0]];
									for (j = 1, jj = from[attr][i].length; j < jj; j++) {
										diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
									}
								}
							} else {
								var m = (element.matrix || new Matrix),
									to2 = {
										_: {transform: _.transform},
										getBBox: function () {
											return element.getBBox(1);
										}
									};
								from[attr] = [
									m.a,
									m.b,
									m.c,
									m.d,
									m.e,
									m.f
								];
								extractTransform(to2, to[attr]);
								to[attr] = to2._.transform;
								diff[attr] = [
										(to2.matrix.a - m.a) / ms,
										(to2.matrix.b - m.b) / ms,
										(to2.matrix.c - m.c) / ms,
										(to2.matrix.d - m.d) / ms,
										(to2.matrix.e - m.e) / ms,
										(to2.matrix.f - m.f) / ms
								];
								// from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
								// var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
								// extractTransform(to2, to[attr]);
								// diff[attr] = [
								//     (to2._.sx - _.sx) / ms,
								//     (to2._.sy - _.sy) / ms,
								//     (to2._.deg - _.deg) / ms,
								//     (to2._.dx - _.dx) / ms,
								//     (to2._.dy - _.dy) / ms
								// ];
							}
							break;
						case "csv":
							var values = Str(params[attr])[split](separator),
								from2 = Str(from[attr])[split](separator);
							if (attr == "clip-rect") {
								from[attr] = from2;
								diff[attr] = [];
								i = from2.length;
								while (i--) {
									diff[attr][i] = (values[i] - from[attr][i]) / ms;
								}
							}
							to[attr] = values;
							break;
						default:
							values = [][concat](params[attr]);
							from2 = [][concat](from[attr]);
							diff[attr] = [];
							i = element.paper.customAttributes[attr].length;
							while (i--) {
								diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
							}
							break;
					}
				}
			}
			var easing = params.easing,
				easyeasy = R.easing_formulas[easing];
			if (!easyeasy) {
				easyeasy = Str(easing).match(bezierrg);
				if (easyeasy && easyeasy.length == 5) {
					var curve = easyeasy;
					easyeasy = function (t) {
						return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
					};
				} else {
					easyeasy = pipe;
				}
			}
			timestamp = params.start || anim.start || +new Date;
			e = {
				anim: anim,
				percent: percent,
				timestamp: timestamp,
				start: timestamp + (anim.del || 0),
				status: 0,
				initstatus: status || 0,
				stop: false,
				ms: ms,
				easing: easyeasy,
				from: from,
				diff: diff,
				to: to,
				el: element,
				callback: params.callback,
				prev: prev,
				next: next,
				repeat: times || anim.times,
				origin: element.attr(),
				totalOrigin: totalOrigin
			};
			animationElements.push(e);
			if (status && !isInAnim && !isInAnimSet) {
				e.stop = true;
				e.start = new Date - ms * status;
				if (animationElements.length == 1) {
					return animation();
				}
			}
			if (isInAnimSet) {
				e.start = new Date - e.ms * status;
			}
			animationElements.length == 1 && requestAnimFrame(animation);
		} else {
			isInAnim.initstatus = status;
			isInAnim.start = new Date - isInAnim.ms * status;
		}
		eve("raphael.anim.start." + element.id, element, anim);
	}

	R.animation = function (params, ms, easing, callback) {
		if (params instanceof Animation) {
			return params;
		}
		if (R.is(easing, "function") || !easing) {
			callback = callback || easing || null;
			easing = null;
		}
		params = Object(params);
		ms = +ms || 0;
		var p = {},
			json,
			attr;
		for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
			json = true;
			p[attr] = params[attr];
		}
		if (!json) {
			return new Animation(params, ms);
		} else {
			easing && (p.easing = easing);
			callback && (p.callback = callback);
			return new Animation({100: p}, ms);
		}
	};

	elproto.animate = function (params, ms, easing, callback) {
		var element = this;
		if (element.removed) {
			callback && callback.call(element);
			return element;
		}
		var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
		runAnimation(anim, element, anim.percents[0], null, element.attr());
		return element;
	};

	elproto.setTime = function (anim, value) {
		if (anim && value != null) {
			this.status(anim, mmin(value, anim.ms) / anim.ms);
		}
		return this;
	};

	elproto.status = function (anim, value) {
		var out = [],
			i = 0,
			len,
			e;
		if (value != null) {
			runAnimation(anim, this, -1, mmin(value, 1));
			return this;
		} else {
			len = animationElements.length;
			for (; i < len; i++) {
				e = animationElements[i];
				if (e.el.id == this.id && (!anim || e.anim == anim)) {
					if (anim) {
						return e.status;
					}
					out.push({
						anim: e.anim,
						status: e.status
					});
				}
			}
			if (anim) {
				return 0;
			}
			return out;
		}
	};

	elproto.pause = function (anim) {
		for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
			if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
				animationElements[i].paused = true;
			}
		}
		return this;
	};

	elproto.resume = function (anim) {
		for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
			var e = animationElements[i];
			if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
				delete e.paused;
				this.status(e.anim, e.status);
			}
		}
		return this;
	};

	elproto.stop = function (anim) {
		for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
			if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
				animationElements.splice(i--, 1);
			}
		}
		return this;
	};
	function stopAnimation(paper) {
		for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
			animationElements.splice(i--, 1);
		}
	}

	eve.on("raphael.remove", stopAnimation);
	eve.on("raphael.clear", stopAnimation);
	elproto.toString = function () {
		return "Rapha\xebl\u2019s object";
	};

	// Set
	var Set = function (items) {
			this.items = [];
			this.length = 0;
			this.type = "set";
			if (items) {
				for (var i = 0, ii = items.length; i < ii; i++) {
					if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
						this[this.items.length] = this.items[this.items.length] = items[i];
						this.length++;
					}
				}
			}
		},
		setproto = Set.prototype;

	setproto.push = function () {
		var item,
			len;
		for (var i = 0, ii = arguments.length; i < ii; i++) {
			item = arguments[i];
			if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
				len = this.items.length;
				this[len] = this.items[len] = item;
				this.length++;
			}
		}
		return this;
	};

	setproto.pop = function () {
		this.length && delete this[this.length--];
		return this.items.pop();
	};

	setproto.forEach = function (callback, thisArg) {
		for (var i = 0, ii = this.items.length; i < ii; i++) {
			if (callback.call(thisArg, this.items[i], i) === false) {
				return this;
			}
		}
		return this;
	};
	for (var method in elproto) if (elproto[has](method)) {
		setproto[method] = (function (methodname) {
			return function () {
				var arg = arguments;
				return this.forEach(function (el) {
					el[methodname][apply](el, arg);
				});
			};
		})(method);
	}
	setproto.attr = function (name, value) {
		if (name && R.is(name, array) && R.is(name[0], "object")) {
			for (var j = 0, jj = name.length; j < jj; j++) {
				this.items[j].attr(name[j]);
			}
		} else {
			for (var i = 0, ii = this.items.length; i < ii; i++) {
				this.items[i].attr(name, value);
			}
		}
		return this;
	};

	setproto.clear = function () {
		while (this.length) {
			this.pop();
		}
	};

	setproto.splice = function (index, count, insertion) {
		index = index < 0 ? mmax(this.length + index, 0) : index;
		count = mmax(0, mmin(this.length - index, count));
		var tail = [],
			todel = [],
			args = [],
			i;
		for (i = 2; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		for (i = 0; i < count; i++) {
			todel.push(this[index + i]);
		}
		for (; i < this.length - index; i++) {
			tail.push(this[index + i]);
		}
		var arglen = args.length;
		for (i = 0; i < arglen + tail.length; i++) {
			this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
		}
		i = this.items.length = this.length -= count - arglen;
		while (this[i]) {
			delete this[i++];
		}
		return new Set(todel);
	};

	setproto.exclude = function (el) {
		for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
			this.splice(i, 1);
			return true;
		}
	};
	setproto.animate = function (params, ms, easing, callback) {
		(R.is(easing, "function") || !easing) && (callback = easing || null);
		var len = this.items.length,
			i = len,
			item,
			set = this,
			collector;
		if (!len) {
			return this;
		}
		callback && (collector = function () {
			!--len && callback.call(set);
		});
		easing = R.is(easing, string) ? easing : collector;
		var anim = R.animation(params, ms, easing, collector);
		item = this.items[--i].animate(anim);
		while (i--) {
			this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
		}
		return this;
	};
	setproto.insertAfter = function (el) {
		var i = this.items.length;
		while (i--) {
			this.items[i].insertAfter(el);
		}
		return this;
	};
	setproto.getBBox = function () {
		var x = [],
			y = [],
			x2 = [],
			y2 = [];
		for (var i = this.items.length; i--;) if (!this.items[i].removed) {
			var box = this.items[i].getBBox();
			x.push(box.x);
			y.push(box.y);
			x2.push(box.x + box.width);
			y2.push(box.y + box.height);
		}
		x = mmin[apply](0, x);
		y = mmin[apply](0, y);
		x2 = mmax[apply](0, x2);
		y2 = mmax[apply](0, y2);
		return {
			x: x,
			y: y,
			x2: x2,
			y2: y2,
			width: x2 - x,
			height: y2 - y
		};
	};
	setproto.clone = function (s) {
		s = new Set;
		for (var i = 0, ii = this.items.length; i < ii; i++) {
			s.push(this.items[i].clone());
		}
		return s;
	};
	setproto.toString = function () {
		return "Rapha\xebl\u2018s set";
	};


	R.registerFont = function (font) {
		if (!font.face) {
			return font;
		}
		this.fonts = this.fonts || {};
		var fontcopy = {
				w: font.w,
				face: {},
				glyphs: {}
			},
			family = font.face["font-family"];
		for (var prop in font.face) if (font.face[has](prop)) {
			fontcopy.face[prop] = font.face[prop];
		}
		if (this.fonts[family]) {
			this.fonts[family].push(fontcopy);
		} else {
			this.fonts[family] = [fontcopy];
		}
		if (!font.svg) {
			fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
			for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
				var path = font.glyphs[glyph];
				fontcopy.glyphs[glyph] = {
					w: path.w,
					k: {},
					d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
						return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
					}) + "z"
				};
				if (path.k) {
					for (var k in path.k) if (path[has](k)) {
						fontcopy.glyphs[glyph].k[k] = path.k[k];
					}
				}
			}
		}
		return font;
	};

	paperproto.getFont = function (family, weight, style, stretch) {
		stretch = stretch || "normal";
		style = style || "normal";
		weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
		if (!R.fonts) {
			return;
		}
		var font = R.fonts[family];
		if (!font) {
			var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
			for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
				if (name.test(fontName)) {
					font = R.fonts[fontName];
					break;
				}
			}
		}
		var thefont;
		if (font) {
			for (var i = 0, ii = font.length; i < ii; i++) {
				thefont = font[i];
				if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
					break;
				}
			}
		}
		return thefont;
	};

	paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
		origin = origin || "middle"; // baseline|middle
		letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
		var letters = Str(string)[split](E),
			shift = 0,
			notfirst = 0,
			path = E,
			scale;
		R.is(font, string) && (font = this.getFont(font));
		if (font) {
			scale = (size || 16) / font.face["units-per-em"];
			var bb = font.face.bbox[split](separator),
				top = +bb[0],
				lineHeight = bb[3] - bb[1],
				shifty = 0,
				height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
			for (var i = 0, ii = letters.length; i < ii; i++) {
				if (letters[i] == "\n") {
					shift = 0;
					curr = 0;
					notfirst = 0;
					shifty += lineHeight;
				} else {
					var prev = notfirst && font.glyphs[letters[i - 1]] || {},
						curr = font.glyphs[letters[i]];
					shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
					notfirst = 1;
				}
				if (curr && curr.d) {
					path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
				}
			}
		}
		return this.path(path).attr({
			fill: "#000",
			stroke: "none"
		});
	};


	paperproto.add = function (json) {
		if (R.is(json, "array")) {
			var res = this.set(),
				i = 0,
				ii = json.length,
				j;
			for (; i < ii; i++) {
				j = json[i] || {};
				elements[has](j.type) && res.push(this[j.type]().attr(j));
			}
		}
		return res;
	};


	R.format = function (token, params) {
		var args = R.is(params, array) ? [0][concat](params) : arguments;
		token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
			return args[++i] == null ? E : args[i];
		}));
		return token || E;
	};

	R.fullfill = (function () {
		var tokenRegex = /\{([^\}]+)\}/g,
			objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
			replacer = function (all, key, obj) {
				var res = obj;
				key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
					name = name || quotedName;
					if (res) {
						if (name in res) {
							res = res[name];
						}
						typeof res == "function" && isFunc && (res = res());
					}
				});
				res = (res == null || res == obj ? all : res) + "";
				return res;
			};
		return function (str, obj) {
			return String(str).replace(tokenRegex, function (all, key) {
				return replacer(all, key, obj);
			});
		};
	})();

	R.ninja = function () {
		oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
		return R;
	};

	R.st = setproto;
	// Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
	(function (doc, loaded, f) {
		if (doc.readyState == null && doc.addEventListener) {
			doc.addEventListener(loaded, f = function () {
				doc.removeEventListener(loaded, f, false);
				doc.readyState = "complete";
			}, false);
			doc.readyState = "loading";
		}
		function isLoaded() {
			(/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
		}

		isLoaded();
	})(document, "DOMContentLoaded");

	oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

	eve.on("raphael.DOMload", function () {
		loaded = true;
	});
})();


// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël - JavaScript Vector Library                                 │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ SVG Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
window.Raphael.svg && function (R) {
	var has = "hasOwnProperty",
		Str = String,
		toFloat = parseFloat,
		toInt = parseInt,
		math = Math,
		mmax = math.max,
		abs = math.abs,
		pow = math.pow,
		separator = /[, ]+/,
		eve = R.eve,
		E = "",
		S = " ";
	var xlink = "http://www.w3.org/1999/xlink",
		markers = {
			block: "M5,0 0,2.5 5,5z",
			classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
			diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
			open: "M6,1 1,3.5 6,6",
			oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
		},
		markerCounter = {};
	R.toString = function () {
		return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
	};
	var $ = function (el, attr) {
			if (attr) {
				if (typeof el == "string") {
					el = $(el);
				}
				for (var key in attr) if (attr[has](key)) {
					if (key.substring(0, 6) == "xlink:") {
						el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
					} else {
						el.setAttribute(key, Str(attr[key]));
					}
				}
			} else {
				el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
				el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
			}
			return el;
		},
		addGradientFill = function (element, gradient) {
			var type = "linear",
				id = "grad:" + element.id + gradient,
				fx = .5, fy = .5,
				o = element.node,
				SVG = element.paper,
				s = o.style,
				el = R._g.doc.getElementById(id);
			if (!el) {
				gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
					type = "radial";
					if (_fx && _fy) {
						fx = toFloat(_fx);
						fy = toFloat(_fy);
						var dir = ((fy > .5) * 2 - 1);
						pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
						(fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
							fy != .5 &&
						(fy = fy.toFixed(5) - 1e-5 * dir);
					}
					return E;
				});
				gradient = gradient.split(/\s*\-\s*/);
				if (type == "linear") {
					var angle = gradient.shift();
					angle = -toFloat(angle);
					if (isNaN(angle)) {
						return null;
					}
					var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
						max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
					vector[2] *= max;
					vector[3] *= max;
					if (vector[2] < 0) {
						vector[0] = -vector[2];
						vector[2] = 0;
					}
					if (vector[3] < 0) {
						vector[1] = -vector[3];
						vector[3] = 0;
					}
				}
				var dots = R._parseDots(gradient);
				if (!dots) {
					return null;
				}
				id = id.replace(/[\(\)\s,\xb0#]/g, "_");

				if (element.gradient && id != element.gradient.id) {
					SVG.defs.removeChild(element.gradient);
					delete element.gradient;
				}

				if (!element.gradient) {
					el = $(type + "Gradient", {id: id});
					element.gradient = el;
					$(el, type == "radial" ? {
						fx: fx,
						fy: fy
					} : {
						x1: vector[0],
						y1: vector[1],
						x2: vector[2],
						y2: vector[3]
						//gradientTransform: element.matrix.invert()
					});
					SVG.defs.appendChild(el);
					for (var i = 0, ii = dots.length; i < ii; i++) {
						el.appendChild($("stop", {
							offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
							"stop-color": dots[i].color || "#fff"
						}));
					}
				}
			}
			$(o, {
				fill: "url(#" + id + ")",
				opacity: 1,
				"fill-opacity": 1
			});
			s.fill = E;
			s.opacity = 1;
			s.fillOpacity = 1;
			return 1;
		},
		updatePosition = function (o) {
			var bbox = o.getBBox(1);
			$(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
		},
		addArrow = function (o, value, isEnd) {
			if (o.type == "path") {
				var values = Str(value).toLowerCase().split("-"),
					p = o.paper,
					se = isEnd ? "end" : "start",
					node = o.node,
					attrs = o.attrs,
					stroke = attrs["stroke-width"],
					i = values.length,
					type = "classic",
					from,
					to,
					dx,
					refX,
					attr,
					w = 3,
					h = 3,
					t = 5;
				while (i--) {
					switch (values[i]) {
						case "block":
						case "classic":
						case "oval":
						case "diamond":
						case "open":
						case "none":
							type = values[i];
							break;
						case "wide":
							h = 5;
							break;
						case "narrow":
							h = 2;
							break;
						case "long":
							w = 5;
							break;
						case "short":
							w = 2;
							break;
					}
				}
				if (type == "open") {
					w += 2;
					h += 2;
					t += 2;
					dx = 1;
					refX = isEnd ? 4 : 1;
					attr = {
						fill: "none",
						stroke: attrs.stroke
					};
				} else {
					refX = dx = w / 2;
					attr = {
						fill: attrs.stroke,
						stroke: "none"
					};
				}
				if (o._.arrows) {
					if (isEnd) {
						o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
						o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
					} else {
						o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
						o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
					}
				} else {
					o._.arrows = {};
				}
				if (type != "none") {
					var pathId = "raphael-marker-" + type,
						markerId = "raphael-marker-" + se + type + w + h;
					if (!R._g.doc.getElementById(pathId)) {
						p.defs.appendChild($($("path"), {
							"stroke-linecap": "round",
							d: markers[type],
							id: pathId
						}));
						markerCounter[pathId] = 1;
					} else {
						markerCounter[pathId]++;
					}
					var marker = R._g.doc.getElementById(markerId),
						use;
					if (!marker) {
						marker = $($("marker"), {
							id: markerId,
							markerHeight: h,
							markerWidth: w,
							orient: "auto",
							refX: refX,
							refY: h / 2
						});
						use = $($("use"), {
							"xlink:href": "#" + pathId,
							transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
							"stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
						});
						marker.appendChild(use);
						p.defs.appendChild(marker);
						markerCounter[markerId] = 1;
					} else {
						markerCounter[markerId]++;
						use = marker.getElementsByTagName("use")[0];
					}
					$(use, attr);
					var delta = dx * (type != "diamond" && type != "oval");
					if (isEnd) {
						from = o._.arrows.startdx * stroke || 0;
						to = R.getTotalLength(attrs.path) - delta * stroke;
					} else {
						from = delta * stroke;
						to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
					}
					attr = {};
					attr["marker-" + se] = "url(#" + markerId + ")";
					if (to || from) {
						attr.d = Raphael.getSubpath(attrs.path, from, to);
					}
					$(node, attr);
					o._.arrows[se + "Path"] = pathId;
					o._.arrows[se + "Marker"] = markerId;
					o._.arrows[se + "dx"] = delta;
					o._.arrows[se + "Type"] = type;
					o._.arrows[se + "String"] = value;
				} else {
					if (isEnd) {
						from = o._.arrows.startdx * stroke || 0;
						to = R.getTotalLength(attrs.path) - from;
					} else {
						from = 0;
						to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
					}
					o._.arrows[se + "Path"] && $(node, {d: Raphael.getSubpath(attrs.path, from, to)});
					delete o._.arrows[se + "Path"];
					delete o._.arrows[se + "Marker"];
					delete o._.arrows[se + "dx"];
					delete o._.arrows[se + "Type"];
					delete o._.arrows[se + "String"];
				}
				for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
					var item = R._g.doc.getElementById(attr);
					item && item.parentNode.removeChild(item);
				}
			}
		},
		dasharray = {
			"": [0],
			"none": [0],
			"-": [3, 1],
			".": [1, 1],
			"-.": [3, 1, 1, 1],
			"-..": [3, 1, 1, 1, 1, 1],
			". ": [1, 3],
			"- ": [4, 3],
			"--": [8, 3],
			"- .": [4, 3, 1, 3],
			"--.": [8, 3, 1, 3],
			"--..": [8, 3, 1, 3, 1, 3]
		},
		addDashes = function (o, value, params) {
			value = dasharray[Str(value).toLowerCase()];
			if (value) {
				var width = o.attrs["stroke-width"] || "1",
					butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
					dashes = [],
					i = value.length;
				while (i--) {
					dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
				}
				$(o.node, {"stroke-dasharray": dashes.join(",")});
			}
		},
		setFillAndStroke = function (o, params) {
			var node = o.node,
				attrs = o.attrs,
				vis = node.style.visibility;
			node.style.visibility = "hidden";
			for (var att in params) {
				if (params[has](att)) {
					if (!R._availableAttrs[has](att)) {
						continue;
					}
					var value = params[att];
					attrs[att] = value;
					switch (att) {
						case "blur":
							o.blur(value);
							break;
						case "href":
						case "title":
						case "target":
							var pn = node.parentNode;
							if (pn.tagName.toLowerCase() != "a") {
								var hl = $("a");
								pn.insertBefore(hl, node);
								hl.appendChild(node);
								pn = hl;
							}
							if (att == "target") {
								pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
							} else {
								pn.setAttributeNS(xlink, att, value);
							}
							break;
						case "cursor":
							node.style.cursor = value;
							break;
						case "transform":
							o.transform(value);
							break;
						case "arrow-start":
							addArrow(o, value);
							break;
						case "arrow-end":
							addArrow(o, value, 1);
							break;
						case "clip-rect":
							var rect = Str(value).split(separator);
							if (rect.length == 4) {
								o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
								var el = $("clipPath"),
									rc = $("rect");
								el.id = R.createUUID();
								$(rc, {
									x: rect[0],
									y: rect[1],
									width: rect[2],
									height: rect[3]
								});
								el.appendChild(rc);
								o.paper.defs.appendChild(el);
								$(node, {"clip-path": "url(#" + el.id + ")"});
								o.clip = rc;
							}
							if (!value) {
								var path = node.getAttribute("clip-path");
								if (path) {
									var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
									clip && clip.parentNode.removeChild(clip);
									$(node, {"clip-path": E});
									delete o.clip;
								}
							}
							break;
						case "path":
							if (o.type == "path") {
								$(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
								o._.dirty = 1;
								if (o._.arrows) {
									"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
									"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
								}
							}
							break;
						case "width":
							node.setAttribute(att, value);
							o._.dirty = 1;
							if (attrs.fx) {
								att = "x";
								value = attrs.x;
							} else {
								break;
							}
						case "x":
							if (attrs.fx) {
								value = -attrs.x - (attrs.width || 0);
							}
						case "rx":
							if (att == "rx" && o.type == "rect") {
								break;
							}
						case "cx":
							node.setAttribute(att, value);
							o.pattern && updatePosition(o);
							o._.dirty = 1;
							break;
						case "height":
							node.setAttribute(att, value);
							o._.dirty = 1;
							if (attrs.fy) {
								att = "y";
								value = attrs.y;
							} else {
								break;
							}
						case "y":
							if (attrs.fy) {
								value = -attrs.y - (attrs.height || 0);
							}
						case "ry":
							if (att == "ry" && o.type == "rect") {
								break;
							}
						case "cy":
							node.setAttribute(att, value);
							o.pattern && updatePosition(o);
							o._.dirty = 1;
							break;
						case "r":
							if (o.type == "rect") {
								$(node, {rx: value, ry: value});
							} else {
								node.setAttribute(att, value);
							}
							o._.dirty = 1;
							break;
						case "src":
							if (o.type == "image") {
								node.setAttributeNS(xlink, "href", value);
							}
							break;
						case "stroke-width":
							if (o._.sx != 1 || o._.sy != 1) {
								value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
							}
							//if (o.paper._vbSize) {
							//    value *= o.paper._vbSize;
							//}
							node.setAttribute(att, value);
							if (attrs["stroke-dasharray"]) {
								addDashes(o, attrs["stroke-dasharray"], params);
							}
							if (o._.arrows) {
								"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
								"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
							}
							break;
						case "stroke-dasharray":
							addDashes(o, value, params);
							break;
						case "fill":
							var isURL = Str(value).match(R._ISURL);
							if (isURL) {
								el = $("pattern");
								var ig = $("image");
								el.id = R.createUUID();
								$(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
								$(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
								el.appendChild(ig);

								(function (el) {
									R._preload(isURL[1], function () {
										var w = this.offsetWidth,
											h = this.offsetHeight;
										$(el, {width: w, height: h});
										$(ig, {width: w, height: h});
										o.paper.safari();
									});
								})(el);
								o.paper.defs.appendChild(el);
								$(node, {fill: "url(#" + el.id + ")"});
								o.pattern = el;
								o.pattern && updatePosition(o);
								break;
							}
							var clr = R.getRGB(value);
							if (!clr.error) {
								delete params.gradient;
								delete attrs.gradient;
								!R.is(attrs.opacity, "undefined") &&
								R.is(params.opacity, "undefined") &&
								$(node, {opacity: attrs.opacity});
								!R.is(attrs["fill-opacity"], "undefined") &&
								R.is(params["fill-opacity"], "undefined") &&
								$(node, {"fill-opacity": attrs["fill-opacity"]});
							} else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
								if ("opacity" in attrs || "fill-opacity" in attrs) {
									var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
									if (gradient) {
										var stops = gradient.getElementsByTagName("stop");
										$(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
									}
								}
								attrs.gradient = value;
								attrs.fill = "none";
								break;
							}
							clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
						case "stroke":
							clr = R.getRGB(value);
							node.setAttribute(att, clr.hex);
							att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
							if (att == "stroke" && o._.arrows) {
								"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
								"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
							}
							break;
						case "gradient":
							(o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
							break;
						case "opacity":
							if (attrs.gradient && !attrs[has]("stroke-opacity")) {
								$(node, {"stroke-opacity": value > 1 ? value / 100 : value});
							}
						// fall
						case "fill-opacity":
							if (attrs.gradient) {
								gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
								if (gradient) {
									stops = gradient.getElementsByTagName("stop");
									$(stops[stops.length - 1], {"stop-opacity": value});
								}
								break;
							}
						default:
							att == "font-size" && (value = toInt(value, 10) + "px");
							var cssrule = att.replace(/(\-.)/g, function (w) {
								return w.substring(1).toUpperCase();
							});
							node.style[cssrule] = value;
							o._.dirty = 1;
							node.setAttribute(att, value);
							break;
					}
				}
			}

			tuneText(o, params);
			node.style.visibility = vis;
		},
		leading = 1.2,
		tuneText = function (el, params) {
			if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
				return;
			}
			var a = el.attrs,
				node = el.node,
				fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

			if (params[has]("text")) {
				a.text = params.text;
				while (node.firstChild) {
					node.removeChild(node.firstChild);
				}
				var texts = Str(params.text).split("\n"),
					tspans = [],
					tspan;
				for (var i = 0, ii = texts.length; i < ii; i++) {
					tspan = $("tspan");
					i && $(tspan, {dy: fontSize * leading, x: a.x});
					tspan.appendChild(R._g.doc.createTextNode(texts[i]));
					node.appendChild(tspan);
					tspans[i] = tspan;
				}
			} else {
				tspans = node.getElementsByTagName("tspan");
				for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
					$(tspans[i], {dy: fontSize * leading, x: a.x});
				} else {
					$(tspans[0], {dy: 0});
				}
			}
			$(node, {x: a.x, y: a.y});
			el._.dirty = 1;
			var bb = el._getBBox(),
				dif = a.y - (bb.y + bb.height / 2);
			dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
		},
		Element = function (node, svg) {
			var X = 0,
				Y = 0;

			this[0] = this.node = node;

			node.raphael = true;

			this.id = R._oid++;
			node.raphaelid = this.id;
			this.matrix = R.matrix();
			this.realPath = null;

			this.paper = svg;
			this.attrs = this.attrs || {};
			this._ = {
				transform: [],
				sx: 1,
				sy: 1,
				deg: 0,
				dx: 0,
				dy: 0,
				dirty: 1
			};
			!svg.bottom && (svg.bottom = this);

			this.prev = svg.top;
			svg.top && (svg.top.next = this);
			svg.top = this;

			this.next = null;
		},
		elproto = R.el;

	Element.prototype = elproto;
	elproto.constructor = Element;

	R._engine.path = function (pathString, SVG) {
		var el = $("path");
		SVG.canvas && SVG.canvas.appendChild(el);
		var p = new Element(el, SVG);
		p.type = "path";
		setFillAndStroke(p, {
			fill: "none",
			stroke: "#000",
			path: pathString
		});
		return p;
	};

	elproto.rotate = function (deg, cx, cy) {
		if (this.removed) {
			return this;
		}
		deg = Str(deg).split(separator);
		if (deg.length - 1) {
			cx = toFloat(deg[1]);
			cy = toFloat(deg[2]);
		}
		deg = toFloat(deg[0]);
		(cy == null) && (cx = cy);
		if (cx == null || cy == null) {
			var bbox = this.getBBox(1);
			cx = bbox.x + bbox.width / 2;
			cy = bbox.y + bbox.height / 2;
		}
		this.transform(this._.transform.concat([
			["r", deg, cx, cy]
		]));
		return this;
	};

	elproto.scale = function (sx, sy, cx, cy) {
		if (this.removed) {
			return this;
		}
		sx = Str(sx).split(separator);
		if (sx.length - 1) {
			sy = toFloat(sx[1]);
			cx = toFloat(sx[2]);
			cy = toFloat(sx[3]);
		}
		sx = toFloat(sx[0]);
		(sy == null) && (sy = sx);
		(cy == null) && (cx = cy);
		if (cx == null || cy == null) {
			var bbox = this.getBBox(1);
		}
		cx = cx == null ? bbox.x + bbox.width / 2 : cx;
		cy = cy == null ? bbox.y + bbox.height / 2 : cy;
		this.transform(this._.transform.concat([
			["s", sx, sy, cx, cy]
		]));
		return this;
	};

	elproto.translate = function (dx, dy) {
		if (this.removed) {
			return this;
		}
		dx = Str(dx).split(separator);
		if (dx.length - 1) {
			dy = toFloat(dx[1]);
		}
		dx = toFloat(dx[0]) || 0;
		dy = +dy || 0;
		this.transform(this._.transform.concat([
			["t", dx, dy]
		]));
		return this;
	};

	elproto.transform = function (tstr) {
		var _ = this._;
		if (tstr == null) {
			return _.transform;
		}
		R._extractTransform(this, tstr);

		this.clip && $(this.clip, {transform: this.matrix.invert()});
		this.pattern && updatePosition(this);
		this.node && $(this.node, {transform: this.matrix});

		if (_.sx != 1 || _.sy != 1) {
			var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
			this.attr({"stroke-width": sw});
		}

		return this;
	};

	elproto.hide = function () {
		!this.removed && this.paper.safari(this.node.style.display = "none");
		return this;
	};

	elproto.show = function () {
		!this.removed && this.paper.safari(this.node.style.display = "");
		return this;
	};

	elproto.remove = function () {
		if (this.removed || !this.node.parentNode) {
			return;
		}
		var paper = this.paper;
		paper.__set__ && paper.__set__.exclude(this);
		eve.unbind("raphael.*.*." + this.id);
		if (this.gradient) {
			paper.defs.removeChild(this.gradient);
		}
		R._tear(this, paper);
		if (this.node.parentNode.tagName.toLowerCase() == "a") {
			this.node.parentNode.parentNode.removeChild(this.node.parentNode);
		} else {
			this.node.parentNode.removeChild(this.node);
		}
		for (var i in this) {
			this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
		}
		this.removed = true;
	};
	elproto._getBBox = function () {
		if (this.node.style.display == "none") {
			this.show();
			var hide = true;
		}
		var bbox = {};
		try {
			bbox = this.node.getBBox();
		} catch (e) {
			// Firefox 3.0.x plays badly here
		} finally {
			bbox = bbox || {};
		}
		hide && this.hide();
		return bbox;
	};

	elproto.attr = function (name, value) {
		if (this.removed) {
			return this;
		}
		if (name == null) {
			var res = {};
			for (var a in this.attrs) if (this.attrs[has](a)) {
				res[a] = this.attrs[a];
			}
			res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
			res.transform = this._.transform;
			return res;
		}
		if (value == null && R.is(name, "string")) {
			if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
				return this.attrs.gradient;
			}
			if (name == "transform") {
				return this._.transform;
			}
			var names = name.split(separator),
				out = {};
			for (var i = 0, ii = names.length; i < ii; i++) {
				name = names[i];
				if (name in this.attrs) {
					out[name] = this.attrs[name];
				} else if (R.is(this.paper.customAttributes[name], "function")) {
					out[name] = this.paper.customAttributes[name].def;
				} else {
					out[name] = R._availableAttrs[name];
				}
			}
			return ii - 1 ? out : out[names[0]];
		}
		if (value == null && R.is(name, "array")) {
			out = {};
			for (i = 0, ii = name.length; i < ii; i++) {
				out[name[i]] = this.attr(name[i]);
			}
			return out;
		}
		if (value != null) {
			var params = {};
			params[name] = value;
		} else if (name != null && R.is(name, "object")) {
			params = name;
		}
		for (var key in params) {
			eve("raphael.attr." + key + "." + this.id, this, params[key]);
		}
		for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
			var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
			this.attrs[key] = params[key];
			for (var subkey in par) if (par[has](subkey)) {
				params[subkey] = par[subkey];
			}
		}
		setFillAndStroke(this, params);
		return this;
	};

	elproto.toFront = function () {
		if (this.removed) {
			return this;
		}
		if (this.node.parentNode.tagName.toLowerCase() == "a") {
			this.node.parentNode.parentNode.appendChild(this.node.parentNode);
		} else {
			this.node.parentNode.appendChild(this.node);
		}
		var svg = this.paper;
		svg.top != this && R._tofront(this, svg);
		return this;
	};

	elproto.toBack = function () {
		if (this.removed) {
			return this;
		}
		var parent = this.node.parentNode;
		if (parent.tagName.toLowerCase() == "a") {
			parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild);
		} else if (parent.firstChild != this.node) {
			parent.insertBefore(this.node, this.node.parentNode.firstChild);
		}
		R._toback(this, this.paper);
		var svg = this.paper;
		return this;
	};

	elproto.insertAfter = function (element) {
		if (this.removed) {
			return this;
		}
		var node = element.node || element[element.length - 1].node;
		if (node.nextSibling) {
			node.parentNode.insertBefore(this.node, node.nextSibling);
		} else {
			node.parentNode.appendChild(this.node);
		}
		R._insertafter(this, element, this.paper);
		return this;
	};

	elproto.insertBefore = function (element) {
		if (this.removed) {
			return this;
		}
		try{
		    var node = element.node || element[0].node;

            node.parentNode.insertBefore(this.node, node);
            R._insertbefore(this, element, this.paper);
		}catch (exp){
		    console.log(exp)
		}

		return this;
	};
	elproto.blur = function (size) {
		// Experimental. No Safari support. Use it on your own risk.
		var t = this;
		if (+size !== 0) {
			var fltr = $("filter"),
				blur = $("feGaussianBlur");
			t.attrs.blur = size;
			fltr.id = R.createUUID();
			$(blur, {stdDeviation: +size || 1.5});
			fltr.appendChild(blur);
			t.paper.defs.appendChild(fltr);
			t._blur = fltr;
			$(t.node, {filter: "url(#" + fltr.id + ")"});
		} else {
			if (t._blur) {
				t._blur.parentNode.removeChild(t._blur);
				delete t._blur;
				delete t.attrs.blur;
			}
			t.node.removeAttribute("filter");
		}
	};
	R._engine.circle = function (svg, x, y, r) {
		var el = $("circle");
		svg.canvas && svg.canvas.appendChild(el);
		var res = new Element(el, svg);
		res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
		res.type = "circle";
		$(el, res.attrs);
		return res;
	};
	R._engine.rect = function (svg, x, y, w, h, r) {
		var el = $("rect");
		svg.canvas && svg.canvas.appendChild(el);
		var res = new Element(el, svg);
		res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
		res.type = "rect";
		$(el, res.attrs);
		return res;
	};
	R._engine.ellipse = function (svg, x, y, rx, ry) {
		var el = $("ellipse");
		svg.canvas && svg.canvas.appendChild(el);
		var res = new Element(el, svg);
		res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
		res.type = "ellipse";
		$(el, res.attrs);
		return res;
	};
	R._engine.image = function (svg, src, x, y, w, h) {
		var el = $("image");
		$(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
		el.setAttributeNS(xlink, "href", src);
		svg.canvas && svg.canvas.appendChild(el);
		var res = new Element(el, svg);
		res.attrs = {x: x, y: y, width: w, height: h, src: src};
		res.type = "image";
		return res;
	};
	R._engine.text = function (svg, x, y, text) {
		var el = $("text");
		svg.canvas && svg.canvas.appendChild(el);
		var res = new Element(el, svg);
		res.attrs = {
			x: x,
			y: y,
			"text-anchor": "middle",
			text: text,
			"font-family": R._availableAttrs["font-family"],
			"font-size": R._availableAttrs["font-size"],
			stroke: "none",
			fill: "#000"
		};
		res.type = "text";
		setFillAndStroke(res, res.attrs);
		return res;
	};
	R._engine.setSize = function (width, height) {
		this.width = width || this.width;
		this.height = height || this.height;
		this.canvas.setAttribute("width", this.width);
		this.canvas.setAttribute("height", this.height);
		if (this._viewBox) {
			this.setViewBox.apply(this, this._viewBox);
		}
		return this;
	};
	R._engine.create = function () {
		var con = R._getContainer.apply(0, arguments),
			container = con && con.container,
			x = con.x,
			y = con.y,
			width = con.width,
			height = con.height;
		if (!container) {
			throw new Error("SVG container not found.");
		}
		var cnvs = $("svg"),
			css = "overflow:hidden;",
			isFloating;
		x = x || 0;
		y = y || 0;
		width = width || 512;
		height = height || 342;
		$(cnvs, {
			height: height,
			version: 1.1,
			width: width,
			xmlns: "http://www.w3.org/2000/svg"
		});
		if (container == 1) {
			cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
			R._g.doc.body.appendChild(cnvs);
			isFloating = 1;
		} else {
			cnvs.style.cssText = css + "position:relative";
			if (container.firstChild) {
				container.insertBefore(cnvs, container.firstChild);
			} else {
				container.appendChild(cnvs);
			}
		}
		container = new R._Paper;
		container.width = width;
		container.height = height;
		container.canvas = cnvs;
		container.clear();
		container._left = container._top = 0;
		isFloating && (container.renderfix = function () {
		});
		container.renderfix();
		return container;
	};
	R._engine.setViewBox = function (x, y, w, h, fit) {
		eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
		var size = mmax(w / this.width, h / this.height),
			top = this.top,
			aspectRatio = fit ? "meet" : "xMinYMin",
			vb,
			sw;
		if (x == null) {
			if (this._vbSize) {
				size = 1;
			}
			delete this._vbSize;
			vb = "0 0 " + this.width + S + this.height;
		} else {
			this._vbSize = size;
			vb = x + S + y + S + w + S + h;
		}
		$(this.canvas, {
			viewBox: vb,
			preserveAspectRatio: aspectRatio
		});
		while (size && top) {
			sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
			top.attr({"stroke-width": sw});
			top._.dirty = 1;
			top._.dirtyT = 1;
			top = top.prev;
		}
		this._viewBox = [x, y, w, h, !!fit];
		return this;
	};

	R.prototype.renderfix = function () {
		var cnvs = this.canvas,
			s = cnvs.style,
			pos;
		try {
			pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
		} catch (e) {
			pos = cnvs.createSVGMatrix();
		}
		var left = -pos.e % 1,
			top = -pos.f % 1;
		if (left || top) {
			if (left) {
				this._left = (this._left + left) % 1;
				s.left = this._left + "px";
			}
			if (top) {
				this._top = (this._top + top) % 1;
				s.top = this._top + "px";
			}
		}
	};

	R.prototype.clear = function () {
		R.eve("raphael.clear", this);
		var c = this.canvas;
		while (c.firstChild) {
			c.removeChild(c.firstChild);
		}
		this.bottom = this.top = null;
		(this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
		c.appendChild(this.desc);
		c.appendChild(this.defs = $("defs"));
	};

	R.prototype.remove = function () {
		eve("raphael.remove", this);
		this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
		for (var i in this) {
			this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
		}
	};
	var setproto = R.st;
	for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
		setproto[method] = (function (methodname) {
			return function () {
				var arg = arguments;
				return this.forEach(function (el) {
					el[methodname].apply(el, arg);
				});
			};
		})(method);
	}
}(window.Raphael);

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël - JavaScript Vector Library                                 │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ VML Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
window.Raphael.vml && function (R) {
	var has = "hasOwnProperty",
		Str = String,
		toFloat = parseFloat,
		math = Math,
		round = math.round,
		mmax = math.max,
		mmin = math.min,
		abs = math.abs,
		fillString = "fill",
		separator = /[, ]+/,
		eve = R.eve,
		ms = " progid:DXImageTransform.Microsoft",
		S = " ",
		E = "",
		map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
		bites = /([clmz]),?([^clmz]*)/gi,
		blurregexp = / progid:\S+Blur\([^\)]+\)/g,
		val = /-?[^,\s-]+/g,
		cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
		zoom = 21600,
		pathTypes = {path: 1, rect: 1, image: 1},
		ovalTypes = {circle: 1, ellipse: 1},
		path2vml = function (path) {
			var total = /[ahqstv]/ig,
				command = R._pathToAbsolute;
			Str(path).match(total) && (command = R._path2curve);
			total = /[clmz]/g;
			if (command == R._pathToAbsolute && !Str(path).match(total)) {
				var res = Str(path).replace(bites, function (all, command, args) {
					var vals = [],
						isMove = command.toLowerCase() == "m",
						res = map[command];
					args.replace(val, function (value) {
						if (isMove && vals.length == 2) {
							res += vals + map[command == "m" ? "l" : "L"];
							vals = [];
						}
						vals.push(round(value * zoom));
					});
					return res + vals;
				});
				return res;
			}
			var pa = command(path), p, r;
			res = [];
			for (var i = 0, ii = pa.length; i < ii; i++) {
				p = pa[i];
				r = pa[i][0].toLowerCase();
				r == "z" && (r = "x");
				for (var j = 1, jj = p.length; j < jj; j++) {
					r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
				}
				res.push(r);
			}
			return res.join(S);
		},
		compensation = function (deg, dx, dy) {
			var m = R.matrix();
			m.rotate(-deg, .5, .5);
			return {
				dx: m.x(dx, dy),
				dy: m.y(dx, dy)
			};
		},
		setCoords = function (p, sx, sy, dx, dy, deg) {
			var _ = p._,
				m = p.matrix,
				fillpos = _.fillpos,
				o = p.node,
				s = o.style,
				y = 1,
				flip = "",
				dxdy,
				kx = zoom / sx,
				ky = zoom / sy;
			s.visibility = "hidden";
			if (!sx || !sy) {
				return;
			}
			o.coordsize = abs(kx) + S + abs(ky);
			s.rotation = deg * (sx * sy < 0 ? -1 : 1);
			if (deg) {
				var c = compensation(deg, dx, dy);
				dx = c.dx;
				dy = c.dy;
			}
			sx < 0 && (flip += "x");
			sy < 0 && (flip += " y") && (y = -1);
			s.flip = flip;
			o.coordorigin = (dx * -kx) + S + (dy * -ky);
			if (fillpos || _.fillsize) {
				var fill = o.getElementsByTagName(fillString);
				fill = fill && fill[0];
				o.removeChild(fill);
				if (fillpos) {
					c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
					fill.position = c.dx * y + S + c.dy * y;
				}
				if (_.fillsize) {
					fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
				}
				o.appendChild(fill);
			}
			s.visibility = "visible";
		};
	R.toString = function () {
		return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
	};
	var addArrow = function (o, value, isEnd) {
			var values = Str(value).toLowerCase().split("-"),
				se = isEnd ? "end" : "start",
				i = values.length,
				type = "classic",
				w = "medium",
				h = "medium";
			while (i--) {
				switch (values[i]) {
					case "block":
					case "classic":
					case "oval":
					case "diamond":
					case "open":
					case "none":
						type = values[i];
						break;
					case "wide":
					case "narrow":
						h = values[i];
						break;
					case "long":
					case "short":
						w = values[i];
						break;
				}
			}
			var stroke = o.node.getElementsByTagName("stroke")[0];
			stroke[se + "arrow"] = type;
			stroke[se + "arrowlength"] = w;
			stroke[se + "arrowwidth"] = h;
		},
		setFillAndStroke = function (o, params) {
			// o.paper.canvas.style.display = "none";
			o.attrs = o.attrs || {};
			var node = o.node,
				a = o.attrs,
				s = node.style,
				xy,
				newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
				isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
				res = o;


			for (var par in params) if (params[has](par)) {
				a[par] = params[par];
			}
			if (newpath) {
				a.path = R._getPath[o.type](o);
				o._.dirty = 1;
			}
			params.href && (node.href = params.href);
			params.title && (node.title = params.title);
			params.target && (node.target = params.target);
			params.cursor && (s.cursor = params.cursor);
			"blur" in params && o.blur(params.blur);
			if (params.path && o.type == "path" || newpath) {
				node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
				if (o.type == "image") {
					o._.fillpos = [a.x, a.y];
					o._.fillsize = [a.width, a.height];
					setCoords(o, 1, 1, 0, 0, 0);
				}
			}
			"transform" in params && o.transform(params.transform);
			if (isOval) {
				var cx = +a.cx,
					cy = +a.cy,
					rx = +a.rx || +a.r || 0,
					ry = +a.ry || +a.r || 0;
				node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
			}
			if ("clip-rect" in params) {
				var rect = Str(params["clip-rect"]).split(separator);
				if (rect.length == 4) {
					rect[2] = +rect[2] + (+rect[0]);
					rect[3] = +rect[3] + (+rect[1]);
					var div = node.clipRect || R._g.doc.createElement("div"),
						dstyle = div.style;
					dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
					if (!node.clipRect) {
						dstyle.position = "absolute";
						dstyle.top = 0;
						dstyle.left = 0;
						dstyle.width = o.paper.width + "px";
						dstyle.height = o.paper.height + "px";
						node.parentNode.insertBefore(div, node);
						div.appendChild(node);
						node.clipRect = div;
					}
				}
				if (!params["clip-rect"]) {
					node.clipRect && (node.clipRect.style.clip = "auto");
				}
			}
			if (o.textpath) {
				var textpathStyle = o.textpath.style;
				params.font && (textpathStyle.font = params.font);
				params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
				params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
				params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
				params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
			}
			if ("arrow-start" in params) {
				addArrow(res, params["arrow-start"]);
			}
			if ("arrow-end" in params) {
				addArrow(res, params["arrow-end"], 1);
			}
			if (params.opacity != null ||
				params["stroke-width"] != null ||
				params.fill != null ||
				params.src != null ||
				params.stroke != null ||
				params["stroke-width"] != null ||
				params["stroke-opacity"] != null ||
				params["fill-opacity"] != null ||
				params["stroke-dasharray"] != null ||
				params["stroke-miterlimit"] != null ||
				params["stroke-linejoin"] != null ||
				params["stroke-linecap"] != null) {
				var fill = node.getElementsByTagName(fillString),
					newfill = false;
				fill = fill && fill[0];
				!fill && (newfill = fill = createNode(fillString));
				if (o.type == "image" && params.src) {
					fill.src = params.src;
				}
				params.fill && (fill.on = true);
				if (fill.on == null || params.fill == "none" || params.fill === null) {
					fill.on = false;
				}
				if (fill.on && params.fill) {
					var isURL = Str(params.fill).match(R._ISURL);
					if (isURL) {
						fill.parentNode == node && node.removeChild(fill);
						fill.rotate = true;
						fill.src = isURL[1];
						fill.type = "tile";
						var bbox = o.getBBox(1);
						fill.position = bbox.x + S + bbox.y;
						o._.fillpos = [bbox.x, bbox.y];

						R._preload(isURL[1], function () {
							o._.fillsize = [this.offsetWidth, this.offsetHeight];
						});
					} else {
						fill.color = R.getRGB(params.fill).hex;
						fill.src = E;
						fill.type = "solid";
						if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
							a.fill = "none";
							a.gradient = params.fill;
							fill.rotate = false;
						}
					}
				}
				if ("fill-opacity" in params || "opacity" in params) {
					var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
					opacity = mmin(mmax(opacity, 0), 1);
					fill.opacity = opacity;
					if (fill.src) {
						fill.color = "none";
					}
				}
				node.appendChild(fill);
				var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
					newstroke = false;
				!stroke && (newstroke = stroke = createNode("stroke"));
				if ((params.stroke && params.stroke != "none") ||
					params["stroke-width"] ||
					params["stroke-opacity"] != null ||
					params["stroke-dasharray"] ||
					params["stroke-miterlimit"] ||
					params["stroke-linejoin"] ||
					params["stroke-linecap"]) {
					stroke.on = true;
				}
				(params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
				var strokeColor = R.getRGB(params.stroke);
				stroke.on && params.stroke && (stroke.color = strokeColor.hex);
				opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
				var width = (toFloat(params["stroke-width"]) || 1) * .75;
				opacity = mmin(mmax(opacity, 0), 1);
				params["stroke-width"] == null && (width = a["stroke-width"]);
				params["stroke-width"] && (stroke.weight = width);
				width && width < 1 && (opacity *= width) && (stroke.weight = 1);
				stroke.opacity = opacity;

				params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
				stroke.miterlimit = params["stroke-miterlimit"] || 8;
				params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
				if (params["stroke-dasharray"]) {
					var dasharray = {
						"-": "shortdash",
						".": "shortdot",
						"-.": "shortdashdot",
						"-..": "shortdashdotdot",
						". ": "dot",
						"- ": "dash",
						"--": "longdash",
						"- .": "dashdot",
						"--.": "longdashdot",
						"--..": "longdashdotdot"
					};
					stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
				}
				newstroke && node.appendChild(stroke);
			}
			if (res.type == "text") {
				res.paper.canvas.style.display = E;
				var span = res.paper.span,
					m = 100,
					fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
				s = span.style;
				a.font && (s.font = a.font);
				a["font-family"] && (s.fontFamily = a["font-family"]);
				a["font-weight"] && (s.fontWeight = a["font-weight"]);
				a["font-style"] && (s.fontStyle = a["font-style"]);
				fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
				s.fontSize = fontSize * m + "px";
				res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
				var brect = span.getBoundingClientRect();
				res.W = a.w = (brect.right - brect.left) / m;
				res.H = a.h = (brect.bottom - brect.top) / m;
				// res.paper.canvas.style.display = "none";
				res.X = a.x;
				res.Y = a.y + res.H / 2;

				("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
				var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
				for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
					res._.dirty = 1;
					break;
				}

				// text-anchor emulation
				switch (a["text-anchor"]) {
					case "start":
						res.textpath.style["v-text-align"] = "left";
						res.bbx = res.W / 2;
						break;
					case "end":
						res.textpath.style["v-text-align"] = "right";
						res.bbx = -res.W / 2;
						break;
					default:
						res.textpath.style["v-text-align"] = "center";
						res.bbx = 0;
						break;
				}
				res.textpath.style["v-text-kern"] = true;
			}
			// res.paper.canvas.style.display = E;
		},
		addGradientFill = function (o, gradient, fill) {
			o.attrs = o.attrs || {};
			var attrs = o.attrs,
				pow = Math.pow,
				opacity,
				oindex,
				type = "linear",
				fxfy = ".5 .5";
			o.attrs.gradient = gradient;
			gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
				type = "radial";
				if (fx && fy) {
					fx = toFloat(fx);
					fy = toFloat(fy);
					pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
					fxfy = fx + S + fy;
				}
				return E;
			});
			gradient = gradient.split(/\s*\-\s*/);
			if (type == "linear") {
				var angle = gradient.shift();
				angle = -toFloat(angle);
				if (isNaN(angle)) {
					return null;
				}
			}
			var dots = R._parseDots(gradient);
			if (!dots) {
				return null;
			}
			o = o.shape || o.node;
			if (dots.length) {
				o.removeChild(fill);
				fill.on = true;
				fill.method = "none";
				fill.color = dots[0].color;
				fill.color2 = dots[dots.length - 1].color;
				var clrs = [];
				for (var i = 0, ii = dots.length; i < ii; i++) {
					dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
				}
				fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
				if (type == "radial") {
					fill.type = "gradientTitle";
					fill.focus = "100%";
					fill.focussize = "0 0";
					fill.focusposition = fxfy;
					fill.angle = 0;
				} else {
					// fill.rotate= true;
					fill.type = "gradient";
					fill.angle = (270 - angle) % 360;
				}
				o.appendChild(fill);
			}
			return 1;
		},
		Element = function (node, vml) {
			this[0] = this.node = node;
			node.raphael = true;
			this.id = R._oid++;
			node.raphaelid = this.id;
			this.X = 0;
			this.Y = 0;
			this.attrs = {};
			this.paper = vml;
			this.matrix = R.matrix();
			this._ = {
				transform: [],
				sx: 1,
				sy: 1,
				dx: 0,
				dy: 0,
				deg: 0,
				dirty: 1,
				dirtyT: 1
			};
			!vml.bottom && (vml.bottom = this);
			this.prev = vml.top;
			vml.top && (vml.top.next = this);
			vml.top = this;
			this.next = null;
		};
	var elproto = R.el;

	Element.prototype = elproto;
	elproto.constructor = Element;
	elproto.transform = function (tstr) {
		if (tstr == null) {
			return this._.transform;
		}
		var vbs = this.paper._viewBoxShift,
			vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
			oldt;
		if (vbs) {
			oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
		}
		R._extractTransform(this, vbt + tstr);
		var matrix = this.matrix.clone(),
			skew = this.skew,
			o = this.node,
			split,
			isGrad = ~Str(this.attrs.fill).indexOf("-"),
			isPatt = !Str(this.attrs.fill).indexOf("url(");
		matrix.translate(-.5, -.5);
		if (isPatt || isGrad || this.type == "image") {
			skew.matrix = "1 0 0 1";
			skew.offset = "0 0";
			split = matrix.split();
			if ((isGrad && split.noRotation) || !split.isSimple) {
				o.style.filter = matrix.toFilter();
				var bb = this.getBBox(),
					bbt = this.getBBox(1),
					dx = bb.x - bbt.x,
					dy = bb.y - bbt.y;
				o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
				setCoords(this, 1, 1, dx, dy, 0);
			} else {
				o.style.filter = E;
				setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
			}
		} else {
			o.style.filter = E;
			skew.matrix = Str(matrix);
			skew.offset = matrix.offset();
		}
		oldt && (this._.transform = oldt);
		return this;
	};
	elproto.rotate = function (deg, cx, cy) {
		if (this.removed) {
			return this;
		}
		if (deg == null) {
			return;
		}
		deg = Str(deg).split(separator);
		if (deg.length - 1) {
			cx = toFloat(deg[1]);
			cy = toFloat(deg[2]);
		}
		deg = toFloat(deg[0]);
		(cy == null) && (cx = cy);
		if (cx == null || cy == null) {
			var bbox = this.getBBox(1);
			cx = bbox.x + bbox.width / 2;
			cy = bbox.y + bbox.height / 2;
		}
		this._.dirtyT = 1;
		this.transform(this._.transform.concat([
			["r", deg, cx, cy]
		]));
		return this;
	};
	elproto.translate = function (dx, dy) {
		if (this.removed) {
			return this;
		}
		dx = Str(dx).split(separator);
		if (dx.length - 1) {
			dy = toFloat(dx[1]);
		}
		dx = toFloat(dx[0]) || 0;
		dy = +dy || 0;
		if (this._.bbox) {
			this._.bbox.x += dx;
			this._.bbox.y += dy;
		}
		this.transform(this._.transform.concat([
			["t", dx, dy]
		]));
		return this;
	};
	elproto.scale = function (sx, sy, cx, cy) {
		if (this.removed) {
			return this;
		}
		sx = Str(sx).split(separator);
		if (sx.length - 1) {
			sy = toFloat(sx[1]);
			cx = toFloat(sx[2]);
			cy = toFloat(sx[3]);
			isNaN(cx) && (cx = null);
			isNaN(cy) && (cy = null);
		}
		sx = toFloat(sx[0]);
		(sy == null) && (sy = sx);
		(cy == null) && (cx = cy);
		if (cx == null || cy == null) {
			var bbox = this.getBBox(1);
		}
		cx = cx == null ? bbox.x + bbox.width / 2 : cx;
		cy = cy == null ? bbox.y + bbox.height / 2 : cy;

		this.transform(this._.transform.concat([
			["s", sx, sy, cx, cy]
		]));
		this._.dirtyT = 1;
		return this;
	};
	elproto.hide = function () {
		!this.removed && (this.node.style.display = "none");
		return this;
	};
	elproto.show = function () {
		!this.removed && (this.node.style.display = E);
		return this;
	};
	elproto._getBBox = function () {
		if (this.removed) {
			return {};
		}
		return {
			x: this.X + (this.bbx || 0) - this.W / 2,
			y: this.Y - this.H,
			width: this.W,
			height: this.H
		};
	};
	elproto.remove = function () {
		if (this.removed || !this.node.parentNode) {
			return;
		}
		this.paper.__set__ && this.paper.__set__.exclude(this);
		R.eve.unbind("raphael.*.*." + this.id);
		R._tear(this, this.paper);
		this.node.parentNode.removeChild(this.node);
		this.shape && this.shape.parentNode.removeChild(this.shape);
		for (var i in this) {
			this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
		}
		this.removed = true;
	};
	elproto.attr = function (name, value) {
		if (this.removed) {
			return this;
		}
		if (name == null) {
			var res = {};
			for (var a in this.attrs) if (this.attrs[has](a)) {
				res[a] = this.attrs[a];
			}
			res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
			res.transform = this._.transform;
			return res;
		}
		if (value == null && R.is(name, "string")) {
			if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
				return this.attrs.gradient;
			}
			var names = name.split(separator),
				out = {};
			for (var i = 0, ii = names.length; i < ii; i++) {
				name = names[i];
				if (name in this.attrs) {
					out[name] = this.attrs[name];
				} else if (R.is(this.paper.customAttributes[name], "function")) {
					out[name] = this.paper.customAttributes[name].def;
				} else {
					out[name] = R._availableAttrs[name];
				}
			}
			return ii - 1 ? out : out[names[0]];
		}
		if (this.attrs && value == null && R.is(name, "array")) {
			out = {};
			for (i = 0, ii = name.length; i < ii; i++) {
				out[name[i]] = this.attr(name[i]);
			}
			return out;
		}
		var params;
		if (value != null) {
			params = {};
			params[name] = value;
		}
		value == null && R.is(name, "object") && (params = name);
		for (var key in params) {
			eve("raphael.attr." + key + "." + this.id, this, params[key]);
		}
		if (params) {
			for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
				var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
				this.attrs[key] = params[key];
				for (var subkey in par) if (par[has](subkey)) {
					params[subkey] = par[subkey];
				}
			}
			// this.paper.canvas.style.display = "none";
			if (params.text && this.type == "text") {
				this.textpath.string = params.text;
			}
			setFillAndStroke(this, params);
			// this.paper.canvas.style.display = E;
		}
		return this;
	};
	elproto.toFront = function () {
		!this.removed && this.node.parentNode.appendChild(this.node);
		this.paper && this.paper.top != this && R._tofront(this, this.paper);
		return this;
	};
	elproto.toBack = function () {
		if (this.removed) {
			return this;
		}
		if (this.node.parentNode.firstChild != this.node) {
			this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
			R._toback(this, this.paper);
		}
		return this;
	};
	elproto.insertAfter = function (element) {
		if (this.removed) {
			return this;
		}
		if (element.constructor == R.st.constructor) {
			element = element[element.length - 1];
		}
		if (element.node.nextSibling) {
			element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
		} else {
			element.node.parentNode.appendChild(this.node);
		}
		R._insertafter(this, element, this.paper);
		return this;
	};
	elproto.insertBefore = function (element) {
		if (this.removed) {
			return this;
		}
		if (element.constructor == R.st.constructor) {
			element = element[0];
		}
		element.node.parentNode.insertBefore(this.node, element.node);
		R._insertbefore(this, element, this.paper);
		return this;
	};
	elproto.blur = function (size) {
		var s = this.node.runtimeStyle,
			f = s.filter;
		f = f.replace(blurregexp, E);
		if (+size !== 0) {
			this.attrs.blur = size;
			s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
			s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
		} else {
			s.filter = f;
			s.margin = 0;
			delete this.attrs.blur;
		}
	};

	R._engine.path = function (pathString, vml) {
		var el = createNode("shape");
		el.style.cssText = cssDot;
		el.coordsize = zoom + S + zoom;
		el.coordorigin = vml.coordorigin;
		var p = new Element(el, vml),
			attr = {fill: "none", stroke: "#000"};
		pathString && (attr.path = pathString);
		p.type = "path";
		p.path = [];
		p.Path = E;
		setFillAndStroke(p, attr);
		vml.canvas.appendChild(el);
		var skew = createNode("skew");
		skew.on = true;
		el.appendChild(skew);
		p.skew = skew;
		p.transform(E);
		return p;
	};
	R._engine.rect = function (vml, x, y, w, h, r) {
		var path = R._rectPath(x, y, w, h, r),
			res = vml.path(path),
			a = res.attrs;
		res.X = a.x = x;
		res.Y = a.y = y;
		res.W = a.width = w;
		res.H = a.height = h;
		a.r = r;
		a.path = path;
		res.type = "rect";
		return res;
	};
	R._engine.ellipse = function (vml, x, y, rx, ry) {
		var res = vml.path(),
			a = res.attrs;
		res.X = x - rx;
		res.Y = y - ry;
		res.W = rx * 2;
		res.H = ry * 2;
		res.type = "ellipse";
		setFillAndStroke(res, {
			cx: x,
			cy: y,
			rx: rx,
			ry: ry
		});
		return res;
	};
	R._engine.circle = function (vml, x, y, r) {
		var res = vml.path(),
			a = res.attrs;
		res.X = x - r;
		res.Y = y - r;
		res.W = res.H = r * 2;
		res.type = "circle";
		setFillAndStroke(res, {
			cx: x,
			cy: y,
			r: r
		});
		return res;
	};
	R._engine.image = function (vml, src, x, y, w, h) {
		var path = R._rectPath(x, y, w, h),
			res = vml.path(path).attr({stroke: "none"}),
			a = res.attrs,
			node = res.node,
			fill = node.getElementsByTagName(fillString)[0];
		a.src = src;
		res.X = a.x = x;
		res.Y = a.y = y;
		res.W = a.width = w;
		res.H = a.height = h;
		a.path = path;
		res.type = "image";
		fill.parentNode == node && node.removeChild(fill);
		fill.rotate = true;
		fill.src = src;
		fill.type = "tile";
		res._.fillpos = [x, y];
		res._.fillsize = [w, h];
		node.appendChild(fill);
		setCoords(res, 1, 1, 0, 0, 0);
		return res;
	};
	R._engine.text = function (vml, x, y, text) {
		var el = createNode("shape"),
			path = createNode("path"),
			o = createNode("textpath");
		x = x || 0;
		y = y || 0;
		text = text || "";
		path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
		path.textpathok = true;
		o.string = Str(text);
		o.on = true;
		el.style.cssText = cssDot;
		el.coordsize = zoom + S + zoom;
		el.coordorigin = "0 0";
		var p = new Element(el, vml),
			attr = {
				fill: "#000",
				stroke: "none",
				"font-family": R._availableAttrs["font-family"],
				"font-size": R._availableAttrs["font-size"],
				text: text
			};
		p.shape = el;
		p.path = path;
		p.textpath = o;
		p.type = "text";
		p.attrs.text = Str(text);
		p.attrs.x = x;
		p.attrs.y = y;
		p.attrs.w = 1;
		p.attrs.h = 1;
		setFillAndStroke(p, attr);
		el.appendChild(o);
		el.appendChild(path);
		vml.canvas.appendChild(el);
		var skew = createNode("skew");
		skew.on = true;
		el.appendChild(skew);
		p.skew = skew;
		p.transform(E);
		return p;
	};
	R._engine.setSize = function (width, height) {
		var cs = this.canvas.style;
		this.width = width;
		this.height = height;
		width == +width && (width += "px");
		height == +height && (height += "px");
		cs.width = width;
		cs.height = height;
		cs.clip = "rect(0 " + width + " " + height + " 0)";
		if (this._viewBox) {
			R._engine.setViewBox.apply(this, this._viewBox);
		}
		return this;
	};
	R._engine.setViewBox = function (x, y, w, h, fit) {
		R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
		var width = this.width,
			height = this.height,
			size = 1 / mmax(w / width, h / height),
			H, W;
		if (fit) {
			H = height / h;
			W = width / w;
			if (w * H < width) {
				x -= (width - w * H) / 2 / H;
			}
			if (h * W < height) {
				y -= (height - h * W) / 2 / W;
			}
		}
		this._viewBox = [x, y, w, h, !!fit];
		this._viewBoxShift = {
			dx: -x,
			dy: -y,
			scale: size
		};
		this.forEach(function (el) {
			el.transform("...");
		});
		return this;
	};
	var createNode;
	R._engine.initWin = function (win) {
		var doc = win.document;
		doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
		try {
			!doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
			createNode = function (tagName) {
				return doc.createElement('<rvml:' + tagName + ' class="rvml">');
			};
		} catch (e) {
			createNode = function (tagName) {
				return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
			};
		}
	};
	R._engine.initWin(R._g.win);
	R._engine.create = function () {
		var con = R._getContainer.apply(0, arguments),
			container = con.container,
			height = con.height,
			s,
			width = con.width,
			x = con.x,
			y = con.y;
		if (!container) {
			throw new Error("VML container not found.");
		}
		var res = new R._Paper,
			c = res.canvas = R._g.doc.createElement("div"),
			cs = c.style;
		x = x || 0;
		y = y || 0;
		width = width || 512;
		height = height || 342;
		res.width = width;
		res.height = height;
		width == +width && (width += "px");
		height == +height && (height += "px");
		res.coordsize = zoom * 1e3 + S + zoom * 1e3;
		res.coordorigin = "0 0";
		res.span = R._g.doc.createElement("span");
		res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
		c.appendChild(res.span);
		cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
		if (container == 1) {
			R._g.doc.body.appendChild(c);
			cs.left = x + "px";
			cs.top = y + "px";
			cs.position = "absolute";
		} else {
			if (container.firstChild) {
				container.insertBefore(c, container.firstChild);
			} else {
				container.appendChild(c);
			}
		}
		res.renderfix = function () {
		};
		return res;
	};
	R.prototype.clear = function () {
		R.eve("raphael.clear", this);
		this.canvas.innerHTML = E;
		this.span = R._g.doc.createElement("span");
		this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
		this.canvas.appendChild(this.span);
		this.bottom = this.top = null;
	};
	R.prototype.remove = function () {
		R.eve("raphael.remove", this);
		this.canvas.parentNode.removeChild(this.canvas);
		for (var i in this) {
			this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
		}
		return true;
	};

	var setproto = R.st;
	for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
		setproto[method] = (function (methodname) {
			return function () {
				var arg = arguments;
				return this.forEach(function (el) {
					el[methodname].apply(el, arg);
				});
			};
		})(method);
	}
}(window.Raphael);
// Functions in this file provide functionality which is not present in
// one of { InternetExplorer 8, Chrome v28, Firefox 3 } but may be present
// in later verisons of the browsers and/or libriries such as Ext/Prototype
// However the goal was to release a dependency-free package, thus some
// of the mehtods available in other libraries were re-implemented.
// None of the methods modify any of the built-in type prototypes.
// Loop types are picked based on http://jsperf.com/loops/128

var Helpers = {};

// To allow debug code to run in IE7 && IE8 && IE9
if (!window.console) {
	window.console = {log: function () {
	}};
}

// For IE7 && IE8 again
if (typeof String.prototype.trim !== 'function') {
	String.prototype.trim = function () {
		return this.replace(/^\s+|\s+$/g, '');
	}
}

// And again (IE7 && IE8 fix)
if (!Array.prototype.forEach) {
	Array.prototype.forEach = function (fun) {
		var t = Object(this);
		var len = t.length >>> 0;
		if (typeof fun !== "function")
			throw new TypeError();

		var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
		for (var i = 0; i < len; i++) {
			if (i in t)
				fun.call(thisArg, t[i], i, t);
		}
	};
}

// Fix for Safari v4 && v5
if (typeof HTMLElement !== 'undefined' && !HTMLElement.prototype.click && document.createEvent) {
	HTMLElement.prototype.click = function () {
		var eventObj = document.createEvent('MouseEvents');
		eventObj.initEvent('click', true, true);
		this.dispatchEvent(eventObj);
	}
}

// Used for: cloning a 2D array of integers (i.e. no deep copy of elements is necessary)
// Specific implementation is pciked based on http://jsperf.com/clone-2d-array/4
Helpers.clone2DArray = function (arr2D) {
	var new2D = [];
	for (var i = 0; i < arr2D.length; ++i) {
		new2D.push(arr2D[i].slice());
	}
	return new2D;
}

// Creates a shallow copy of the given object
// Specific implementation is picked based on http://jsperf.com/cloning-an-object/4
Helpers.cloneObject = function (obj) {
	var target = {};
	for (var i in obj) {
		if (obj.hasOwnProperty(i))
			target[i] = obj[i];
	}
	return target;
}

// (Recursively) for every property in template check if data has the same property
// and set template value to the one in data.
Helpers.setByTemplate = function (template, data) {
	if (typeof template !== 'object' || typeof data !== 'object') {
		return;
	}
	for (var key in template) {
		if (data.hasOwnProperty(key) && template.hasOwnProperty(key)) {
			if (typeof template[key] === 'object') {
				if (Object.prototype.toString.call(template[key]) === '[object Array]') {
					template[key] = data[key].slice(); // array -> make a copy
				} else {
					Helpers.setByTemplate(template[key], data[key]); // other type of object -> set properties recursively
				}
			} else {
				template[key] = data[key];
			}
		}
	}
}

// Assigns values to all properties which are set in Source to the Target
Helpers.copyProperties = function (objectSource, objectTarget) {
	for (var p in objectSource) {
		if (objectSource.hasOwnProperty(p)) {
			objectTarget[p] = objectSource[p];
		}
	}
}

// Equivalent to (Array.indexOf() != -1)
Helpers.arrayContains = function (array, item) {
	if (Array.prototype.indexOf) {
		return !(array.indexOf(item) < 0);
	}
	else {
		for (var i = 0, len = array.length; i < len; ++i) {
			if (array[i] === item)
				return true;
		}
		return false;
	}
}

// Equivalent to Array.indexOf
Helpers.arrayIndexOf = function (array, item) {
	if (Array.prototype.indexOf) {
		return (array.indexOf(item));
	}
	else {
		for (var i = 0, len = array.length; i < len; ++i) {
			if (array[i] === item)
				return i;
		}
		return -1;
	}
}

Helpers.indexOfLastMinElementInArray = function (array) {
	var min = array[0];
	var minIndex = 0;

	for (var i = 1, len = array.length; i < len; ++i) {
		if (array[i] <= min) {
			minIndex = i;
			min = array[i];
		}
	}
	return minIndex;
}

// Returns an array of unique values from the given array
// Specific implementation is picked based on http://jsperf.com/array-unique2/19
Helpers.filterUnique = function (array) {
	var hash = {},
		result = [],
		i = array.length;
	while (i--) {
		if (!hash[array[i]]) {
			hash[array[i]] = true;
			result.push(array[i]);
		}
	}
	return result;
}

// Replaces the first occurence of `value` in `array` by `newValue`. Does nothing if `value` is not in `array`
Helpers.replaceInArray = function (array, value, newValue) {
	for (var i = 0, len = array.length; i < len; ++i) {
		if (array[i] === value) {
			array[i] = newValue;
			break;
		}
	}
}

// Removes the first occurence of `value` in `array`. Does nothing if `value` is not in `array`
Helpers.removeFirstOccurrenceByValue = function (array, item) {
	for (var i = 0, len = array.length; i < len; ++i) {
		if (array[i] == item) {
			array.splice(i, 1);
			break;
		}
	}
}

// Returns true iff the object has no properties
Helpers.isObjectEmpty = function (map) {
	for (var key in map) {
		if (map.hasOwnProperty(key)) {
			return false;
		}
	}
	return true;
}

// Returns num lines in a text block, or 0 for empty lines. Ignores leading and trailing whitespace
Helpers.numTextLines = function (text) {
	if (text === null || text == "" || (Object.keys(text).length === 0 && text.constructor === Object)) {
		return 0;
	}

	var useText = text.replace(/^\s+|\s+$/g, '');
	var numLines = (useText.match(/\n/g) || []).length + 1;
	return numLines;
}

// Used for: user input validation
Helpers.isInt = function (n) {
	//return +n === n && !(n % 1);
	//return !(n % 1);
	return (!isNaN(n) && parseInt(n) == parseFloat(n));
}

Helpers.toObjectWithTrue = function (array) {
	var obj = {};
	for (var i = 0; i < array.length; ++i)
		if (array[i] !== undefined) obj[array[i]] = true;
	return obj;
}

Helpers.romanize = function (num) {
	if (!+num)
		return false;
	var digits = String(+num).split(""),
		key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
			"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
			"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"],
		roman = "",
		i = 3;
	while (i--)
		roman = (key[+digits.pop() + (i * 10)] || "") + roman;
	return Array(+digits.join("") + 1).join("M") + roman;
}

/*function objectKeys(obj) {
 if (Object.keys)
 return Object.keyhs(obj);

 var keys = [];
 for (var i in obj) {
 if (obj.hasOwnProperty(i)) {
 keys.push(i);
 }
 }
 return keys;
 }*/

Helpers.stopEventPropagation = function (event) {
	event.preventDefault();
	event.stopPropagation();
	event.stopImmediatePropagation();

}
Helpers.disableMouseclicks = function (element) {
	element.__oldMouseDown = element.onmousedown;
	element.onmousedown = Helpers.stopEventPropagation;
	element.__oldClick = element.onclick;
	element.onclick = Helpers.stopEventPropagation;

}
Helpers.enableMouseclicks = function (element) {
	if (element.hasOwnProperty("__oldMouseDown")) {
		element.onmousedown = element.__oldMouseDown;
		delete element.__oldMouseDown;
	} else {
		element.onmousedown = null;
	}
	if (element.hasOwnProperty("__oldClick")) {
		element.onclick = element.__oldClick;
		delete element.__oldClick;
	} else {
		element.onclick = null;
	}
}

//-------------------------------------------------------------
// Used during ordering for bucket order permutations
//-------------------------------------------------------------
Helpers.makeFlattened2DArrayCopy = function (array) {
	var flattenedcopy = [].concat.apply([], array);
	return flattenedcopy;
}

Helpers.swap = function (array, i, j) {
	var b = array[j];
	array[j] = array[i];
	array[i] = b;
}

Helpers.permute2DArrayInFirstDimension = function (permutations, array, from) {
	var len = array.length;

	if (from == len - 1) {
		permutations.push(Helpers.makeFlattened2DArrayCopy(array));
		return;
	}

	for (var j = from; j < len; j++) {
		Helpers.swap(array, from, j);
		Helpers.permute2DArrayInFirstDimension(permutations, array, from + 1);
		Helpers.swap(array, from, j);
	}
}
//-------------------------------------------------------------


//-------------------------------------------------------------
// Used for profiling code
Helpers.Timer = function () {
	this.startTime = undefined;
	this.lastCheck = undefined;
	this.start();
};

Helpers.Timer.prototype = {

	start: function () {
		this.startTime = new Date().getTime();
		this.lastCheck = this.startTime;
	},

	restart: function () {
		this.start();
	},

	report: function () {
		var current = new Date().getTime();
		var elapsed = current - this.lastCheck;
		return elapsed;
	},

	printSinceLast: function (msg) {
		var current = new Date().getTime();
		var elapsed = current - this.lastCheck;
		this.lastCheck = current;
		console.log(msg + elapsed + "ms");
	},
};
//-------------------------------------------------------------


//-------------------------------------------------------------
Helpers.stringifyObject = function (obj) {
	return _printObjectInternal(obj, 1);
}

Helpers.printObject = function (obj) {
	console.log(_printObjectInternal(obj, 0));
}

_printObjectInternal = function (o, level) {
	if (level > 10) return "...[too deep, possibly a recursive object]...";

	var output = '';

	if (typeof o === 'object') {

		if (Object.prototype.toString.call(o) === '[object Array]') {
			output = '[';
			for (var i = 0; i < o.length; i++) {
				if (i > 0) output += ', ';
				output += _printObjectInternal(o[i], level + 1);
			}
			output += ']';
		}
		else {
			output = '{';
			var idx = 0;
			if (level == 0) output += '\n';
			for (var property in o) {
				if (!o.hasOwnProperty(property)) continue;

				if (level != 0 && idx != 0)
					output += ', ';
				output += property + ': ' + _printObjectInternal(o[property], level + 1);

				if (level == 0)
					output += '\n';
				idx++;
			}
			output += '}';
		}
	}
	else if (typeof o === 'string') {
		output = "'" + o + "'";
	}
	else
		output = '' + o;

	return output;
}

Helpers.padString = function (string, width, padding, onLeft) {
	return (width <= string.length) ? string : Helpers.padString((onLeft ? (padding + string) : (string + padding)), width, padding, onLeft);
}
//-------------------------------------------------------------

Helpers.createRandomID = function()
{
	var text = "";
	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

	for( var i=0; i < 5; i++ )
		text += possible.charAt(Math.floor(Math.random() * possible.length));

	return text;
}

Helpers.getSiteURL = function(){
	//returns site address like : "https://gmc.genomicsengland.nhs.uk/rarediseases/demo" OR "http://localhost:8083/openclinica"
	return window.location.origin + window.location.pathname.substr(0, window.location.pathname.lastIndexOf('/'));
}

Helpers.getGenderDisplayText = function(genderString){

	var gender = "Unknown";

	if (!genderString){
	    return gender; //cater for null gender string
	}

	var genderString = genderString.toLowerCase();
	if (genderString == "female" || genderString == "f" || genderString == "2")
		gender = "Female";
	else if (genderString == "male" || genderString == "m" || genderString == "1")
		gender = "Male";
	else if (genderString == "other" || genderString == "o" || genderString == "9")
		gender = "Other";
	return gender;
};

Helpers.wrapStringNonBreak = function(stringToWrap, maxWidth){
    try{
        if (stringToWrap === null || stringToWrap === undefined){
                return stringToWrap;
        }
            var splits = stringToWrap.split('\n');
            var arr = [];
            var returnVal = '';
            var regStr = ".{1," + maxWidth + "}";
            var regex = new RegExp(regStr,"g");

            for (var j=0; j<splits.length; j++ ){
                if (splits[j].length > maxWidth){
                    //var words = splits[j].match(/.{1,5}/g);
                    var words = splits[j].match(regex);
                    arr = arr.concat(words);
                    //arr.push(splits[j].slice(0, maxWidth-1));
                    //arr.push(splits[j].slice(maxWidth-1, splits[j].length-1));
                }else{
                    arr.push(splits[j]);
                }
            }

            for(var i = 0; i < arr.length; i++){
                if (returnVal === ''){
                    returnVal = arr[0];
                }else{
                    returnVal = returnVal + '\n' + arr[i];
                }
            }
            return returnVal;
    }
    catch (err){

        console.warn(err);
        return stringToWrap;
    }


};

Helpers.wrapString = function(stringToWrap, maxWidth){
    try{
        var regStr = '(?![^\\n]{1,maxWidth}$)([^\\n]{1,maxWidth})\\s'.replace(/maxWidth/g, maxWidth);
            return stringToWrap.replace(new RegExp(regStr, 'g'), '$1\n');
    }catch(err){
        console.error("Error wrapping string = " + stringToWrap +  " err="+ err);
    }
};

Helpers.toTitleCase = function (str) {
    var original = str;

    if (str === null || str === undefined || str === ' '){
        return str;
    }

    try{
       str = str.toLowerCase().split(' ');
       for (var i = 0; i < str.length; i++) {
           str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1);
       }
       return str.join(' ');
    }catch (err){
       console.log('Error converting to title case : ' + str );
       return original;
    }


};

Array.prototype.remove = function() {
    var what, a = arguments, L = a.length, ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};

/*For IE 11*/
if (!window.URLSearchParams){
    console.warn('Polyfilling URLSearchParams. Not supported in browser')
    window.URLSearchParams = window.URLSearchParams || function (searchString) {
            var self = this;
            self.searchString = searchString;
            self.get = function (name) {
                var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(self.searchString);
                if (results == null) {
                    return null;
                }
                else {
                    return decodeURI(results[1]) || 0;
                }
            };
        }
}
/*IE 11 support for includes */
if (!String.prototype.includes) {
    String.prototype.includes = function(search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > this.length) {
        return false;
      } else {
        return this.indexOf(search, start) !== -1;
      }
    };
  }
Queue = function () {
	this.data = [];
};

Queue.prototype = {

	setTo: function (list) {
		this.data = list.slice();
	},

	push: function (v) {
		this.data.push(v);
	},

	pop: function (v) {
		return this.data.shift();
	},

	size: function () {
		return this.data.length;
	},

	clear: function () {
		this.data = [];
	}
};


Stack = function () {
	this.data = [];
};

Stack.prototype = {

	setTo: function (list) {
		this.data = list.slice();
	},

	push: function (v) {
		this.data.push(v);
	},

	pop: function (v) {
		return this.data.pop();
	},

	size: function () {
		return this.data.length;
	}
};


// BaseGraph represents the pedigree tree as a graph of nodes and edges with certain
//           properties attached to both (e.g. names for nodes and weights for edges).
//
//           Nodes represent either persons or partnerships, while edges represent
//           either "is part of this partnership" or "is a child of" relationships
//           between the connected nodes.
//
// BaseGraph contains only the information found in the pedigree (plus possibly
//           some cached data), i.e. there is no layout data here.

BaseGraph = function (defaultPersonNodeWidth, defaultNonPersonNodeWidth) {
	this.v = [];        // for each V lists (as unordered arrays of ids) vertices connected from V
	this.inedges = [];        // for each V lists (as unordered arrays of ids) vertices connecting to V

	this.maxRealVertexId = -1; // used for separation of real vertices from virtual-multi-rank-edge-breaking ones (stored for performance)

	this.weights = [];        // for each V contains outgoing edge weights as {target1: weight1, t2: w2}

	this.type = [];      // for each V node type (see BaseGraph.TYPE)
	this.properties = [];      // for each V a set of type-specific properties {"gender": "M"/"F"/"O"/"U", etc.}

	this.vWidth = [];
	this.defaultPersonNodeWidth = defaultPersonNodeWidth ? defaultPersonNodeWidth : 10;
	this.defaultNonPersonNodeWidth = defaultNonPersonNodeWidth ? defaultNonPersonNodeWidth : 2;
};

BaseGraph.TYPE = {
	RELATIONSHIP: 1,
	CHILDHUB: 2,
	PERSON: 3,
	VIRTUALEDGE: 4    // for nodes not present in the original graph used as intermediate steps in multi-rank edges
};

BaseGraph.prototype = {

	serialize: function (saveWidth) {
		var output = [];

		for (var v = 0; v < this.v.length; v++) {
			var data = {};

			data["id"] = v;

			if (saveWidth) // may not want this for compactness of output when all width are equal to default
				data["width"] = this.vWidth[v];

			if (this.type[v] == BaseGraph.TYPE.PERSON) {
				//
			}
			else if (this.type[v] == BaseGraph.TYPE.RELATIONSHIP) {
				data["rel"] = true;
				data["hub"] = true;
			}
			else if (this.type[v] == BaseGraph.TYPE.CHILDHUB) {
				data["chhub"] = true;
			}
			else
				data["virt"] = true;

			data["prop"] = this.properties[v];

			out = [];
			var outEdges = this.getOutEdges(v);
			for (var i = 0; i < outEdges.length; i++) {
				var to = outEdges[i];
				var weight = this.getEdgeWeight(v, to);
				if (weight == 1)
					out.push({"to": outEdges[i]});
				else
					out.push({"to": outEdges[i], "weight": weight});
			}

			if (out.length > 0)
				data["outedges"] = out;

			output.push(data);
		}

		return output;
	},

	//-[construction for ordering]--------------------------

	// After rank assignment, edges between nodes more than one rank apart are replaced by
	// chains of unit length edges between temporary or ‘‘virtual’’ nodes. The virtual nodes are
	// placed on the intermediate ranks, converting the original graph into one whose edges connect
	// only nodes on adjacent ranks
	//
	// Note: ranks is modified to contain ranks of virtual nodes as well

	makeGWithSplitMultiRankEdges: function (ranks) {
		var newG = new BaseGraph(this.defaultPersonNodeWidth, this.defaultNonPersonNodeWidth);

		// add all original vertices
		for (var i = 0; i < this.v.length; i++) {
			newG._addVertex(i, this.type[i], this.properties[i], this.vWidth[i]);
		}

		// go over all original edges:
		// - if edge conects vertices with adjacent ranks just add it
		// - else create a series of virtual vertices and edges and add them together
		for (var sourceV = 0; sourceV < this.v.length; sourceV++) {

			var sourceRank = ranks[sourceV];

			for (var i = 0; i < this.v[sourceV].length; i++) {
				var targetV = this.v[sourceV][i];

				var weight = this.getEdgeWeight(sourceV, targetV);

				var targetRank = ranks[targetV];

				if (targetRank < sourceRank)
					throw "Assertion failed: only forward edges";

				if (targetRank == sourceRank + 1 || targetRank == sourceRank) {
					newG.addEdge(sourceV, targetV, weight);
				}
				else {
					// create virtual vertices & edges
					var prevV = sourceV;
					for (var midRank = sourceRank + 1; midRank <= targetRank - 1; midRank++) {
						var nextV = newG._addVertex(null, BaseGraph.TYPE.VIRTUALEDGE, {"fName": "_" + sourceV + '->' + targetV + '_' + (midRank - sourceRank - 1)}, this.defaultNonPersonNodeWidth);
						ranks[nextV] = midRank;
						newG.addEdge(prevV, nextV, weight);
						prevV = nextV;
					}
					newG.addEdge(prevV, targetV, weight);
				}
			}
		}

		newG.validate();

		return newG;
	},

	makeGWithCollapsedMultiRankEdges: function () {
		// performs the opposite of what makeGWithSplitMultiRankEdges() does
		var newG = new BaseGraph(this.defaultPersonNodeWidth, this.defaultNonPersonNodeWidth);

		// add all original vertices
		for (var i = 0; i <= this.maxRealVertexId; i++) {
			newG._addVertex(i, this.type[i], this.properties[i], this.vWidth[i]);
		}

		// go over all original edges:
		// - if edge conects two non-virtual vertices just add it
		// - else add an edge to the first non-virtual edge at the end of the chain of virtual edges
		for (var sourceV = 0; sourceV <= this.maxRealVertexId; sourceV++) {

			for (var i = 0; i < this.v[sourceV].length; i++) {
				var targetV = this.v[sourceV][i];

				var weight = this.getEdgeWeight(sourceV, targetV);

				while (targetV > this.maxRealVertexId)
					targetV = this.getOutEdges(targetV)[0];

				newG.addEdge(sourceV, targetV, weight);
			}
		}

		newG.validate();

		return newG;
	},

	//--------------------------[construction for ordering]-

	getLeafAndParentlessNodes: function () {
		var result = { "parentlessNodes": [],
			"leafNodes": [] };

		// find all vertices without an in-edge
		for (var vid = 0; vid <= this.maxRealVertexId; vid++) {
			if (this.getInEdges(vid).length == 0) {
				result.parentlessNodes.push(vid);
			}
			else if (this.getOutEdges(vid).length == 0) {
				result.leafNodes.push(vid);
			}
		}

		return result;
	},

	// id: optional. If not specified then next available is used.
	// note: unlike insertVetex() does not do any id shifting and should be used only for initialization of the graph
	_addVertex: function (id, type, properties, width) {
		if (id && this.v[id]) throw "addVertex: vertex with id=" + id + " is already in G";

		var nextId = (id == null) ? this.v.length : id;

		this.v[nextId] = [];

		this.inedges[nextId] = [];

		this.weights[nextId] = {};

		this.vWidth[nextId] = width;

		this.type[nextId] = type;

		this.properties[nextId] = properties;

		if (type != BaseGraph.TYPE.VIRTUALEDGE && nextId > this.maxRealVertexId)
			this.maxRealVertexId = nextId;

		return nextId;
	},

	addEdge: function (fromV, toV, weight) {
		// adds an edge, but does not update all the internal structures for performance reasons.
		// shoudl be used for bulk updates where it makes sense to do one maintenance run for all the nodes
		if (this.v.length < Math.max(fromV, toV))
			throw "addEdge: vertex ID=" + Math.max(fromV, toV) + "] is not in G";

		if (this.hasEdge(fromV, toV))
			throw "addEdge: edge from ID=" + fromV + " to ID=" + toV + " already exists";
		// [maybe] add weights if the same edge is present more than once?

		this.v[fromV].push(toV);
		this.inedges[toV].push(fromV);
		this.weights[fromV][toV] = weight;
	},

	removeEdge: function (fromV, toV) {
		if (!this.hasEdge(fromV, toV))
			throw "removeEdge: edge does not exist";

		Helpers.removeFirstOccurrenceByValue(this.v[fromV], toV);
		Helpers.removeFirstOccurrenceByValue(this.inedges[toV], fromV);

		var weight = this.weights[fromV][toV]
		delete this.weights[fromV][toV];

		return weight;
	},

	insertVertex: function (type, properties, edgeWeights, inedges, outedges, width) {
		var width = width ? width : ((type == BaseGraph.TYPE.PERSON) ? this.defaultPersonNodeWidth : this.defaultNonPersonNodeWidth);

		//TODO: consider making placeholder nodes more narrow. Would require some
		//      more advanced placement once the node is converted to a normal person
		//if (properties.hasOwnProperty("placeholder") && properties["placeholder"]) {
		//    width = this.defaultNonPersonNodeWidth;
		//}

		if (type == BaseGraph.TYPE.PERSON && !properties.hasOwnProperty("gender"))
			properties["gender"] = "U";

		var newNodeId = (type == BaseGraph.TYPE.VIRTUALEDGE) ? this.v.length : this.maxRealVertexId + 1;    // all real node IDs should be <= maxRealVertexId, so have to insert new node here

		// shift all IDs greater or equal to newNodeId up by one (can only hapen when virtual nodes are present)
		if (this.v.length >= newNodeId) {
			// as all existing IDs >= v are increased by one, and all references should be updated
			var test = function (u) {
				return (u >= newNodeId);
			}
			var modification = function (u) {
				return u + 1;
			}
			this._updateAllReferencesToNewIDs(test, modification);
		}

		this.v.splice(newNodeId, 0, []);
		this.inedges.splice(newNodeId, 0, []);
		this.weights.splice(newNodeId, 0, {});
		this.vWidth.splice(newNodeId, 0, width);
		this.type.splice(newNodeId, 0, type);
		this.properties.splice(newNodeId, 0, properties);

		if (type != BaseGraph.TYPE.VIRTUALEDGE)
			this.maxRealVertexId++;

		// add new edges
		for (var i = 0; i < inedges.length; i++)
			this.addEdge(inedges[i], newNodeId, edgeWeights);
		for (var i = 0; i < outedges.length; i++)
			this.addEdge(newNodeId, outedges[i], edgeWeights);

		return newNodeId;
	},

	unplugVirtualVertex: function (v) {
		// disconnectes virtual node from parent/child so that it is easy to recycle/remove later
		if (v <= this.getMaxRealVertexId())
			throw "Attempting to unplug a non-virtual vertex";

		// virtiual nodes guaranteed to have only one in and one out edge
		var parent = this.inedges[v][0];
		var child = this.v[v][0];

		// replace outgoing edge for parent from V to child
		Helpers.replaceInArray(this.v[parent], v, child);
		this.weights[parent][child] = this.weights[parent][v];
		delete this.weights[parent][v];

		// replace incoming edge for child from V to parent
		Helpers.replaceInArray(this.inedges[child], v, parent);

		this.v[v] = [];
		this.inedges[v] = [];
		this.weights[v] = {};
	},

	remove: function (v) {
		for (var i = 0; i < this.v[v].length; i++) {
			var target = this.v[v][i];
			Helpers.removeFirstOccurrenceByValue(this.inedges[target], v);
		}
		for (var i = 0; i < this.inedges[v].length; i++) {
			var incoming = this.inedges[v][i];
			Helpers.removeFirstOccurrenceByValue(this.v[incoming], v);
			delete this.weights[incoming][v];
		}

		//console.log("V before: " + Helpers.stringifyObject(this.v));
		this.v.splice(v, 1);
		//console.log("V after: " + Helpers.stringifyObject(this.v));
		this.inedges.splice(v, 1);
		this.weights.splice(v, 1);
		this.vWidth.splice(v, 1);
		this.type.splice(v, 1);
		this.properties.splice(v, 1);
		if (v <= this.maxRealVertexId)
			this.maxRealVertexId--;

		// as all IDs above v are decreased by one, and all references should be updated
		var test = function (u) {
			return (u > v);
		}
		var modification = function (u) {
			return u - 1;
		}
		this._updateAllReferencesToNewIDs(test, modification);
	},

	_updateAllReferencesToNewIDs: function (test, modification) {
		// updates all references (e.g. out- and in- edge targets, etc.) pointing to
		// ids passing the test() according to modification()
		// decrease all IDs above v by one in all the arrays (v, inedges, weights)

		for (var i = 0; i < this.v.length; i++) {
			for (var j = 0; j < this.v[i].length; j++)
				if (test(this.v[i][j]))
					this.v[i][j] = modification(this.v[i][j]);
			for (var j = 0; j < this.inedges[i].length; j++)
				if (test(this.inedges[i][j]))
					this.inedges[i][j] = modification(this.inedges[i][j]);

			var newWeights = {};
			var weights = this.weights[i];
			for (var u in weights) {
				if (weights.hasOwnProperty(u))
					u = parseInt(u);
				if (test(u))
					newWeights[modification(u)] = weights[u];
				else
					newWeights[u] = weights[u];
			}
			this.weights[i] = newWeights;
		}
	},

	validate: function () {
		//console.log("-- VALIDATING: " + Helpers.stringifyObject(this));

		if (this.v.length == 0) return;

		for (var v = 0; v < this.v.length; v++) {
			var outEdges = this.getOutEdges(v);
			var inEdges = this.getInEdges(v);

			if (this.isPerson(v)) {
				if (inEdges.length > 1)
					throw "Assertion failed: person nodes can't have two in-edges as people are produced by a single pregnancy (failed for " + this.getVertexDescription(v) + ")";
				for (var i = 0; i < outEdges.length; i++)
					if (!this.isRelationship(outEdges[i]) && !this.isVirtual(outEdges[i]))
						throw "Assertion failed: person nodes have only out edges to relationships (failed for " + this.getVertexDescription(v) + ")";
			}
			else if (this.isRelationship(v)) {
				// TODO: for Childless relations this is not true!
				if (outEdges.length == 0)
					throw "Assertion failed: all relationships should have a childhub associated with them (failed for " + this.getVertexDescription(v) + ")";
				if (outEdges.length > 1)
					throw "Assertion failed: all relationships should have only one outedge (to a childhub) (failed for " + this.getVertexDescription(v) + ")";
				if (!this.isChildhub(outEdges[0]))
					throw "Assertion failed: relationships should only have out edges to childhubs (failed for " + this.getVertexDescription(v) + ")";
				if (inEdges.length != 2)
					throw "Assertion failed: relationships should always have exactly two associated persons (failed for " + this.getVertexDescription(v) + ")";
			}
			else if (this.isVirtual(v)) {
				if (outEdges.length != 1)
					throw "Assertion failed: all virtual nodes have exactly one out edge (to a virtual node or a relationship)";
				if (inEdges.length != 1)
					throw "Assertion failed: all virtual nodes have exactly one in edge (from a person or a virtual node)";
				if (!this.isRelationship(outEdges[0]) && !this.isVirtual(outEdges[0]))
					throw "Assertion failed: all virtual nodes may only have an outedge to a virtual node or a relationship";
			}
			else if (this.isChildhub(v)) {
				if (outEdges.length < 1)
					throw "Assertion failed: all childhubs should have at least one child associated with them";  // if not, re-ranking relationship nodes breaks
				for (var i = 0; i < outEdges.length; i++)
					if (!this.isPerson(outEdges[i]))
						throw "Assertion failed: childhubs are only connected to people (failed for " + this.getVertexDescription(v) + ")";
			}
		}

		var leafAndRootlessInfo = this.getLeafAndParentlessNodes();

		// check for cycles - supposedly pedigrees can't have any
		if (leafAndRootlessInfo.parentlessNodes.length == 0)
			throw "Assertion failed: pedigrees should have no cycles (no parentless nodes found)";
		for (var j = 0; j < leafAndRootlessInfo.parentlessNodes.length; j++) {
			if (this._DFSFindCycles(leafAndRootlessInfo.parentlessNodes[j], {}))
				throw "Assertion failed: pedigrees should have no cycles";
		}

		// check for disconnected components
		var reachable = {};
		this._markAllReachableComponents(leafAndRootlessInfo.parentlessNodes[0], reachable);
		for (var v = 0; v < this.v.length; v++) {
			if (!reachable.hasOwnProperty(v))
				throw "Assertion failed: disconnected component detected (" + this.getVertexDescription(v) + ")";
		}

	},

	_DFSFindCycles: function (vertex, visited) {
		visited[vertex] = true;

		var outEdges = this.getOutEdges(vertex);

		for (var i = 0; i < outEdges.length; i++) {
			var v = outEdges[i];

			if (visited.hasOwnProperty(v)) {
				return true;
			}
			else if (this._DFSFindCycles(v, visited)) {
				return true;
			}
		}

		delete visited[vertex];
		return false;
	},

	_markAllReachableComponents: function (vertex, reachable) {
		reachable[vertex] = true;

		var outEdges = this.getOutEdges(vertex);
		for (var i = 0; i < outEdges.length; i++) {
			var v = outEdges[i];
			if (!reachable.hasOwnProperty(v))
				this._markAllReachableComponents(v, reachable);
		}

		var inEdges = this.getInEdges(vertex);
		for (var j = 0; j < inEdges.length; j++) {
			var v = inEdges[j];
			if (!reachable.hasOwnProperty(v))
				this._markAllReachableComponents(v, reachable);
		}
	},

	getVertexNameById: function (v) {
		var firstname = this.properties[v].hasOwnProperty("fName") ? this.properties[v]["fName"] : "";
		var lastname = this.properties[v].hasOwnProperty("lName") ? this.properties[v]["lName"] : "";

		if (firstname != "" && lastname != "") firstname += " ";

		return firstname + lastname;
	},

	getVertexDescription: function (v) {
		var desc = "id: " + v + ", name: <" + this.getVertexNameById(v) + ">, type: ";
		switch (this.type[v]) {
			case BaseGraph.TYPE.PERSON:
				desc += "PERSON";
				break;
			case BaseGraph.TYPE.RELATIONSHIP:
				desc += "RELATION";
				break;
			case BaseGraph.TYPE.CHILDHUB:
				desc += "CHILDHUB";
				break;
			case BaseGraph.TYPE.VIRTUALEDGE:
				desc += "VIRTUAL";
				break;
			default:
				desc += "ERROR";
				break;
		}
		return "[" + desc + "]";
	},

	getVertexWidth: function (v) {
		return this.vWidth[v];
	},

	getVertexHalfWidth: function (v) {
		return Math.floor(this.vWidth[v] / 2);
	},

	getEdgeWeight: function (fromV, toV) {
		return this.weights[fromV][toV];
	},

	hasEdge: function (fromV, toV) {
		return this.weights[fromV].hasOwnProperty(toV);
	},

	isValidId: function (v) {
		return (v >= 0 && v < this.v.length);
	},

	getNumVertices: function () {
		return this.v.length;
	},

	getMaxRealVertexId: function () {
		return this.maxRealVertexId; // all vertices with IDs greater than this are of type VIRTUALEDGE
	},

	getOutEdges: function (v) {
		return this.v[v];
	},

	getInEdges: function (v) {
		return this.inedges[v];
	},

	getAllEdgesWithWeights: function (v) {
		var edgeToWeight = {};

		var outEdges = this.getOutEdges(v);
		for (var i = 0; i < outEdges.length; i++) {
			var u = outEdges[i];
			edgeToWeight[u] = {"weight": this.weights[v][u], "out": true };
		}
		var inEdges = this.getInEdges(v);
		for (var i = 0; i < inEdges.length; i++) {
			var u = inEdges[i];
			edgeToWeight[u] = {"weight": this.weights[u][v], "out": false };
		}

		return edgeToWeight;
	},

	getAllEdges: function (v) {
		return this.getOutEdges(v).concat(this.getInEdges(v));
	},

	isRelationship: function (v) {
		return (this.type[v] == BaseGraph.TYPE.RELATIONSHIP);
	},

	isChildhub: function (v) {
		return (this.type[v] == BaseGraph.TYPE.CHILDHUB);
	},

	isPerson: function (v) {
		return (this.type[v] == BaseGraph.TYPE.PERSON);
	},

	isPlaceholder: function (v) {
		if (!this.isPerson(v) || !this.properties[v].hasOwnProperty("placeholder")) {
			return false;
		}
		if (this.properties[v]["placeholder"]) {
			return true;
		}
		return false;
	},

	isVirtual: function (v) {
		return (this.type[v] == BaseGraph.TYPE.VIRTUALEDGE);  // also: v > getmaxRealVertexId()
	},

	isAdoptedIn: function (v) {
		if (this.properties[v].hasOwnProperty("adoptedStatus"))
			return this.properties[v]["adoptedStatus"] == "adoptedIn";
		return false;
	},

	isAdoptedOut: function (v) {
		if (this.properties[v].hasOwnProperty("adoptedStatus"))
			return this.properties[v]["adoptedStatus"] == "adoptedOut";
		return false;
	},

	getGender: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get gender of a non-person";
		return this.properties[v]["gender"];
	},

	getLastName: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get last name of a non-person";
		if (!this.properties[v].hasOwnProperty("lName")) {
			if (!this.properties[v].hasOwnProperty("lNameAtB")) {
				return "";
			} else {
				return this.properties[v]["lNameAtB"];
			}
		}
		return this.properties[v]["lName"];
	},

	getLastNameAtBirth: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get last name at birth of a non-person";
		if (!this.properties[v].hasOwnProperty("lNameAtB"))
			return "";
		return this.properties[v]["lNameAtB"];
	},

	getOppositeGender: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get gender of a non-person";

		if (this.getGender(v) == "U") {
			return "U";
		}
		else if (this.getGender(v) == "O") {
			return "U";
		}
		else if (this.getGender(v) == "M") {
			return "F";
		}
		else {
			return "M";
		}
	},

	getRelationshipChildhub: function (v) {
		if (!this.isRelationship(v))
			throw "Assertion failed: applying getRelationshipChildhub() to a non-relationship node";

		return this.v[v][0];
	},

	getAllRelationships: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get relationships of a non-person";

		var relationships = this.v[v];

		var result = [];
		for (var r = 0; r < relationships.length; ++r) {
			var edgeTo = relationships[r];
			var relationship = this.downTheChainUntilNonVirtual(edgeTo);
			result.push(relationship);
		}
		return result;
	},

	getAllPartners: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get partners of a non-person";

		var relationships = this.getAllRelationships(v);

		var result = [];
		for (var r = 0; r < relationships.length; ++r) {
			var partners = this.getParents(relationships[r]);
			if (partners[0] != v)
				result.push(partners[0]);
			else
				result.push(partners[1]);
		}
		return result;
	},

	getParents: function (v) {
		if (!this.isPerson(v) && !this.isRelationship(v))
			throw "Assertion failed: attempting to get parents of a non-person and non-relationship";

		// skips through relationship and child nodes and returns an array of two real parents. If none found returns []

		var parentRelationship = this.isPerson(v) ? this.getProducingRelationship(v) : v;

		if (parentRelationship == null)  // no parents
			return [];

		var inEdges = this.getInEdges(parentRelationship);

		if (inEdges.length != 2)
			throw "Assertion failed: exactly two parents";

		return [this.upTheChainUntilNonVirtual(inEdges[0]), this.upTheChainUntilNonVirtual(inEdges[1])];
	},

	getPathToParents: function (v) {
		// returns an array with two elements: path to parent1 (excluding v) and path to parent2 (excluding v):
		// [ [virtual_node_11, ..., virtual_node_1n, parent1], [virtual_node_21, ..., virtual_node_2n, parent21] ]

		var result = [];

		if (!this.isRelationship(v))
			throw "Assertion failed: incorrect v in getPathToParents()";

		var inEdges = this.getInEdges(v);

		result.push(this.getUpPathEndingInNonVirtual(inEdges[0]));
		result.push(this.getUpPathEndingInNonVirtual(inEdges[1]));

		return result;
	},

	getProducingRelationship: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: attempting to get producing relationship of a non-person";

		// find the relationship which produces this node (or null if not present)
		if (this.inedges[v].length == 0) return null;
		var chHub = this.inedges[v][0];

		if (this.inedges[chHub].length == 0) return null;
		return this.inedges[chHub][0];
	},

	upTheChainUntilNonVirtual: function (v) {
		if (!this.isVirtual(v)) return v;

		return this.upTheChainUntilNonVirtual(this.inedges[v][0]);  // virtual nodes have only one in-edges, all the way up until a person node
	},

	downTheChainUntilNonVirtual: function (v) {
		if (!this.isVirtual(v)) return v;

		return this.downTheChainUntilNonVirtual(this.v[v][0]);  // virtual nodes have only one in-edges, all the way up until a person node
	},

	getUpPathEndingInNonVirtual: function (v) {
		var path = [v];

		while (this.isVirtual(v)) {
			v = this.inedges[v][0];
			path.push(v);
		}

		return path;
	},

	getUnusedTwinGroupId: function (v) {
		if (!this.isRelationship(v))
			throw "Assertion failed: incorrect v in getNumTwinGroups()";

		var childhubId = this.v[v][0];
		var children = this.v[childhubId];

		var twinGroupExists = [];
		for (var c = 0; c < children.length; c++) {
			var child = children[c];
			if (this.properties[child].hasOwnProperty('twinGroup'))
				twinGroupExists[this.properties[child]['twinGroup']] = true;
		}

		var firstFreeTwinGroupId = 0;
		for (var i = 0; i < twinGroupExists.length; i++) {
			if (twinGroupExists[i] !== undefined)
				firstFreeTwinGroupId = i + 1;
			else
				break;
		}
		return firstFreeTwinGroupId;
	},

	getTwinGroupId: function (v) {
		if (!this.properties[v].hasOwnProperty('twinGroup'))
			return null;
		return this.properties[v]['twinGroup'];
	},

	getAllSiblingsOf: function (v) {
		// note: includes v itself

		if (!this.isPerson(v))
			throw "Assertion failed: incorrect v in getAllSiblingsOf()";

		if (this.inedges[v].length == 0) {
			return [v];
		}

		var childhubId = this.inedges[v][0];
		var children = this.v[childhubId];
		return children.slice(0);
	},

	getAllTwinsOf: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: incorrect v in getAllTwinsOf()";

		if (!this.properties[v].hasOwnProperty('twinGroup') || this.inedges[v].length == 0) {
			// no twinGroup or twinGroup is a leftover from a previous state and parents (and twins) have been deleted by now
			return [v];
		}

		var twinGroupId = this.properties[v]['twinGroup'];

		var childhubId = this.inedges[v][0];
		var children = this.v[childhubId];

		var twins = [];
		for (var c = 0; c < children.length; c++) {
			var child = children[c];
			if (this.properties[child].hasOwnProperty('twinGroup') && this.properties[child]['twinGroup'] == twinGroupId)
				twins.push(child);
		}
		return twins;
	},

	isParentToTwinEdge: function (fromV, toV) {
		if (this.isPerson(toV) && this.isChildhub(fromV) &&
			this.getTwinGroupId(toV) != null) return true;

		return false;
	},

	getAllAncestors: function (v) {
		var ancestors = {};
		ancestors[v] = true;

		var q = new Queue();
		q.push(v);

		while (q.size() > 0) {
			var nextV = q.pop();

			var inEdges = this.getInEdges(nextV);
			for (var j = 0; j < inEdges.length; j++) {
				var v = inEdges[j];
				if (!ancestors.hasOwnProperty(v)) {
					q.push(v);
					ancestors[v] = true;
				}
			}
		}
		return ancestors;
	}
};

/*
 * xinit: coordinates of _center_ of every vertex, or null
 */
XCoord = function (xinit, graph) {
	// local copies just for convenience & performance
	this.halfWidth = [];
	for (var i = 0; i < graph.GG.vWidth.length; i++)
		this.halfWidth[i] = Math.floor(graph.GG.vWidth[i] / 2);

	this.graph = graph;

	if (xinit)
		this.xcoord = xinit; // coordinates of _center_ of every vertex
	else
		this.xcoord = this.init_xcoord();
};

XCoord.prototype = {

	relationshipOrChhub: function (v) {
		if (this.graph.GG.type[v] == BaseGraph.TYPE.RELATIONSHIP || this.graph.GG.type[v] == BaseGraph.TYPE.CHILDHUB) return true;
		return false;
	},

	getSeparation: function (v1, v2) {
		if (this.relationshipOrChhub(v1) && this.relationshipOrChhub(v2))
			return this.graph.horizontalTwinSeparationDist;

		if (this.relationshipOrChhub(v1) || this.relationshipOrChhub(v2))
			return this.graph.horizontalRelSeparationDist;

		if ((this.graph.GG.type[v1] == BaseGraph.TYPE.VIRTUALEDGE || this.graph.GG.type[v2] == BaseGraph.TYPE.VIRTUALEDGE)) {
			if (this.graph.GG.hasEdge(v1, v2) || this.graph.GG.hasEdge(v2, v1))
				return this.graph.horizontalRelSeparationDist;
			return this.graph.horizontalTwinSeparationDist;
		}

		// separation between twins: a bit less than between other people
		if ((this.graph.GG.type[v1] == BaseGraph.TYPE.PERSON || this.graph.GG.type[v2] == BaseGraph.TYPE.PERSON) &&
			(this.graph.GG.getTwinGroupId(v1) == this.graph.GG.getTwinGroupId(v2)) &&
			(this.graph.GG.getTwinGroupId(v1) != null))
			return this.graph.horizontalTwinSeparationDist;

		return this.graph.horizontalPersonSeparationDist;
	},

	init_xcoord: function () {
		var xinit = [];
		// For each rank, the left-most node is assigned coordinate 0 (actually, since xinit[v] is
		// the coordinate of the center, not 0 but halfWidth[node]). The coordinate of the next
		// node is then assigned a value sufficient to satisfy the minimal separation from the prev
		// one, and so on. Thus, on each rank, nodes are initially packed as far left as possible.
		for (var r = 0; r < this.graph.order.order.length; r++) {

			xinit[this.graph.order.order[r][0]] = this.halfWidth[this.graph.order.order[r][0]];

			for (var i = 1; i < this.graph.order.order[r].length; i++) {
				var vPrev = this.graph.order.order[r][i - 1];
				var v = this.graph.order.order[r][i];
				var separation = this.getSeparation(vPrev, v);

				xinit[v] = xinit[vPrev] + this.halfWidth[vPrev] + separation + this.halfWidth[v];
			}
		}
		return xinit;
	},

	getLeftMostNoDisturbPosition: function (v) {
		var leftNeighbour = this.graph.order.getLeftNeighbour(v, this.graph.ranks[v]);
		if (leftNeighbour !== null) {
			var leftBoundary = this.getRightEdge(leftNeighbour) + this.getSeparation(v, leftNeighbour) + this.halfWidth[v];
			//console.log("leftNeighbour: " + leftNeighbour + ", rightEdge: " + this.getRightEdge(leftNeighbour) + ", separation: " + this.getSeparation(v, leftNeighbour));
			return leftBoundary;
		}
		return -Infinity;
	},

	getSlackOnTheLeft: function (v) {
		return this.xcoord[v] - this.getLeftMostNoDisturbPosition(v);
	},

	getRightMostNoDisturbPosition: function (v, alsoMoveRelationship) {
		var rightNeighbour = this.graph.order.getRightNeighbour(v, this.graph.ranks[v]);
		if (rightNeighbour !== null) {
			var rightBoundary = this.getLeftEdge(rightNeighbour) - this.getSeparation(v, rightNeighbour) - this.halfWidth[v];

			if (alsoMoveRelationship && this.graph.GG.type[rightNeighbour] == BaseGraph.TYPE.RELATIONSHIP) {
				var rightMost = this.getRightMostNoDisturbPosition(rightNeighbour);
				var slack = rightMost - this.xcoord[rightNeighbour];
				rightBoundary += slack;
			}
			return rightBoundary;
		}
		return Infinity;
	},

	getSlackOnTheRight: function (v) {
		return this.getRightMostNoDisturbPosition(v, false) - this.xcoord[v];
	},

	getLeftEdge: function (v) {
		return this.xcoord[v] - this.halfWidth[v];
	},

	getRightEdge: function (v) {
		return this.xcoord[v] + this.halfWidth[v];
	},

	shiftLeftOneVertex: function (v, amount) {
		// attempts to move vertex v to the left by ``amount``, but stops
		// as soon as it get as close as allowed to it's left neighbour

		var leftBoundary = this.getLeftMostNoDisturbPosition(v);

		var actualShift = Math.min(amount, this.xcoord[v] - leftBoundary);

		this.xcoord[v] -= actualShift;

		return actualShift;
	},

	shiftRightOneVertex: function (v, amount) {
		// attempts to move vertex v to the right by ``amount``, but stops
		// as soon as it get as close as allowed to it's right neighbour

		var rightBoundary = this.getRightMostNoDisturbPosition(v);

		var actualShift = Math.min(amount, rightBoundary - this.xcoord[v]);

		this.xcoord[v] += actualShift;

		return actualShift;
	},

	shiftRightAndShiftOtherIfNecessary: function (v, amount) {
		// shifts a vertext to the right by the given ``amount``, and shifts
		// all right neighbours, the minimal amount to accomodate this shift
		this.xcoord[v] += amount;

		var rightEdge = this.getRightEdge(v);
		var rank = this.graph.ranks[v];
		var order = this.graph.order.vOrder[v];

		for (var i = order + 1; i < this.graph.order.order[rank].length; i++) {
			var rightNeighbour = this.graph.order.order[rank][i];
			if (this.getLeftEdge(rightNeighbour) >= rightEdge + this.getSeparation(v, rightNeighbour)) {
				// we are not interfering with the vertex to the right
				break;

			}
			this.xcoord[rightNeighbour] = rightEdge + this.getSeparation(v, rightNeighbour) + this.halfWidth[rightNeighbour];

			rightEdge = this.getRightEdge(rightNeighbour);
			v = rightNeighbour;
		}

		return amount;
	},

	moveNodeAsCloseToXAsPossible: function (v, targetX) {
		var x = this.xcoord[v];
		if (x > targetX) {
			var leftMostOK = this.getLeftMostNoDisturbPosition(v);
			if (leftMostOK <= targetX)
				this.xcoord[v] = targetX;
			else
				this.xcoord[v] = leftMostOK;
		}
		else {
			var rightMostOK = this.getRightMostNoDisturbPosition(v);
			if (rightMostOK >= targetX)
				this.xcoord[v] = targetX;
			else
				this.xcoord[v] = rightMostOK;
		}

		if (this.xcoord[v] != x) // we've moved the mode
			return true;

		return false;
	},

	normalize: function () {
		var leftMostElement = Helpers.indexOfLastMinElementInArray(this.xcoord);
		var moveAmount = this.xcoord[leftMostElement] - this.halfWidth[leftMostElement];

		for (var i = 0; i < this.xcoord.length; i++)
			this.xcoord[i] -= moveAmount;
	},

	copy: function () {
		// returns an instance with deep copy of this.xcoord
		var newX = new XCoord(this.xcoord.slice(0), this.graph, this.halfWidth);

		return newX;
	},

	findVertexSetSlacks: function (set) {
		// returns the minimum slack (on the left and right) of the set of vertices, assuming all of them are moved at once
		//
		// e.g. separately for left/right, for each vertex in the set if the vertex to the given side of it is not in the set
		// computes min(vertex_slack_on_that_side, current_min_slack_for_that_side) and returns total min slack
		var leftSlack = Infinity;
		var rightSlack = Infinity;

		for (var v in set) {
			if (set.hasOwnProperty(v)) {
				var leftNeighbour = this.graph.order.getLeftNeighbour(v, this.graph.ranks[v]);
				if (!set.hasOwnProperty(leftNeighbour)) {
					leftSlack = Math.min(leftSlack, this.getSlackOnTheLeft(v));
				}
				var rightNeighbour = this.graph.order.getRightNeighbour(v, this.graph.ranks[v]);
				if (!set.hasOwnProperty(rightNeighbour)) {
					rightSlack = Math.min(rightSlack, this.getSlackOnTheRight(v));
				}
			}
		}

		return { "rightSlack": rightSlack, "leftSlack": leftSlack };
	}
};

//==================================================================================================

XCoordScore = function (maxRealVertexId) {
	this.score = 0;
	this.inEdgeMaxLen = [];
	this.maxRealVertexId = maxRealVertexId;
	this.numStraightLong = 0;
};

XCoordScore.prototype = {

	add: function (amount) {
		this.score += amount;
	},

	addEdge: function (v, u, length) {
		if (u > this.maxRealVertexId) {
			if (length == 0 && v > this.maxRealVertexId)
				this.numStraightLong++;

			length /= 2;
		}

		if (!this.inEdgeMaxLen[u] || length > this.inEdgeMaxLen[u]) {
			this.inEdgeMaxLen[u] = length;
		}

		for (var i = 0; i < u; i++)
			if (this.inEdgeMaxLen[i] === undefined)
				this.inEdgeMaxLen[i] = 0;
	},

	isBettertThan: function (otherScore) {
		if (this.score == otherScore.score) {
			if (this.numStraightLong == otherScore.numStraightLong) {
				// if score is the same the arrangements with smaller sum of
				// longest in-edges wins
				//if (this.inEdgeMaxLen.length == 0 || otherScore.inEdgeMaxLen.length == 0 ) {
				//    Helpers.printObject(this);
				//    Helpers.printObject(otherScore);
				//}
				var score1 = this.inEdgeMaxLen.length == 0 ? 0 : this.inEdgeMaxLen.reduce(function (a, b) {
					return a + b;
				});
				var score2 = otherScore.inEdgeMaxLen.length == 0 ? 0 : otherScore.inEdgeMaxLen.reduce(function (a, b) {
					return a + b;
				});

				if (score1 == score2)
					return (Math.max.apply(null, this.inEdgeMaxLen) < Math.max.apply(null, otherScore.inEdgeMaxLen)); // given everything else equal, prefer layout with shorter longest edge

				return (score1 < score2); // prefer layout with smaller total edge length
			}
			return (this.numStraightLong > otherScore.numStraightLong);
		}
		return (this.score < otherScore.score);
	}
};

//==================================================================================================

VerticalLevels = function () {

	this.rankVerticalLevels = [];   // for each rank: how many "levels" of horizontal edges are between this and next ranks
	this.childEdgeLevel = [];   // for each "childhub" node contains the verticalLevelID to use for the child edges
	// (where levelID is for levels between this and next ranks)
	this.outEdgeVerticalLevel = [];   // for each "person" node contains outgoing relationship edge level as {target1: {attachLevel: level, lineLevel: level}, target2: ... }
	// (where levelID is for levels between this and previous ranks)
};

VerticalLevels.prototype = {
	copy: function () {
		var result = new VerticalLevels();

		result.rankVerticalLevels = this.rankVerticalLevels.slice(0);
		result.childEdgeLevel = this.childEdgeLevel.slice(0);
		result.outEdgeVerticalLevel = this.outEdgeVerticalLevel.slice(0);
		return result;
	}
};


Ordering = function (order, vOrder) {
	this.order = order;        // 1D array of 1D arrays - for each rank list of vertices in order
	this.vOrder = vOrder;       // 1D array - for each v vOrder[v] = order within rank

	// TODO: verify validity?
};

Ordering.prototype = {

	serialize: function () {
		return this.order;
	},

	deserialize: function (data) {
		this.order = data;
		this.vOrder = [];
		//console.log("Order deserialization: [" + Helpers.stringifyObject(this.order) + "]");

		// recompute vOrders
		for (var r = 0; r < this.order.length; r++) {
			var ordersAtRank = this.order[r];
			for (var i = 0; i < ordersAtRank.length; i++) {
				this.vOrder[ordersAtRank[i]] = i;
			}
		}
	},

	insert: function (rank, insertOrder, vertex) {
		this.order[rank].splice(insertOrder, 0, vertex);
		this.vOrder[vertex] = insertOrder;
		for (var next = insertOrder + 1; next < this.order[rank].length; ++next)
			this.vOrder[ this.order[rank][next] ]++;
	},

	exchange: function (rank, index1, index2) {
		// exchanges vertices at two given indices within the same given rank

		var v1 = this.order[rank][index1];
		var v2 = this.order[rank][index2];

		this.order[rank][index2] = v1;
		this.order[rank][index1] = v2;

		this.vOrder[v1] = index2;
		this.vOrder[v2] = index1;
	},

	canMove: function (rank, index, amount) {
		var newIndex = index + amount;
		if (newIndex < 0) return false;
		if (newIndex > this.order[rank].length - 1) return false;
		return true;
	},

	move: function (rank, index, amount) {
		// changes vertex order within the same rank. Moves "amount" positions to the right or to the left
		if (amount == 0) return true;

		var newIndex = index + amount;
		if (newIndex < 0) return false;

		var ord = this.order[rank];
		if (newIndex > ord.length - 1) return false;

		var v = ord[index];

		if (newIndex > index) {
			for (var i = index; i < newIndex; ++i) {
				var vv = ord[i + 1];
				ord[i] = vv;
				this.vOrder[vv] = i;
			}
		}
		else {
			for (var i = index; i > newIndex; --i) {
				var vv = ord[i - 1];
				ord[i] = vv;
				this.vOrder[vv] = i;
			}
		}

		ord[newIndex] = v;
		this.vOrder[v] = newIndex;

		return true;
	},

	copy: function () {
		// returns a deep copy
		return new Ordering(Helpers.clone2DArray(this.order), this.vOrder.slice());
	},

	moveVertexToRankAndOrder: function (oldRank, oldOrder, newRank, newOrder) {
		// changes vertex rank and order. Insertion happens right before the node currently occupying the newOrder position on rank newRank
		var v = this.order[oldRank][oldOrder];

		this.order[oldRank].splice(oldOrder, 1);

		this.order[newRank].splice(newOrder, 0, v);

		this.vOrder[v] = newOrder;
		for (var i = newOrder + 1; i < this.order[newRank].length; ++i) {
			var nextV = this.order[newRank][i];
			this.vOrder[nextV]++;
		}
		for (var i = oldOrder; i < this.order[oldRank].length; ++i) {
			var nextV = this.order[oldRank][i];
			this.vOrder[nextV]--;
		}
	},

	moveVertexToOrder: function (rank, oldOrder, newOrder) {
		// changes vertex order within the same rank. Insertion happens right before the node currently occupying the newOrder position
		// (i.e. changing order form 3 to 4 does nothing, as before position 4 is still position 3)
		var shiftAmount = (newOrder <= oldOrder) ? (newOrder - oldOrder) : (newOrder - oldOrder - 1);
		this.move(rank, oldOrder, shiftAmount);
	},

	removeUnplugged: function () {
		var result = this.order[0].slice(0); //copy of original unplugged IDs

		for (var u = 0; u < this.order[0].length; ++u) {
			var unplugged = this.order[0][u];

			for (var i = 0; i < this.order.length; ++i)
				for (var j = 0; j < this.order[i].length; ++j) {
					if (this.order[i][j] > unplugged)
						this.order[i][j]--;
				}

			this.vOrder.splice(unplugged, 1);
		}

		this.order[0] = [];

		return result;
	},

	remove: function (v, rank) {
		var order = this.vOrder[v];
		this.moveVertexToRankAndOrder(rank, order, 0, 0);
		this.removeUnplugged();
	},

	insertAndShiftAllIdsAboveVByOne: function (v, rank, newOrder) {
		// used when when a new vertex is inserted into the graph, which increases all IDs above v by one
		// so need to modify the data for all existing vertices first, and then insert the new vertex

		for (var i = this.vOrder.length; i > v; --i) {
			this.vOrder[i] = this.vOrder[i - 1];
		}

		for (var i = 0; i < this.order.length; ++i)
			for (var j = 0; j < this.order[i].length; ++j) {
				if (this.order[i][j] >= v)
					this.order[i][j]++;
			}

		this.insert(rank, newOrder, v);
	},

	insertRank: function (insertBeforeRank) {
		this.order.splice(insertBeforeRank, 0, []);
	},

	getRightNeighbour: function (v, rank) {
		var order = this.vOrder[v];
		if (order < this.order[rank].length - 1)
			return this.order[rank][order + 1];
		return null;
	},

	getLeftNeighbour: function (v, rank) {
		var order = this.vOrder[v];
		if (order > 0)
			return this.order[rank][order - 1];
		return null;
	},

	sortByOrder: function (v_list) {
		var vorders = this.vOrder;
		var result = v_list.slice(0);
		result.sort(function (x, y) {
			return vorders[x] - vorders[y]
		});
		return result;
	},

	// returns all vertices ordered from left-to-right and from top-to-bottom
	getLeftToRightTopToBottomOrdering: function (onlyType, GG) {
		var result = [];
		for (var i = 1; i < this.order.length; ++i) {
			for (var j = 0; j < this.order[i].length; ++j) {
				var v = this.order[i][j];
				if (!onlyType || GG.type[v] == onlyType)
					result.push(this.order[i][j]);
			}
		}
		return result;
	}
};


PedigreeImport = function () {
};

PedigreeImport.prototype = {
};

/*PedigreeImport.SUPORTED_FORMATS = {
 PED:                    1,      // standard .PED format. Can only import family structure, gender and the affected status
 PHENOTIPS_GRAPH:        2,      // Phenotips pedigree format, whithout positioning information (needs to be laid out automaticaly)
 PHENOTIPS_INTERNAL_OLD: 3       // Phenotips internal format used during development and in test cases (to be replaced)
 };

 PedigreeImport.autodetectFormat = function(input) {

 }*/

PedigreeImport.initFromPhenotipsInternal = function (inputG) {
	// note: serialize() produces the correct input for this function

	var newG = new BaseGraph();

	var nameToId = {};

	var relationshipHasExplicitChHub = {};

	// first pass: add all vertices and assign vertex IDs
	for (var v = 0; v < inputG.length; v++) {

		if (!inputG[v].hasOwnProperty("name") && !inputG[v].hasOwnProperty("id"))
			throw "Invalid input: a node without id and without name";

		var type = BaseGraph.TYPE.PERSON;
		if (inputG[v].hasOwnProperty('relationship') || inputG[v].hasOwnProperty('rel')) {
			type = BaseGraph.TYPE.RELATIONSHIP;
			// normally users wont specify childhubs explicitly - but save via JSON does
			if (inputG[v].hasOwnProperty('hub') || inputG[v].hasOwnProperty('haschhub'))
				relationshipHasExplicitChHub[v] = true;
		}
		else if (inputG[v].hasOwnProperty('chhub')) {
			type = BaseGraph.TYPE.CHILDHUB;
		}
		else if (inputG[v].hasOwnProperty('virtual') || inputG[v].hasOwnProperty('virt')) {
			type = BaseGraph.TYPE.VIRTUALEDGE;
		}

		var properties = {};
		if (inputG[v].hasOwnProperty('properties') || inputG[v].hasOwnProperty('prop'))
			properties = inputG[v].hasOwnProperty('properties') ? inputG[v]["properties"] : inputG[v]["prop"];

		if (type == BaseGraph.TYPE.PERSON) {
			if (properties.hasOwnProperty("sex") && !properties.hasOwnProperty("gender")) {
				properties["gender"] = properties["sex"];
			}

			if (!properties.hasOwnProperty("gender"))
				properties["gender"] = "U";

			if (inputG[v].hasOwnProperty("gender")) {
				var genderString = inputG[v]["gender"].toLowerCase();
				if (genderString == "female" || genderString == "f" || genderString == "2")
					properties["gender"] = "F";
				if (genderString == "other" || genderString == "o"  || genderString == "9")
					properties["gender"] = "O";
				else if (genderString == "male" || genderString == "m" || genderString == "1")
					properties["gender"] = "M";
			}
		}

		var width = inputG[v].hasOwnProperty('width') ?
			inputG[v].width :
			(type == BaseGraph.TYPE.PERSON ? newG.defaultPersonNodeWidth : newG.defaultNonPersonNodeWidth);

		var newID = newG._addVertex(null, type, properties, width);   // "null" since id is not known yet

		if (inputG[v].hasOwnProperty("name")) {  // note: this means using user input (not produced by this.serialize)
			if (nameToId[inputG[v].name])
				throw "Invalid user input: multiple nodes with the same name";
			if (type == BaseGraph.TYPE.PERSON)
				newG.properties[newID]["fName"] = inputG[v].name;
			nameToId[inputG[v].name] = newID;
		}

		// when entered by user manually allow users to skip childhub nodes (and create them automatically)
		// (but when saving/restoring from a JSON need to save/restore childhub nodes as they
		//  may have some properties assigned by the user which we need to save/restore)
		if (type == BaseGraph.TYPE.RELATIONSHIP && !relationshipHasExplicitChHub.hasOwnProperty(v)) {
			var chHubId = newG._addVertex(null, BaseGraph.TYPE.CHILDHUB, null, width);
			nameToId["_chhub_" + newID] = chHubId;
		}
	}

	// second pass (once all vertex IDs are known): process edges
	for (var v = 0; v < inputG.length; v++) {
		var nextV = inputG[v];

		var vID = nextV.hasOwnProperty("id") ? nextV.id : nameToId[nextV.name];
		var origID = vID;

		var substitutedID = false;

		if (newG.type[vID] == BaseGraph.TYPE.RELATIONSHIP && !relationshipHasExplicitChHub.hasOwnProperty(vID)) {
			// replace edges from rel node by edges from childhub node
			var childhubID = nameToId["_chhub_" + vID];
			vID = childhubID;
			substitutedID = true;
		}

		var maxChildEdgeWeight = 0;

		if (nextV.outedges) {
			for (var outE = 0; outE < nextV.outedges.length; outE++) {
				var target = nextV.outedges[outE].to;
				var targetID = nameToId[target] ? nameToId[target] : target;  // can specify target either by name or ID

				if (!newG.isValidId(targetID))
					throw "Invalid input: invalid edge target (" + target + ")";

				var weight = 1;
				if (nextV.outedges[outE].hasOwnProperty('weight'))
					weight = nextV.outedges[outE].weight;
				if (weight > maxChildEdgeWeight)
					maxChildEdgeWeight = weight;

				newG.addEdge(vID, targetID, weight);
			}
		}

		if (substitutedID) {
			newG.addEdge(origID, vID, maxChildEdgeWeight);
		}
	}

	newG.validate();

	return newG;
}

/* ===============================================================================================
 *
 * Creates and returns a BaseGraph from a text string in the PED/LINKAGE format.
 *
 * PED format:
 * (from http://pngu.mgh.harvard.edu/~purcell/plink/data.shtml#ped)
 *   Family ID
 *   Individual ID
 *   Paternal ID
 *   Maternal ID
 *   Sex (1=male; 2=female; other=unknown)
 *   Phenotype
 *
 *   Phenotype, by default, should be coded as:
 *      -9 missing
 *       0 missing
 *       1 unaffected
 *       2 affected
 *
 * =================
 *
 * LINKAGE format:
 * (from http://www.helsinki.fi/~tsjuntun/autogscan/pedigreefile.html)
 *
 *   Column 1:   Pedigree number
 *   Column 2:   Individual ID number
 *   Column 3:   ID of father
 *   Column 4:   ID of mother
 *   Column 5:   First offspring ID
 *   Column 6:   Next paternal sibling ID
 *   Column 7:   Next maternal sibling ID
 *   Column 8:   Sex
 *   Column 9:   Proband status (1=proband, higher numbers indicate doubled individuals formed
 *                               in breaking loops. All other individuals have a 0 in this field.)
 *   Column 10+: Disease and marker phenotypes (as in the original pedigree file)
 * ===============================================================================================
 */
PedigreeImport.initFromPED = function (inputText, acceptOtherPhenotypes, markEvaluated, saveIDAsExternalID, affectedCodeOne, disorderNames) {
	var inputLines = inputText.match(/[^\r\n]+/g);
	if (inputLines.length == 0) {
		throw "Unable to import: no data";
	}

	// autodetect if data is in pre-makeped or post-makeped format
	var postMakeped = false;
	if (inputLines[0].indexOf("Ped:") > 0 && inputLines[0].indexOf("Per:") > 0)
		postMakeped = true;

	var familyPrefix = "";

	var newG = new BaseGraph();

	var nameToId = {};

	var phenotypeValues = {};  // set of all posible valuesin the phenotype column

	var extendedPhenotypesFound = false;

	// support both automatic and user-defined assignment of proband
	var nextID = postMakeped ? 1 : 0;

	// first pass: add all vertices and assign vertex IDs
	for (var i = 0; i < inputLines.length; i++) {
		if (inputLines[i].charAt(0) == '#') {
			continue;
		}

		inputLines[i] = inputLines[i].replace(/[^a-zA-Z0-9_.\-\s*]/g, ' ');
		inputLines[i] = inputLines[i].replace(/^\s+|\s+$/g, '');  // trim()

		var parts = inputLines[i].split(/\s+/);
		//console.log("Parts: " + Helpers.stringifyObject(parts));

		if (parts.length < 6 || (postMakeped && parts.length < 10)) {
			throw "Input line has not enough columns: [" + inputLines[i] + "]";
		}

		if (familyPrefix == "") {
			familyPrefix = parts[0];
		} else {
			if (parts[0] != familyPrefix) {
				throw "Unsupported feature: multiple families detected within the same pedigree";
			}
		}

		var pedID = parts[1];
		if (nameToId.hasOwnProperty(pedID)) {
			throw "Multiple persons with the same ID [" + pedID + "]";
		}

		var genderValue = postMakeped ? parts[7] : parts[4];
		var gender = "U";
		if (genderValue == 1) {
			gender = "M";
		} else if (genderValue == 2) {
			gender = "F";
		}
		var properties = {"gender": gender};

		if (saveIDAsExternalID) {
			properties["externalID"] = pedID;
		}

		var useID = (postMakeped && parts[8] == 1) ? 0 : nextID++;
		if (i == inputLines.length - 1 && newG.v[0] === undefined) {
			// last node and no node with id 0 yet
			useID = 0;
		}

		var pedigreeID = newG._addVertex(useID, BaseGraph.TYPE.PERSON, properties, newG.defaultPersonNodeWidth);

		nameToId[pedID] = pedigreeID;

		var phenotype = postMakeped ? parts[9] : parts[5];
		phenotypeValues[phenotype] = true;
		if (acceptOtherPhenotypes && phenotype != "-9" && phenotype != "0" && phenotype != "1" && phenotype != "2") {
			extendedPhenotypesFound = true;
		}
	}

	// There are two popular schemes for the phenotype column (-9/0/1/2 or -9/0/1).
	// Use the "standard" by default, unless directed to use the other one by the user
	if (affectedCodeOne) {
		if (extendedPhenotypesFound || phenotypeValues.hasOwnProperty("2")) {
			throw "Phenotypes with codes other than 0 or 1 were found";
		}
		var affectedValues = { "1": true };
		var missingValues = { "-9": true };
		var unaffectedValues = { "0": true };
	} else {
		var affectedValues = { "2": true };
		var missingValues = { "0": true, "-9": true };
		var unaffectedValues = { "1": true };
	}

	if (!disorderNames) {
		disorderNames = {};
		if (extendedPhenotypesFound) {
			for (var phenotype in phenotypeValues)
				if (phenotypeValues.hasOwnProperty(phenotype)) {
					if (phenotype != "-9" && phenotype != "0" && phenotype != "1") {
						disorderNames[phenotype] = "affected (phenotype " + phenotype + ")";
						affectedValues[phenotype] = true;
					}
				}
		}
	}

	var defaultEdgeWeight = 1;

	var relationshipTracker = new RelationshipTracker(newG, defaultEdgeWeight);

	// second pass (once all vertex IDs are known): process edges
	for (var i = 0; i < inputLines.length; i++) {
		if (inputLines[i].charAt(0) == '#') {
			continue;
		}

		var parts = inputLines[i].split(/\s+/);

		var thisPersonName = parts[1];
		var id = nameToId[thisPersonName];

		var phenotype = postMakeped ? parts[9] : parts[5];
		if (affectedValues.hasOwnProperty(phenotype)) {
			var disorder = disorderNames.hasOwnProperty(phenotype) ? disorderNames[phenotype] : "Affected";
			newG.properties[id]["carrierStatus"] = 'Affected';
			newG.properties[id]["disorders"] = [disorder];
			if (markEvaluated) {
				newG.properties[id]["evaluated"] = true;
			}
		} else if (unaffectedValues.hasOwnProperty(phenotype)) {
			newG.properties[id]["carrierStatus"] = '';
			if (markEvaluated) {
				newG.properties[id]["evaluated"] = true;
			}
		} else if (!missingValues.hasOwnProperty(phenotype)) {
			//treat all unsupported values as "unknown/no evaluation"
			//throw "Individual with ID [" + thisPersonName + "] has unsupported phenotype value [" + phenotype + "]";
		}

		// check if parents are given for this individual; if at least one parent is given,
		// check if the corresponding relationship has already been created. If not, create it. If yes,
		// add an edge from childhub to this person

		var fatherID = parts[2];
		var motherID = parts[3];

		if (fatherID == 0 && motherID == 0) continue;

		// .PED supports specifying only mohter of father. Pedigree editor requires both (for now).
		// So create a virtual parent in case one of the parents is missing
		if (fatherID == 0) {
			fatherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "M", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			fatherID = nameToId[fatherID];
			if (typeof fatherID === 'undefined') {
				throw "Unable to import pedigree: incorrect father link on line " + (i + 1) + "; Maybe import data is not in PED format?";
			}
			if (newG.properties[fatherID].gender == "F") {
				//throw "Unable to import pedigree: a person declared as female [id: " + fatherID + "] is also declared as being a father for [id: " + thisPersonName + "]";
				console.warn("A person declared as female [id: " + fatherID + "] is also declared as being a father for [id: " + thisPersonName + "]");
			}
		}
		if (motherID == 0) {
			motherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "F", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			motherID = nameToId[motherID];
			if (typeof motherID === 'undefined') {
				throw "Unable to import pedigree: incorrect mother link on line " + (i + 1) + "; Maybe import data is not in PED format?";
			}
			if (newG.properties[motherID].gender == "M") {
				//throw "Unable to import pedigree: a person declared as male [id: " + motherID + "] is also declared as being a mother for [id: " + thisPersonName + "]";
				console.warn("A person declared as male [id: " + motherID + "] is also declared as being a mother for [id: " + thisPersonName + "]");
			}
		}

		// both motherID and fatherID are now given and represent valid existing nodes in the pedigree

		// if there is a relationship between motherID and fatherID the corresponding childhub is returned
		// if there is no relationship, a new one is created together with the chldhub
		var chhubID = relationshipTracker.createOrGetChildhub(motherID, fatherID);

		newG.addEdge(chhubID, id, defaultEdgeWeight);
	}

	PedigreeImport.validateBaseGraph(newG);

	return newG;
}


/* ===============================================================================================
 *
 * Creates and returns a BaseGraph from a text string in the BOADICEA format.
 *
 *  BOADICEA format:
 *  (from https://pluto.srl.cam.ac.uk/bd3/v3/docs/BWA_v3_user_guide.pdf)
 *
 *  line1: BOADICEA import pedigree file format 2.0
 *  line2: column titles
 *  line3+: one patient per line, with values separated by spaces or tabs, as follows:
 *
 *   FamID: Family/pedigree ID, character string (maximum 13 characters)
 *   Name: First name/ID of the family member, character string (maximum 8 characters)
 *   Target: The family member for whom the BOADICEA risk calculation is made, 1 = target for BOADICEA risk calculation, 0 = other family members. There must only be one BOADICEA target individual.
 *   IndivID: Unique ID of the family member, character string (maximum 7 characters)
 *   FathID: Unique ID of their father, 0 = no father, or character string (maximum 7 characters)
 *   MothID: Unique ID of their mother, 0 = unspecified, or character string (maximum 7 characters)
 *   Sex: M or F
 *   Twin: Identical twins, 0 = no identical twin, any non-zero character = twin.
 *   Dead: The current status of the family member, 0 = alive, 1 = dead
 *   Age: Age at last follow up, 0 = unspecified, integer = age at last follow up
 *   Yob: Year of birth, 0 = unspecified, or integer (consistent with Age if the person is alive)
 *   1BrCa: Age at first breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   2BrCa: Age at contralateral breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   OvCa: Age at ovarian cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   ProCa: Age at prostate cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   PanCa: Age at pancreatic cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   Gtest: Genetic test status, 0 = untested, S = mutation search, T = direct gene test
 *   Mutn: 0 = untested, N = no mutation, 1 = BRCA1 positive, 2 = BRCA2 positive, 3 = BRCA1 and BRCA2 positive
 *   Ashkn: 0 = not Ashkenazi, 1 = Ashkenazi
 *   ER: Estrogen receptor status, 0 = unspecified, N = negative, P = positive
 *   PR: Progestrogen receptor status, 0 = unspecified, N = negative, P = positive
 *   HER2: Human epidermal growth factor receptor 2 status, 0 = unspecified, N = negative, P = positive
 *   CK14: Cytokeratin 14 status, 0 = unspecified, N = negative, P = positive
 *   CK56: Cytokeratin 56 status, 0 = unspecified, N = negative, P = positive
 * ===============================================================================================
 */
PedigreeImport.initFromBOADICEA = function (inputText, saveIDAsExternalID) {
	var inputLines = inputText.match(/[^\r\n]+/g);

	if (inputLines.length <= 2) {
		throw "Unable to import: no data";
	}
	if (inputLines[0].match(/^BOADICEA import pedigree file format 2/i) === null) {
		throw "Unable to import: unsupported version of the BOADICEA format";
	}
	inputLines.splice(0, 2); // remove 2 header lines

	var familyPrefix = "";

	var newG = new BaseGraph();

	var nameToId = {};

	var nextID = 1;

	// first pass: add all vertices and assign vertex IDs
	for (var i = 0; i < inputLines.length; i++) {

		inputLines[i] = inputLines[i].replace(/[^a-zA-Z0-9_.\-\s*]/g, ' ');
		inputLines[i] = inputLines[i].replace(/^\s+|\s+$/g, '');  // trim()

		var parts = inputLines[i].split(/\s+/);
		//console.log("Parts: " + Helpers.stringifyObject(parts));

		if (parts.length < 24) {
			throw "Input line has not enough columns: [" + inputLines[i] + "]";
		}

		if (familyPrefix == "") {
			familyPrefix = parts[0];
		} else {
			if (parts[0] != familyPrefix) {
				throw "Unsupported feature: multiple families detected within the same pedigree";
			}
		}

		var extID = parts[3];
		if (nameToId.hasOwnProperty(extID))
			throw "Multiple persons with the same ID [" + extID + "]";

		var genderValue = parts[6];
		var gender = "M";
		if (genderValue == "F") {
			gender = "F";
		}
		var name = parts[1];
		//if (Helpers.isInt(name)) {
		//  name = "";
		//}
		var properties = {"gender": gender, "fName": name};

		if (saveIDAsExternalID) {
			properties["externalID"] = extID;
		}

		var deadStatus = parts[8];
		if (deadStatus == "1") {
			properties["lifeStatus"] = "Deceased";
		}

		var yob = parts[10];
		if (yob != "0" && Helpers.isInt(yob)) {
			properties["dob"] = {"decade": yob + "s", "year": parseInt(yob)};
		}

		var addCommentToProperties = function (properties, line) {
			if (!line || line == "") return;
			if (!properties.hasOwnProperty("comments")) {
				properties["comments"] = line;
			} else {
				properties["comments"] += "\n" + line;
			}
		}

		// TODO: handle all the columns and proper cancer handling
		//
		// 11: 1BrCa: Age at first breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected unknown)
		// 12: 2BrCa: Age at contralateral breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected unknown)
		// 13: OvCa:  Age at ovarian cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected unknown)
		// 14: ProCa: Age at prostate cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected unknown)
		// 15: PanCa: Age at pancreatic cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected unknown)
		var cancers = [
			{ "column": 11, "label": "Breast", "comment": ""},
			{ "column": 12, "label": "Breast", "comment": "Contralateral breast cancer", "onlySetComment": true},
			{ "column": 13, "label": "Ovarian", "comment": ""},
			{ "column": 14, "label": "Prostate", "comment": ""},
			{ "column": 15, "label": "Pancreatic", "comment": ""}
		];

		for (var c = 0; c < cancers.length; c++) {
			var cancer = cancers[c];

			if (!properties.hasOwnProperty("cancers")) {
				properties["cancers"] = {};
			}

			var cancerData = {};
			if (parts[cancer["column"]] == "0") {
				if (!cancer.hasOwnProperty("onlySetComment") || !cancer.onlySetComment) {
					cancerData["affected"] = false;
				}
			} else {
				cancerData["affected"] = true;
				var age = parts[cancer["column"]];
				if (Helpers.isInt(age)) {
					var numericAge = parseInt(age);
					cancerData["numericAgeAtDiagnosis"] = numericAge;
					if (numericAge > 100) {
						age = "after_100";
					}
					cancerData["ageAtDiagnosis"] = age;
				}
				addCommentToProperties(properties, cancer["comment"]);
			}
			if (!cancer.onlySetComment) {
				properties["cancers"][cancer.label] = cancerData;
			}
		}

		// Mutn: 0 = untested, N = no mutation, 1 = BRCA1 positive, 2 = BRCA2 positive, 3 = BRCA1 and BRCA2 positive
		var mutations = parts[17];
		if (mutations == "1" || mutations == "2" || mutations == "3") {
			properties["candidateGenes"] = [];
			if (mutations == 1 || mutations == 3) {
				properties["candidateGenes"].push("BRCA1");
			}
			if (mutations == 2 || mutations == 3) {
				properties["candidateGenes"].push("BRCA2");
			}
		} else if (mutations == "N") {
			addCommentToProperties(properties, "BRCA tested: no mutations");
		}

		var ashkenazi = parts[18];
		if (ashkenazi != "0") {
			properties["ethnicities"] = ["Ashkenazi Jews"];
		}

		var proband = (parts[2] == 1);
		var useID = proband ? 0 : nextID++;
		if (i == inputLines.length - 1 && newG.v[0] === undefined) {
			// last node and no proband yet
			useID = 0;
		}

		var pedigreeID = newG._addVertex(useID, BaseGraph.TYPE.PERSON, properties, newG.defaultPersonNodeWidth);

		nameToId[extID] = pedigreeID;
	}

	var defaultEdgeWeight = 1;

	var relationshipTracker = new RelationshipTracker(newG, defaultEdgeWeight);

	// second pass (once all vertex IDs are known): process edges
	for (var i = 0; i < inputLines.length; i++) {
		var parts = inputLines[i].split(/\s+/);

		var extID = parts[3];
		var id = nameToId[extID];

		// check if parents are given for this individual; if at least one parent is given,
		// check if the corresponding relationship has already been created. If not, create it. If yes,
		// add an edge from childhub to this person

		var fatherID = parts[4];
		var motherID = parts[5];

		if (fatherID == 0 && motherID == 0) {
			continue;
		}

		// .PED supports specifying only mother or father. Pedigree editor requires both (for now).
		// So create a virtual parent in case one of the parents is missing
		if (fatherID == 0) {
			fatherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "M", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			fatherID = nameToId[fatherID];
			if (newG.properties[fatherID].gender == "F") {
				//throw "Unable to import pedigree: a person declared as female [id: " + fatherID + "] is also declared as being a father for [id: " + extID + "]";
				//Possible via unassigned which allows one to put it anywhere after a warning
				console.warn("Unable to import pedigree: a person declared as female [id: " + fatherID + "] is also declared as being a father for [id: " + extID + "]");
			}
		}
		if (motherID == 0) {
			motherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "F", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			motherID = nameToId[motherID];
			if (newG.properties[motherID].gender == "M") {
				//throw "Unable to import pedigree: a person declared as male [id: " + motherID + "] is also declared as being a mother for [id: " + extID + "]";
				//Possible via unassigned which allows one to put it anywhere after a warning
				console.warn("Unable to import pedigree: a person declared as male [id: " + motherID + "] is also declared as being a mother for [id: " + extID + "]");
			}
		}

		// both motherID and fatherID are now given and represent valid existing nodes in the pedigree

		// if there is a relationship between motherID and fatherID the corresponding childhub is returned
		// if there is no relationship, a new one is created together with the childhub
		var chhubID = relationshipTracker.createOrGetChildhub(motherID, fatherID);

		newG.addEdge(chhubID, id, defaultEdgeWeight);
	}

	PedigreeImport.validateBaseGraph(newG);

	return newG;
}

/* ===============================================================================================
 *
 * Validates the generated basegraph and throws one of the following exceptions:
 *
 *  1) "Unsupported pedigree: some components of the imported pedigree are disconnected from each other"
 *  2) "Unable to import pedigree"
 *
 * The method is a wrapper around the internal vlaidate method, which may throw many exceptions
 * which change form version to version
 *
 * ===============================================================================================
 */
PedigreeImport.validateBaseGraph = function (newG) {
	try {
		newG.validate();
	} catch (err) {
		if (err.indexOf("disconnected component")) {
			throw "Unsupported pedigree: some components of the imported pedigree are disconnected from each other";
		} else {
			throw "Unable to import pedigree";
		}
	}
}

/* ===============================================================================================
 *
 * Creates and returns a BaseGraph from a text string in the "simple JSON" format.
 *
 *  Simple JSON format: an array of objects, each object representing one person or one relationship, e.g.:
 *
 *    [ { "name": "f11", "sex": "female", "lifeStatus": "deceased" },
 *      { "name": "m11", "sex": "male" },
 *      { "name": "f12", "sex": "female", "disorders": [603235, "142763", "custom disorder"] },
 *      { "name": "m12", "sex": "male" },
 *      { "name": "m21", "sex": "male", "mother": "f11", "father": "m11" },
 *      { "name": "f21", "sex": "female", "mother": "f12", "father": "m12" },
 *      { "name": "ch1", "sex": "female", "mother": "f21", "father": "m21", "disorders": [603235], "proband": true },
 *      { "name": "m22", "sex": "male" },
 *      { "relationshipId": 1, "partner1": "f21", "partner2": "m22"} ]
 *
 *  Supported properties for person nodes:
 *   - "id": string or number (default: none). If two nodes with the same ID are found an error is reported.
 *           If present, this id is used only for the purpose of linking nodes to each other and is not recorded
 *           in the imported pedigree. Use "externalId" if an ID should be stored
 *   - "proband": boolean (default: true for the first object, false for all other objects. If another object
 *                                  is explicitly indicated as a proband, the firs tobject also defaults to false.
 *                                  If more than one node is indicated as a proband only the first one is considered ot be one)
 *   - "name" or "firstName": string (default: none). if both are defined "firstName" is used as "first name" and name is used for mother/father reference checks only
 *   - "lastName": string (default: none)
 *   - "lastNameAtBirth": string (default: none)
 *   - "comments": string (default: none)
 *   - "externalId": string (default: none)
 *   - "sex": one of "male" or "m", "female" or "f", "other" or "o", "unknown" or "u" (default: "unknown")
 *   - "twinGroup": integer. All children of the sam eparents with the same twin group are considered twins. (fefault: none)
 *   - "monozygotic": boolean. (only applicable for twins)
 *   - "adoptedIn": boolean (default: false)
 *   - "evaluated": boolean (default: false)
 *   - "birthDate": string (default: none)
 *   - "deathDate": string (default: none)
 *   - "nodeNumber": string (default: none) pedigree node number as of last renumbering
 *   - "lostContact": boolean (default: false) "false" if proband lost contact with the given individual
 *   - "numPersons": integer. When present and not 0 this individual is treated as a "person group"
 *   - "lifeStatus": one of {"alive", "deceased", "aborted", "miscarriage", "stillborn", "unborn"}.
 *                   (default: "alive". If death date is given status defaults to "deceased" and overwrites
 *                             the explicitly given status if it were "alive")
 *   - "disorders": array of strings or integers (a string representing an integer is considered to be an integer), integers treated as OMIM IDs. (default: none)
 *   - "carrierStatus": one of {'', 'carrier', 'affected', 'presymptomatic'}
 *                      (default: if a disorder is given, default is 'affected', otherwise: none.
 *                       also, if a disorder is given and status is explicitly '', it is automatically changed to 'affected')
 *   - "childlessStatus": one of {none, 'Childless','Infertile'} (default: none)
 *   - "childlessReason": string or null (default: none)
 *   - "mother" and "father": string, a reference to another node given in the JSON.
 *                            First a match versus an existing ID is checked, if not found a check against "externalId",
 *                            if not found a check against "name" and finally "firstName".
 *                            If one of the parents is given and the other one is not a virtual new node is created
 *
 *  Supported properties for relationship nodes:
 *   - "relationshipId": string or number. The valu eis not used, only required ot indicate that this
 *                       entry represents a relationship.
 *   - "separated": boolean (default: false)
 *   - "consanguinity": one of {"Y","N"} (default: none). If not given it is computed automatically based ont the family graph
 *   - "childlessStatus": one of {none, 'Childless','Infertile'} (default: none). If there are no children with the same
 *                        set of parents, "childlessStatus" is automatically set to "Childless".
 *   - "childlessReason": string or null (default: none)
 *   - "partner1" and "partner2": string, a reference to another node given in the JSON.
 *                                Used in the same way "mother" and "father" are used for person nodes.
 *
 *   Each person node should have at least one of {"id", "externalId", "name", "firstName"} defined,
 *   each relationship node should have "relationshipId", "mother" and "father".
 *
 *   Relationship nodes should only be included to indicate a relationship without children (as a way
 *   to indicate there is a link) or to spcify relationship properties, if different from default.
 * ===============================================================================================
 */
PedigreeImport.initFromSimpleJSON = function (inputText) {
	try {
		var inputArray = JSON.parse(inputText);
	} catch (err) {
		throw "Unable to import pedigree: input is not a valid JSON string " + err;
	}

	if (typeof inputArray != 'object' || Object.prototype.toString.call(inputArray) !== '[object Array]') {
		throw "Unable to import pedigree: JSON does not represent an array of objects";
	}
	if (inputArray.length == 0) {
		throw "Unable to import pedigree: input is empty";
	}

	var newG = new BaseGraph();

	var nameToID = {};
	var externalIDToID = {};
	var ambiguousReferences = {};
	var hasID = {}

	//Added for GEL .................................
	var unRenderedNodes = undefined;
	// ..............................................

	// first pass: add all vertices and assign vertex IDs
	for (var i = 0; i < inputArray.length; i++) {
		if (inputArray[i].hasOwnProperty("relationshipId")) {
			continue;
		}

		//Added for GEL ...........................................................................................
		//IF it has 'unrendered', which means it's an ambiguous node and we should just show it in unRenderedLegend
		if ((inputArray[i].hasOwnProperty("unrendered") || inputArray[i].hasOwnProperty("unRendered"))
		&& inputArray[i].unRendered == true
		) {
			if(!unRenderedNodes){
				unRenderedNodes = [];
			}
			unRenderedNodes.push(inputArray[i]);
			continue;
		}
		//.........................................................................................................

		var nextPerson = inputArray[i];

		if (typeof nextPerson != 'object') {
			throw "Unable to import pedigree: JSON does not represent an array of objects";
		}

		if (!nextPerson.hasOwnProperty("id") && !nextPerson.hasOwnProperty("name") && !nextPerson.hasOwnProperty("firstName") && !nextPerson.hasOwnProperty("externalId")) {
			throw "Unable to import pedigree: a node with no ID or name is found";
		}

		var pedigreeID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {}, newG.defaultPersonNodeWidth);

		var properties = {};
		properties["gender"] = "U";     // each person should have some gender set
		//console.log(nextPerson)
		for (var property in nextPerson) {
			if (nextPerson.hasOwnProperty(property)) {
				/* handle loading properties that arn't in model */
        if(property == "otherIdentifier"
					|| property == "otherIdentifierType"
          || property == "estimatedDateOfDelivery"
          || property == "participatingInTest"
          || property == "clinicalIndicationName"
          || property == "tumour"
					|| property == "numberOfColorectalPolypsAdenomas"
          || property == "numberOfColorectalPolypsTotal"
          || property == "clinicalIndicationName"
          || property == "lastMenstralPeriod"
          || property == "nonNgisPatientStableUid"
					|| property == "ngisRegisteredPatientSimpleId" // Using simple ID at the request of GEL
					|| property == "ngisRegisteredPatientUid" // This is hidden
          || property == "clinicalIndicationAgeOfOnset"
          || property == "carrierStatus"
          || property == "gestationAgeDays"
					|| property == "gestationAgeWeeks"
					|| property == "chiNumber"
					|| property == "organDonorId"
					|| property == "localIdentifier"
            		|| property == "clinicalIndicationAgeOfOnsetMonths"
        || property == "clinicalIndicationAgeOfOnsetYears"){
          console.log("Adding Custom Property",property, value)

          var processed = PedigreeImport.convertProperty(property, nextPerson[property]);
          if (processed !== null) {
              properties[processed.propertyName] = processed.value;
          }
        }

				var value = nextPerson[property];
				var property = property.toLowerCase();

				if (property == "mother" || property == "father")  // those are processed on the second pass
					continue;

				if (property == "sex" && value != null) {
					var genderString = value.toLowerCase();
					if (genderString == "female" || genderString == "f" || genderString == "2")
						properties["gender"] = "F";
					else if (genderString == "male" || genderString == "m" || genderString == "1")
						properties["gender"] = "M";
					//else if (genderString == "other" || genderString == "o" || genderString == "9")
					//	properties["gender"] = "O";
					else if (genderString == "indeterminate" || genderString == "o"|| genderString == "9")
                    	properties["gender"] = "O";
				} else if (property == "id") {
					if (externalIDToID.hasOwnProperty(value)) {
						throw "Unable to import pedigree: multiple persons with the same ID [" + value + "]";
					}
					if (nameToID.hasOwnProperty(value) && nameToID[value] != pedigreeID) {
						delete nameToID[value];
						ambiguousReferences[value] = true;
					} else {
						externalIDToID[value] = pedigreeID;
						hasID[pedigreeID] = true;
					}
				} else if (property == "name" || property == "firstname") {
					properties["fName"] = value;
					if (nameToID.hasOwnProperty(value) && nameToID[value] != pedigreeID) {
						// multiple nodes have this first name
						delete nameToID[value];
						ambiguousReferences[value] = true;
					} else if (externalIDToID.hasOwnProperty(value) && externalIDToID[value] != pedigreeID) {
						// some other node has this name as an ID
						delete externalIDToID[value];
						ambiguousReferences[value] = true;
					} else {
						nameToID[value] = pedigreeID;
					}
				} else {
					var processed = PedigreeImport.convertProperty(property, value);
					if (processed !== null) {
						// supported property
						properties[processed.propertyName] = processed.value;
					}
				}
			}
		}

		// only use externalID if id is not present
		if (nextPerson.hasOwnProperty("externalId") && !hasID.hasOwnProperty(pedigreeID)) {
			externalIDToID[nextPerson.externalId] = pedigreeID;
			hasID[pedigreeID] = true;
		}

		newG.properties[pedigreeID] = properties;
	}

	var getPersonID = function (person) {
		if (person.hasOwnProperty("id"))
			return externalIDToID[person.id];

		if (person.hasOwnProperty("firstName"))
			return nameToID[person.firstName];

		if (person.hasOwnProperty("name"))
			return nameToID[person.name];
	};

	var findReferencedPerson = function (reference, refType) {
		if (ambiguousReferences.hasOwnProperty(reference))
			throw "Unable to import pedigree: ambiguous reference to [" + reference + "]";

		if (externalIDToID.hasOwnProperty(reference))
			return externalIDToID[reference];

		if (nameToID.hasOwnProperty(reference))
			return nameToID[reference];

		throw "Unable to import pedigree: [" + reference + "] is not a valid " + refType + " reference (does not correspond to a name or an ID of another person)";
	};

	var defaultEdgeWeight = 1;

	var relationshipTracker = new RelationshipTracker(newG, defaultEdgeWeight);

	// second pass (once all vertex IDs are known): process parents/children & add edges
	for (var i = 0; i < inputArray.length; i++) {
		if (inputArray[i].hasOwnProperty("relationshipId")) {
			continue;
		}

		var nextPerson = inputArray[i];

		var personID = getPersonID(nextPerson);

		var motherLink = nextPerson.hasOwnProperty("mother") ? nextPerson["mother"] : null;
		var fatherLink = nextPerson.hasOwnProperty("father") ? nextPerson["father"] : null;

		if (motherLink == null && fatherLink == null)
			continue;

		// create a virtual parent in case one of the parents is missing
		if (fatherLink == null) {
			var fatherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "M", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			var fatherID = findReferencedPerson(fatherLink, "father");
			if (newG.properties[fatherID].gender == "F")
				//throw "Unable to import pedigree: a person declared as female is also declared as being a father (" + fatherLink + ")";
				//possible before of ability for put an unassigned node anywhere (even after warnings)
				console.warn("Unable to import pedigree: a person declared as female is also declared as being a father (" + fatherLink + ")");
		}
		if (motherLink == null) {
			var motherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "F", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			var motherID = findReferencedPerson(motherLink, "mother");
			if (newG.properties[motherID].gender == "M")
				//throw "Unable to import pedigree: a person declared as male is also declared as being a mother (" + motherLink + ")";
				console.warn("Unable to import pedigree: a person declared as male is also declared as being a mother (" + motherLink + ")");
		}

		if (fatherID == personID || motherID == personID)
			throw "Unable to import pedigree: a person is declared to be his or hew own parent";

		// both motherID and fatherID are now given and represent valid existing nodes in the pedigree

		// if there is a relationship between motherID and fatherID the corresponding childhub is returned
		// if there is no relationship, a new one is created together with the chldhub
		var chhubID = relationshipTracker.createOrGetChildhub(motherID, fatherID);

		newG.addEdge(chhubID, personID, defaultEdgeWeight);
	}

	// finally, go over relationships specified in the input, and either create those not yet created
	// (because they are Childless) or set properties for those already created
	for (var i = 0; i < inputArray.length; i++) {
		if (!inputArray[i].hasOwnProperty("relationshipId")) {
			continue;
		}
		var nextRelationship = inputArray[i];

		var partnerLink1 = nextRelationship.hasOwnProperty("partner1") ? nextRelationship["partner1"] : null;
		var partnerLink2 = nextRelationship.hasOwnProperty("partner2") ? nextRelationship["partner2"] : null;

		if (partnerLink1 == null || partnerLink2 == null) {
			throw "Unable to import pedigree: a relationship has only one partner specified";
		}

		var partnerID1 = findReferencedPerson(partnerLink1);
		var partnerID2 = findReferencedPerson(partnerLink2);

		// get or create a relationship
		var chhubID = relationshipTracker.createOrGetChildhub(partnerID1, partnerID2);

		// if there are no children, create a placeholder child
		if (newG.getOutEdges(chhubID).length == 0) {
			var placeholderID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "U", "placeholder": true}, newG.defaultPersonNodeWidth);
			newG.addEdge(chhubID, placeholderID, defaultEdgeWeight);
		}

		// set relationship properties
		var relationshipID = relationshipTracker.getRelationshipIDForChildHub(chhubID);
		for (var property in nextRelationship) {
			if (nextRelationship.hasOwnProperty(property)) {
				var value = nextRelationship[property];
				var property = property.toLowerCase();

				if (property == "partner1" || property == "partner2")  // those are already processed
					continue;

				var processed = PedigreeImport.convertRelationshipProperty(property, value);
				if (processed !== null) {
					// supported property
					newG.properties[relationshipID][processed.propertyName] = processed.value;
				}
			}
		}
	}

	PedigreeImport.validateBaseGraph(newG);

	//Added for GEL .................................
	//Add unRenderedNodes into this field
	newG.unRenderedNodes = unRenderedNodes;
	//...............................................
	return newG;
}


/* ===============================================================================================
 *
 * GEDCOM file format: http://en.wikipedia.org/wiki/GEDCOM
 *
 * Supported individual (INDI) properties: NAME, SEX, NOTE, ADOP, BIRT, DEAT and DATE
 *  - Non-standard "_GENSTAT" is partially supported (for compatibility with Cyrillic v3)
 *  - Non-standard "_MAIDEN", "_INFO" and "_COMMENT" are supported (for compatibility with Cyrillic v3)
 *  - FAMS is ignored, instead 0-level FAM families are parsed/processed
 *  - only the first instance is used if the same property is given multiple times (e.g. multiple BIRT records)
 *
 * Suported family (FAM) properties: HUSB, WIFE, CHIL
 *
 * Note: reverse-engineered _GENSTAT values: the following symbols, in any position, mean:
 *   Disorder status:
 *    AFFECTED:  "O"
 *    HEARSAY:   "¬"  (hearsay graphic == pre-symptomatic graphic)
 *    UNTESTED:  "E"
 *    "carrier" and "examined" does not seem to be exported to GEDCOM or CSV
 *   Other:
 *    PROBAND:   "C"  (may be more than one)
 *    STILLBORN: "K"
 *    INFERTILE: "M"
 * ===============================================================================================
 */
PedigreeImport.initFromGEDCOM = function (inputText, markEvaluated, saveIDAsExternalID) {
	var inputLines = inputText.match(/[^\r\n]+/g);
	if (inputLines.length == 0) throw "Unable to import: no data";

	var convertToObject = function (inputLines) {
		/* converts GEDCOM text into an object, where 0-level items are stored as "header", "individuals" and "families"
		 * properties, and all items below are arrays of objects, e.g. an array of objects representing each individual.
		 *
		 * Each next-level keyword is a key in the object, and the associated value is an array of objects, each
		 * object representing one encountered instance of the keyword (designed this way as ther emay be more than one
		 * keyword with the same nem, e.g. multiple alternative DATEs for an event, or multiple CHILdren in a family)
		 *
		 * The value of the keyword itself (if any) is stored under the "value" key. In the example below the
		 * all "DATA" keywords have no values, while all TEXT and DATE have some values assigned, and only some
		 * EVEN keywords have a value.
		 *
		 * 0 @I1@ INDI
		 *  1 EVEN AAA
		 *   2 DATE 10 JAN 1800
		 *   2 SOUR @S1@
		 *    3 DATA
		 *     4 TEXT ABC
		 *    3 DATA
		 *     4 TEXT DEF
		 *    3 NOTE DEF
		 *    3 ZZZZ 2
		 *    3 ZZZZ 3
		 *  1 EVEN
		 *   2 DATE 1800
		 *   2 SOUR @S2@
		 *  1 EVEN BBB
		 *   2 DATE 1900
		 * 0 @I2@ INDI
		 *  1 ...
		 *
		 * is stranslated to:
		 *  // level
		 *  //  1       2       3        4
		 *  [{id: '@I1@'
		 *    EVEN: [
		 *           {value: 'AAA',
		 *            DATE:  [{value: '10 JAN 1800'}],
		 *            SOUR:  [{value: '@S1@',
		 *                     DATA:  [{TEXT: [{value: 'ABC'}]}, {TEXT: [{value: 'DEF'}]}],
		 *                     NOTE:  [{value: 'DEF'}],
		 *                     ZZZZ:  [{value: '2'}, {value: '3'}]
		 *                    }
		 *                   ]
		 *           },
		 *           {DATE:  [{value: '1800'}],
		 *            SOUR:  [{value: '@S2@'}]
		 *           },
		 *           {value: 'BBB',
		 *            DATE:  [{value: '1900'}]
		 *           }
		 *          ]
		 *   },
		 *   {id: '@I2@' ...}
		 *  ]
		 */
		var obj = { "header": {}, "individuals": [], "families": [] };

		var currentObject = [];

		for (var i = 0; i < inputLines.length; i++) {
			var nextLine = inputLines[i].replace(/[^a-zA-Z0-9.\@\/\-\s*]/g, ' ').replace(/^\s+|\s+$/g, ''); // sanitize + trim

			var words = inputLines[i].split(/\s+/);
			var parts = words.splice(0, 2);
			parts.push(words.join(' '));

			// now parts[0] = level, parts[1] = record type, parts[2] = value, if any

			var level = parseInt(parts[0]);

			currentObject.splice(level);

			if (level == 0) {
				if (parts[1] == "HEAD") {
					currentObject[0] = obj.header;
				} else if (parts[1][0] == '@' && parts[2] == "INDI") {
					obj.individuals.push({});
					currentObject[0] = obj.individuals[obj.individuals.length - 1];
					currentObject[0]["id"] = parts[1];
				} else if (parts[1][0] == '@' && parts[2] == "FAM") {
					obj.families.push({});
					currentObject[0] = obj.families[obj.families.length - 1];
					currentObject[0]["id"] = parts[1];
				} else {
					currentObject[0] = {};
				}
			} else {
				if (currentObject.length < level - 1) {
					throw "Unable to import GEDCOM: a multi-level jump detected in line: [" + inputLines[i] + "]";
				}

				if (!currentObject[level - 1].hasOwnProperty(parts[1]))
					currentObject[level - 1][parts[1]] = [];  // array of values

				if (currentObject.length < level + 1) {
					currentObject[level] = {};
					currentObject[level - 1][parts[1]].push(currentObject[level]);
				}

				if (parts[2] != "") {
					currentObject[level]["value"] = parts[2];
				}
			}
			currentLevel = parts[0];
		}

		return obj;
	};

	var gedcom = convertToObject(inputLines);
	console.log("GEDCOM object: " + Helpers.stringifyObject(gedcom));

	if (gedcom.header.hasOwnProperty("GEDC")) {
		if (gedcom.header.GEDC.hasOwnProperty("VERS")) {
			if (gedcom.header.GEDC.VERS != "5.5" && gedcom.header.GEDC.VERS != "5.5.1") {
				alert("Unsupported GEDCOM version detected: [" + gedcom.header.GEDC.VERS + "]. " +
					"Import will continue but the correctness is not guaranteed. Supportede versions are 5.5 and 5.5.1");
			}
		}
	}

	if (gedcom.individuals.length == 0) {
		throw "Unable to create a pedigree from GEDCOM: no individuals are defined in the import data";
	}

	var newG = new BaseGraph();

	var externalIDToID = {};

	// first pass: add all vertices and assign vertex IDs
	for (var i = 0; i < gedcom.individuals.length; i++) {
		var nextPerson = gedcom.individuals[i];

		var pedigreeID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {}, newG.defaultPersonNodeWidth);

		externalIDToID[nextPerson.id] = pedigreeID;

		var cleanedID = nextPerson.id.replace(/@/g, '')
		var properties = saveIDAsExternalID ? {"externalID": cleanedID} : {};

		properties["gender"] = "U";     // each person should have some gender set

		var getFirstValue = function (obj) {
			//if (Object.prototype.toString.call(obj) === '[object Array]')
			return obj[0].value;
		}

		var parseDate = function (gedcomDate) {
			gedcomDate = gedcomDate[0].value;

			// treat possible date modifiers
			//  "ABT" - "about"
			//  "EST" - "estimated"
			//  "BEF" - "before"
			//  "AFT" - "after"
			//  "BET ... AND ..." = "between ... and ..."
			// for all of the above the date itself is used as the date; for the "between" the first date is used.

			// TODO: add support for importing approximate dates, since those are now supported by PedigreeDate object
			gedcomDate = gedcomDate.replace(/^(\s*)ABT(\s*)/, "");
			gedcomDate = gedcomDate.replace(/^(\s*)EST(\s*)/, "");
			gedcomDate = gedcomDate.replace(/^(\s*)BEF(\s*)/, "");
			gedcomDate = gedcomDate.replace(/^(\s*)AFT(\s*)/, "");
			var getBetweenDate = /^\s*BET\s+(.+)\s+AND.*/;
			var match = getBetweenDate.exec(gedcomDate);
			if (match != null) {
				gedcomDate = match[1];
			}

			if (gedcomDate == "?") return null;

			// TODO: can handle approx. dates (i.e. "ABT" and "EST") better using new Pedigree fuzzy dates
			//       conversion below would convert "ABT JAN 1999" to "JAN 1 1999" instead of fuzzy date "Jan 1999"
			var timestamp = Date.parse(gedcomDate)
			if (isNaN(timestamp) == false) {
				return new PedigreeDate(new Date(timestamp));
			}
			return null;
		};

		for (var property in nextPerson) {
			if (nextPerson.hasOwnProperty(property)) {
				if (property == "SEX") {
					var genderString = getFirstValue(nextPerson[property])[0].toLowerCase(); // use first character only
					if (genderString == "female" || genderString == "f")
						properties["gender"] = "F";
					else if (genderString == "male" || genderString == "m")
						properties["gender"] = "M";
				} else if (property == "BIRT") {
					if (nextPerson[property][0].hasOwnProperty("DATE")) {
						var date = parseDate(nextPerson[property][0]["DATE"]);
						if (date !== null) {
							properties["dob"] = new PedigreeDate(date).getSimpleObject()
						}
					}
				} else if (property == "DEAT") {
					if (properties.hasOwnProperty("lifeStatus") && properties["lifeStatus"] == "Stillborn")
						continue;
					properties["lifeStatus"] = "Deceased";
					if (nextPerson[property][0].hasOwnProperty("DATE")) {
						var date = parseDate(nextPerson[property][0]["DATE"]);
						if (date !== null) {
							properties["dod"] = new PedigreeDate(date).getSimpleObject();
						}
					}
				} else if (property == "ADOP") {
					properties["adoptedStatus"] = "adoptedIn";
				} else if (property == "_INFO") {
					if (!properties.hasOwnProperty("comments"))
						properties["comments"] = "";
					properties["comments"] += "(Info: " + getFirstValue(nextPerson[property]) + ")\n";
				} else if (property == "NOTE" || property == "_COMMENT") {
					if (!properties.hasOwnProperty("comments"))
						properties["comments"] = "";
					properties["comments"] += getFirstValue(nextPerson[property]) + "\n";
					if (nextPerson[property][0].hasOwnProperty("CONT")) {
						var more = nextPerson[property][0]["CONT"];
						for (var cc = 0; cc < more.length; cc++) {
							properties["comments"] += more[cc].value + "\n";
						}
					}
				} else if (property == "NAME") {
					var nameParts = getFirstValue(nextPerson[property]).split('/');
					var firstName = nameParts[0].replace(/^\s+|\s+$/g, '');
					var lastName = nameParts.length > 1 ? nameParts[1].replace(/^\s+|\s+$/g, '') : "";
					properties["fName"] = firstName;
					if (lastName != "")
						properties["lName"] = lastName;
				} else if (property == "_MAIDEN") {
					var nameParts = getFirstValue(nextPerson[property]).split('/');
					var firstName = nameParts[0].replace(/^\s+|\s+$/g, '');
					var lastName = nameParts.length > 1 ? nameParts[1].replace(/^\s+|\s+$/g, '') : "";
					properties["lNameAtB"] = firstName;
					if (lastName != "")
						properties["lNameAtB"] += " " + lastName;
				} else if (property == "_GENSTAT") {
					var props = getFirstValue(nextPerson[property]).split('');
					for (var p = 0; p < props.length; p++) {
						var value = props[p];
						if (value.charCodeAt(0) == 65533 || value.charCodeAt(0) == 172) {
							// one value is obtained via copy-paste, another via file upload
							value = "HEARSAY";
						}
						switch (value) {
							case "O":
								properties["carrierStatus"] = 'Affected';
								properties["disorders"] = ['Affected'];
								if (markEvaluated)
									properties["evaluated"] = true;
								break;
							case "HEARSAY":
								properties["carrierStatus"] = 'Presymptomatic'; // the closest graphic to cyrillic's "hearsay"
								if (markEvaluated)
									properties["evaluated"] = true;
								break;
							case "K":
								properties["lifeStatus"] = "Stillborn";
								break;
							case "M":
								properties["childlessStatus"] = "Infertile";
								break;
							case "E":
								if (!properties.hasOwnProperty("comments")) {
									properties["comments"] = "(untested)";
								}
								else {
									properties["comments"] = "(untested)\n" + properties["comments"];
								}
								break;
							case "O":
								// TODO: proband
								break;
						}
					}
				}
			}
		}
		if (properties.hasOwnProperty("comments")) {
			// remove trailing newlines and/or empty comments
			properties.comments = properties.comments.replace(/^\s+|\s+$/g, '');
			if (properties.comments == "")
				delete properties.comments;
		}
		newG.properties[pedigreeID] = properties;
	}

	var defaultEdgeWeight = 1;

	var relationshipTracker = new RelationshipTracker(newG, defaultEdgeWeight);

	// second pass (once all vertex IDs are known): process families & add edges
	for (var i = 0; i < gedcom.families.length; i++) {
		var nextFamily = gedcom.families[i];

		var motherLink = nextFamily.hasOwnProperty("WIFE") ? getFirstValue(nextFamily["WIFE"]) : null;
		var fatherLink = nextFamily.hasOwnProperty("HUSB") ? getFirstValue(nextFamily["HUSB"]) : null;

		// create a virtual parent in case one of the parents is missing
		if (fatherLink == null) {
			var fatherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "M", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			var fatherID = externalIDToID[fatherLink];
			if (newG.properties[fatherID].gender == "F")
				throw "Unable to import pedigree: a person declared as female is also declared as being a father (" + fatherLink + ")";
		}
		if (motherLink == null) {
			var motherID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "F", "comments": "unknown"}, newG.defaultPersonNodeWidth);
		} else {
			var motherID = externalIDToID[motherLink];
			if (newG.properties[motherID].gender == "M")
				throw "Unable to import pedigree: a person declared as male is also declared as being a mother (" + motherLink + ")";
		}

		// both motherID and fatherID are now given and represent valid existing nodes in the pedigree

		// if there is a relationship between motherID and fatherID the corresponding childhub is returned
		// if there is no relationship, a new one is created together with the chldhub
		var chhubID = relationshipTracker.createOrGetChildhub(motherID, fatherID);

		var children = nextFamily.hasOwnProperty("CHIL") ? nextFamily["CHIL"] : null;

		if (children == null) {
			// create a virtual child
			var childID = newG._addVertex(null, BaseGraph.TYPE.PERSON, {"gender": "U", "placeholder": true}, newG.defaultPersonNodeWidth);
			externalIDToID[childID] = childID;
			children = [
				{"value": childID}
			];
			// TODO: add "Infertile by choice" property to the relationship
		}

		for (var j = 0; j < children.length; j++) {
			var externalID = children[j].value;

			var childID = externalIDToID.hasOwnProperty(externalID) ? externalIDToID[externalID] : null;

			if (childID == null) {
				throw "Unable to import pedigree: child link does not point to an existing individual: [" + externalID + "]";
			}

			newG.addEdge(chhubID, childID, defaultEdgeWeight);
		}
	}

	PedigreeImport.validateBaseGraph(newG);

	return newG;
}


// ===============================================================================================


// TODO: convert internal properties to match public names and rename this to "supportedProperties"
PedigreeImport.JSONToInternalPropertyMapping = {
  "proband": "proband",
  "lastname": "lName",
  //"ngisRegisteredPatientId":"ngisRegisteredPatientId",
  //"nonNgisStableId":"nonNgisStableId",
  "participatingInTest":"participatingInTest",
  "otherIdentifier":"otherIdentifier",
  "otherIdentifierType":"otherIdentifierType",
  "gestationAgeWeeks":"gestationAgeWeeks",
  "gestationAgeDays":"gestationAgeDays",
  "estimatedDateOfDelivery":"estimatedDateOfDelivery",
  "comments":"comments",
  "nhsnumber":       "NHSNumber",
  "chiNumber": "chiNumber",
  "localIdentifier": "localIdentifier",
  "organDonorId": "organDonorId",
  "familyid":       "familyId",
  "gelsuperfamilyid": "gelSuperFamilyId",
  "consanguineouspopulation":"consanguineousPopulation",
  "karyotypicsex":"karyotypicSex",
  "ancestries": "ancestries",
  "participantid":   "participantId",
  "registered":   "registered",
  "lastnameatbirth": "lNameAtB",
  "comments": "comments",
  "twingroup": "twinGroup",
  "monozygotic": "monozygotic",
  "adoptedstatus": "adoptedStatus",
  "evaluated": "evaluated",
  "birthdate": "dob",
  "deathdate": "dod",
  "ageatdeath": "ageOfDeath",
  "ageatdeathformat": "ageOfDeathFormat",
  "lifestatus": "lifeStatus",
  "disorders": "disorders",
  "disordersfulldetails": "disordersFullDetails", //Added for GEL(GenomicsEngland)
  "hpoterms": "hpoTerms",
  "hpotermsfulldetails": "hpoTermsFullDetails", //Added for GEL(GenomicsEngland)
  "candidategenes": "candidateGenes",
  "ethnicities": "ethnicities",
  "carrierStatus": "carrierStatus",
  "externalid": "externalID",
  "clinicalIndicationAgeOfOnsetMonths":"clinicalIndicationAgeOfOnsetMonths",
    "clinicalIndicationAgeOfOnsetYears":"clinicalIndicationAgeOfOnsetYears",
    "numpersons": "numPersons",
  "lostcontact": "lostContact",
  "nodenumber": "nodeNumber",
  "cancers": "cancers",
  "childlessstatus": "childlessStatus",
  "childlessreason": "childlessReason",
  "clinicalIndicationName": "clinicalIndicationName",
  "tumour":"cancers",
  "numberOfColorectalPolypsAdenomas":"numberOfColorectalPolypsAdenomas",
  "numberOfColorectalPolypsTotal":"numberOfColorectalPolypsTotal",
  "nonNgisPatientStableUid":"nonNgisPatientStableUid",
  "ngisRegisteredPatientSimpleId":"ngisRegisteredPatientUid", // Remapping to simple ID at the request of GEL
  "ngisRegisteredPatientUid":"ngisRegisteredPatientSimpleId", // This gets hidden in pedigree.js
  "lastMenstralPeriod":"lastMenstralPeriod"
};


/*
 * Converts property name from external JSON format to internal - also helps to
 * support aliases for some terms and weed out unsupported terms.
 */
PedigreeImport.convertProperty = function (externalPropertyName, value) {

	if (!PedigreeImport.JSONToInternalPropertyMapping.hasOwnProperty(externalPropertyName))
		return null;

	var internalPropertyName = PedigreeImport.JSONToInternalPropertyMapping[externalPropertyName];

	return {"propertyName": internalPropertyName, "value": value };
}

PedigreeImport.JSONToInternalRelationshipPropertyMapping = {
	"childlessstatus": "childlessStatus",
	"childlessreason": "childlessReason",
	"consanguinity": "consangr",
	"separated": "broken"
};

PedigreeImport.convertRelationshipProperty = function (externalPropertyName, value) {

	if (!PedigreeImport.JSONToInternalRelationshipPropertyMapping.hasOwnProperty(externalPropertyName))
		return null;

	var internalPropertyName = PedigreeImport.JSONToInternalRelationshipPropertyMapping[externalPropertyName];

	if (externalPropertyName == "consanguinity") {
		if (["Y","N","P","U"].indexOf(value) == -1){
			return null;
		}
	}
	return {"propertyName": internalPropertyName, "value": value };
}
//===============================================================================================

/*
 * Helper class which keeps track of relationships already seen in pedigree being imported
 */
RelationshipTracker = function (newG, defaultEdgeWeight) {
	this.newG = newG;

	this.defaultEdgeWeight = defaultEdgeWeight;

	this.relationships = {};
	this.relChildHubs = {};
	this.chhubRels = {};
};

RelationshipTracker.prototype = {

	// if there is a relationship between partnerID1 and partnerID2 the corresponding childhub is returned
	// if there is no relationship, a new one is created together with the chldhub
	createOrGetChildhub: function (partnerID1, partnerID2) {
		// both partnerID1 and partnerID2 are now given. Check if there is a relationship between the two of them
		if (this.relationships.hasOwnProperty(partnerID1) && this.relationships[partnerID1].hasOwnProperty(partnerID2)) {
			var relID = this.relationships[partnerID1][partnerID2];
			var chhubID = this.relChildHubs[relID];
		} else {
			if (this.relationships[partnerID1] === undefined) this.relationships[partnerID1] = {};
			if (this.relationships[partnerID2] === undefined) this.relationships[partnerID2] = {};

			var relID = this.newG._addVertex(null, BaseGraph.TYPE.RELATIONSHIP, {}, this.newG.defaultNonPersonNodeWidth);
			var chhubID = this.newG._addVertex(null, BaseGraph.TYPE.CHILDHUB, {}, this.newG.defaultNonPersonNodeWidth);

			this.newG.addEdge(relID, chhubID, this.defaultEdgeWeight);
			this.newG.addEdge(partnerID1, relID, this.defaultEdgeWeight);
			this.newG.addEdge(partnerID2, relID, this.defaultEdgeWeight);

			this.relationships[partnerID1][partnerID2] = relID;
			this.relationships[partnerID2][partnerID1] = relID;
			this.relChildHubs[relID] = chhubID;
			this.chhubRels[chhubID] = relID;
		}

		return chhubID;
	},

	getRelationshipIDForChildHub: function (chhubID) {
		return this.chhubRels[chhubID];
	}
};


PedigreeExport = function () {
};

PedigreeExport.prototype = {
};

/* ===============================================================================================
 *
 * Creates and returns a JSON in the "simple JSON" format (see PedigreeImport.initFromSimpleJSON)
 *
 *  Simple JSON format: an array of objects, each object representing one person, e.g.:
 *
 *    [ { "name": "f11", "sex": "female", "lifeStatus": "deceased" },
 *      { "name": "m11", "sex": "male" },
 *      { "name": "f12", "sex": "female", "disorders": [603235, "142763", "custom disorder"] },
 *      { "name": "m12", "sex": "male" },
 *      { "name": "m21", "sex": "male", "mother": "f11", "father": "m11" },
 *      { "name": "f21", "sex": "female", "mother": "f12", "father": "m12" },
 *      { "name": "ch1", "sex": "female", "mother": "f21", "father": "m21", "disorders": [603235], "proband": true },
 *      { "name": "m22", "sex": "male" },
 *      { "relationshipId": 1, "partner1": "f21", "partner2": "m22"} ]
 *
 * @param pedigree {PositionedGraph}
 * ===============================================================================================
 */
PedigreeExport.exportAsSimpleJSON = function (pedigree, privacySetting) {
	var exportObj = [];

	var getMotherFather = function (nodeID) {
		// mother & father
		var parents = pedigree.GG.getParents(nodeID);
		if (parents.length > 0) {
			var father = parents[0];
			var mother = parents[1];
			if (pedigree.GG.properties[parents[0]]["gender"] == "F" ||
				pedigree.GG.properties[parents[1]]["gender"] == "M") {
				father = parents[1];
				mother = parents[0];
			}
		}
		return {"mother": mother, "father": father};
	};

	var idToJSONId = PedigreeExport.createNewIDs(pedigree);

	for (var i = 0; i <= pedigree.GG.getMaxRealVertexId(); i++) {
		if (!pedigree.GG.isPerson(i) || pedigree.GG.isPlaceholder(i)) continue;

		var person = {"id": idToJSONId[i]};

		var parents = getMotherFather(i);
		person["father"] = idToJSONId[parents.father];
		person["mother"] = idToJSONId[parents.mother];

		// all other properties
    var properties = pedigree.GG.properties[i];
		for (var property in properties) {
			if (properties.hasOwnProperty(property)) {
				if (privacySetting != "all") {
					if (property == 'lName' || property == 'fName' || property == 'lNameAtB' ||
						property == 'dob' || property == 'bob') continue;
					if (privacySetting == "minimal" && property == "comments") continue
				}
				var converted = PedigreeExport.convertProperty(property, properties[property]);
				if (converted !== null) {
					person[converted.propertyName] = converted.value;
				}
				//Added for GEL(GenomicsEngland)
				//if 'ageOfDeath is not provided, then delete 'ageOfDeathFormat' and do not export it
				//we will either have data-of-birth and data-of-death OR a
				if(converted && converted.propertyName == "ageOfDeathFormat" && (!person["ageOfDeath"] || (person["ageOfDeath"] && person["ageOfDeath"] == ""))){
					delete person["ageOfDeathFormat"]
				}
			}
		}
		exportObj.push(person);
	}

	var nextRelId = 1;
	for (var i = 0; i <= pedigree.GG.getMaxRealVertexId(); i++) {
		if (!pedigree.GG.isRelationship(i)) continue;

		var relationship = {"relationshipId": nextRelId++};

		// only indicate Childless relationships or relationships with properties
		var properties = pedigree.GG.properties[i];
		var hasProperties = false;
		for (var property in properties) {
			if (properties.hasOwnProperty(property)) {
				hasProperties = true;
				var converted = PedigreeExport.convertRelationshipProperty(property, properties[property]);
				if (converted !== null) {
					relationship[converted.propertyName] = converted.value;
				}
			}
		}

		if (!hasProperties) {
			continue;
		}

		var parents = getMotherFather(i);
		relationship["partner1"] = idToJSONId[parents.father];
		relationship["partner2"] = idToJSONId[parents.mother];

		exportObj.push(relationship);
  }

	return JSON.stringify(exportObj);
}

//===============================================================================================

/*
 *  PED format:
 *  (from http://pngu.mgh.harvard.edu/~purcell/plink/data.shtml#ped)
 *   Family ID
 *   Individual ID
 *   Paternal ID
 *   Maternal ID
 *   Sex (1=male; 2=female; other=unknown)
 *   Phenotype
 *
 *   Phenotype, by default, should be coded as:
 *      -9 missing
 *       0 missing
 *       1 unaffected
 *       2 affected
 */
PedigreeExport.exportAsPED = function (pedigree, idGenerationPreference) {
	var output = "";

	var familyID = XWiki.currentDocument.page;

	var idToPedId = PedigreeExport.createNewIDs(pedigree, idGenerationPreference);

	for (var i = 0; i <= pedigree.GG.getMaxRealVertexId(); i++) {
		if (!pedigree.GG.isPerson(i)) continue;
		if (pedigree.GG.isPlaceholder(i)) continue;

		output += familyID + " " + idToPedId[i] + " ";

		// mother & father
		var parents = pedigree.GG.getParents(i);
		if (parents.length > 0) {
			var father = parents[0];
			var mother = parents[1];

			if (pedigree.GG.properties[parents[0]]["gender"] == "F" ||
				pedigree.GG.properties[parents[1]]["gender"] == "M") {
				father = parents[1];
				mother = parents[0];
			}
			output += idToPedId[father] + " " + idToPedId[mother] + " ";
		} else {
			output += "0 0 ";
		}

		var sex = 3;
		if (pedigree.GG.properties[i]["gender"] == "M") {
			sex = 1;
		}
		else if (pedigree.GG.properties[i]["gender"] == "F") {
			sex = 2;
		}
		output += (sex + " ");

		var status = -9; //missing
		if (pedigree.GG.properties[i].hasOwnProperty("carrierStatus")) {
			if (pedigree.GG.properties[i]["carrierStatus"] == "Affected" ||
				pedigree.GG.properties[i]["carrierStatus"] == "Carrier" ||
				pedigree.GG.properties[i]["carrierStatus"] == "Presymptomatic")
				status = 2;
			else
				status = 1;
		}
		output += status + "\n";
	}

	return output;
}

//===============================================================================================

/*
 *  BOADICEA format:
 *  (from https://pluto.srl.cam.ac.uk/bd3/v3/docs/BWA_v3_user_guide.pdf)
 *
 *  line1: BOADICEA import pedigree file format 2.0
 *  line2: column titles
 *  line3+: one patient per line, with values separated by spaces or tabs, as follows:
 *
 *   FamID: Family/pedigree ID, character string (maximum 13 characters)
 *   Name: First name/ID of the family member, character string (maximum 8 characters)
 *   Target: The family member for whom the BOADICEA risk calculation is made, 1 = target for BOADICEA risk calculation, 0 = other family members. There must only be one BOADICEA target individual.
 *   IndivID: Unique ID of the family member, character string (maximum 7 characters)
 *   FathID: Unique ID of their father, 0 = no father, or character string (maximum 7 characters)
 *   MothID: Unique ID of their mother, 0 = unspecified, or character string (maximum 7 characters)
 *   Sex: M or F
 *   Twin: Identical twins, 0 = no identical twin, any non-zero character = twin.
 *   Dead: The current status of the family member, 0 = alive, 1 = dead
 *   Age: Age at last follow up, 0 = unspecified, integer = age at last follow up
 *   Yob: Year of birth, 0 = unspecified, or integer (consistent with Age if the person is alive)
 *   1BrCa: Age at first breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   2BrCa: Age at contralateral breast cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   OvCa: Age at ovarian cancer diagnosis, 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   ProCa: Age at prostate cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   PanCa: Age at pancreatic cancer diagnosis 0 = unaffected, integer = age at diagnosis, AU = unknown age at diagnosis (affected, age unknown)
 *   Gtest: Genetic test status, 0 = untested, S = mutation search, T = direct gene test
 *   Mutn: 0 = untested, N = no mutation, 1 = BRCA1 positive, 2 = BRCA2 positive, 3 = BRCA1 and BRCA2 positive
 *   Ashkn: 0 = not Ashkenazi, 1 = Ashkenazi
 *   ER: Estrogen receptor status, 0 = unspecified, N = negative, P = positive
 *   PR: Progestrogen receptor status, 0 = unspecified, N = negative, P = positive
 *   HER2: Human epidermal growth factor receptor 2 status, 0 = unspecified, N = negative, P = positive
 *   CK14: Cytokeratin 14 status, 0 = unspecified, N = negative, P = positive
 *   CK56: Cytoke ratin 56 status, 0 = unspecified, N = negative, P = positive
 */
PedigreeExport.exportAsBOADICEA = function (dynamicPedigree, idGenerationPreference) {
	var pedigree = dynamicPedigree.DG;

	var output = "BOADICEA import pedigree file format 2.0\n";
	output += "FamID\t\tName\tTarget\tIndivID\tFathID\tMothID\tSex\tTwin\tDead\tAge\tYob\t1BrCa\t2BrCa\tOvCa\tProCa\tPanCa\tGtest\tMutn\tAshkn\tNot_implemented_yet\n";

	// note: a bug in BOADICEA online app requires that the column header line starts with "FamID" followed by a space.
	//       Anything else, including "FamilyID ..." will be reported as an error in pedigree.

	var familyID = XWiki.currentDocument.page;

	var idToBoadId = PedigreeExport.createNewIDs(pedigree, idGenerationPreference, 7 /* max ID length */, true /* forbid non-alphanum */);

	var alertUnknownGenderFound = false; // BOADICEA does not support unknown genders
	var warnAboutMissingDOB = false; // BOADICEA seem to require all individuals with cancer to have some age specified

	for (var i = 0; i <= pedigree.GG.getMaxRealVertexId(); i++) {
		if (!pedigree.GG.isPerson(i)) continue;
		if (pedigree.GG.isPlaceholder(i)) continue;

		var id = idToBoadId[i];

		var name = pedigree.GG.properties[i].hasOwnProperty("fName") ? pedigree.GG.properties[i]["fName"].substring(0, 8).replace(/[^A-Za-z0-9]/g, '') : id;

		var proband = (i == 0) ? "1" : "0";

		output += familyID + "\t" + name + "\t" + proband + "\t" + id + "\t";

		// mother & father
		var parents = pedigree.GG.getParents(i);
		if (parents.length > 0) {
			if (pedigree.GG.properties[parents[0]]["gender"] == "U" &&
				pedigree.GG.properties[parents[1]]["gender"] == "U") {
				editor.getOkCancelDialogue().showCustomized("Unable to export in BOADICEA format when both parents of any node are of unknown gender",
					"Can't export: missing gender data", "OK", null);
				return "";
			}

			var father = parents[0];
			var mother = parents[1];

			if (pedigree.GG.properties[parents[0]]["gender"] == "F" ||
				pedigree.GG.properties[parents[1]]["gender"] == "M") {
				father = parents[1];
				mother = parents[0];
			}
			output += idToBoadId[father] + "\t" + idToBoadId[mother] + "\t";
		} else {
			output += "0\t0\t";
		}

		var sex = "M";
		var gender = pedigree.GG.properties[i]["gender"];
		if (gender == "F") {
			sex = "F";
		} else if (gender == "U" || gender == "O") {
			// check partner gender(s) and if possible assign the opposite gender
			var possibleGenders = dynamicPedigree.getPossibleGenders(i);
			if (!possibleGenders["F"] && !possibleGenders["M"]) {
				// there is a person which can't be assigned both M and F because both conflict with other partner genders
				editor.getOkCancelDialogue().showCustomized("Unable to export in BOADICEA format since gender assignment in pedigree is inconsistent",
					"Can't export: gender inconsistency in pedigree", "OK", null);
				return "";
			}
			if (possibleGenders["F"] && !possibleGenders["M"]) {
				sex = "F";
			} else if (possibleGenders["M"] && !possibleGenders["F"]) {
				sex = "M";
			} else {
				// can be both, no restrictions: assign "M"
				sex = "M";
			}
			alertUnknownGenderFound = true;
		}
		output += sex + "\t";

		if (pedigree.GG.getTwinGroupId(i) !== null
			&& pedigree.GG.properties[i].hasOwnProperty('monozygotic')
			&& pedigree.GG.properties[i].monozygotic) {
			output += "1\t";
		} else {
			output += "0\t";
		}

		var dead = "0";
		if (pedigree.GG.properties[i].hasOwnProperty("lifeStatus")) {
			if (pedigree.GG.properties[i]["lifeStatus"] != "Alive") {
				var dead = "1";
			}
		}
		output += dead + "\t";

		var age = "0";
		var yob = "0";
		if (pedigree.GG.properties[i].hasOwnProperty("dob")) {
			var birthDate = new PedigreeDate(pedigree.GG.properties[i]["dob"]);
			// BOADICEA file format does not support fuzzy dates, so get an estimate if only decade is available
			yob = parseInt(birthDate.getAverageYearEstimate());
			if (pedigree.GG.properties[i].hasOwnProperty("dod")) {
				var deathDate = new PedigreeDate(pedigree.GG.properties[i]["dod"]);
				var lastYearAlive = parseInt(deathDate.getAverageYearEstimate());
				if (deathDate.toJSDate().getDayOfYear() < birthDate.toJSDate().getDayOfYear()) {
					lastYearAlive--;
				}
			} else {
				var lastYearAlive = new Date().getFullYear();
			}
			age = lastYearAlive - yob;
			if (age < 0) {  // e.g.: Birth: 2007, Death: 2000s
				age = "0";
			}
		}
		output += age + "\t" + yob + "\t";

		// TODO: Contralateral breast cancer export/field?
		var cancerSequence = [ "Breast", "", "Ovarian", "Prostate", "Pancreatic" ];

		for (var c = 0; c < cancerSequence.length; c++) {
			cancer = cancerSequence[c];
			if (cancer == "" || !pedigree.GG.properties[i].hasOwnProperty("cancers")) {
				output += "0\t";
				continue;
			}

			if (pedigree.GG.properties[i].cancers.hasOwnProperty(cancer)) {
				var cancerData = pedigree.GG.properties[i].cancers[cancer];
				if (!cancerData.affected) {
					output += "0\t";
				} else {
					var ageAtDetection = cancerData.hasOwnProperty("numericAgeAtDiagnosis") && (cancerData.numericAgeAtDiagnosis > 0)
						? cancerData.numericAgeAtDiagnosis : "AU";
					output += ageAtDetection.toString() + "\t";
					if (yob == "0") {
						warnAboutMissingDOB = true;
					}
				}
			} else {
				output += "0\t";
			}
		}

		output += "0\t"; // TODO: Genetic test status

		// BRCA1/BRCA2 mutations
		if (pedigree.GG.properties[i].hasOwnProperty("candidateGenes")) {
			var genes = pedigree.GG.properties[i].candidateGenes;
			var status = "0";
			if (Helpers.arrayIndexOf(genes, "BRCA1") >= 0) {
				status = "1";
			}
			if (Helpers.arrayIndexOf(genes, "BRCA2") >= 0) {
				if (status == "1") {
					status = "3";
				} else {
					status = "2";
				}
			}
			// TODO: if BRCA1 and/or BRCA2 are among rejected genes set status to "N"
			output += status + "\t";
		} else {
			output += "0\t";
		}

		var ashkenazi = "0";
		if (pedigree.GG.properties[i].hasOwnProperty("ethnicities")) {
			var ethnicities = pedigree.GG.properties[i]["ethnicities"];
			for (var k = 0; k < ethnicities.length; k++) {
				if (ethnicities[k].match(/ashkenaz/i) !== null) {
					ashkenazi = "1";
					break;
				}
			}
		}
		output += ashkenazi + "\t";

		output += "0\t0\t0\t0\t0";  // unimplemented fields: receptor status, etc.

		output += "\n";
	}

	if (alertUnknownGenderFound || warnAboutMissingDOB) {
		var warningText = "Pedigree can be exported, but there are warnings:\n\n\n";

		var numberWarnings = false;
		if (alertUnknownGenderFound && warnAboutMissingDOB) {
			numberWarnings = true;
		}
		if (alertUnknownGenderFound) {
			warningText += (numberWarnings ? "1) " : "") +
				"BOADICEA format does not support unknown or other genders.\n\n" +
				"All persons of unknown or other gender were either assigned a gender " +
				"opposite to their partner's gender or saved as male in the export file";
		}
		if (warnAboutMissingDOB) {
			warningText += (numberWarnings ? "\n\n\n2) " : "") +
				"BOADICEA requires that all individuals with cancer have their age specified or estimated.\n\n" +
				"A person with cancer is missing age data, data will be exported but may not be accepted by BOADICEA";
		}
		alert(warningText);
	}

	return output;
}

// ===============================================================================================

// TODO: convert internal properties to match public names and rename this to "supportedProperties"
PedigreeExport.internalToJSONPropertyMapping = {
  "proband": "proband",
  "otherIdentifier":"otherIdentifier",
  "otherIdentifierType":"otherIdentifierType",
  "participatingInTest":"participatingInTest",
  "gestationAgeWeeks":"gestationAgeWeeks",
  "gestationAgeDays":"gestationAgeDays",
  "estimatedDateOfDelivery":"estimatedDateOfDelivery",
  "comments":"comments",
  "fName": "firstName",
	"lName": "lastName",
	"NHSNumber": "NHSNumber",
	"chiNumber": "chiNumber",
	"localIdentifier": "localIdentifier",
	"organDonorId": "organDonorId",
	"gelSuperFamilyId": "gelSuperFamilyId",
	"karyotypicSex":"karyotypicSex",
	"consanguineousPopulation": "consanguineousPopulation",
	"ancestries": "ancestries",
	"participantId": "participantId",
	"registered": "registered",
	"lNameAtB": "lastNameAtBirth",
	"twinGroup": "twinGroup",
	"monozygotic": "monozygotic",
	"adoptedStatus": "adoptedStatus",
	"evaluated": "evaluated",
	"dob": "birthDate",
	"dod": "deathDate",
	"ageOfDeath": "ageAtDeath",
	"ageOfDeathFormat": "ageAtDeathFormat",
	"lifeStatus": "lifeStatus",
	"disorders": "disorders",
	"disordersFullDetails": "disordersFullDetails", //Added for GEL(GenomicsEngland)
	"ethnicities": "ethnicities",
	"carrierStatus": "carrierStatus",
	"externalID": "externalId",
	"gender": "sex",
	"numPersons": "numPersons",
	"hpoTerms": "hpoTerms",
	"hpoTermsFullDetails": "hpoTermsFullDetails", //Added for GEL(GenomicsEngland)
	"candidateGenes": "candidateGenes",
	"lostContact": "lostContact",
	"nodeNumber": "nodeNumber",
	"cancers": "cancers",
	"childlessStatus": "childlessStatus",
	"childlessReason": "childlessReason",
  "clinicalIndicationName": "clinicalIndicationName",
  "numberOfColorectalPolypsAdenomas":"numberOfColorectalPolypsAdenomas",
  "numberOfColorectalPolypsTotal":"numberOfColorectalPolypsTotal",
  "nonNgisPatientStableUid":"nonNgisPatientStableUid",
	"ngisRegisteredPatientUid":"ngisRegisteredPatientSimpleId", // Remapping to simple ID at the request of GEL
	"ngisRegisteredPatientSimpleId":"ngisRegisteredPatientUid", // This is hidden (pedigree.js)
  "clinicalIndicationAgeOfOnset":"clinicalIndicationAgeOfOnset",
    "clinicalIndicationAgeOfOnsetYears":"clinicalIndicationAgeOfOnsetYears",
    "clinicalIndicationAgeOfOnsetMonths":"clinicalIndicationAgeOfOnsetMonths"

};

PedigreeExport.internalToJSONRelationshipPropertyMapping = {
	"childlessStatus": "childlessStatus",
	"childlessReason": "childlessReason",
	"consangr": "consanguinity",
	"broken": "separated"
};

/*
 * Converts property name from internal format to external JSON format - also helps to
 * support aliases for some terms and weed out unsupported terms.
 */
PedigreeExport.convertProperty = function (internalPropertyName, value) {

	if (!PedigreeExport.internalToJSONPropertyMapping.hasOwnProperty(internalPropertyName)) {
		return null;
	}

	var externalPropertyName = PedigreeExport.internalToJSONPropertyMapping[internalPropertyName];

	if (externalPropertyName == "sex") {
		if (value == "M" || value == "m" || value == "1") {
			value = "Male";
		} else if (value == "F" || value == "f" || value == "2") {
			value = "Female";
		} else if (value == "O" || value == "9") {
			value = "Indeterminate";
		} else {
			value = "Unknown";
		}
	}

	return {"propertyName": externalPropertyName, "value": value };
}

/*
 * Converts property name from internal format to external JSON format.
 */
PedigreeExport.convertRelationshipProperty = function (internalPropertyName, value) {

	if (!PedigreeExport.internalToJSONRelationshipPropertyMapping.hasOwnProperty(internalPropertyName)) {
		return null;
	}

	var externalPropertyName = PedigreeExport.internalToJSONRelationshipPropertyMapping[internalPropertyName];

	if (externalPropertyName == "consanguinity") {
		if (value != "Y" && value != "N" && value != "P" && value != "U") {
			return null;
		}
	}
	return {"propertyName": externalPropertyName, "value": value };
}

/**
 * idGenerationPreference: {"newid"|"external"|"name"}, default: "newid"
 */
PedigreeExport.createNewIDs = function (pedigree, idGenerationPreference, maxLength, forbidNonAlphaNum) {
	if (!idGenerationPreference) {
		idGenerationPreference = "newid";
	}

	var idToNewId = {};
	var usedIDs = {};

	var nextUnusedID = 1;

	for (var i = 0; i <= pedigree.GG.getMaxRealVertexId(); i++) {
		if (!pedigree.GG.isPerson(i)) continue;
		if (pedigree.GG.isPlaceholder(i)) continue;

		var id = nextUnusedID++;
		if (idGenerationPreference == "external" && pedigree.GG.properties[i].hasOwnProperty("externalID")) {
			nextUnusedID--;
			id = pedigree.GG.properties[i]["externalID"].replace(/\s/g, '_');
		} else if (idGenerationPreference == "name" && pedigree.GG.properties[i].hasOwnProperty("fName")) {
			nextUnusedID--;
			id = pedigree.GG.properties[i]["fName"].replace(/\s/g, '_');
		}
		id = String(id);
		if (forbidNonAlphaNum) {
			id = id.replace(/[^A-Za-z0-9]/g, '');  // can't use \W since that allows "_"
		}
		if (maxLength && id.length > maxLength) {
			id = id.substring(0, maxLength);
		}
		var baseID = id;
		var numSimilar = 2;
		while (usedIDs.hasOwnProperty(id)) {
			if (maxLength) {
				var length = baseID.length + String(numSimilar).length;
				var cutSize = length - maxLength;
				id = baseID.substring(0, id.length - cutSize);
			} else {
				id = baseID;
			}
			id = id + String(numSimilar);
			numSimilar++;
		}

		idToNewId[i] = id;
		usedIDs[id] = true;
	}

	return idToNewId;
}

// TODO: test performance improvement: this.pairScoreFunc() is called for all possible combinations of (i,j,level_i,level_j)
//                                     during computeCrosses(). Store the values and avoid calling the function again?
//                                     (may not make any difference since function computation is trivial)
VerticalPosIntOptimizer = function (pairScoreFunc, initLevels, minLevels) {
	this.pairScoreFunc = pairScoreFunc;      // function(u, v, uLev, vLev) - returns penalty for interaction between two edges u and v when u's level is uLev and v's level is vLev
	//                              (assumed to be symetrical, i.e. f(a,b,levA,levB) = f(b,a,levB,levA)

	this.initLevels = initLevels;            // array[int]

	this.maxOfMinlevels = 1;
	if (minLevels) {
		this.maxOfMinlevels = Math.max.apply(null, minLevels);
		if (this.maxOfMinlevels > 1)
			this.minLevels = minLevels;
	}

	var precompute = this.computeComponents();
	//console.log("Precomputed: " + Helpers.stringifyObject(precompute));
	this.components = precompute.components;  // class             - mapping between edges and connected components; see Components class
	this.crosses = precompute.crosses;     // array[array[int]] - for each edge the list of edges it directly intersects with (for performance optimization)
};

VerticalPosIntOptimizer.prototype = {

	// computes penalty ofr the number of levels used.
	// value: (0 <= numberOfLevelsPenalty < 1) => this affects the total penalty less than a single extra crossing,
	// i.e. we want to use as few levels as possible, but it is beter to use an extra level than to have more crossings
	numberOfLevelsPenalty: function (maxLevelUsed, minRequired, numEdges) {
		return ( maxLevelUsed - minRequired ) / (numEdges + 1);       // 1 level => (penalty == 0), above 1 level => (0 < penalty < 1)
	},

	componentScoreFunc: function (levels, componentID) {
		//console.log("scoring: " + Helpers.stringifyObject(levels));

		var penalty = 0;
		var maxLevelUsed = 0;
		var minRequired = 1;

		var component = this.components.getComponentEdges(componentID);

		for (var i = 0; i < component.length; i++) {
			var edge = component[i];
			if (levels[edge] > maxLevelUsed)
				maxLevelUsed = levels[edge];
			if (this.minLevels && this.minLevels[edge] > minRequired)
				minRequired = this.minLevels[edge];
			var crosses = this.crosses[edge];
			for (var j = 0; j < crosses.length; j++) {
				var intersects = crosses[j];
				if (intersects > edge) {                  // because we want to only count each intersection only once, and score func is symmetrical
					//console.log("[p] " + edge + " + " + intersects + " = " + this.pairScoreFunc( edge, intersects, levels[edge], levels[intersects] ));
					penalty += this.pairScoreFunc(edge, intersects, levels[edge], levels[intersects], levels);
					if (!isFinite(penalty))
						return penalty;
				}
			}
		}

		// add penalty for the number of levels used: less levels is better given the same "crossing" score
		// (note: only care about max level used, as that affects the layout, we don't care if there are unused levels inbetween)
		var numLevelsPen = this.numberOfLevelsPenalty(maxLevelUsed, minRequired, component.length);
		penalty += numLevelsPen;
		//console.log("num levels penalty: " + numLevelsPen);

		//console.log("Score: " + penalty + " (numLevels: " + numLevelsPen + ")");
		return penalty;
	},

	computeComponents: function () {
		// find all connected components, for now - using plain (and likely non-optimal) O(n^2) algo
		// (as a side effect can compute minimum posible penalty score)

		var components = new Complonents();   // mapping between edges and connected components; see Components class

		var crosses = [];                     // for each edge the list of edges it directly intersects with

		var hasToBeAboveForPerfectScore = []; // used for heurisic computation of minimum number of levels required

		var numEdges = this.initLevels.length;
		for (var i = 0; i < numEdges; i++) {
			crosses[i] = [];
			hasToBeAboveForPerfectScore[i] = [];
		}

		for (var i = 0; i < numEdges - 1; i++) {
			for (var j = i + 1; j < numEdges; j++) {
				if (this.pairScoreFunc(i, j, 1, 1) == Infinity) {  // only happens when edges intersect and can't be at the same level
					crosses[i].push(j);
					crosses[j].push(i);

					var componentI = components.getEdgeComponent(i);
					var componentJ = components.getEdgeComponent(j);

					if (componentI === undefined && componentJ === undefined) {
						// both i and j are not in any component yet
						components.addToNewComponent(i);
						components.addToExistingComponent(j, components.getEdgeComponent(i));
					}
					else if (componentI !== undefined) {
						if (componentJ !== undefined) {
							// both i and j are assigned to a component
							if (componentI != componentJ) {
								// ...to different components: merge (ow we are ok)
								components.mergeComponents(componentI, componentJ);
							}
						} else {
							// i has a component, j does not
							components.addToExistingComponent(j, componentI);
						}
					} else {
						// j has a component, i does not
						components.addToExistingComponent(i, componentJ);
					}

					// if edges cross => the best arrangement of these two edges is either one above the other or v.v.
					// in any case there may be some penalty associated for that, but can't do beter than the best
					// of these two options. Compute it so that later once (if) minimum possible penalty is achieved
					// the algorithm stop without wasting more time
					var scoreAbove = this.pairScoreFunc(i, j, 1, 2);
					var scoreBelow = this.pairScoreFunc(i, j, 2, 1);

					var compID = components.getEdgeComponent(i);
					components.addRequiredPenaltyToComponent(compID, Math.min(scoreAbove, scoreBelow));

					if (scoreAbove < scoreBelow) {
						hasToBeAboveForPerfectScore[i].push(j);
					}
					if (scoreAbove > scoreBelow) {
						hasToBeAboveForPerfectScore[j].push(i);
					}
				}
			}
		}

		// it is good to know best possible score so that algorithm may stops earlier if this score is
		// achieved; it is hard to compute precisely though, as that is equivalent to solving the problem.
		//
		// One posible heuristic is the size of the largest clique, but that is hard to compute (clique problem
		// is hard), and even if at most 2 edges overlap at the same time, may need many levels as they stack
		// below each other (e.g. in a stairs-like structure)
		//
		// So the following dumb heuristic is used to determine num levels needed for each component:
		//  - for each edge min level is max( minLevel given in the input, max(min levels of all edges it should be above) )

		for (var compID = 0; compID < components.getNumComponents(); compID++) {

			// if min penalty is above 0 it means at least one crossing => at least 2 levels are required
			var minNumLevels = 1;
			var minRequired = 1;
			var minMinLevel = Infinity;

			var component = components.getComponentEdges(compID);
			for (var i = 0; i < component.length; i++) {
				var edge = component[i];

				if (this.minLevels) {
					if (this.minLevels[edge] > minRequired)
						minRequired = this.minLevels[edge];
					if (this.minLevels[edge] < minMinLevel)
						minMinLevel = this.minLevels[edge];
				}

				var minForThisEdge = this.minLevels ? this.minLevels[edge] : 1;

				for (var j = 0; j < hasToBeAboveForPerfectScore[edge].length; j++) {
					var needToBeAboveEdge = hasToBeAboveForPerfectScore[edge][j];
					var minForOtherEdge = this.minLevels ? this.minLevels[edge] : 1;
					// if the other edge also has to be above something and has min level
					if (hasToBeAboveForPerfectScore[needToBeAboveEdge].length > 0 && minForOtherEdge == 1)
						minForOtherEdge++;
					minForThisEdge = Math.max(minForThisEdge, minForOtherEdge + 1);
				}

				minNumLevels = Math.max(minNumLevels, minForThisEdge);
			}

			var needExtraLevelsAboveMin = (components.getMinPossiblePenalty(compID) == 0) ? 0 : 1;
			if (!isFinite(minMinLevel)) minMinLevel = 1;
			minNumLevels = Math.max(minNumLevels, minMinLevel + needExtraLevelsAboveMin);

			// this penalty is guaranteed to be less than 1 => this affects the penalty less than a single extra crossing
			var penaltyForNumLevelsUsed = this.numberOfLevelsPenalty(minNumLevels, minRequired, component.length);
			components.addRequiredPenaltyToComponent(compID, penaltyForNumLevelsUsed);
		}

		//console.log("Components: " + Helpers.stringifyObject(components));
		return {"crosses": crosses, "components": components };
	},

	computeVerticalPositions: function (maxFullSearchSize, maxSteps, seed) {
		// maxFullSearchSize - max number of edges in a cluster which can be searched fully via brute force; max time = C1 * maxFullSearchSize! per cluster
		// maxSteps          - max number of steps for a heuristic; max time = C2 * maxSteps per cluster
		//                     (where C2 > C1, and both include computing the penalty for a given arrangmenet, which is ~O(clusterSize^2)

		this.seed = seed ? seed : 1;

		var bestSoFar = this.initLevels;

		// fix component-by-component
		for (var compID = 0; compID < this.components.getNumComponents(); compID++) {

			//console.log("Optimizing next component [ID="+compID+"] with edges: " + Helpers.stringifyObject(this.components.getComponentEdges(compID)));

			//console.log("CompID[" + compID + "]: MinPossiblePenalty: " + this.components.getMinPossiblePenalty(compID));
			//console.log("CompID[" + compID + "]: Initial Penalty:    " + this.componentScoreFunc(bestSoFar, compID));
			//console.log("CompID[" + compID + "]: Initial assignment: " + Helpers.stringifyObject(bestSoFar));

			// problem size for exhaustiveSearch ~= numEdges!, can't afford to try all combinations for large problems
			if (this.components.getComponentEdges(compID).length <= maxFullSearchSize)
				bestSoFar = this.exhaustiveSearch(compID, bestSoFar);
			else
				bestSoFar = this.simulatedAnnellingOptimizer(compID, bestSoFar, maxSteps);

			//console.log("CompID[" + compID + "]: Final assignment: " + Helpers.stringifyObject(bestSoFar));
			//console.log("CompID[" + compID + "]: Final Penalty:    " + this.componentScoreFunc(bestSoFar, compID));
		}

		//console.log("Final assignment: " + Helpers.stringifyObject(bestSoFar));

		return bestSoFar;
	},

	//----------------------------------------------------------------------------------
	exhaustiveSearch: function (componentID, bestSoFar) {

		var initScore = this.componentScoreFunc(bestSoFar, componentID)

		//this.checkedNumber = 0; // TODO: debug
		//console.log("minPossiblePenalty: " + this.components.getMinPossiblePenalty(componentID));

		var result = this.recursiveExhaustiveSearch(componentID, bestSoFar.slice(0), 0, {"values": bestSoFar, "score": initScore});

		//console.log("[fsearch] CompID[" + componentID + "]: Tried " +  this.checkedNumber + " combinations"); // TODO: debug

		return result.values;
	},

	recursiveExhaustiveSearch: function (componentID, valuesSoFar, level, bestSoFar) {

		var component = this.components.getComponentEdges(componentID);

		// reached the end of the recursion
		if (level == component.length) {
			var score = this.componentScoreFunc(valuesSoFar, componentID);
			//console.log("SCORING: " + Helpers.stringifyObject(valuesSoFar) + " -> Score: " + score );
			if (score < bestSoFar.score) {
				bestSoFar.values = valuesSoFar.slice(0);
				bestSoFar.score = score;
				//console.log("[fsearch] New best: " + Helpers.stringifyObject(bestSoFar.values) + " (score: " + bestSoFar.score + ")");
			}
			//console.log("best value at enter [" + level + "]: " + Helpers.stringifyObject(valuesSoFar));
			//this.checkedNumber++; // TODO: debug
			return bestSoFar;
		}

		var edge = component[level];

		// TODO: since we don't want any gaps in levels, a smarter search can be used which fills the gaps
		//       once it is known that if they are not filled now the arrangmenet will be incorrect

		// TODO: exclude assignments where two intersecting edges have the same level. Only consider edges
		//       with lover IDs since those are already assigned a value. Edges with higher ids haveno assignment yet

		var minValue = 1;
		var maxValue = component.length;

		if (this.minLevels) {
			minValue = this.minLevels[edge];
			maxValue += (minValue - 1);
		}

		for (var i = minValue; i <= maxValue; i++) {
			valuesSoFar[edge] = i;

			bestSoFar = this.recursiveExhaustiveSearch(componentID, valuesSoFar, level + 1, bestSoFar);

			if (bestSoFar.score == this.components.getMinPossiblePenalty(componentID)) break;
		}
		//console.log("best value at exit [" + level + "]: " + Helpers.stringifyObject(bestSoFar.values) + " (score: " + bestSoFar.score + ")");

		return bestSoFar;
	},
	//----------------------------------------------------------------------------------


	//--[ simulatedAnnelling() related ]------------------------------------------------
	makeBasicValidAssignment: function (initLevels, componentID) {
		var component = this.components.getComponentEdges(componentID);
		var value = 1;

		// give each edge that crosses a separate level - may not be optimal, but guaranteed to be "valid" with a penalty below Infinity
		var newAssignemnt = initLevels.slice(0);
		for (var i = 0; i < component.length; i++) {
			var edge = component[i];
			if (this.minLevels && value < this.minLevels[edge])
				value = this.minLevels[edge];
			newAssignemnt[edge] = value;
			value++; // for next age to be different form this one
		}

		//console.log("[asearch] CompID[" + componentID + "]: Initial assignment:   " + Helpers.stringifyObject(initLevels)    + ", score: " + this.componentScoreFunc(initLevels, componentID));
		//console.log("[asearch] CompID[" + componentID + "]: InitValid assignment: " + Helpers.stringifyObject(newAssignemnt) + ", score: " + this.componentScoreFunc(newAssignemnt, componentID));
		return newAssignemnt;
	},

	computeNeighbour: function (currentState, componentID, step) {
		// general idea: assign some other "level" to one of the edges (where "some" and "one of" can be picked randomly/depending on the `step`).
		//               If that level is forbidden due to a crossing with some other edges assign the first OK level in the direction of change
		//               + normalize after the change (e.g. remove unused levels + shift to make smallest used levle to be level #1)

		// 1. pick random edge
		// 2. pick new random level for the edge (different form the old value)
		// 3. while (value is forbidden or unchanged) increment value (if new>old) or decrement value (if new<old)

		//console.log("computeNeighbour - current: " + Helpers.stringifyObject(currentState));

		var component = this.components.getComponentEdges(componentID);

		var newState = currentState.slice(0);

		do {
			// pick a random edge in the component
			var edge = component[ Math.floor(this.random() * component.length) ];
			var oldLevel = newState[edge];
			var maxUsedLevel = oldLevel;

			// check random value and if it makes sense to increment or decrement it
			var isBelowAll = true;
			var isAboveAll = true;
			var forbidden = {};
			for (var i = 0; i < this.crosses[edge].length; i++) {
				var crossesWith = this.crosses[edge][i];
				var crossLevel = newState[crossesWith];
				if (crossLevel > maxUsedLevel)
					maxUsedLevel = crossLevel;
				forbidden[crossLevel] = true;
				if (crossLevel >= oldLevel)
					isAboveAll = false;
				if (crossLevel <= oldLevel)
					isBelowAll = false;
			}
			if (this.minLevels && oldLevel == this.minLevels[edge]) {
				isBelowAll = true;       // if level == minLevel for the edge does not make sense to decrese the level
			}
		}
		while (isAboveAll && isBelowAll);  // if both above all and below all no sense to play with the edge; need to pick another edge

		// pick new random level for the edge (different form the old value)
		var newLevel;
		do {
			// note: new level will be in the range = [0...maxUsedLevel+1]
			// note: 0 is not a valid "level" but lets the edge to be
			// positioned below any other (and later normalized to have proper minLevel)
			newLevel = Math.floor(this.random() * (maxUsedLevel + 2));
		}
		while (newLevel == oldLevel || (isBelowAll && newLevel < oldLevel) || (isAboveAll && newLevel > oldLevel));

		if (forbidden.hasOwnProperty(newLevel)) {
			for (var i = 0; i < component.length; i++) {
				var e = component[i];
				if (newState[e] <= newLevel) {
					newState[e]++;
				}
			}
		}
		newState[edge] = newLevel;
		//console.log("Edge: " + edge + ", oldLevel: " + oldLevel + ", newLevel: " + newLevel);

		this.normalize(newState, component);
		//console.log("computeNeighbour: " + Helpers.stringifyObject(newState) + ", score: " + this.componentScoreFunc( newState, componentID ));

		return newState;
	},

	normalize: function (levels, component) {
		//console.log("pre-normalized levels: " + Helpers.stringifyObject(levels));

		// 1. if there are gaps (e.g. 1,2,4,5) decrement all levels above each gap to fill the gap
		var usedLevels = Helpers.filterUnique(levels).sort();
		for (var i = usedLevels.length - 1; i > 0; i--) {
			if (usedLevels[i] != usedLevels[i - 1] + 1) {      // there may be only one gap so no need to implement a more robust algorithm
				for (var j = 0; j < component.length; j++) {
					var e = component[j];
					if (levels[e] >= usedLevels[i])
						levels[e]--;
				}
				//console.log("found gap [" + usedLevels[i-1] + " - " + usedLevels[i] + "]");
				break;
			}
		}
		//console.log("post fill gap levels: " + Helpers.stringifyObject(levels));

		// 2. make sure all edges satisfy their min levels (including fixing 0 level)
		for (var i = 0; i < component.length; i++) {
			var edge = component[i];

			var curLevel = levels[edge];
			var minLevel = this.minLevels ? this.minLevels[edge] : 1;

			if (curLevel < minLevel) {
				var adjust = minLevel - curLevel;
				for (var j = 0; j < component.length; j++) {
					levels[component[j]] += adjust;
				}
			}
		}

		// 3. try to minimize the highest used level
		do {
			var changed = false;
			for (var i = 0; i < component.length; i++) {
				var edge = component[i];
				var curLevel = levels[edge];
				var minLevel = this.minLevels ? this.minLevels[edge] : 1;
				if (curLevel > minLevel) {
					var highestBelow = 0;
					for (var j = 0; j < this.crosses[edge].length; j++) {
						var level = levels[this.crosses[edge][j]];
						if (level < curLevel && level > highestBelow)
							highestBelow = levels[this.crosses[edge][j]];
					}
					if (highestBelow < curLevel - 1) {
						levels[edge] = highestBelow + 1;
					}
				}
			}
		} while (changed);

		//console.log("post normalization: " + Helpers.stringifyObject(levels));
	},

	localOptimization: function (levels, currentScore, componentID, untilFirstImprovement) {
		/*
		 * TODO: after improvements made to the main algorithm this heuristic may not be necessary,
		 *       but leaving it here for now as a placeholder
		 *
		 // tries to find a better position for just one edge using complete search
		 // (e.g. local not global optimization)

		 var component = this.components.getComponentEdges(componentID);
		 for (var e = 0; e < component.length; e++) {
		 var edge     = component[e];
		 var curLevel = levels[edge];
		 var minLevel = this.minLevels ? this.minLevels[edge] : 1;

		 var forbidden  = {};
		 for (var i = 0; i < this.crosses[edge].length; i++) {
		 var crossesWith = this.crosses[edge][i];
		 var crossLevel  = levels[crossesWith];
		 forbidden[crossLevel] = true;
		 }
		 // TODO
		 }
		 */
		return currentScore;
	},

	random: function () {
		// very crude but ok for the purpose of this algorithm in the context of vertical edge allocation
		// http://jsfiddle.net/bhrLT/3/
		var x = Math.sin(this.seed++) * 16;
		return x - Math.floor(x);
	},

	doSwitchDuringAnneling: function (oldScore, newScore, stepsSinceReset) {
		if (newScore <= oldScore) return true;

		var probability = Math.exp(-(newScore - oldScore) * Math.log((stepsSinceReset + 1) * 5));

		if (probability > this.random()) {
			//console.log("[debug] switch to worse score");
			return true;
		}
		return false;
	},

	simulatedAnnellingOptimizer: function (componentID, bestSoFar, maxSteps) {

		//console.log("[asearch] Starting simulatedAnnellingOptimizer");

		var bestScore = this.componentScoreFunc(bestSoFar, componentID);

		var bestState = isFinite(bestScore) ? bestSoFar : this.makeBasicValidAssignment(bestSoFar, componentID);
		var bestScore = isFinite(bestScore) ? bestScore : this.componentScoreFunc(bestState, componentID);
		var bestStep = maxSteps;

		var currentState = bestState;
		var currentScore = bestScore;

		//console.log("Component: " + Helpers.stringifyObject(this.components.getComponentEdges(componentID)) +
		//            ", init score: " + bestScore + ", best possible score: " + this.components.getMinPossiblePenalty(componentID));

		// alogrithm (as in wiki):
		//-------------------------------------------
		// s ← s0; e ← E(s)                                  // Initial state, energy.
		// sbest ← s; ebest ← e                              // Initial "best" solution
		// k ← 0                                              // Energy evaluation count.
		// while k < kmax and e > emax                        // While time left & not good enough:
		//   T ← temperature(k/kmax)                          // Temperature calculation.
		//   snew ← neighbour(s)                              // Pick some neighbour.
		//   enew ← E(snew)                                   // Compute its energy.
		//   if P(e, enew, T) > random() then                 // Should we move to it?
		//     s ← snew; e ← enew                            // Yes, change state.
		//   if enew < ebest then                             // Is this a new best?
		//     sbest ← snew; ebest ← enew                    // Save 'new neighbour' to 'best found'.
		//   k ← k + 1                                       // One more evaluation done
		// return sbest                                      // Return the best solution found.

		var maxWrongDirection = maxSteps / 6;

		var step = maxSteps;
		while (bestScore > this.components.getMinPossiblePenalty(componentID) && step >= 0) {

			// reset once in the middle of the search (TODO: investigate if we need more resets or don't need resets at all)
			if (step < bestStep - maxWrongDirection) {
				currentState = bestState.slice(0);
				currentScore = this.localOptimization(currentState, bestScore, componentID, true);  // restart from a slightly optimized last best point
				bestStep = step;
				console.log("[asearch] reset to: " + Helpers.stringifyObject(currentState) + ", score: " + currentScore + " (@ step = " + (maxSteps - step + 1) + ")");
			}

			var neighbourState = this.computeNeighbour(currentState, componentID, step);
			var neighbourScore = this.componentScoreFunc(neighbourState, componentID);

			if (this.doSwitchDuringAnneling(currentScore, neighbourScore, bestStep - step)) {
				currentState = neighbourState;
				currentScore = neighbourScore;
			}

			if (currentScore < bestScore) {
				console.log("[asearch] New best: " + Helpers.stringifyObject(currentState) + ", score: " + currentScore + " (@ step = " + (maxSteps - step + 1) + ")");
				bestState = currentState.slice(0);
				bestScore = currentScore;
				bestStep = step;
			}

			step--;
		}

		//bestState = [1, 2, 3, 5, 6, 7, 4, 6, 7, 4];
		//bestScore = this.componentScoreFunc( bestState, componentID );
		bestScore = this.localOptimization(bestState, bestScore, componentID);
		console.log("[asearch] Final optimized best: " + Helpers.stringifyObject(bestState) + ", score: " + bestScore);

		return bestState;
	}
	//-------------------------------------------------[ simulatedAnnelling() related ]--
};


Complonents = function () {
	this.components = []; // arrat[arrat[int]] - for each component -> a list of edges
	this.minPossiblePenalty = []; // array[double]     - for each component min possible penalty per component

	// Note: data in edgeComponents can be derived from data in components (and v.v.),
	//       but both are stored for performance reasons
	this.edgeComponents = [];  // array[int] - for each edge -> component ID
};

Complonents.prototype = {
	getNumComponents: function () {
		return this.components.length;
	},

	getComponentEdges: function (componentID) {
		return this.components[componentID];
	},

	// returns component ID of the edge
	getEdgeComponent: function (edge) {
		return this.edgeComponents[edge];
	},

	addToNewComponent: function (edge) {
		this.edgeComponents[edge] = this.components.length;
		this.components.push([edge]);   // new component has just one edge
		this.minPossiblePenalty.push(0);        // new component has 0 min penalty
	},

	addToExistingComponent: function (edge, componentID) {
		this.components[componentID].push(edge);
		this.edgeComponents[edge] = componentID;
	},

	// NOTE: may reassign some unrelated component IDs
	mergeComponents: function (component1, component2) {
		if (component1 == component2)
			return;
		var minID = Math.min(component1, component2);
		var maxID = Math.max(component1, component2);

		// move all edges in maxID to minID
		for (var i = 0; i < this.components[maxID].length; i++) {
			var edge = this.components[maxID][i];
			this.addToExistingComponent(edge, minID);
		}

		// add penalties
		this.minPossiblePenalty[minID] += this.minPossiblePenalty[maxID];

		// remove component maxID
		this.components.splice(maxID, 1);
		this.minPossiblePenalty.splice(maxID, 1);
	},

	addRequiredPenaltyToComponent: function (componentID, penalty) {
		this.minPossiblePenalty[componentID] += penalty;
	},

	// for performance reasons we want to stop as soon as we hit the best possible assignment;
	// while it is hard to compute the actual optimal score, we can estimate it from below,
	// such that if this low estimate is achieved we are guaranteed we have the best assignment
	getMinPossiblePenalty: function (componentID) {
		return this.minPossiblePenalty[componentID];
	}
};

/**
 * Returns the age of a person with the given birth and death dates
 * @param {Date} birthDate
 * @param {Date} [deathDate]
 * @return {String} Age formatted with years, months, days
 */
function getAge(birthDate, deathDate, onlyYears) {
	if (birthDate.onlyDecadeAvailable() || (deathDate && deathDate.onlyDecadeAvailable())) {
		if (onlyYears) {
			var lastYearAlive = new Date().getFullYear();
			if (deathDate != null) {
				lastYearAlive = deathDate.getYear(true);
				if (deathDate.onlyDecadeAvailable()) {
					lastYearAlive += 10;
				}
			}
			var oldestYear = birthDate.onlyDecadeAvailable() ? parseInt(birthDate.getDecade()) : birthDate.getYear();
			var age = lastYearAlive - oldestYear;
			var decadeOld = Math.ceil(age / 10) * 10;
			return "before_" + decadeOld;
		}
		return "";
	}

	var now;
	if (deathDate == null) {
		now = new Date();
	}
	else {
		now = deathDate.toJSDate();
	}

	birthDate = birthDate.toJSDate();

	var aSecond = 1000;
	var aMinute = aSecond * 60;
	var aHour = aMinute * 60;
	var aDay = aHour * 24;
	var aWeek = aDay * 7;
	var aMonth = aDay * 30.5;

	var age = now.getTime() - birthDate.getTime();

	if (age <= 0) {
		if (deathDate == null) {
			if (age < 0) {
				return "not born yet"
			}
		} else {
			return "";
		}
	}

	var years = now.getFullYear() - birthDate.getFullYear() - (now.getDayOfYear() < birthDate.getDayOfYear() ? 1 : 0);

	if (onlyYears) {
		return years;
	}

	var agestr = "";

	// TODO: can do a bit better with up-to-a-day precision
	//       (e.g. born Apr 10, now May 9 => 0 month, May 10 => 1 month) - but don't need it here
	var months = Math.floor(age / aMonth);

	if (months < 12) {
		var days = Math.floor(age / aDay);

		if (days < 21) {
			if (days == 1) {
				agestr = days + ' day';
			}
			else {
				agestr = days + ' days';
			}
		}
		else if (days < 60) {
			var weeks = Math.floor(age / aWeek);
			agestr = weeks + " wk";
		} else {
			agestr = months + ' mo';
		}
	} else {
		agestr = years + " y";
	}
	return agestr;
}
var AgeCalc = {};
AgeCalc.getAge = getAge;

// PositionedGraph represents the pedigree tree projected to a 2D surface,
//                 i.e. both the underlying graph and node & edge X and Y coordinates
PositionedGraph = function (baseG,                          // mandatory, BaseGraph
							horizontalPersonSeparationDist, // mandatory, int
							horizontalRelSeparationDist,    // mandatory, int
							maxInitOrderingBuckets,         // optional,  int
							maxOrderingIterations,          // optional,  int
							maxXcoordIterations,            // optional,  int
							performVerticalPositioning,     // optional,  bool  (DynamicGraph does its own vertical positioning, so can save some time)
							suggestedRanks)                // optional,  array[int] - ranks suggested for all nodes
{
	this.GG = undefined;         // graph without any positioning info (of type BaseGraph);
	// same as baseG, but with multi-rank edges replaced by virtual vertices/edges

	this.ranks = undefined;  // 1D array: index = vertex id, value = rank
	this.maxRank = undefined;  // integer:  max rank in the above array (maintained for performance reasons)

	this.order = undefined;  // class: Ordering

	this.positions = undefined;  // 1D array: index = vertex id, value = x-coordinate

	this.vertLevel = undefined;  // class: VerticalLevels
	this.rankY = undefined;  // 1D aray: index = rank, value = y-coordinate

	this.ancestors = undefined;  // {}: for each node contains a set of all its ancestors and the closest relationship distance
	this.consangr = undefined;  // {}: for each node a set of consanguineous relationship IDs

	this.initialize(baseG,
		horizontalPersonSeparationDist, horizontalRelSeparationDist,
		maxInitOrderingBuckets, maxOrderingIterations, maxXcoordIterations,
		performVerticalPositioning, suggestedRanks);
};

PositionedGraph.prototype = {

	maxInitOrderingBuckets: 5,           // it may take up to ~factorial_of_this_number iterations to generate initial ordering
	maxOrderingIterations: 24,          // up to so many iterations are spent optimizing initial ordering
	maxXcoordIterations: 4,
	xCoordEdgeWeightValue: true,        // when optimizing edge length/curvature take
	// edge weight into account or not
	horizontalPersonSeparationDist: 10,
	horizontalTwinSeparationDist: 8,
	horizontalRelSeparationDist: 6,
	yDistanceNodeToChildhub: 20,
	yDistanceChildhubToNode: 14,
	yExtraPerHorizontalLine: 4,
	yAttachPortHeight: 1.5,
	yCommentLineHeight: 2.9,

	initialize: function (baseG, horizontalPersonSeparationDist, horizontalRelSeparationDist, maxInitOrderingBuckets, maxOrderingIterations, maxXcoordIterations, performVerticalPositioning, suggestedRanks) {
		if (horizontalPersonSeparationDist) this.horizontalPersonSeparationDist = horizontalPersonSeparationDist;
		if (horizontalRelSeparationDist)    this.horizontalRelSeparationDist = horizontalRelSeparationDist;
		if (maxInitOrderingBuckets)         this.maxInitOrderingBuckets = maxInitOrderingBuckets;
		if (maxOrderingIterations)          this.maxOrderingIterations = maxOrderingIterations;
		if (maxXcoordIterations)            this.maxXcoordIterations = maxXcoordIterations;

		if (this.maxInitOrderingBuckets > 8)
			throw "Too many ordering buckets: number of permutations (" + this.maxInitOrderingBuckets.toString() + "!) is too big";

		var timer = new Helpers.Timer();

		// 1)
		this.ranks = this.rank(baseG, suggestedRanks);

		this.maxRank = Math.max.apply(null, this.ranks);

		timer.printSinceLast("=== Ranking runtime: ");

		// 1.1)
		// ordering algorithms needs all edges to connect nodes on neighbouring ranks only;
		// to accomodate that multi-rank edges are split into a chain of edges between new
		// "virtual" nodes on intermediate ranks, and the resulting graph is use in all
		// further algorithms
		this.GG = baseG.makeGWithSplitMultiRankEdges(this.ranks);

		//Helpers.printObject( this.GG );

		// 1.2)
		// twins should always be next to each other. The easiest and fastest way to accomodate that is by
		// conbining all twins in each group into one node, connected to all the nodes all of the twins in
		// the group connect to. This reduces the size of the graph and keeps twins together
		var disconnectedTwins = this.disconnectTwins();

		// 2)
		timer.restart();

		this.order = this.ordering(this.maxInitOrderingBuckets, this.maxOrderingIterations, disconnectedTwins);

		timer.printSinceLast("=== Ordering runtime: ");

		// 2.1)
		// once ordering is known need to re-rank relationship nodes to be on the same level as the
		// lower ranked parent. Attempt to place next to one of the parents; having ordering info
		// helps to pick the parent in case parents are on the same level and not next to each other
		this.reRankRelationships();

		// once all ordering and ranking is done twins in each twin group need to be separated back into separate nodes
		this.reconnectTwins(disconnectedTwins);

		// 2.2)
		var ancestors = this.findAllAncestors();

		this.ancestors = ancestors.ancestors;
		this.consangr = ancestors.consangr;

		timer.printSinceLast("=== Ancestors + re-ranking runtime: ");

		// 3)
		this.positions = this.position();

		timer.printSinceLast("=== Positioning runtime: ");

		// 4)
		if (performVerticalPositioning) {
			this.vertLevel = this.positionVertically();
			this.rankY = this.computeRankY();
			timer.printSinceLast("=== Vertical spacing runtime: ");
		}
	},

	//=[rank]============================================================================
	rank: function (baseG, suggestedRanks) {
		// use the suggested ranks, if available.
		// Note: even if present, using suggested ranks may fail if inconsistencies are found
		//       e.g. if a user drew a new "child" edge from a node to a node with a higher or equal rank
		if (suggestedRanks) {
			var ranks = this.init_rank(baseG, suggestedRanks);
			if (ranks) {
				return ranks;   // if suggested ranks are valid. if not ranks would be null
			}
		}

		// initial ranking via a spanning tree. Minimum rank == 1.
		var ranks = this.init_rank(baseG);

		// re-rank all nodes as far down the tree as possible (e.g. people with no
		// parents in the tree should be on the same level as their first documented
		// relationship partner)
		this.lower_ranks(baseG, ranks);

		return ranks;
	},

	// init ranks by computing a spanning tree over the directed graph, starting from the nodes with no parents
	init_rank: function (baseG, suggestedRanks) {
		//   Algorithm: nodes are placed in the queue when they have no unscanned in-edges.
		//   As nodes are taken off the queue, they are assigned the least rank
		//   that satisfies their in-edges, and their out-edges are marked as scanned.
		//
		//   [precondition] graph must be acyclic.

		if (baseG.v.length == 0) return [];

		var initRank = 1;

		var ranks = [];       // index == vertexID, ranks[v] == rank assigned to v
		var numRankedParents = [];       // index == vertexID, numRanked[v] == number of nodes which have
		//                    edges to v which were already assigned a rank

		for (var i = 0; i < baseG.getNumVertices(); i++) {
			ranks.push(-1);
			numRankedParents.push(0);
		}

		var queue = new Queue();         // holds non-ranked nodes which have all their parents already ranked

		if (suggestedRanks) {
			for (var i = 0; i < suggestedRanks.length; i++) {
				var nodesAtRank = suggestedRanks[i];
				for (var j = 0; j < nodesAtRank.length; j++) {
					ranks[nodesAtRank[j]] = (i * 3) + 1;
				}
			}

			for (var v = 0; v < baseG.getNumVertices(); v++) {
				if (baseG.isPerson(v) && ranks[v] == -1) {
					// a person node is without a rank => suggestedRanksa re bad
					return null;
				}
				if (baseG.isRelationship(v)) {
					queue.push(v);
				}
			}
		} else {
			var parentlessNodes = baseG.getLeafAndParentlessNodes().parentlessNodes;
			queue.setTo(parentlessNodes);
		}

		while (queue.size() > 0) {
			var nextNode = queue.pop();

			// ...assign the least rank satisfying nextParent's in-edges (which is max(parent_ranks) + 1)
			var inEdges = baseG.getInEdges(nextNode);
			var useRank = initRank;
			for (var i = 0; i < inEdges.length; i++) {
				var v = inEdges[i];
				if (ranks[v] >= useRank)
					useRank = ranks[v] + 1;
			}

			ranks[nextNode] = useRank;

			// add edge to spanning tree (if we need the tree):
			//  parent[nextNode] = useParent;
			//
			//  if (useParent !== undefined)
			//      spanTreeEdges[useParent].push(nextNode);

			// ...mark out-edges as scanned
			var outEdges = baseG.getOutEdges(nextNode);

			for (var u = 0; u < outEdges.length; u++) {
				var vertex = outEdges[u];

				if (suggestedRanks && ranks[vertex] != -1) {
					if (ranks[vertex] <= ranks[nextNode]) {
						// suggested ranks are inconsistent
						return null;
					}
				}

				numRankedParents[vertex]++;

				var numVertexInEdges = baseG.getInEdges(vertex).length;

				if (numRankedParents[vertex] == numVertexInEdges) {
					queue.push(vertex);    // all potential parents are ranked, now we can rank the vertex itself
				}
			}
		}

		return ranks;
	},

	lower_ranks: function (baseG, ranks) {
		if (ranks.length <= 1) return; // no nodes or only 1 node

		// re-ranks all nodes as far down the tree as possible (e.g. people with no
		// parents in the tree should be on the same level as their first documented
		// relationship partner, or as low as possible given their children relationships)

		// Algorithm:
		// 1. find disconnected components when multi-rank edges are removed (using "flood fill")
		// 2. for each component find the incoming or outgoing milti-rank edge of minimum length
		//    note1: sometimes a component may have both incoming and outgoing muti-rank edges;
		//           only one of those can be shortened and the choice is made based on edge weight
		//    note2: we can only keep track of outgoing edges as for each incoming edge there is an
		//           outgoing edge in another component, and we only shorten one edge per re-ranking iteration
		// 3. reduce all ranks by that edge's length minus 1
		// 4. once any two components are merged need to redo the entire process because the new
		//    resuting component may have other minimum in/out multi-rnak edges

		console.log("Re-ranking ranks before: " + Helpers.stringifyObject(ranks));

		while (true) {
			var nodeColor = [];   // for each node which component it belongs to
			var component = [];   // for each component list of vertices in the component
			var minOutEdgeInfo = [];   // for each component length & weight of the shortest outgoing multi-rank edge

			for (var v = 0; v < baseG.getNumVertices(); v++) {
				nodeColor.push(null);
			}

			var currentComponentColor = 0;
			for (var v = 0; v < baseG.getNumVertices(); v++) {

				if (nodeColor[v] == null) {
					// This node will be the first node of the next component, which
					// includes all nodes reachable using non-multi-rank edges (any direction).
					// All nodes in the component will be colored as "maxComponentColor"

					var thisComponent = [];

					var potentialLongEdges = {};

					var queue = new Queue();
					queue.push(v);

					while (queue.size() > 0) {
						var nextV = queue.pop();

						//console.log("processing: " + nextV);
						if (nodeColor[nextV] != null) continue;

						nodeColor[nextV] = currentComponentColor;
						thisComponent.push(nextV);

						var rankV = ranks[nextV];

						var allEdges = baseG.getAllEdgesWithWeights(nextV);
						for (var vv in allEdges) {
							if (allEdges.hasOwnProperty(vv) && nodeColor[vv] != currentComponentColor) {
								var edgeLength = Math.abs(rankV - ranks[vv]);
								if (edgeLength == 1) {          // using only edges between neighbouring ranks
									if (nodeColor[vv] == null)
										queue.push(vv);         // add nodes not in any component to this one
								} else {
									// save all long edges into a separate list, and check it once component is fully computed
									if (allEdges[vv].out) {
										potentialLongEdges[vv] = {"length": edgeLength, "weight": allEdges[vv].weight };
									}
								}
							}
						}
					}

					component[currentComponentColor] = thisComponent;
					minOutEdgeInfo[currentComponentColor] = { "length": Infinity, "weight": 0 };

					// go over all long edges originating from nodes in the component,
					// and find the shortest long edge which goes out of component
					for (var vv in potentialLongEdges) {
						if (potentialLongEdges.hasOwnProperty(vv)) {
							if (nodeColor[vv] == currentComponentColor) continue;  // ignore nodes which are now in the same component

							var nextEdge = potentialLongEdges[vv];

							if (nextEdge.length < minOutEdgeInfo[currentComponentColor].length ||
								(nextEdge.length == minOutEdgeInfo[currentComponentColor].length &&
									nextEdge.weight > minOutEdgeInfo[currentComponentColor].weight)) {
								minOutEdgeInfo[currentComponentColor] = nextEdge;
							}
						}
					}

					currentComponentColor++;
				}
			}


			//console.log("components: " + Helpers.stringifyObject(component));
			if (currentComponentColor == 1) return; // only one component - done re-ranking

			// for each component we should either increase the rank (to shorten out edges) or
			// decrease it (to shorten in-edges. If only in- (or only out-) edges are present there
			// is no choice, if there are both pick the direction where minimum length edge has higher
			// weight (TODO: alternatively can pick the one which reduces total edge len*weight more,
			// but the way pedigrees are entered by the user the two methods are probably equivalent in practice)

			// However we do not want negative ranks, and we can accomodate this by always increasing
			// the rank (as for each decrease there is an equivalent increase in the other component).

			// so we find the heaviest out edge and increase the rank of the source component
			// - in case of a tie use the shortest of the heaviest edges
			var minComponent = 0;
			for (var i = 1; i < component.length; i++) {
				if (minOutEdgeInfo[i].weight > minOutEdgeInfo[minComponent].weight ||
					(minOutEdgeInfo[i].weight == minOutEdgeInfo[minComponent].weight &&
						minOutEdgeInfo[i].length < minOutEdgeInfo[minComponent].length)) {
					minComponent = i;
				}
			}

			//console.log("MinLen: " + Helpers.stringifyObject(minOutEdgeLength));

			// reduce rank of all nodes in component "minComponent" by minEdgeLength[minComponent] - 1
			for (var v = 0; v < component[minComponent].length; v++) {
				ranks[component[minComponent][v]] += (minOutEdgeInfo[minComponent].length - 1);
			}

			//console.log("Re-ranking ranks update: " + Helpers.stringifyObject(ranks));
		}

		console.log("Ranks after re-ranking: " + Helpers.stringifyObject(ranks));
	},
	//============================================================================[rank]=


	//=[ordering]========================================================================
	ordering: function (maxInitOrderingBuckets, maxOrderingIterations, disconnectedTwins) {
		if (this.GG.v.length == 0) return new Ordering([], []);  // empty graph

		var best = undefined;
		var bestCrossings = Infinity;

		// we find leaf nodes and rootless nodes because removing some of them improves both speed and quality of ordering algorithms
		// (e.g. we know that leaf siblings should be placed together, so might as well just leave one in the graph for ordering purposes;
		//  similarly if there is apartner with no parents and no other partnerships it is easy to position that person next to his or her
		//  partner once everything else is positioned, and removing nodes speed all the graph-traversal & edge-cross-computation algorithms)
		var leafAndRootlessInfo = this.GG.getLeafAndParentlessNodes();

		var rootlessPartners = this.findAllRootlessPartners(leafAndRootlessInfo);
		this.disconnectRootlessPartners(rootlessPartners);

		var leafSiblings = this.findLeafSiblings(leafAndRootlessInfo);
		this.disconnectLeafSiblings(leafSiblings);

		var permutationsRoots = this.computePossibleParentlessNodePermutations(maxInitOrderingBuckets, leafAndRootlessInfo, rootlessPartners);
		var permutationsLeafs = this.computePossibleLeafNodePermutations(maxInitOrderingBuckets, leafAndRootlessInfo, leafSiblings, disconnectedTwins);

		var initOrderIterTotal = 0;  // just for reporting

		var useStack = false;

		var timer = new Helpers.Timer();

		//permutationsRoots = [[27, 0, 5, 4, 8, 9, 1, 28]];
		//useStack = true;

		while (true) {
			//var timer2 = new Helpers.Timer();
			for (var initOrderIter = 0; initOrderIter < permutationsRoots.length; initOrderIter++) {
				initOrderIterTotal++;

				order = this.init_order_top_to_bottom(permutationsRoots[initOrderIter], useStack);

				this.transpose(order, false, bestCrossings * 4 + 5);  // fix locally-fixable edge crossings,
				// but do not bother doing minor optimizations (for performance reasons)

				var numCrossings = this.edge_crossing(order);

				if (numCrossings < bestCrossings) {
					best = order.copy();
					bestCrossings = numCrossings;
					//console.log("UsingP: " + Helpers.stringifyObject(permutationsRoots[initOrderIter]) + " " + useStack.toString() + "  SCORE: " + numCrossings);
					if (numCrossings == 0) break;
				}
			}
			//timer2.printSinceLast("Top-to-bottom: ");

			if (bestCrossings == 0) break;
			for (var initOrderIter2 = 0; initOrderIter2 < permutationsLeafs.length; initOrderIter2++) {
				initOrderIterTotal++;

				order = this.init_order_bottom_to_top(permutationsLeafs[initOrderIter2], useStack);

				this.transpose(order, false, bestCrossings * 4 + 5);  // fix locally-fixable edge crossings

				var numCrossings = this.edge_crossing(order);

				if (numCrossings < bestCrossings) {
					best = order.copy();
					bestCrossings = numCrossings;
					//console.log("UsingL: " + Helpers.stringifyObject(permutationsLeafs[initOrderIter2]) + " " + useStack.toString() + "  SCORE: " + numCrossings);
					if (numCrossings == 0) break;
				}
			}
			//timer2.printSinceLast("Bottom-to-top: ");

			if (bestCrossings == 0) break;
			if (useStack) break;
			useStack = true;
		}

		timer.printSinceLast("Initial ordering: ");
		var bestEdgeLengthScore = this.edge_length_score(best);

		console.log("Initial ordering: " + Helpers.stringifyObject(best.order));
		console.log("Initial ordering:  numCrossings= " + bestCrossings + ",  edhgeLengthScore= " + bestEdgeLengthScore);

		//this.reconnectRootlessPartners(best, rootlessPartners);
		//this.reconnectLeafSiblings(best, leafSiblings);
		//return best;

		var noChangeIterations = 0;

		var order = best.copy();

		for (var i = 0; i < maxOrderingIterations; i++) {
			//if (bestCrossings == 0) break;   // still want to optimize for edge lengths

			// try to optimize based on a heuristic: just do it without checking if the result
			// is good or not. The layout may be not as good rigth away but better after a few
			// iterations
			var changed = this.wmedian(order, i);

			//console.log("median: " + Helpers.stringifyObject(order.order));

			// try to optimize locally (fix easily-fixable edge crossings, put children
			// and partners closer to each other) checking if each step is useful and
			// discarding bad adjustments (i.e. guaranteed to either improve or leave as is)
			this.transpose(order, true);

			//console.log("transpose: " + Helpers.stringifyObject(order.order));

			var numCrossings = this.edge_crossing(order);

			var edgeLengthScore = this.edge_length_score(order);

			if (numCrossings < bestCrossings ||
				(numCrossings == bestCrossings && edgeLengthScore < bestEdgeLengthScore)) {
				console.log("ordering: new better one selected (" + numCrossings + " crossings, " + edgeLengthScore + " edgeLengthScore)");

				best = order.copy();
				bestCrossings = numCrossings;
				bestEdgeLengthScore = edgeLengthScore;
				noChangeIterations = 0;
			}
			else {
				if (!changed) noChangeIterations++;
				if (noChangeIterations == 6) break;
			}
		}

		this.transpose(best, true);

		this.reconnectRootlessPartners(best, rootlessPartners);
		this.transpose(best, true);

		this.reconnectLeafSiblings(best, leafSiblings);
		//this.transpose(best, true);

		timer.restart();

		//console.log("-----> " + Helpers.stringifyObject(this.GG));

		// try to optimize long edge placement (bad adjustments are discarded)
		var newBestCrossings = this.transposeLongEdges(best, bestCrossings);

		timer.printSinceLast("Ordering long edges: ");

		console.log("Ordering stats:  initOrderIter= " + initOrderIterTotal + ",  reOrderingIter= " + i + ",  noChangeIterations= " + noChangeIterations);
		console.log("Final ordering: " + Helpers.stringifyObject(best.order));
		console.log("Final ordering:  numCrossings= " + newBestCrossings);

		return best;
	},

	findAllRootlessPartners: function (leafAndRootlessInfo) {
		// finds all people without parents which are only connected to one non-rootless node.
		// we know it should be placed right next to that partner in any optimal ordering

		var rootlessPartners = {};

		for (var i = 0; i < leafAndRootlessInfo.parentlessNodes.length; i++) {
			var v = leafAndRootlessInfo.parentlessNodes[i];

			if (this.GG.getOutEdges(v).length == 1) {
				var relationShipNode = this.GG.downTheChainUntilNonVirtual(this.GG.getOutEdges(v)[0]);

				var parents = this.GG.getParents(relationShipNode);

				var otherParent = (parents[0] == v) ? parents[1] : parents[0];

				// Note: can't ignore nodes which are parentless and are connected to only one partner,
				//       but are not on the same rank with the partner
				if (this.ranks[v] != this.ranks[otherParent]) {
					continue;
				}

				//if (this.GG.getInEdges(otherParent).length > 0 || v > otherParent || this.GG.getOutEdges(otherParent).length > 1) {
				if (this.GG.getInEdges(otherParent).length > 0) {
					if (rootlessPartners[otherParent])
						rootlessPartners[otherParent].push(v);
					else
						rootlessPartners[otherParent] = [v];
				}
			}
		}
		//console.log("Found rootless partners: " + Helpers.stringifyObject(rootlessPartners));
		return rootlessPartners;
	},

	disconnectRootlessPartners: function (rootlessPartners) {
		for (var p in rootlessPartners) {
			if (rootlessPartners.hasOwnProperty(p)) {
				var rootless = rootlessPartners[p];
				for (var i = 0; i < rootless.length; i++) {
					var v = rootless[i];
					var outEdges = this.GG.getOutEdges(v);
					var relNode = outEdges[0];

					// remove edge v->relNode from the graph. Only remove the in-edge, as outedge will never be scanned
					Helpers.removeFirstOccurrenceByValue(this.GG.inedges[relNode], v);  // was [p,v], becomes [p]
				}

			}
		}
	},

	reconnectRootlessPartners: function (order, rootlessPartners) {
		//console.log("Order before reconnect rootless: " + Helpers.stringifyObject(order));
		for (var p in rootlessPartners) {
			if (rootlessPartners.hasOwnProperty(p)) {

				// now check all rootless partners of p. Will place them next to p in the ordering

				var partnersToTheLeft = 0;
				var partnersToTheRight = 0;
				var pOrder = order.vOrder[p];
				var rank = this.ranks[p];

				var pRelationships = this.GG.getOutEdges(p);
				for (var j = 0; j < pRelationships.length; j++) {
					if (this.GG.isRelationship(pRelationships[j])) {   // ignore long edges
						var parents = this.GG.getInEdges(pRelationships[j]);
						if (parents.length == 2) { // e.g. skip relationships with removed parents
							var partner = (parents[0] == p) ? parents[1] : parents[0];
							if (order.vOrder[partner] > pOrder)
								partnersToTheRight++;
							else
								partnersToTheLeft++;
						}
					}
				}

				var rootless = rootlessPartners[p];
				for (var i = 0; i < rootless.length; i++) {
					var v = rootless[i];
					var outEdges = this.GG.getOutEdges(v);
					var relNode = outEdges[0];

					// add back the v->relNode edge
					this.GG.inedges[relNode].push(v);   // was [p], becomes [p,v]

					// insert v into ordering: insert on the side with less partners.
					// ideally we should insert according to the relationship node order, but that will be auto-fixed by transpose()

					if (partnersToTheRight <= partnersToTheLeft) {
						partnersToTheRight++;
						order.insert(rank, pOrder + 1, v);
					}
					else {
						partnersToTheLeft++;
						order.insert(rank, pOrder, v);
					}
				}

			}
		}
		//console.log("Order after reconnect rootless: " + Helpers.stringifyObject(order));
	},

	findLeafSiblings: function (leafAndRootlessInfo) {
		// finds all siblings of non-leaf people which are leaves

		var leafSiblings = {};

		for (var i = 0; i < leafAndRootlessInfo.leafNodes.length; i++) {
			var v = leafAndRootlessInfo.leafNodes[i];

			var childHubNode = this.GG.getInEdges(v)[0];

			if (leafSiblings.hasOwnProperty(childHubNode)) continue;  // we've already processed children of this childhub

			var children = this.GG.getOutEdges(childHubNode);

			if (children.length > 1) {
				leafSiblings[childHubNode] = [];

				var keepChild = v;  // need to keep at least one leaf per childhub so that
				// bottom-to-top ordering has an option of juggling with this leaf/childhub

				for (var j = 0; j < children.length; j++) {
					var child = children[j];
					var outNum = this.GG.getOutEdges(child).length;

					if (child != keepChild && outNum == 0)
						leafSiblings[childHubNode].push(child);
				}
			}
		}

		//console.log("Found leaf siblings: " + Helpers.stringifyObject(leafSiblings));
		return leafSiblings;
	},

	disconnectLeafSiblings: function (leafSiblings) {
		for (var p in leafSiblings) {
			if (leafSiblings.hasOwnProperty(p)) {
				var leaves = leafSiblings[p];
				for (var i = 0; i < leaves.length; i++) {
					var l = leaves[i];

					// remove edge p->l from the graph
					// (don't bother about the weight, and ignore in-edge as it wil never be scanned before re-connection)

					Helpers.removeFirstOccurrenceByValue(this.GG.v[p], l);
				}
			}
		}
	},

	reconnectLeafSiblings: function (order, leafSiblings) {
		//console.log("Order before reconnect leaves: " + Helpers.stringifyObject(order));
		for (var p in leafSiblings) {
			if (leafSiblings.hasOwnProperty(p)) {
				var leaves = leafSiblings[p];
				for (var i = 0; i < leaves.length; i++) {
					var l = leaves[i];

					//console.log("inserting: " + l);

					// add back the p->l edge
					this.GG.v[p].push(l);

					var rank = this.ranks[l];

					order.insert(rank, 0, l);

					var bestO = 0;
					var bestCross = this.edge_crossing(order, rank);
					var bestScore = this.edge_length_score(order, rank);

					// insert l at the best possible order
					for (var o = 0; o < order.order[rank].length - 1; o++) {

						order.exchange(rank, o, o + 1);

						var newEdgeCrossings = this.edge_crossing(order, rank);
						var newLengthScore = this.edge_length_score(order, rank);

						//console.log("order: " + order.vOrder[l] + ", cross: " + newEdgeCrossings);

						if (newEdgeCrossings < bestCross ||
							(newEdgeCrossings == bestCross && newLengthScore < bestScore)) {
							bestO = o + 1;
							bestCross = newEdgeCrossings;
							bestScore = newLengthScore;
						}
					}

					order.moveVertexToOrder(rank, order.vOrder[l], bestO);

					//console.log("inserted at: " + order.vOrder[l]);
				}
			}
		}
		//console.log("Order after reconnect leaves: " + Helpers.stringifyObject(order));
	},

	disconnectTwins: function () {
		var disconnectedTwins = {};

		var handled = {};
		for (var v = 0; v <= this.GG.getMaxRealVertexId(); v++) {
			if (handled[v]) continue;
			if (!this.GG.isPerson(v)) continue;
			var twinGroupId = this.GG.getTwinGroupId(v);
			if (twinGroupId == null) continue;

			disconnectedTwins[v] = [];

			var childhub = this.GG.getInEdges(v)[0];
			var allTwins = this.GG.getAllTwinsOf(v);
			for (var i = 0; i < allTwins.length; i++) {
				var twin = allTwins[i];
				if (twin == v) continue;

				// 1) remove connection from childhub to twin
				// 2) replace in-edges for all nodes twin connects to by an inedge from v
				// 3) add all twin's outedges to v
				// 4) add twin to the backup list of twins of v

				// 1
				Helpers.removeFirstOccurrenceByValue(this.GG.v[childhub], twin);
				// 2 + 3
				var outEdges = this.GG.getOutEdges(twin);
				for (var j = 0; j < outEdges.length; j++) {
					var rel = outEdges[j];
					Helpers.replaceInArray(this.GG.inedges[rel], twin, v);
					this.GG.v[v].push(rel);
					// need to keep in mind the special case of two twins in a relationship
					if (this.GG.weights[v].hasOwnProperty(rel))
						this.GG.weights[v][rel] += this.GG.weights[twin][rel];    // sum the weights
					else
						this.GG.weights[v][rel] = this.GG.weights[twin][rel];     // use the other twin's weight
				}
				// 4
				disconnectedTwins[v].push(twin);

				handled[twin] = true;

				//console.log("REMOVED TWIN " + twin);
			}
		}

		return disconnectedTwins;
	},

	reconnectTwins: function (disconnectedTwins) {
		//console.log("Order before reconnect twins: " + Helpers.stringifyObject(this.order));
		for (var v in disconnectedTwins) {
			if (disconnectedTwins.hasOwnProperty(v)) {

				var rank = this.ranks[v];

				var childhub = this.GG.getInEdges(v)[0];

				var allDisconnectedTwins = disconnectedTwins[v];

				// sort twins by number of reationships, so that twins with no relationships are inserted last
				var GG = this.GG;
				var byNumberOfRelationships = function (a, b) {
					var an = GG.getOutEdges(a).length;
					var bn = GG.getOutEdges(b).length;
					return bn - an;
				}
				allDisconnectedTwins.sort(byNumberOfRelationships);

				for (var i = 0; i < allDisconnectedTwins.length; i++) {
					var twin = allDisconnectedTwins[i];

					// 1) remove outedges which actually belong to twin from v (needed for next step)
					// 2) find the position to reinsert the twin & insert it
					// 3) restore connection from childhub to twin
					// 4) restore in-edges for all nodes twin connects to to twin

					//1
					var outEdges = this.GG.getOutEdges(twin);
					for (var j = 0; j < outEdges.length; j++) {
						var rel = outEdges[j];
						Helpers.removeFirstOccurrenceByValue(this.GG.inedges[rel], v);
						Helpers.removeFirstOccurrenceByValue(this.GG.v[v], rel);

						// need to keep in mind the spcial case of two twins in a relationship; if
						// there is no relationship => weight[v][rel] == weight[twin][rel]
						if (this.GG.weights[v][rel] == this.GG.weights[twin][rel])
							delete this.GG.weights[v][rel];
						else
						// otherwise it is twice as big and need to cut in half to get back to original value
							this.GG.weights[v][rel] -= this.GG.weights[twin][rel];

						this.GG.inedges[rel].push(twin);
					}
					//2
					var insertOrder = this.findBestTwinInsertPosition(twin, this.GG.getOutEdges(twin), this.order);
					this.order.insert(rank, insertOrder, twin);
					//3 + 4
					this.GG.v[childhub].push(twin);

					// handle special case of a relationship between two twins - best handle it after all twins have been reinserted
					// tested by Testcase "3c"
					var groupID = this.GG.getTwinGroupId(twin);
					var outEdges = this.GG.getOutEdges(twin);
					for (var j = 0; j < outEdges.length; j++) {
						var rel = outEdges[j];
						if (this.GG.isVirtual(rel)) continue;
						var parents = this.GG.getInEdges(rel);
						var otherParent = (parents[0] == twin) ? parents[1] : parents[0];
						if (this.GG.getTwinGroupId(otherParent) == groupID &&     // the other partner is this twin's twin
							this.GG.hasEdge(childhub, otherParent)) {             // and both twins have been re-inserted already
							// the twin just re-inserted has a relationship with another twin (which has been re-inserted as well)
							//console.log("RELAT between " + twin + " and " + otherParent);
							// TODO: can do a smarter thing and rearrange twins based on other relationships.
							//       but since this is a rare case for now just do the simple improvement
							var orderRel = this.order.vOrder[rel];
							var orderTwin1 = this.order.vOrder[twin];
							var orderTwin2 = this.order.vOrder[otherParent];
							if (Math.abs(orderTwin1 - orderTwin2) != 1) {
								if (this.GG.getOutEdges(twin).length == 1) {
									if (orderTwin1 < orderTwin2)
										this.order.moveVertexToOrder(rank, orderTwin1, orderTwin2);
									else
										this.order.moveVertexToOrder(rank, orderTwin1, orderTwin2 + 1);
								} else if (this.GG.getOutEdges(otherParent).length == 1) {
									if (orderTwin2 < orderTwin1)
										this.order.moveVertexToOrder(rank, orderTwin2, orderTwin1);
									else
										this.order.moveVertexToOrder(rank, orderTwin2, orderTwin1 + 1);
								} else
									continue; // twins are not next to each other and both have multiple relationships: TODO

								// update orders after possible re-arrangement of nodes
								orderRel = this.order.vOrder[rel];
								orderTwin1 = this.order.vOrder[twin];
								orderTwin2 = this.order.vOrder[otherParent];
							}
							// insert rel inbetween the twins (e.g. after leftmost of the twins and before rightmost
							//console.log("order rel: " + orderRel + ", Twin1: " + orderTwin1 + ", Twin2: " + orderTwin2);
							if (orderTwin1 < orderTwin2)
								this.order.moveVertexToOrder(rank, orderRel, orderTwin2);
							else
								this.order.moveVertexToOrder(rank, orderRel, orderTwin1);
						}
					}
				}
			}
		}
		//console.log("Order after reconnect twins: " + Helpers.stringifyObject(this.order));
	},

	computePossibleParentlessNodePermutations: function (maxInitOrderingBuckets, leafAndRootlessInfo, rootlessPartners) {
		// 1) split all parentless nodes into at most maxInitOrderingBuckets groups/buckets
		// 2) compute all possible permutations of these groups discarding mirror copies (e.g. [1,2,3] and [3,2,1])
		// 3) return the list of permutations, with the default ordering first in the list

		var buckets = [];
		// 1) detect mini-groups: if two parentless nodes are connected by a relationship and not
		//    connected to anything else treat them as one node (they should be close to each other)
		// 2) split all nodes into at most maxInitOrderingBuckets buckets.
		//    note: if there are less nodes (counting a sub-group from #1 as one node) than max ##
		//           of buckets it is ok, if there are more then have to space them evenly into the buckets.
		// note: each bucket should be an array of node IDs, even if there is only one ID

		console.log("maxInitOrderingBuckets: " + maxInitOrderingBuckets);

		var handled = {};

		for (var p in rootlessPartners) {
			if (rootlessPartners.hasOwnProperty(p)) {
				var rootless = rootlessPartners[p];
				for (var i = 0; i < rootless.length; i++)
					handled[rootless[i]] = true;   // those nodes will be automatically added at correct ordering later
			}
		}

		for (var i = 0; i < leafAndRootlessInfo.parentlessNodes.length; i++) {
			var v = leafAndRootlessInfo.parentlessNodes[i];

			if (handled.hasOwnProperty(v)) continue;

			var nextBucket = [];

			nextBucket.push(v);
			handled[v] = true;

			// essy grouping: place parents which are only connected to the same relationship in the same bucket
			if (this.GG.getOutEdges(v).length == 1) {

				var rel = this.GG.downTheChainUntilNonVirtual(this.GG.getOutEdges(v)[0]);
				var parents = this.GG.getParents(rel);

				var otherPartner = (parents[0] == v) ? parents[1] : parents[0];

				if (!handled.hasOwnProperty(otherPartner)
					&& this.GG.getInEdges(otherPartner).length == 0
					&& this.GG.getOutEdges(otherPartner).length == 1) {   // the other partner has no parents && only this relationhsip
					nextBucket.push(otherPartner);
					handled[otherPartner] = true;
				}
			}

			buckets.push(nextBucket);
		}

		// if number of buckets is large, merge some (closely related) buckets
		// until the number of buckets is no more than the specified maximum
		if (buckets.length > maxInitOrderingBuckets)
			this.mergeBucketsUntilNoMoreThanGivenLeft(buckets, maxInitOrderingBuckets);

		var permutations = [];

		// Now compute all possible permutations of the buckets
		Helpers.permute2DArrayInFirstDimension(permutations, buckets, 0);

		Helpers.printObject(buckets);
		//Helpers.printObject(permutations);
		//permutations = [ leafAndRootlessInfo.parentlessNodes ];  //DEBUG: no permutations
		//permutations = [[5,4,0,1,2,9]];

		console.log("Found " + permutations.length + " permutations of parentless nodes");

		return permutations;
	},

	computePossibleLeafNodePermutations: function (maxInitOrderingBuckets, leafAndRootlessInfo, leafSiblings, disconnectedTwins) {
		// see computePossibleParentlessNodePermutations

		var buckets = [];
		// 1) detect mini-groups: if two leaf nodes are connected to a childhub and not
		//    connected to anything else treat them as one node (they should be close to each other)
		// 2) split all nodes into at most maxInitOrderingBuckets buckets.

		var handled = {};
		for (var p in leafSiblings) {
			if (leafSiblings.hasOwnProperty(p)) {
				var leaves = leafSiblings[p];
				for (var i = 0; i < leaves.length; i++)
					handled[leaves[i]] = true;   // these nodes (leaves) will be automatically added at correct ordering later
			}
		}
		for (var p in disconnectedTwins) {
			if (disconnectedTwins.hasOwnProperty(p)) {
				var twins = disconnectedTwins[p];
				for (var i = 0; i < twins.length; i++)
					handled[twins[i]] = true;   // these nodes (twis) will be automatically added at correct ordering later
			}
		}

		var nextBucket = 0;
		for (var i = 0; i < leafAndRootlessInfo.leafNodes.length; i++) {
			var v = leafAndRootlessInfo.leafNodes[i];

			if (handled.hasOwnProperty(v)) continue;

			var nextBucket = [];

			nextBucket.push(v);
			handled[v] = true;

			if (this.GG.getInEdges(v).length != 1)
				throw "Assertion failed: only one in edge into a leaf node";
			var childhubNode = this.GG.getInEdges(v)[0];

			// find all nodes which are only connected to V's childhub
			for (var j = i + 1; j < leafAndRootlessInfo.leafNodes.length; j++) {
				var u = leafAndRootlessInfo.leafNodes[j];
				if (handled.hasOwnProperty(u)) continue;

				var childhubNodeU = this.GG.getInEdges(u)[0];

				if (childhubNode == childhubNodeU) {
					nextBucket.push(u);
					handled[u] = true;
				}
			}

			buckets.push(nextBucket);
		}

		// if number of buckets is large, merge some (closely related) buckets
		// until the number of buckets is no more than the specified maximum
		if (buckets.length > maxInitOrderingBuckets)
			this.mergeBucketsUntilNoMoreThanGivenLeft(buckets, maxInitOrderingBuckets, true /* use in-edges when computing closeness */);

		var permutations = [];

		// Now compute all possible permutations of the buckets
		Helpers.permute2DArrayInFirstDimension(permutations, buckets, 0);

		Helpers.printObject(buckets);
		console.log("Found " + permutations.length + " permutations of leaf nodes");

		return permutations;
	},

	mergeBucketsUntilNoMoreThanGivenLeft: function (buckets, maxInitOrderingBuckets, useInEdges) {
		console.log("original buckets: " + Helpers.stringifyObject(buckets));

		while (buckets.length > maxInitOrderingBuckets && this.mergeMostRelatedBuckets(buckets, useInEdges));

		console.log("merged buckets: " + Helpers.stringifyObject(buckets));
	},

	mergeMostRelatedBuckets: function (buckets, useInEdges) {
		// 1. find two most related buckets
		// 2. merge the buckets

		//console.log("original buckets: " + Helpers.stringifyObject(buckets));

		var minDistance = Infinity;
		var bucket1 = 0;
		var bucket2 = 1;

		//var timer = new Helpers.Timer();

		for (var i = 0; i < buckets.length - 1; i++)
			for (var j = i + 1; j < buckets.length; j++) {
				var dist = this.findDistanceBetweenBuckets(buckets[i], buckets[j], useInEdges);

				//console.log("distance between buckets " + i + " and " + j + " is " + dist);

				// pick most closely related buckets for merging. Break ties by bucket size (prefer smaller resulting buckets)
				if (dist < minDistance ||
					(dist == minDistance && buckets[i].length + buckets[j].length < buckets[bucket1].length + buckets[bucket2].length)) {
					minDistance = dist;
					bucket1 = i;
					bucket2 = j;
				}
			}

		//timer.printSinceLast("Compute distance between buckets: ");

		if (minDistance == Infinity) {
			throw "Assumption failed: unrelated buckets";
		}

		// merge all items from bucket1 into bucket2
		for (var i = 0; i < buckets[bucket2].length; i++) {
			buckets[bucket1].push(buckets[bucket2][i]);
		}

		buckets.splice(bucket2, 1);  // remove bucket2

		//console.log("merged buckets: " + Helpers.stringifyObject(buckets));

		return true; // was able to merge some buckets
	},

	findDistanceBetweenBuckets: function (bucket1nodes, bucket2nodes, useInEdges) {
		// only looks for common relatives in one direction: using inEdges iff useInEdges and outEdges otherwise
		var distance = [];

		for (var i = 0; i < bucket1nodes.length; i++)
			distance[bucket1nodes[i]] = 1;
		for (var i = 0; i < bucket2nodes.length; i++)
			distance[bucket2nodes[i]] = -1;

		var queue1 = new Queue();
		queue1.setTo(bucket1nodes);

		var queue2 = new Queue();
		queue2.setTo(bucket2nodes);

		var iter = 0;  // safeguard against infinite loop
		while (iter < 100) {
			iter++;

			if (queue1.size() == 0 && queue2.size() == 0)
				return Infinity;       // buckets are not related/not mergeable

			var nextQueue1 = new Queue();
			while (queue1.size() > 0) {
				var nextNode = queue1.pop();

				var dist = distance[nextNode];

				var edges = useInEdges ? this.GG.getInEdges(nextNode) : this.GG.getOutEdges(nextNode);

				for (var j = 0; j < edges.length; j++) {
					var nextV = edges[j];
					if (distance[nextV] < 0)
						return -distance[nextV] + dist;   // actually distance is (return_value - 1), but it does not matter for this algorithm
					distance[nextV] = dist + 1;
					nextQueue1.push(nextV);
				}
			}
			queue1 = nextQueue1;

			var nextQueue2 = new Queue();
			while (queue2.size() > 0) {
				var nextNode = queue2.pop();

				var dist = distance[nextNode];  // a negative number for nodes in queue2

				var edges = useInEdges ? this.GG.getInEdges(nextNode) : this.GG.getOutEdges(nextNode);

				for (var j = 0; j < edges.length; j++) {
					var nextV = edges[j];
					if (distance[nextV] > 0)
						return distance[nextV] - dist;
					distance[nextV] = dist - 1;
					nextQueue2.push(nextV);
				}
			}
			queue2 = nextQueue2;
		}

		throw "Assertion failed: possible loop detected";
	},

	init_order_top_to_bottom: function (parentlessNodes, useStack) {
		// initially orders the nodes in each rank by a depth-first or breadth-first
		// searches starting with vertices of minimum rank. Vertices are assigned positions
		// in their ranks in left-to-right order as the search progresses.

		var order = [];          // array of arrays - for each rank list of vertices in order
		var vOrder = [];          // array - for each v vOrder[v] = order within rank

		for (var r = 0; r <= this.maxRank; r++)
			order[r] = [];

		for (var i = 0; i < this.GG.getNumVertices(); i++)
			vOrder[i] = undefined;

		// Use BFS -----------------------------
		var queue = useStack ? new Stack() : new Queue();
		queue.setTo(parentlessNodes);

		//console.log("Use stacK: " + useStack + ", parentless: " + Helpers.stringifyObject(parentlessNodes));

		while (queue.size() > 0) {
			var next = queue.pop();
			// we may have already assigned this vertex a rank
			if (vOrder[next] != undefined) continue;

			// assign next available order at next's rank
			var rank = this.ranks[next];

			var nextOrder = order[rank].length;
			vOrder[next] = nextOrder;
			order[rank].push(next);

			// add all children to the queue
			var outEdges = this.GG.getOutEdges(next);

			//alreadyOrderedSortFunc = function(a,b){return b-a};
			//outEdges.sort(alreadyOrderedSortFunc);

			for (var u = 0; u < outEdges.length; u++)
				queue.push(outEdges[u]);
		}
		//--------------------------------------

		//var o = new Ordering(order, vOrder);
		//Helpers.printObject(o);
		//return o;
		return new Ordering(order, vOrder);
	},

	init_order_bottom_to_top: function (leafNodes, useStack) {
		// initially orders the nodes in each rank using depth-first or breadth-first
		// searches starting with he leaf vertices. Vertices are assigned positions in
		// their ranks in left-to-right order as the search progresses.

		var order = [];          // array of arrays - for each rank list of vertices in order
		var vOrder = [];          // array - for each v vOrder[v] = order within rank

		for (var r = 0; r <= this.maxRank; r++)
			order[r] = [];

		for (var i = 0; i < this.GG.getNumVertices(); i++)
			vOrder[i] = undefined;

		var queue = useStack ? new Stack() : new Queue();
		queue.setTo(leafNodes);

		while (queue.size() > 0) {
			var next = queue.pop();
			// we may have already assigned this vertex a rank
			if (vOrder[next] != undefined) continue;

			// assign next available order at next's rank
			var rank = this.ranks[next];

			var nextOrder = order[rank].length;
			vOrder[next] = nextOrder;
			order[rank].push(next);

			// add all children to the queue
			var inEdges = this.GG.getInEdges(next);

			for (var u = 0; u < inEdges.length; u++)
				queue.push(inEdges[u]);
		}

		return new Ordering(order, vOrder);
	},

	edge_length_score: function (order, onlyRank) {
		// Returns the penalty score that penalizes:
		//   higher priority: people in a relationship being far from each other
		//                    (higher penalty for greater distance)
		//   lower priority:  children of the same relationship not being close to each other
		//                    (higher penalty for greater distance between leftmost and rightmost child)
		//   lowest priority: father not being on the left, mother notbeing on the right
		//                    (constant penalty for each case)

		var totalEdgeLengthInPositions = 0;
		var totalEdgeLengthInChildren = 0;
		var totalPenaltyForFatherOnRight = 0;  // penalty for not having father on the left/mother on the right
		var totalPenaltyForChildAgeOrder = 0;  // penalty for not having children ordered by age

		for (var i = 0; i < this.GG.getNumVertices(); i++) {

			if (onlyRank) {
				var rank = this.ranks[i];
				if (rank < onlyRank - 1 || rank > onlyRank + 1) continue;
			}

			if (this.GG.isRelationship(i)) {
				var parents = this.GG.getInEdges(i);

				if (parents.length == 2) {     // while each relationship has 2 parents, during ordering some parents may be "unplugged" to simplify the graph
					// only if parents have the same rank
					if (this.ranks[parents[0]] != this.ranks[parents[1]])
						continue;

					var order1 = order.vOrder[parents[0]];
					var order2 = order.vOrder[parents[1]];

					totalEdgeLengthInPositions += Math.abs(order1 - order2);

					// penalty, if any, for father on the left, mother on the right
					var leftParent = (order1 < order2) ? parents[0] : parents[1];
					var genderOfLeft = this.GG.properties[leftParent]["gender"];
					if (genderOfLeft == 'F')
						totalPenaltyForFatherOnRight++;
				}
			}

			if (this.GG.isChildhub(i)) {
				// get the distance between the rightmost and leftmost child
				var children = this.GG.getOutEdges(i);
				if (children.length > 1) {
					var orderedChildren = order.sortByOrder(children);

					var minOrder = order.vOrder[orderedChildren[0]];
					var maxOrder = order.vOrder[orderedChildren[orderedChildren.length - 1]];
					totalEdgeLengthInChildren += (maxOrder - minOrder);

					var leftChildDOB = this.GG.properties[orderedChildren[0]].hasOwnProperty("dob") ?
						new PedigreeDate(this.GG.properties[orderedChildren[0]]["dob"]) : null;
					for (var j = 1; j < orderedChildren.length; j++) {
						var thisChildDOB = this.GG.properties[orderedChildren[j]].hasOwnProperty("dob") ?
							new PedigreeDate(this.GG.properties[orderedChildren[j]]["dob"]) : null;

						if (thisChildDOB != null) {
							if (leftChildDOB == null) {
								// prefer all without date of birth to be on the right, i.e. penalty for no date on the left
								totalPenaltyForChildAgeOrder++;
							} else {
								// both are not null: compare dates
								if (leftChildDOB.getTime() > thisChildDOB.getTime()) {
									// penalty for older child on the right
									totalPenaltyForChildAgeOrder++;
								}
							}
						}
						leftChildDOB = thisChildDOB;
					}
				}
			}
		}

		//console.log("r = " + onlyRank + ", edgeLength = " + totalEdgeLengthInPositions + ", childLen = " + totalEdgeLengthInChildren);
		return totalEdgeLengthInPositions * 100000 + totalEdgeLengthInChildren * 1000 + totalPenaltyForFatherOnRight * 5 + totalPenaltyForChildAgeOrder;
	},

	edge_crossing: function (order, onlyRank, dontUseApproximationForRelationshipEdges) {
		// Counts edge crossings in the graph accoring to given node ordering.
		//
		// Iff onlyRank is defined, only counts edge crossings affected by re-ordering of
		// nodes on given rank.
		//
		// Assumes that edges always go from lower ranks to higher ranks or
		// between nodes of the same rank

		var numCrossings = 0.0;

		var rankFrom = onlyRank ? Math.max(1, onlyRank - 1) : 1;
		var rankTo = onlyRank ? onlyRank : this.maxRank;

		//Helpers.printObject(order);
		for (var r = rankFrom; r <= rankTo; ++r) {
			var numVert = order.order[r].length;

			// TODO: investigate about person nodes at the last position, and not counting crossings due to its relationship
			//       when "-1" is removed testcase "abraham" incorrectly places "rachel" on the other side of twins
			for (var i = 0; i < numVert - 1; ++i) {   // -1 because we only check crossings of edges going out of vertices of higher orders
				var v = order.order[r][i];

				var isChhub = this.GG.isChildhub(v);
				var outEdges = this.GG.getOutEdges(v);
				var len = outEdges.length;

				for (var j = 0; j < len; ++j) {
					var targetV = outEdges[j];

					// special considerations: after ordering is done all relationship nodes will be
					// re-ranked one level higher. In most cases the number of edge crossings is the
					// same, however it may not be. For most cases the following heuristic results
					// in optimal arrangement:
					// for each relationship node add the number of crossings equal to the number of
					// nodes on the parent rank between it's parents according to current ordering
					if (!dontUseApproximationForRelationshipEdges && this.GG.isRelationship(targetV)) {
						var parents = this.GG.getInEdges(targetV);
						if (parents.length == 2) {
							var order1 = order.vOrder[parents[0]];
							var order2 = order.vOrder[parents[1]];
							var crossings = this.numNodesWithParentsInBetween(order, r, order1, order2);
							numCrossings += crossings / 2; // only assign it half a crossing because most will be fixed by transpose()
							// - and if "1" is assigned transpose wont fix certain local cases
						}
						//if (i == numVert-1) continue;
					}

					// so we have an edge v->targetV. Have to check how many edges
					// between rank[v] and rank[targetV] this particular edge corsses.
					var crossings = this._edge_crossing_crossingsByOneEdge(order, v, targetV);

					// special case: count edges from parents to twins twice
					// (since all twins are combined into one, and this edge actually represents multiple parent-child edges)
					//var twinCoeff = (isChhub && this.GG.isParentToTwinEdge(v, targetV)) ? 2.0 : 1.0;
					var twinCoeff = (isChhub && this.GG.getTwinGroupId(targetV) != null) ? 2.0 : 1.0;

					numCrossings += crossings * twinCoeff;
				}
			}
		}

		//if (!onlyRank)
		//    console.log("crossings: " + numCrossings);

		return numCrossings;
	},

	_edge_crossing_crossingsByOneEdge: function (order, v, targetV) {
		// Crossing occurs if either
		// 1) there is an edge going from rank[v]-ranked vertex with a smaller order
		//     than v to a rank[targetV]-ranked vertex with a larger order than targetV
		// 2) there is an edge going from rank[v]-ranked vertex with a larger order
		//     than v to a rank[targetV]-ranked vertex with a smaller order than targetV
		//
		// However we don't want to count each crossing twice (once for each edge), so
		// here we only count crossings in the 2nd case. The first case will be counted
		// when we process that other vertex

		var rankV = this.ranks[v];
		var rankT = this.ranks[targetV];

		var orderV = order.vOrder[v];
		var orderT = order.vOrder[targetV];

		if (rankV == rankT) {
			return this.numNodesWithParentsInBetween(order, rankV, orderV, orderT);
		}

		var crossings = 0;

		var verticesAtRankV = order.order[ rankV ];    // all vertices at rank V

		// edges from rankV to rankT: only those after v (orderV+1)
		for (var ord = orderV + 1; ord < verticesAtRankV.length; ++ord) {
			var vertex = verticesAtRankV[ord];

			var isChhub = this.GG.isChildhub(vertex);
			var outEdges = this.GG.getOutEdges(vertex);
			var len = outEdges.length;

			for (var j = 0; j < len; ++j) {
				var target = outEdges[j];

				if (order.vOrder[target] < orderT) {
					crossings++;

					// special case: count edges from parents to twins twice
					// (since all twins are combined into one, and this edge actually represents multiple parent-child edges)
					//if (isChhub && this.GG.isParentToTwinEdge(vertex, target))
					if (isChhub && this.GG.getTwinGroupId(target) != null)
						crossings++;
				}
			}
		}

		// prefer long edges to cross other edges at the point they originate from, since
		// this generaly results in better long edge placement once head segment on the same
		// rank with person is added
		if (crossings > 0 && this.GG.isPerson(v) && this.GG.isVirtual(targetV))
			crossings -= 0.1;

		return crossings;
	},

	numNodesWithParentsInBetween: function (order, rank, order1, order2) {
		// TODO: while this function correctly computes what its name suggests, it is
		//       actually used to compute number of crossings for same-rank edges. And for that
		//       need not only to sompute nodes with parents, but correctly compute crossings of
		//       other same-rank edges (relationship edges). The difference is:
		//       - even if a node between order1 and order2 has an in-edge, that in-edge may not cross the
		//         edge from order1 to order2 because both source and target are between order1 & order2
		//       - it may be an out-edge instead of an in-edge, but still crosses as source is inside,
		//         but target is outside [order1, order2]

		var numNodes = 0;
		var fromBetween = Math.min(order1, order2) + 1;
		var toBetween = Math.max(order1, order2) - 1;
		for (var o = fromBetween; o <= toBetween; o++) {
			var b = order.order[rank][o];

			if (this.GG.getInEdges(b).length > 0) {
				// 1. edges which come from higher ranks create a crosing
				// 2. edges that come from the same rank outside the order1-order2 interval create a crossing
				for (var i = 0; i < this.GG.getInEdges(b).length; i++) {
					var u = this.GG.getInEdges(b)[i];

					if (this.ranks[u] != rank) {
						numNodes++;                     // 1. u is of higher rank
					}
					else {
						var orderOther = order.vOrder[u];
						if (orderOther < (fromBetween - 1) || orderOther > (toBetween + 1)) // +1 to skip vertex itself, e.g. multiple relationships
							numNodes++;                 // 2. same rank from outside [order1,order2];
					}
				}
				//numNodes++;
			}

			if (this.GG.isPerson(b)) {
				// count crossing twin's parental edge as a multiple crossing
				// (since all twins are combined into one, and this one parent edge actually represents multiple edges)
				var twinGroupId = this.GG.getTwinGroupId(b);
				if (twinGroupId != null) {
					numNodes++;
				}
			}
		}
		return numNodes;
	},

	//-[wmedian]-------------------------------------------------------------------------
	wmedian: function (order, iter) {
		// The weighted median heuristic: depending on the parity of the current iteration number,
		// the ranks are traversed from top to bottom or from bottom to top.

		var changed = false;

		if (iter % 2 == 0) {
			for (var r = 2; r <= this.maxRank; r++) {
				if (order.order[r].length <= 1 ||            // no need to re-order 1 vertex
					order.order[r - 1].length <= 1) continue;    // if only one same parent for all V:
				// all V will have equivalen median[]
				var median = [];
				var len = order.order[r].length;
				for (var i = 0; i < len; i++) {
					var v = order.order[r][i];
					median[v] = this.median_value(order, v, r - 1);
				}
				changed != this.sort_orders(order, r, median);
			}
		}
		else {
			for (var r = this.maxRank - 1; r >= 1; r--) {
				if (order.order[r].length <= 1 ||            // no need to re-order 1 vertex
					order.order[r + 1].length <= 1) continue;    // if only one same child for all V

				var median = [];
				var len = order.order[r].length;
				for (var i = 0; i < len; i++) {
					var v = order.order[r][i];
					median[v] = this.median_value(order, v, r + 1);
				}
				changed != this.sort_orders(order, r, median);
			}
		}

		return changed;
	},

	median_value: function (order, v, adj_rank) {
		var P = this.adj_position(order, v, adj_rank);

		if (P.length == 0) return -1.0;

		var m = Math.floor(P.length / 2);

		if (P.length % 2 == 1) return P[m];

		if (P.length == 2) return (P[0] + P[1]) / 2;

		var left = P[m - 1] - P[0];
		var right = P[P.length - 1] - P[m];

		return (P[m - 1] * right + P[m] * left) / (left + right);
	},

	adj_position: function (order, v, adj_rank) {
		// returns an ordered array of the present positions of the nodes
		// adjacent to v in the given adjacent rank.
		var result = [];

		var verticesAtRankAdj = order.order[adj_rank];  // all vertices at rank adj_rank

		var len = verticesAtRankAdj.length;
		for (var j = 0; j < len; j++) {
			var adjV = verticesAtRankAdj[j];
			if (this.GG.hasEdge(adjV, v) || this.GG.hasEdge(v, adjV)) {
				result.push(j);      // add order
			}
		}

		return result;
	},

	sort_orders: function (order, rank, weightToUseForThisRank) {

		var sortfunc = function (a, b) {
			return (weightToUseForThisRank[a] - weightToUseForThisRank[b]);
		};

		// re-order vertices within a rank according to weightToUseForThisRank
		order.order[rank].sort(sortfunc);

		var changed = false;

		// update order.vOrder[] accordingly, based on how we just sorted order.order[]
		for (var i = 0; i < order.order[rank].length; i++) {
			var v = order.order[rank][i];
			if (order.vOrder[v] != i)     // if it is not already at what it is
			{
				order.vOrder[v] = i;
				changed = true;
			}
		}

		return changed;
	},
	//-------------------------------------------------------------------------[wmedian]-

	isChhubsOrderOK: function (rank, order) {
		for (var i = 0; i < order.order[rank].length - 1; i++) {
			var v = order.order[rank][i];
			if (!this.GG.isChildhub(v)) continue;

			// take the next childhub to the right: skip all virtual edge pieces
			for (var next = i + 1; next < order.order[rank].length; next++) {
				if (this.GG.isChildhub(order.order[rank][next])) break;
			}
			var u = order.order[rank][next];
			if (!this.GG.isChildhub(u)) continue;

			var aboveV = this.GG.getInEdges(v)[0];
			var aboveU = this.GG.getInEdges(u)[0];

			if (order.vOrder[aboveV] > order.vOrder[aboveU])
				return false;
		}
		return true;
	},

	placeChhubsInCorrectOrder: function (rank, order) {
		var GG = this.GG;
		var byRelOrder = function (a, b) {
			var above1 = GG.getInEdges(a)[0];
			var above2 = GG.getInEdges(b)[0];
			if (above1 == above2) {
				// keep existing order of pieces of virtual edges as well
				return order.vOrder[a] - order.vOrder[b];
			}
			return order.vOrder[above1] - order.vOrder[above2];
		}
		order.order[rank].sort(byRelOrder);

		for (var i = 0; i < order.order[rank].length; i++)
			order.vOrder[ order.order[rank][i] ] = i;
	},

	transpose: function (order, doMinorImprovements, stopIfMoreThanCrossings) {
		// for each rank: goes over all vertices in the rank and tries to switch orders of two
		//                adjacent vertices. If numCrossings is improved keeps the new order.
		//                repeats for each rank, and if there was an improvementg tries again.
		var improved = true;

		//if (doMinorImprovements) Helpers.printObject(order);

		var totalEdgeCrossings = this.edge_crossing(order);
		if (stopIfMoreThanCrossings && totalEdgeCrossings > stopIfMoreThanCrossings) return;

		var iter = 0;
		while (improved) {
			iter++;
			if (!doMinorImprovements && iter > 4) break;
			if (iter > 100) {
				console.log("Assertion failed: too many iterations in transpose(), NumIter == " + iter);
				break;
			}

			improved = false;

			for (var r = 1; r <= this.maxRank; r++) {
				if (r % 3 == 0) {
					// just place all childhubs in the same order as their relationships
					// (..and keep existing order of pieces of virtual edges at this rank)
					this.placeChhubsInCorrectOrder(r, order);
					continue;
				}

				var numEdgeCrossings = this.edge_crossing(order, r);

				if (!doMinorImprovements && numEdgeCrossings == 0) continue;

				var edgeLengthScore = doMinorImprovements ? this.edge_length_score(order, r) : 0;

				var rankImproved = false;

				var maxIndex = order.order[r].length - 1;
				for (var i = 0; i < maxIndex; ++i) {

					order.exchange(r, i, i + 1);

					var newEdgeCrossings = this.edge_crossing(order, r);
					var newLengthScore = doMinorImprovements ? this.edge_length_score(order, r) : 0;

					//if (doMinorImprovements)
					//    console.log("trying: " + v1 + "  <-> " + v2);
					//if ( v1 == 8 || v1 == 9 )  {
					//    console.log("v = " + v1 + ", u = " + v2 + ", newScore= " + newEdgeCrossings +
					//                ", lenScore= " + newLengthScore + ", oldScore= " + numEdgeCrossings +
					//                ", oldLenScore= " + edgeLengthScore);
					//}

					if (newEdgeCrossings < numEdgeCrossings ||
						(newEdgeCrossings == numEdgeCrossings && newLengthScore < edgeLengthScore)) {
						// this was a good exchange, apply it to the current real ordering
						improved = true;
						rankImproved = true;
						var improvement = (numEdgeCrossings - newEdgeCrossings);
						totalEdgeCrossings -= improvement;
						numEdgeCrossings = newEdgeCrossings;
						edgeLengthScore = newLengthScore;
						//console.log("exchanged "+ v1 + " <-> " + v2);
						if (!doMinorImprovements) {
							if (totalEdgeCrossings == 0) return; // still want to optimize for edge lengths
							if (numEdgeCrossings == 0) break; // for this rank
						}

					}
					else {
						// exchange back
						order.exchange(r, i, i + 1);
					}
				}

				if (rankImproved) r--; // repeat again for the same rank
			}
		}
		//if (doMinorImprovements) Helpers.printObject(order);
	},

	transposeLongEdges: function (order, numCrossings, postReRanking) {
		if (numCrossings == 0)
			return numCrossings;

		var maxRealId = this.GG.getMaxRealVertexId();
		var numVert = this.GG.getNumVertices();

		var checked = [];
		for (var v = maxRealId + 1; v < numVert; v++)
			checked[v] = false;

		for (var v = maxRealId + 1; v < numVert; v++) {

			if (checked[v] || this.ranks[v] == 0) continue;

			// find a long edge - an edge connecting real nodes of non-neighbouring ranks,
			// consisting of virtual vertices on intermediate ranks (plus source/target)

			// start from head node - the first virtual node
			var head = v;
			while (this.GG.isVirtual(this.GG.getInEdges(head)[0]))
				head = this.GG.getInEdges(head)[0];

			var chain = [];
			var next = head;

			// go towards the tail through out-edges
			do {
				checked[next] = true;
				chain.push(next);
				next = this.GG.getOutEdges(next)[0];
			}
			while (this.GG.isVirtual(next));
			chain.push(next);

			var bestScore = numCrossings;
			var bestOrder = undefined;

			console.log("Optimizing long edge placement: chain " + Helpers.stringifyObject(chain));

			// try to find best placement: brute force, try to reposition up to 3 pieces at a time simultaneously
			// checking all possible positions for the pieces in question up to 4 positions to the left or right
			if (chain.length <= 10) {
				var beforeChainEnd = 2;
				if (postReRanking)
					beforeChainEnd = 4;
				for (var i = 0; i < chain.length - beforeChainEnd; i++) {

					var piece1 = chain[i];
					var piece2 = chain[i + 1];
					var piece3 = chain[i + 2];

					var rank1 = this.ranks[piece1];
					var rank2 = this.ranks[piece2];
					var rank3 = this.ranks[piece3];

					var ord1 = order.vOrder[piece1];
					var ord2 = order.vOrder[piece2];
					var ord3 = order.vOrder[piece3];

					//console.log("chain piece " + piece1 + ", " + piece2 + ", " + piece3);

					for (var move1 = -4; move1 <= 4; move1++) {
						if (!order.canMove(rank1, ord1, move1)) continue;
						for (var move2 = -4; move2 <= 4; move2++) {
							if (!order.canMove(rank2, ord2, move2)) continue;
							for (var move3 = -4; move3 <= 4; move3++) {
								if (move1 == 0 && move2 == 0 && move3 == 0) continue;
								if (!order.canMove(rank3, ord3, move3)) continue;

								var newOrder = order.copy();
								newOrder.move(rank1, ord1, move1);
								newOrder.move(rank2, ord2, move2);
								newOrder.move(rank3, ord3, move3);

								// TODO: performance: only count crossings caused by the long edge itself?
								var newCross = this.edge_crossing(newOrder, false, postReRanking);
								if (newCross < bestScore) {
									//console.log("+");
									bestScore = newCross;
									bestOrder = [rank1, ord1, move1, rank2, ord2, move2, rank3, ord3, move3];
								}

								//if (move1 == 1 && move2 == 0 && move3 == 0)
								//    console.log("New Score: " + newCross + ", best: " + bestScore );

							}
						}
					}
				}
			}

			if (bestScore < numCrossings) {
				order.move(bestOrder[0], bestOrder[1], bestOrder[2]);
				order.move(bestOrder[3], bestOrder[4], bestOrder[5]);
				order.move(bestOrder[6], bestOrder[7], bestOrder[8]);
				numCrossings = bestScore;
			}

			if (numCrossings == 0) break;
		}

		return numCrossings;
	},
	//========================================================================[ordering]=

	//=====================================================================[re-ordering]=
	reRankRelationships: function () {
		// re-rank all relationship nodes to be on the same level as the lower ranked
		// parent. Attempt to place the re-ranked node next to one of the parents;
		// having ordering info helps to pick the parent & the location.
		// Note1: we may not be able to place a relationship node right next to a
		//        parent (because both parents already have a relationship node on the
		//        requested side), but we can always place it next to another
		//        relationship by the same parent.
		// Note2: also need to shorten incoming multi-rank edges by one node
		//        (see removeRelationshipRanks())

		//console.log("GG: "  + Helpers.stringifyObject(this.GG));
		//console.log("Orders: " + Helpers.stringifyObject(this.order));

		if (this.maxRank === undefined || this.GG.v.length == 0) return;

		var handled = {};

		var initialOrdering = this.order.copy();

		for (var r = 2; r <= this.maxRank; r += 3) {

			// pass1: simple cases: parents are next to each other.
			//        looks better when all such cases are processed before more complicated cases
			//        (otherwise in case of say 3 relationship nodes may end up with two
			//         ugly placements (#2 and #3) instead of only one (#2) when #2 becomes ugly)
			for (var oo = 0; oo < initialOrdering.order[r].length; oo++) {
				var i = initialOrdering.order[r][oo];   // i is the relationship ID
				if (this.GG.isVirtual(i)) continue;
				if (!this.GG.isRelationship(i)) throw "[1] Unexpected node " + i + " at rank " + r;

				//console.log("==> [1] Handling: " + i);

				var parents = this.GG.getInEdges(i);

				// note: each "relationship" node is guaranteed to have exactly two "parent" nodes (validate() checks that)

				if (this.ranks[parent[0]] != this.ranks[parent[1]])
					throw "Assertion failed: edges betwen neighbouring ranks only";

				var order1 = this.order.vOrder[parents[0]];
				var order2 = this.order.vOrder[parents[1]];

				var minOrder = Math.min(order1, order2);
				var maxOrder = Math.max(order1, order2);

				// if parents are next to each other in the ordering
				if (maxOrder == minOrder + 1) {
					//console.log("=== is relationship: " + i + ", minOrder: " + minOrder + ", maxOrder: " + maxOrder );
					this.moveVertexToRankAndOrder(i, this.ranks[parents[0]], maxOrder);
					handled[i] = true;
				}
			}

			// pass2: parents are not next to each other on the same rank
			for (var oo = 0; oo < initialOrdering.order[r].length; oo++) {
				var i = initialOrdering.order[r][oo];   // i is the relationship ID
				if (this.GG.isVirtual(i)) continue;
				if (!this.GG.isRelationship(i)) throw "[2] Unexpected node " + i + " at rank " + r;

				if (handled.hasOwnProperty(i))
					continue; // this node has already been handled

				//console.log("==> [2] Handling: " + i);

				var parents = this.GG.getInEdges(i);

				// rearrange so that parent0 is on the left - for simplicity in further logic
				if (this.order.vOrder[parents[0]] > this.order.vOrder[parents[1]])
					parents.reverse();

				//console.log("NEED TO re-rank relatioship " + i + ", parents=" + Helpers.stringifyObject(parents));

				var rank = this.ranks[parents[0]];

				// 1. for each parent pick which side of the parent to use
				// 2. pick which parent is a better target:
				//    - prefer parent with no relationship node on the corect side
				//    - somewhere in the middle if both parents have other nodes on the preferred side:
				//      - try not to get inbetween well-placed relationships
				//      - count edge crossings (TODO)

				var order1 = this.order.vOrder[parents[0]];
				var order2 = this.order.vOrder[parents[1]];

				if (order2 == order1 + 1)
					throw "Assertion failed: all relationship with parents next to each other are already handled (for parents: " + Helpers.stringifyObject(parents) + ")";

				var insertOrder = order1 + 1;   // set some default in case all other heuroistics fail

				var rightOfParent0 = this.order.order[rank][order1 + 1];
				var leftOfParent1 = this.order.order[rank][order2 - 1];
				//console.log("o1: " + order1 + ", o2: " + order2 + ", rp0: " + rightOfParent0 + ", lp1: " + leftOfParent1 );
				var p0busy = false;
				var p1busy = false;
				if (this.GG.hasEdge(parents[0], rightOfParent0))
					p0busy = true;
				if (this.GG.hasEdge(parents[1], leftOfParent1))
					p1busy = true;
				//console.log("p0busy: " + p0busy + ", p1busy: " + p1busy);

				if (p1busy && p0busy) {
					// TODO: testcase 5K, relationship with ID=15 is inserted not optimaly
					// both busy: find position which does not disturb "nice" relationship nodes
					for (var o = order1 + 2; o <= order2 - 1; o++) {
						var next = this.order.order[rank][o];
						if (!this.GG.hasEdge(parents[0], next)) {
							insertOrder = o;
							break;
						}
					}
					if (insertOrder == null) {
						var parentsOfLeft = this.GG.getInEdges(leftOfParent1);
						var otherP1 = (parentsOfLeft[0] != parents[1]) ? parentsOfLeft[0] : parentsOfLeft[1];
						var orderP1 = this.order.vOrder[otherP1];
						if (orderP1 < order1)
							insertOrder = order2;
						else
							insertOrder = order1 + 1;
					}
				}
				else if (p1busy) {
					// p0 is free, p1 already has a relationship node next to it
					insertOrder = order1 + 1;
				}
				else if (p0busy) {
					// p1 is free, p0 already has a relationship node next to it
					insertOrder = order2;
				}
				else {
					// both p0 and p1 can have the relationship node right next to them
					// for now arbitrarily pick p1
					// TODO: try both pick the one with less crossed edges. Need a testcase
					insertOrder = order2;
				}

				//console.log("==> inserting: " + i + " on order " + insertOrder + " (after " + this.order.order[rank][insertOrder-1] + " and before " + this.order.order[rank][insertOrder] + ")");
				this.moveVertexToRankAndOrder(i, rank, insertOrder);

				//-----
				// fix the problem described in issue #664
				var oldOrder = initialOrdering.vOrder[i];
				if (oldOrder > 0) {
					var oldNeighbourLeft = initialOrdering.order[r][oldOrder - 1];
					if (this.GG.isRelationship(oldNeighbourLeft) && this.order.vOrder[oldNeighbourLeft] > this.order.vOrder[i] && this.ranks[oldNeighbourLeft] == this.ranks[i]) {
						//console.log("L: " + oldNeighbourLeft);
						// fix the case when two relationships switched order during re-ranking - we may want to change the order of children as well
						this.swapChildrenIfAllAToTheLeftOfB(oldNeighbourLeft, i);

						// TODO: remove
						// Also make sure childhubs are in the correct order
						var chHubL = this.GG.getOutEdges(oldNeighbourLeft)[0];
						var chHubR = this.GG.getOutEdges(i)[0];
						if (this.order.vOrder[chHubL] < this.order.vOrder[chHubR])
							this.order.exchange(this.ranks[chHubL], this.order.vOrder[chHubL], this.order.vOrder[chHubR]);
					}
				}
				if (oldOrder < initialOrdering.order[rank + 1].length - 1) {
					var oldNeighbourRight = initialOrdering.order[r][oldOrder + 1];
					if (this.GG.isRelationship(oldNeighbourRight) && this.order.vOrder[oldNeighbourRight] < this.order.vOrder[i] && this.ranks[oldNeighbourRight] == this.ranks[i]) {
						//console.log("R: " + oldNeighbourRight);
						// same as above, but switch right-to-left instead of left-to-right
						this.swapChildrenIfAllAToTheLeftOfB(i, oldNeighbourRight);

						// TODO: remove
						// Also make sure childhubs are in the correct order
						var chHubL = this.GG.getOutEdges(i)[0];
						var chHubR = this.GG.getOutEdges(oldNeighbourRight)[0];
						if (this.order.vOrder[chHubL] < this.order.vOrder[chHubR])
							this.order.exchange(this.ranks[chHubL], this.order.vOrder[chHubL], this.order.vOrder[chHubR]);
					}
				}
				//-----
			}
		}

		this.removeRelationshipRanks();

		// Fix ordering mistakes introduced by the re-ranking algorithm. It is easier to fix post-factum
		// than to order correctly rigth away (e.g. generally the above algo is doing the same thing, but
		// in some special cases can do better once everything is complete)
		this.improveOrdering();

		// after re-ordering long edges are shorter, try to improve long edge placement again
		var edgeCrossings = this.edge_crossing(this.order, false, true);
		this.transposeLongEdges(this.order, edgeCrossings, true);

		console.log("Final re-ordering: " + Helpers.stringifyObject(this.order.order));
		console.log("Final ranks: " + Helpers.stringifyObject(this.ranks));
	},

	moveVertexToRankAndOrder: function (v, newRank, newOrder) {
		var oldRank = this.ranks[v];
		var oldOrder = this.order.vOrder[v];

		this.order.moveVertexToRankAndOrder(oldRank, oldOrder, newRank, newOrder);
		this.ranks[v] = newRank;
	},

	swapChildrenIfAllAToTheLeftOfB: function (leftRel, rightRel) {
		// we assume that during re-ordering relationship `leftRel` which used ot be to the left or relationship `rightRel`
		// is now to the right of `rightRel`. This may have introduced some unnecessary crossed edges. Fix those by swapping
		// the order of relationship children as well, if it clearly wont break other things, e.g.
		// - if there are no nodes which are not children of `leftRel` of `rightRel` between the leftmost and rightmost child of either leftR or rightR
		// - all children of `leftRel` are to the left of all children of `rightRel`
		// - there are no relationships between `leftRel` children and any nodes to the left of `leftRel` OR on any other rank
		// - there are no relationships between `rightRel` children and any nodes to the right of `rightRel` OR on any other rank
		console.log("Attempting to swap children of " + leftRel + " and " + rightRel + " (due to change of order during re-ranking)");

		var chHubL = this.GG.getOutEdges(leftRel)[0];
		var chHubR = this.GG.getOutEdges(rightRel)[0];

		var childrenL = this.GG.getOutEdges(chHubL);
		var childrenR = this.GG.getOutEdges(chHubR);
		var allChildren = childrenL.concat(childrenR);

		var order = this.order;
		var byOrder = function (a, b) {
			return order.vOrder[a] - order.vOrder[b];
		}
		allChildren.sort(byOrder);
		//console.log("all children sorted by order: " + Helpers.stringifyObject(allChildren));

		var childRank = this.ranks[allChildren[0]];

		var leftMostOrder = order.vOrder[allChildren[0]];
		var rightMostOrder = order.vOrder[allChildren[allChildren.length - 1]];
		// we only swap orders if there are no other nodes inbetween the children of leftRel and rightRel
		if (rightMostOrder - leftMostOrder + 1 != childrenL.length + childrenR.length) return;

		for (var i = 0; i < allChildren.length; i++) {
			var nextInOrder = allChildren[i];

			var shouldBeLeftRelChild = (i < childrenL.length);

			if (shouldBeLeftRelChild && this.GG.getInEdges(nextInOrder)[0] != chHubL)    // a child of `rightRel` must be to the left of one of the children of `leftRel` => quit
				return;

			// make sure there are no relationships which will result in extra edge crossings if we swap order of children
			var outEdges = this.GG.getOutEdges(nextInOrder);
			if (outEdges.length > 0) {
				for (var j = 0; j < outEdges.length; j++) {
					var rel = outEdges[j];
					if (this.GG.isVirtual(rel)) return; // do not touch long edges (TODO: can improve, see tescase HUGE1 and nodes with IDs 23 & 4)

					var parents = this.GG.getParents(rel);

					for (var k = 0; k < parents.length; k++) {
						if (this.ranks[parents[k]] != childRank) return;   // relationship with a node on another rank - no swaps

						if (shouldBeLeftRelChild && order.vOrder[parents[k]] < leftMostOrder) return;    // leftRel children in relationship with nodes to the left
						// ->after swap there will be many crossed edges
						if (!shouldBeLeftRelChild && order.vOrder[parents[k]] > rightMostOrder) return;  // rightRel children in rel. with nodes to the right
					}
				}
			}
		}

		// swap by inverting the order
		//console.log("Performing swap");
		var middle = Math.floor((leftMostOrder + rightMostOrder) / 2);

		for (var i = leftMostOrder; i <= middle; i++) {
			var tmp = this.order.order[childRank][i];
			this.order.order[childRank][i] = this.order.order[childRank][leftMostOrder + rightMostOrder - i];
			this.order.order[childRank][leftMostOrder + rightMostOrder - i] = tmp;

			this.order.vOrder[this.order.order[childRank][i]] = i;
			this.order.vOrder[this.order.order[childRank][leftMostOrder + rightMostOrder - i]] = leftMostOrder + rightMostOrder - i;
		}
	},

	removeRelationshipRanks: function () {
		// removes ranks previously occupied by relationship nodes (which is every 3rd rank)
		// (these ranks have either no nodes at all or only virtual nodes
		// from multi-rank edges passing through)
		for (var r = 2; r <= this.maxRank; r += 2) {
			// r+=2 because each 3rd rank is a relationship rank, but once this rank is removed it becomes r+2 not r+3

			if (this.order.order[r].length > 0) {
				// there are some virtual nodes left
				for (var i = 0; i < this.order.order[r].length; i++) {
					var v = this.order.order[r][i];
					// it takes a lot of work to completely remove a vertex from a graph.
					// however it is easy to disconnect and place it into rank 0 which is ignored when drawing/assigning coordinates
					this.GG.unplugVirtualVertex(v);
					this.ranks[v] = 0;
					this.order.vOrder[v] = this.order.order[0].length;
					this.order.order[0].push(v);
				}
			}

			this.order.order.splice(r, 1);

			for (var v = 0; v < this.ranks.length; v++) {
				if (this.ranks[v] > r)
					this.ranks[v]--;
			}

			this.maxRank--;
		}

		// remove all unplugged vertices
		var unplugged = this.order.removeUnplugged().sort(function (a, b) {
			return a - b
		});
		console.log("Removing unnecessary long edge pieces: " + Helpers.stringifyObject(unplugged));
		for (var i = 0; i < unplugged.length; i++) {
			var removedID = unplugged[i] - i;   // "-i" because after each splice array size decreases by one and item N is going to be at location N-1, then N-2, etc
			this.ranks.splice(removedID, 1);
			this.GG.remove(removedID);
		}
	},

	improveOrdering: function () {
		// 1) fix re-ranking mistakes:
		//
		//    A) in a case like the one below "partner1" can be placed right next to "relationship1"
		//                           /--------------\ /--------------- ...  ---[partner1]
		//               -----------/---\            X
		//      [person]/----[rel1]/     \--[rel2]--/ \____[partner1]
		//
		for (var r = 1; r <= this.maxRank; r += 1) {
			for (var oo = 0; oo < this.order.order[r].length; oo++) {
				var v = this.order.order[r][oo];
				if (!this.GG.isPerson(v)) continue;

				if (this.GG.getInEdges(v).length != 0) continue;  // skip nodes with parents

				var relationships = this.GG.getOutEdges(v);
				if (relationships.length != 1) continue;          // only when one and only one relationship

				var rel = relationships[0];
				if (this.ranks[rel] != r) continue;               // only when relationship is on the same rank

				var orderV = this.order.vOrder[v];
				var orderRel = this.order.vOrder[rel];

				if (Math.abs(orderRel - orderV) != 1) {
					// not next to each other
					if (orderRel > orderV) {
						this.order.move(r, orderV, (orderRel - orderV - 1));
					} else {
						this.order.move(r, orderV, (orderRel - orderV + 1));
					}
				}
			}
		}

		// 2) TODO: come up with heuristics which can be applied at this point
		//          (on a need-to-improve basis once an imperfection is discovered):
		// after re-ranking there may be some orderings which are equivalent in terms
		// of the number of edge crossings, but more or less visually pleasing
		// depending on what kinds of edges are crossing.
		// Until re-ordering is done it is computationally harder to make these tests,
		// but once reordering is complete it is easier in some cases
		// (e.g: testcase 5A, relationship with both a parent and parent's child)

		// 3) make sure chhubs are ordered in the same way their relationships are
		for (var r = 2; r <= this.maxRank; r += 2) {
			// place all childhubs in the same order as their relationships
			// (..and keep existing order of pieces of virtual edges at this rank)

			// check if we need to do that: if they are already OK it is usually better not to mess with orders
			// as chhubs will be OK anyway, but virtual edge pieces may get screwed
			if (!this.isChhubsOrderOK(r, this.order)) {
				//console.log("Fixing chhub order @ rank " + r);
				this.placeChhubsInCorrectOrder(r, this.order);
			}
		}
	},

	//=====================================================================[re-ordering]=

	findConnectedComponent: function (v, edgeIncludedFunc, stopSet, maxSize) {
		// computes connected component which includes vertex v (or all vertice sin array v)
		// and all vertices reachable from v not using edges which do not pass the `edgeIncludedFunc()` test
		//
		// stops when a vertex from the `stopSet` set is found and includes `reachedStopSet` key in the response
		// stops when component size exceeds `maxSize`

		var component = {};
		var size = 0;
		var stopFound = false;

		// if v is not an arrya make it an array with one element
		if (Object.prototype.toString.call(v) !== '[object Array]') {
			v = [v];
		}

		var q = new Queue();
		for (var i = 0; i < v.length; i++) {
			q.push(v[i]);
			component[v[i]] = true;
		}

		while (q.size() > 0) {
			var nextV = q.pop();

			var allConnected = this.GG.getAllEdgesWithWeights(nextV);
			for (var u in allConnected) {
				if (!allConnected.hasOwnProperty(u)) continue;

				var from = allConnected[u].out ? nextV : u;
				var to = allConnected[u].out ? u : nextV;

				if (edgeIncludedFunc(from, to) && !component.hasOwnProperty(u)) {
					component[u] = true;
					q.push(u);
					size++;

					if (stopSet.hasOwnProperty(u)) {
						stopFound = true;
						break;
					}
				}

				if (size > maxSize) {
					q.clear();
					break;
				}
			}
		}
		return { "component": component, "size": size, "stopSetReached": stopFound };
	},

	//=[ancestors]=======================================================================
	findAllAncestors: function () {
		var ancestors = {};
		var consangr = {};

		// got from low ranks to high ranks. For each node merge ancestors of its parents
		for (var r = 1; r <= this.maxRank; r++) {
			var nextRank = this.order.order[r];

			for (var i = 0; i < nextRank.length; i++) {
				var v = this.order.order[r][i];
				if (!this.GG.isPerson(v)) continue;
				ancestors[v] = {};
				ancestors[v][v] = 0;
				if (this.GG.isAdoptedIn(v)) continue; // TODO: assume adopted have no known parents
				var parents = this.GG.getParents(v);
				//console.log("v: " + v + ", parents: " + Helpers.stringifyObject(parents));
				for (var j = 0; j < parents.length; j++) {
					var familyBranch = ancestors[parents[j]];

					for (var u in familyBranch) {
						if (familyBranch.hasOwnProperty(u)) {
							if (ancestors[v].hasOwnProperty(u)) {   // parents are relatives: pick the shortest path to that relative
								ancestors[v][u] = Math.min(familyBranch[u] + 1, ancestors[v][u]);
							}
							else
								ancestors[v][u] = familyBranch[u] + 1;
						}
					}
				}
			}
		}

		// repeat the same for relationship nodes. Note that this second pas sis required because we need to make sure both
		// parents got their relatives computed before the relationship ancestors canbe updated.
		// Could do all in one pass iff relationship nodes were ranked below person nodes, but while they are
		// twins could nto be inserted correctly. So need to re-rank first, re-insert twins, compute ancestors for all including twins
		for (var r = 1; r <= this.maxRank; r++) {
			var nextRank = this.order.order[r];

			for (var i = 0; i < nextRank.length; i++) {
				var v = this.order.order[r][i];
				if (!this.GG.isRelationship(v)) continue;
				ancestors[v] = {};
				ancestors[v][v] = 0;
				var parents = this.GG.getParents(v);
				for (var j = 0; j < parents.length; j++) {
					var familyBranch = ancestors[parents[j]];
					for (var u in familyBranch) {
						if (familyBranch.hasOwnProperty(u)) {
							if (ancestors[v].hasOwnProperty(u)) {   // parents are relatives
								consangr[v] = true;
								ancestors[v][u] = Math.min(familyBranch[u] + 1, ancestors[v][u]);
							}
							else
								ancestors[v][u] = familyBranch[u] + 1;
						}
					}
				}
			}
		}

		//console.log("Ancestors: " + Helpers.stringifyObject(ancestors));
		//console.log("Consangr:  " + Helpers.stringifyObject(consangr));

		return {ancestors: ancestors, consangr: consangr};
	},
	//=======================================================================[ancestors]=

	//=[vertical separation for horizontal edges]========================================
	positionVertically: function () {
		/*// debug: very useful debug case, which is very hard to reproduce without fiddling with
		 //        a normally-processed MS_004 graph. TODO: remove
		 if (this.positions.length > 60) {
		 this.positions[50] = 80;
		 this.positions[51] = 193;
		 this.positions[53] = 217;
		 this.positions[60] = 440;
		 this.order.vOrder[45] = this.order.vOrder[50];
		 this.order.vOrder[50] = 0;
		 }*/

		var verticalLevels = new VerticalLevels();

		// for all ranks:
		//
		// 1) if rank has childhub nodes:
		//    pick vertical position (within the rank, as a discrete integer "level") for the horizontal part of the child edge
		//    (in a way which minimizes crossings between vertical and horizontal parts of different relationship-to-child lines)
		//
		// 2) if rank has person nodes:
		//    for all person which has a relationship vertically position all outgoing relationship edges
		//    (within the rank, as a discrete integer "level") in a way to avoid overlaps between different relationship edges

		var _startRank = 2;
		var _rankStep = 2;
		/*
		 // TODO: DEBUG: computations below are to accomodate debugging when reRankRelationships() may be omitted
		 for (var i = 0; i<this.order.order[_startRank].length; i++)
		 if ( !this.GG.isVirtual(this.order.order[_startRank][i]) && !this.GG.isChildhub( this.order.order[_startRank][i] ) )
		 {
		 _startRank = 3;
		 _rankStep  = 3;
		 break;
		 }*/

		for (var r = 1; r <= this.maxRank; r += 1)
			verticalLevels.rankVerticalLevels[r] = 1;    // number of "vertical levels" (i.e. parallel horizontal edges) between rank r and r+1. Start with 1 for all ranks

		if (this.GG.v.length <= 1) return verticalLevels;

		//console.log("GG: " + Helpers.stringifyObject(this.GG));
		//console.log("Order: " + Helpers.stringifyObject(this.order));

		// 1) go over childnode ranks.
		//    a) for each vertex on the rank, in the ordering order
		//    b) check if any edges cross any edges of the vertices earlier in the order
		//    c) if yes, add that level to the set of forbidden levels
		//    d) pick minimum level which is not forbidden
		for (var r = _startRank; r <= this.maxRank; r += _rankStep) {

			var initLevels = [];
			var edgeInfo = [];

			var len = this.order.order[r].length;
			for (var i = 0; i < len; i++) {
				var v = this.order.order[r][i];

				if (this.GG.isVirtual(v)) continue;
				if (!this.GG.isChildhub(v)) throw "Assertion failed: childhub nodes at every other rank (" + v + ")";

				var realationship = this.GG.getInEdges(v)[0];
				var top_x = this.positions[realationship];  // x cooordinate of the line going up
				var left_x = top_x;                          // the leftmost edge of the horizontal part
				var right_x = top_x;                          // the rightmost edge of the horizontal part
				var childCoords = [];

				var outEdges = this.GG.getOutEdges(v);

				for (var j = 0; j < outEdges.length; j++) {
					var child_x = this.positions[outEdges[j]];
					childCoords.push(child_x);

					left_x = Math.min(left_x, child_x);
					right_x = Math.max(right_x, child_x);
				}

				if (left_x == right_x) {
					// no horizontal part, just  astraight line - no need to optimize anything
					verticalLevels.childEdgeLevel[v] = 0;
				} else {
					// special case improvement: single child which is leftmost on the rank and its parent is to the right of it
					// (this may not produce less edge crossings, but is more visually pleasing)
					var needTopmost = (outEdges.length == 1) &&
						( ( (this.order.vOrder[outEdges[0]] == 0) && (top_x > this.positions[outEdges[0]]) ) ||
							( (this.order.vOrder[outEdges[0]] == this.order.vOrder.length - 1) && (top_x < this.positions[outEdges[0]]) ) );
					edgeInfo.push({ "childhub": v, "top_x": top_x, "left_x": left_x, "right_x": right_x, "childCoords": childCoords, "needTopmost": needTopmost});
					initLevels.push(1);
				}
			}
			//console.log("EdgeInfo: " + Helpers.stringifyObject(edgeInfo));

			// compose the "crossing score" function which, given edgeInfo + which horizontal line is higher,
			// can tell the number of crossings between two childhub-to-children sets of edges
			var pairScoreFunc = function (edge1, edge2, edge1level, edge2level) {
				//
				// general form of a displayed edges is like:
				//                                                             relationship_a    relationship_b
				//              top_x                                                       |    |
				//                |                                                         |    +-----+-------+---+   <--- level1
				//  left_x   +----+-----+   right_x , multiple edges may be arranged like:  +------+---|---+   |   |   <--- level2
				//           |  |    |  |                                                          |   |   |   |   |
				//        (one or more childX)                                                    a1  b1  a2  b2  b3
				//
				// This function computes the number of intersections of two shapes like the ones
				// draw above given their vertical "levels", i.e. which one is above the other.

				if (edgeInfo[edge1].right_x < edgeInfo[edge2].left_x ||
					edgeInfo[edge1].left_x > edgeInfo[edge2].right_x)
					return 0;                                              // edges do not intersect/overlap => no penalty for any level assignment

				if (edge1level == edge2level) return Infinity;              // intersect and at the same level => forbidden => (penalty == Infinity)

				if (edge1level > edge2level) {
					var tmpEdge = edge1;
					var tmpLevel = edge1level;
					edge1 = edge2;
					edge1level = edge2level;
					edge2 = tmpEdge;
					edge2level = tmpLevel;
				}

				// compute number of intersections
				var intersections = 0;
				// potentially childhub-to-horizontal segment of edge2 may cross horizontal segment of edge1
				if (edgeInfo[edge2].top_x >= edgeInfo[edge1].left_x && edgeInfo[edge2].top_x <= edgeInfo[edge1].right_x)
					intersections++;
				// potentially horizontal-to-child vertical lines of edge1 may cross horizontal segment of edge2
				for (var j = 0; j < edgeInfo[edge1].childCoords.length; j++) {
					var childX = edgeInfo[edge1].childCoords[j];
					if (childX >= edgeInfo[edge2].left_x && childX <= edgeInfo[edge2].right_x)
						intersections++;
				}
				if (edgeInfo[edge2].needTopmost)    // single leftmost child should be topmost
					return intersections += 0.1;
				return intersections;
			};

			var optimizer = new VerticalPosIntOptimizer(pairScoreFunc, initLevels);

			// - full exhaustive search when up to 5 edges cross other edges on this rank
			// - heuristic with up to 600 steps is used otherwise
			//
			//   max full search running time: ~                 f(numEdgesThatCross) * scoreFuncTime  (*)
			//   max heuristic running time:   ~  bigC * numEdgesThatCross * numSteps * scoreFuncTime
			//
			//   (*) where f(numEdgesThatCross) is (currently) numEdgesThatCross^numEdgesThatCross, e.g. f(5) = 3125
			var edgeLevels = optimizer.computeVerticalPositions(5, 600);

			//console.log("[rank " + r + "] Final vertical childedge levels: " +  Helpers.stringifyObject(edgeLevels));

			for (var v = 0; v < edgeInfo.length; v++) {
				verticalLevels.childEdgeLevel[edgeInfo[v]["childhub"]] = edgeLevels[v];
				if (edgeLevels[v] > verticalLevels.rankVerticalLevels[r])
					verticalLevels.rankVerticalLevels[r] = edgeLevels[v];
			}
		}

		// 2) vertical positioning of person-relationship edges:
		for (var r = 1; r <= this.maxRank; r++) {

			var numLevels = 1;

			var initLevels = [];
			var edgeInfo = [];
			var relEdges = {};

			var len = this.order.order[r].length;
			for (var i = 0; i < len; i++) {
				var v = this.order.order[r][i];

				if (this.GG.isPerson(v)) {
					var outEdges = this.GG.getOutEdges(v);
					if (outEdges.length <= 0) continue;

					var v_x = this.positions[v];

					verticalLevels.outEdgeVerticalLevel[v] = {};

					//console.log("Vert Positioning rel edges from person " + v);
					//console.log("leftEdges: " + Helpers.stringifyObject(leftEdges));
					//console.log("rightEdges: " + Helpers.stringifyObject(rightEdges));

					var vOrder = this.order.vOrder;

					var positionEdgesOnOneSide = function (edges) {
						var nextAttachPort = 0;      // attachment point of the line connecting the node and it's relationship
						var nextVerticalLevel = 0;      // vertical level of the line
						for (var k = 0; k < edges.length; k++) {
							var u = this.GG.downTheChainUntilNonVirtual(edges[k]);    // final destination for the edge - possibly at another rank
							var dest = edges[k];                                           // immediate target - on the same rank

							// check what lies between V and DEST. Need to raise the edge by different amounts depending on what lies there
							// (nothing, relationship nodes, real nodes)
							var minOrder = Math.min(vOrder[dest], vOrder[v]) + 1;
							var maxOrder = Math.max(vOrder[dest], vOrder[v]);
							var minLevel = (minOrder == maxOrder) ? 0 : 1;  // 0 if next to each other, 1 if at least anything inbetween
							//console.log("v: " + v + "(" + vOrder[v] + "),  dest: " + dest +  "(" + vOrder[dest] + "), minOrder: " + minOrder + ", maxOrder: " + maxOrder);
							var otherVirtualEdge = false;
							var goesOver = [];
							for (var o = minOrder; o < maxOrder; o++) {
								var w = this.order.order[r][o];
								if (this.GG.isPlaceholder(w)) {
									continue;
								}
								if (this.GG.isRelationship(w)) {
									minLevel = Math.max(minLevel, 2);
								}
								if (this.GG.isPerson(w)) {
									minLevel = Math.max(minLevel, 3);
								}
								if (this.GG.isVirtual(w) && this.GG.getInEdges(w)[0] != v) {
									otherVirtualEdge = true;
								}
								goesOver.push(w);
							}
							nextVerticalLevel = Math.max(nextVerticalLevel, minLevel);
							//console.log("attaching ->" + dest + "(" + u + ") at attach port " + nextAttachPort + " and level " + nextVerticalLevel);
							verticalLevels.outEdgeVerticalLevel[v][u] = { attachlevel: nextAttachPort, verticalLevel: nextVerticalLevel, numAttachLevels: edges.length };

							//------------------------------
							if (minLevel >= 2 || (minLevel == 1 && otherVirtualEdge)) {
								// potentially crossing some other relatioship edges: add to the set of edges to be optimized

								var left_x = Math.min(v_x, this.positions[dest]);
								var right_x = Math.max(v_x, this.positions[dest]);
								var down_x = this.positions[dest];

								// if the edge is going upwards need to take that into account when positioning edges
								// on this rank, not on the rank of the other parent
								var top_x = Infinity;
								if (dest == u) {                      // same as !this.GG.isVirtual(u)
									var parents = this.GG.getInEdges(u);
									var otherParent = (parents[0] == v) ? parents[1] : parents[0];
									if (this.GG.isVirtual(otherParent)) {       // can only be if the edge goes upwards since relationship nodes
										top_x = this.positions[otherParent];    //  are always ranked at the rank of the lower-ranked partner
										if (top_x > right_x)
											right_x = top_x;
										if (top_x < left_x)
											left_x = top_x;
									}
								}

								edgeInfo.push({ "v": v, "u": u, "v_x": v_x, "left_x": left_x, "right_x": right_x, "down_x": down_x, "top_x": top_x, "over": goesOver });
								initLevels.push(nextVerticalLevel);
								if (!relEdges.hasOwnProperty(u))
									relEdges[u] = [];
								relEdges[u].push(edgeInfo.length - 1);
							}
							//------------------------------

							nextAttachPort++;
							nextVerticalLevel++;
						}

						return (nextVerticalLevel - 1);
					}.bind(this);

					var partnerInfo = this._findLeftAndRightPartners(v);
					//console.log("Asigning left edges");
					var maxLeftLevel = positionEdgesOnOneSide(partnerInfo.leftPartners);
					//console.log("Asigning right edges");
					var maxRightLevel = positionEdgesOnOneSide(partnerInfo.rightPartners);

					numLevels = Math.max(numLevels, Math.max(maxLeftLevel, maxRightLevel));
				}
			}

			if (edgeInfo.length > 1) {    // if at most one edge crosses other vertices - we know everything is already laid out perfectly

				for (var e = 0; e < edgeInfo.length; e++) {
					if (!edgeInfo[e].hasOwnProperty("edgeComplement")) {
						var nextRel = edgeInfo[e].u;
						var nextEdges = relEdges[nextRel];
						if (nextEdges.length > 1) {
							var otherEdge = (nextEdges[0] == e) ? nextEdges[1] : nextEdges[0];
							edgeInfo[e]["edgeComplement"] = otherEdge;
							edgeInfo[otherEdge]["edgeComplement"] = e;
						}
					}
				}

				// compose the "crossing score" function which, given edgeInfo + which horizontal line is higher,
				// can tell the number of crossings between two node-to-relationship edges
				var pairScoreFunc = function (edge1, edge2, edge1level, edge2level, levels) {
					//
					// general form of a displayed edges is one of:
					// (where the solid line is part of the edge and the dotted part is treated as a separate edge related to the other partner or some other node)
					//
					// a)             ___________                           .....                   <-- level 2   \
					//            ___/           \                         .     .                                 }  <--- between rank R and R-1
					//     [node1]......[other]   \_____[relationship]..../       \....[node2]      <-- level 1   /
					//                    .                   |
					//                    .                   |
					//       ^                                ^
					//     left_x & v_x               right_x & down_x      (no top_x)
					//
					// b)                                                    ........[node2]                          <--- on some other rank
					//                _________                              |
					//               /         \                             |
					//     [node1]__/   [...]   \_____[relationship]_____[virtual]        <--- this virtual node is the "otherParent" of relationship
					//                                      |
					//                                      |
					//       ^                              ^                ^
					//     left_x & v_x                  down_x       right_x & top_x
					//
					// c)            _________
					//              /         \
					//     [node]__/   [...]   \__[virtual]
					//                               |
					//                               |
					//                               .......[relationship].....[node2]                                <--- on some other rank
					//       ^                       ^
					//     left_x & v_x      right_x & down_x     (no top_x)

					if (edgeInfo[edge1].right_x <= edgeInfo[edge2].left_x ||
						edgeInfo[edge1].left_x >= edgeInfo[edge2].right_x)
						return 0;                                              // edges do not overlap => no penalty for any level assignment

					if (edge1level == edge2level) return Infinity;              // intersect and at the same level => forbidden => (penalty == Infinity)

					if (edge2level > edge1level) {
						var tmpEdge = edge1;
						var tmpLevel = edge1level;
						edge1 = edge2;
						edge1level = edge2level;
						edge2 = tmpEdge;
						edge2level = tmpLevel;
					}

					// edge1 is the upper edge by now

					if (edgeInfo[edge1].v == edgeInfo[edge2].v &&
						edgeInfo[edge1].direction == edgeInfo[edge2].direction &&
						edgeInfo[edge1].attachLevel < edgeInfo[edge2].attachLevel) {
						return Infinity;                 // edges originating from the same vertex in the same direction
						// should keep their relative positioning, period
					}

					// edge1 completely overlaps edge2 and is above - this is optimal, penalty = 0
					if (edgeInfo[edge1].left_x <= edgeInfo[edge2].left_x && edgeInfo[edge1].right_x >= edgeInfo[edge2].right_x)
						return 0;
					// should overlap but instead is below - 2 unnecessary intersections
					if (edgeInfo[edge1].left_x >= edgeInfo[edge2].left_x && edgeInfo[edge1].right_x <= edgeInfo[edge2].right_x)
						return 2;

					var extraIntersections = 1.0;

					// edges cross: if lower edge has top_x and it crosses the other edge -> report 1 unnecessary crossing
					if (edgeInfo[edge2].top_x >= edgeInfo[edge1].left_x && edgeInfo[edge2].top_x <= edgeInfo[edge1].right_x)
						extraIntersections++;

					// [edge1] ------\           /- - - - - [edge1-complement]
					//               |           |
					// [edge2] ------1-----------2-------
					//               |           |
					//               \___[rel]_ _/
					//                     |
					//
					// in a case like this, [rel] will be moved to a position above [edge2] and instead of
					// two intersection {1,2} there will be only one intersection of downward egge with edge2.
					// So if a case like this is detected we subtract 0.4 crossings from intersections 1 and 2
					// (and from minimum score as well) - as long as there is [edge1-complement]
					//
					if (edgeInfo[edge1].hasOwnProperty("edgeComplement") &&
						(!levels || levels[edgeInfo[edge1].edgeComplement] > edge2level)) {
						if (edgeInfo[edge1].down_x >= edgeInfo[edge2].left_x && edgeInfo[edge1].down_x <= edgeInfo[edge2].right_x)
							extraIntersections -= 0.4;
					}

					return extraIntersections;
				}

				//console.log("[rank " + r + "] Init vertical relatioship levels: " +  Helpers.stringifyObject(initLevels));

				var optimizer = new VerticalPosIntOptimizer(pairScoreFunc, initLevels, initLevels);  // init level == min level

				var relEdgeLevels = optimizer.computeVerticalPositions(5, 500);

				//console.log("[rank " + r + "] Final vertical relatioship levels: " +  Helpers.stringifyObject(relEdgeLevels));

				numLevels = 0;
				// place computed levels where they ultimately belong
				for (var i = 0; i < edgeInfo.length; i++) {
					verticalLevels.outEdgeVerticalLevel[ edgeInfo[i].v ][ edgeInfo[i].u ].verticalLevel = relEdgeLevels[i];
					if (relEdgeLevels[i] > numLevels)
						numLevels = relEdgeLevels[i];
				}

				// optimize cases where an edge has rank > 1 because it supposedly goes over a relationship, but all
				// relationships it goes over are raised because all their edges have higher levels.
				// In such a case it looks beter when the edge in question is re-ranked back to rank 1
				for (var i = 0; i < edgeInfo.length; i++) {
					// optimize cases where an edge has rank 2 (because it goes over a relationship), but all
					// relationships it goes over are raised => re-rank to rank 1
					var level = relEdgeLevels[i];
					if (level > 1) {
						var lowerLevel = true;
						for (var e = 0; e < edgeInfo[i].over.length; e++) {
							var w = edgeInfo[i].over[e];
							if (!this.GG.isRelationship(w)) {
								lowerLevel = false;
								break;
							}
							var parents = this.GG.getParents(w);
							if (verticalLevels.outEdgeVerticalLevel[ parents[0] ][ w ].verticalLevel <= level ||
								verticalLevels.outEdgeVerticalLevel[ parents[1] ][ w ].verticalLevel <= level) {
								lowerLevel = false;
								break;
							}
						}
						if (lowerLevel)
							verticalLevels.outEdgeVerticalLevel[ edgeInfo[i].v ][ edgeInfo[i].u ].verticalLevel = 1;
					}
				}
			}

			verticalLevels.rankVerticalLevels[r - 1] += Math.max(0, (numLevels - 2));
		}

		//console.log("Vert child:         " + Helpers.stringifyObject(verticalLevels.childEdgeLevel));
		//console.log("Vert relationships: " + Helpers.stringifyObject(verticalLevels.outEdgeVerticalLevel));
		//console.log("Vert levels:        " + Helpers.stringifyObject(verticalLevels.rankVerticalLevels));

		return verticalLevels;
	},

	_findLeftAndRightPartners: function (v, useOrdering) {
		var ordering = useOrdering ? useOrdering.vOrder : this.order.vOrder;   // useOrdering is passed when thi sis called from the initial ordering procedure

		var rank = this.ranks[v];
		var orderV = ordering[v];
		var outEdges = this.GG.getOutEdges(v);

		var leftEdges = [];
		var rightEdges = [];

		for (var j = 0; j < outEdges.length; j++) {
			var rel = outEdges[j];
			if (this.ranks[rel] != rank) continue;
			if (ordering[rel] < orderV)
				leftEdges.push(rel);
			else
				rightEdges.push(rel);
		}

		var byDistToV = function (a, b) {
			var dist1 = Math.abs(ordering[a] - orderV);
			var dist2 = Math.abs(ordering[b] - orderV);
			return dist1 - dist2;
		};
		leftEdges.sort(byDistToV);
		rightEdges.sort(byDistToV);

		//console.log("v: " + v + ", leftP: " + Helpers.stringifyObject(leftEdges) + ", rightP: " + Helpers.stringifyObject(rightEdges));
		return { "leftPartners": leftEdges, "rightPartners": rightEdges };
	},

	// finds the bes tposition to insert a new twin of v which has the given set of relationships
	findBestTwinInsertPosition: function (v, insertedTwinRelationships, useOrdering) {     // useOrdering is passed when this is called from the initial ordering procedure
		var allTwins = this.GG.getAllTwinsOf(v);

		var rank = this.ranks[v];
		var rankOrder = useOrdering ? useOrdering.order[rank] : this.order.order[rank];
		var vOrder = useOrdering ? useOrdering.vOrder : this.order.vOrder;

		var byOrder = function (a, b) {
			return vOrder[a] - vOrder[b];
		};
		allTwins.sort(byOrder);

		// for each position [left of leftmost twin, ... ,right of rightmost twin] the total number
		// of partnership edges originating form all twins right of position going left of position
		// plus all edges from left of position going right of position
		// plus number of crossings due to edges to nodes in "insertedTwinRelationships" crossing other twins
		var numEdgesAcross = [];
		for (var i = 0; i <= allTwins.length; i++)
			numEdgesAcross[i] = 0;

		//console.log("edges across: " + Helpers.stringifyObject(numEdgesAcross));

		// for each position compute number of edge crossings due to new twin edges
		var leftMostTwinOrder = vOrder[allTwins[0]];
		for (var i = 0; i < insertedTwinRelationships.length; i++) {
			var rel = insertedTwinRelationships[i];
			var relOrder = vOrder[rel];

			if (relOrder < leftMostTwinOrder)
				for (var j = 1; j <= allTwins.length; j++) // if we insert the twin at any position other then leftmost new edges will cross all twins to the left
					numEdgesAcross[j] += j;
			else
				for (var j = 0; j < allTwins.length; j++)  // if we insert the twin at any position other then rightmost new edges will cross all twins to the right
					numEdgesAcross[j] += (allTwins.length - j);
		}

		//console.log("after self edges - edges across: " + Helpers.stringifyObject(numEdgesAcross));

		// for each position compute number of edge crossings due to existing twin edges
		for (var i = 0; i < allTwins.length; i++) {
			var partnerInfo = this._findLeftAndRightPartners(allTwins[i], useOrdering);
			var numLeftOf = partnerInfo.leftPartners.length;
			var numRightOf = partnerInfo.rightPartners.length;

			// TODO: can improve a bit when two of the twins are in a relationship and there are other twins
			for (var j = 0; j <= i; j++)
				numEdgesAcross[j] += numLeftOf;
			for (var j = i + 1; j <= allTwins.length; j++)
				numEdgesAcross[j] += numRightOf;

			//console.log("after twin " + allTwins[i] + " (leftOf: " + numLeftOf + ", rightOf: " + numRightOf + ") -> edges across: " + Helpers.stringifyObject(numEdgesAcross));
		}

		//console.log("twin penalties: " + Helpers.stringifyObject(numEdgesAcross));
		var orderOfLeftMostTwin = vOrder[allTwins[0]];
		var minEdgeCrossLocation = Helpers.indexOfLastMinElementInArray(numEdgesAcross);   // (index == 0) => "insert before leftmost" => (order := orderOfLeftMostTwin)

		var order = orderOfLeftMostTwin + minEdgeCrossLocation;
		// increment the order by the number of relaitonship nodes found inbetween the twins,
		// so that minEdgeCrossLocation corresponds to the gap between the expected two twins
		for (var i = orderOfLeftMostTwin + 1; i < order; i++) {
			var nodeID = rankOrder[i];
			if (this.GG.isRelationship(nodeID))
				order++;
		}

		//console.log("edges across: " + Helpers.stringifyObject(numEdgesAcross));
		//console.log("BEST INSERT POSITION for a twin of " + v + " with edges to " + Helpers.stringifyObject(insertedTwinRelationships) + " is " + order);
		return order;
	},

	computeRankY: function (oldRanks, oldRankY) {
		var rankY = [0, 0];  // rank 0 is virtual, rank 1 starts at relative 0

		for (var r = 2; r <= this.maxRank; r++) {
			var yDistance = (this.isChildhubRank(r)) ? this._computePersonRankHeight(r - 1) : this.yDistanceChildhubToNode;

			// note: yExtraPerHorizontalLine * vertLevel.rankVerticalLevels[r] part comes from the idea that if there are many
			//       horizontal lines (childlines & relationship lines) between two ranks it is good to separate those ranks vertically
			//       more than ranks with less horizontal lines between them
			rankY[r] = rankY[r - 1] + yDistance + this.yExtraPerHorizontalLine * (Math.max(this.vertLevel.rankVerticalLevels[r - 1], 1) - 1);
		}

		if (oldRanks && oldRankY) {
			// attempt to keep the old Y coordinate for the node with ID == 0 to minimize UI redraws
			var oldRank = oldRanks[0];
			var newRank = this.ranks[0];
			var oldY = oldRankY[oldRank];
			var newY = rankY[newRank];
			var shiftAmount = newY - oldY;
			for (var r = 0; r <= this.maxRank; r++) {
				rankY[r] -= shiftAmount;
			}
		}

		return rankY;
	},

	isChildhubRank: function (r) {
		for (var i = 0; i < this.order.order[r].length; i++) {
			if (this.GG.isPerson(this.order.order[r][i]) ||
				this.GG.isRelationship(this.order.order[r][i])) return false;
			if (this.GG.isChildhub(this.order.order[r][i])) return true;
		}
		return true;
	},

	_computePersonRankHeight: function (r) {
		var height = this.yDistanceNodeToChildhub;

		var maxNumLinesInComments = 0;
		for (var i = 0; i < this.order.order[r].length; i++) {
			if (this.GG.isPerson(this.order.order[r][i])) {
				var person = this.order.order[r][i];
				var numLabelLines = 0;
				var personProperties = this.GG.properties[person];

				if (personProperties.hasOwnProperty("comments")) {
					var comments = personProperties.comments.replace(/^\s+|\s+$/g, '');
					// count number of new lines
					numLabelLines += ((comments.match(/\n/g) || []).length + 1);
				}
				var dob = personProperties.hasOwnProperty("dob") ? new PedigreeDate(personProperties.dob) : null;
				var dod = personProperties.hasOwnProperty("dod") ? new PedigreeDate(personProperties.dod) : null;
				if (dob !== null && dob.isComplete()) {
					numLabelLines++;
				}
				if (dod !== null && dod.isComplete()) {
					numLabelLines++;
				}
				// if both DOB and DOD is given 2 lines are assumed. However this only happens
				// when age is in years (and thus is displayed as e.g. "45 y")
				if (dob !== null && dob.isComplete() && dod !== null && dod.isComplete()) {
					var age = AgeCalc.getAge(dob, dod);
					if (age.length < 2 || age.indexOf(" y") < 0) {
						numLabelLines--;
					}
				}
				if (personProperties.hasOwnProperty("lName") || personProperties.hasOwnProperty("fName")) {
					numLabelLines++;
				}
				if (personProperties.hasOwnProperty("externalID")) {
					numLabelLines++;
				}
				if (editor && editor.getPreferencesManager().getConfigurationOption("displayCancerLabels")) {
					// count number of cancer labels
					if (personProperties.hasOwnProperty("cancers")) {
						for (var cancer in personProperties.cancers) {
							if (personProperties.cancers.hasOwnProperty(cancer)) {
								if (personProperties.cancers[cancer].hasOwnProperty("Affected")) {
									if (personProperties.cancers[cancer].affected) {
										numLabelLines++;
									}
								}
							}
						}
					}
				}
				if (numLabelLines > maxNumLinesInComments) {
					maxNumLinesInComments = numLabelLines;
				}
			}
		}
		if (maxNumLinesInComments > 4) {
			height += (maxNumLinesInComments - 4) * this.yCommentLineHeight;
		}
		return height;
	},

	computeNodeY: function (rank, level) {
		return this.rankY[rank] + (level - 1) * this.yExtraPerHorizontalLine;
	},

	computeRelLineY: function (rank, attachLevel, verticalLevel) {
		var attachY = this.rankY[rank] - (attachLevel) * this.yAttachPortHeight;

		var relLineY = this.rankY[rank];

		if (verticalLevel == 1) {
			// going above another line
			relLineY -= (attachLevel) * this.yAttachPortHeight;
		} else if (verticalLevel == 2) {
			// going above relationship node
			relLineY -= this.yExtraPerHorizontalLine * 1.25;
		} else {
			relLineY -= verticalLevel * this.yExtraPerHorizontalLine;
		}

		return {"attachY": attachY, "relLineY": relLineY };
	},
	//========================================[vertical separation for horizontal edges]=

	//=[position]========================================================================

	displayGraph: function (xcoord, message) {
		TIME_DRAWING_DEBUG = 0;
		if (!DISPLAY_POSITIONING_DEBUG) return;

		var debugTimer = new Helpers.Timer();

		var renderPackage = { convertedG: this.GG,
			ranks: this.ranks,
			ordering: this.order,
			positions: xcoord,
			consangr: this.consangr };

		debug_display_processed_graph(renderPackage, 'output', true, message);

		TIME_DRAWING_DEBUG = debugTimer.report();
	},

	position: function () {
		var longEdges = this.find_long_edges();  // pre-find long edges for performance reasons

		var xcoord = new XCoord(null, this);
		//Helpers.printObject(xcoord.xcoord);

		//this.displayGraph(xcoord.xcoord, 'init');

		this.try_shift_right(xcoord, true, false);
		this.try_shift_right(xcoord, false, true);
		xcoord.normalize();

		//this.displayGraph(xcoord.xcoord, 'firstAdj');
		Helpers.printObject(xcoord.xcoord);

		var xbest = xcoord.copy();
		var bestScore = this.xcoord_score(xbest);

		for (var i = 0; i <= this.maxXcoordIterations; i++) {
			this.try_shift_right(xcoord, true, true);
			this.try_straighten_long_edges(longEdges, xcoord);

			//this.displayGraph(xcoord.xcoord, 'Adj' + i);
			xcoord.normalize();

			var score = this.xcoord_score(xcoord);

			if (score.isBettertThan(bestScore)) {
				xbest = xcoord.copy();
				bestScore = score;
			}
			else
				break;
		}

		//this.displayGraph(xbest.xcoord, 'final');
		Helpers.printObject(xbest.xcoord);

		return xbest.xcoord;
	},

	xcoord_score: function (xcoord, considerOnlyRank, considerEdgesFromAbove, considerEdgesToBelow, fromOrderOnRank) {
		// Returns xcoord score, the less the better.
		//
		//  Score equal to the     Σ     (  Ω(e) * ω(e) * X[w] − X[v]  )
		//                      e = (v,w)
		//
		//   where  Ω(e) is an internal value distinct from the input edge weight ω(e),
		//   defined to favor straightening long edges and edges from relationships to child nodes:
		//   - for long edges, it is more important to reduce the horizontal distance between virtual
		//   nodes, so chains may be aligned vertically and thus straightened. The failure to
		//   straighten long edges can result in a ‘‘spaghetti effect’’. Thus Ω(e) is higher for
		//   edges between virtual edges
		//   - for relationship-to-child nodes, it just produces a visually more pleasing arrangement
		//   - Ω(e) is computed by the edge_importance_to_straighten() function

		var score = new XCoordScore(this.GG.getMaxRealVertexId());

		var rankFrom = 1;
		var rankTo = this.maxRank;
		if (typeof(considerOnlyRank) != "undefined") {
			// we have edges:
			//   1) r-1 -> r
			//   2) r   -> r
			//   3) r   -> r+1
			// If not consider above, need to exclude edges of type 1
			// If not consider below, need to exclude edges of type 3
			// Always care about edges of type 2

			rankFrom = considerOnlyRank - 1;
			rankTo = considerOnlyRank;
			if (rankFrom == 0) rankFrom = 1;
			if (!considerEdgesFromAbove) rankFrom = considerOnlyRank;  // exclude edges of type 1
		}

		for (var r = rankFrom; r <= rankTo; r++) {
			var len = this.order.order[r].length;

			var fromOrder = 0;
			if (typeof(considerOnlyRank) != "undefined" && r == considerOnlyRank)
				fromOrder = fromOrderOnRank;

			for (var i = fromOrder; i < len; ++i) {
				var v = this.order.order[r][i];

				var outEdges = this.GG.getOutEdges(v);
				var lenO = outEdges.length;

				for (var j = 0; j < lenO; ++j) {
					var u = outEdges[j];

					if (typeof(considerOnlyRank) != "undefined") {
						if (!considerEdgesToBelow && this.ranks[u] != considerOnlyRank)  // exclude edges of type 3
							continue;
						if (this.ranks[u] == considerOnlyRank && this.order.vOrder[u] < fromOrderOnRank)
							continue;
						//if (considerEdgesFromAbove && considerEdgesToBelow && this.ranks[u] == considerOnlyRank && this.GG.isRelationship(v))
						//    continue;
					}

					// have an edge from 'v' to 'u' with weight this.GG.weights[v][u]

					// determine edge type: from real vertex to real, real to/from virtual or v. to v.
					var coeff = this.edge_importance_to_straighten(v, u);

					var w = this.xCoordEdgeWeightValue ? this.GG.weights[v][u] : 1.0;

					var dist = Math.abs(xcoord.xcoord[v] - xcoord.xcoord[u]);

					var thisScore = coeff * w * dist;

					//if (this.GG.isChildhub(v)) thisScore *= Math.min( 15.0, dist );
					//if (mostCompact) thisScore *= dist;  // place higher value on shorter edges

					score.add(thisScore);

					score.addEdge(v, u, dist);
				}
			}
		}

		//console.log("XcoordScore: " + Helpers.stringifyObject(score));
		return score;
	},

	edge_importance_to_straighten: function (fromV, toV) {
		if (this.GG.isRelationship(toV)) return 1.0;

		if (!this.GG.isVirtual(fromV) && this.GG.isVirtual(toV)) return 1.5;

		if (this.GG.isRelationship(fromV)) return 8.0;

		if (this.GG.isVirtual(fromV)) {
			if (this.GG.isVirtual(toV)) return 16.0;
			return 4.0;
		}
		return 2.0;
	},

	try_shift_right: function (xcoord, scoreQualityOfNodesBelow, scoreQualityOfNodesAbove) {
		// goes over all ranks (top to bottom or bottom to top, depending on iteration)
		// and tries to shift vertices right one at a time. If a shift is good leaves it,
		// if not keeps going further.
		//
		// more precisely, tries to shift the vertex to the desired position up to and including
		// the position optimal according to the median rule, searching the positions in between.
		// Since we are not guaranteed the strictly increasing/decreasing score "smart" searches
		// such as binary search might not work well.

		//this.displayGraph( xcoord.xcoord, "shiftright-start" );
		for (var rr = 0; rr <= this.maxRank; rr++) {

			// go from top to bottom or bottom to top depending on which ranks (above or below)
			// we consider when trying to shift the nodes
			var r;
			if (!scoreQualityOfNodesAbove)
				r = this.maxRank - rr;
			else
				r = rr;

			if (r == 0) continue;  // disregard all discarded vertices

			var considerEdgesToBelow = (scoreQualityOfNodesBelow || (r == 1)) && (r != this.maxRank);
			var considerEdgesFromAbove = (scoreQualityOfNodesAbove || r == this.maxRank) && (r != 1);

			var toO = 0;
			var fromO = this.order.order[r].length - 1;

			for (var i = fromO; i >= toO; i--) {

				var v = this.order.order[r][i];

				// we care about the quality of resulting graph only for some ranks: sometimes
				// only above the change, sometimes only below the change; in any case we know
				// the change of position of vertices on this rank is not going to affect ranks
				// far away, so we can only compute the score for the ranks we care about.

				var median = this.compute_median(v, xcoord, considerEdgesFromAbove, considerEdgesToBelow);

				//if (v == 28)
				//    console.log("[28] median: " + median);

				if (median != median)
					median = xcoord.xcoord[v];

				var maxShift = median - xcoord.xcoord[v];

				// speed optimization: shift which we can do without disturbing other vertices and
				//                     thus requiring no backup/restore process
				var noDisturbMax = xcoord.getRightMostNoDisturbPosition(v);
				var maxSafeShift = (noDisturbMax < median) ? noDisturbMax - xcoord.xcoord[v] : maxShift;

				//if (v==28)
				//    console.log("shiftright-rank-" + r + "-v-" + v + "  -->  DesiredShift: " + maxShift + ", maxSafe: " + maxSafeShift);

				if (maxShift <= 0) continue;

				var bestShift = 0;
				var bestScore = this.xcoord_score(xcoord, r, considerEdgesFromAbove, considerEdgesToBelow, i);
				var shiftAmount = maxShift;

				//if (v==28)
				//    console.log("InitScore: " + Helpers.stringifyObject(bestScore));
				//if ( r == 7 ) this.displayGraph( xcoord.xcoord, "shiftright-rank-" + r + "-v-" + v + "(before)");

				do
				{
					var newScore;

					if (shiftAmount <= maxSafeShift) {
						xcoord.xcoord[v] += shiftAmount;
						newScore = this.xcoord_score(xcoord, r, considerEdgesFromAbove, considerEdgesToBelow, i);
						xcoord.xcoord[v] -= shiftAmount;
					}
					else {
						var newCoord = xcoord.copy();
						newCoord.shiftRightAndShiftOtherIfNecessary(v, shiftAmount);
						newScore = this.xcoord_score(newCoord, r, considerEdgesFromAbove, considerEdgesToBelow, i);
					}

					//if (v==9 || v == 10)
					//    console.log("Shift: " + shiftAmount + ", score: " + newScore.score + " / " + Helpers.stringifyObject(newScore.inEdgeMaxLen));

					if (newScore.isBettertThan(bestScore)) {
						bestShift = shiftAmount
						bestScore = newScore;
					}

					shiftAmount -= 1;
				}
				while (shiftAmount >= Math.max(0, maxSafeShift));

				if (bestShift > 0) {
					xcoord.shiftRightAndShiftOtherIfNecessary(v, bestShift);
				}
				//if ( r == 7 ) this.displayGraph( xcoord.xcoord, "shiftright-rank-" + r + "-v-" + v );
			}

			//this.displayGraph( xcoord.xcoord, "shiftright-rank-" + r + "-end");
		}
	},

	compute_median: function (v, xcoord, considerAbove, considerBelow) {
		var positionsAbove = [];
		var positionsBelow = [];

		var allEdgesWithWeights = this.GG.getAllEdgesWithWeights(v);

		for (var u in allEdgesWithWeights) {
			if (allEdgesWithWeights.hasOwnProperty(u)) {
				if (u == v) continue;
				var weight = allEdgesWithWeights[u]["weight"];

				var coeff = allEdgesWithWeights[u]["out"] ?
					this.edge_importance_to_straighten(v, u) :
					this.edge_importance_to_straighten(u, v);

				var w = this.xCoordEdgeWeightValue ? weight : 1.0;

				var score = coeff * w;

				for (var i = 0; i < score; i++) {
					if (this.ranks[u] <= this.ranks[v]) {
						positionsAbove.push(xcoord.xcoord[u]);
					}
					if (this.ranks[u] >= this.ranks[v]) {
						positionsBelow.push(xcoord.xcoord[u]);
					}
				}
			}
		}

		var numericSortFunc = function (a, b) {
			return a - b;
		};

		var median = undefined;
		var medianAbove = undefined;
		var medianBelow = undefined;

		if ((considerAbove || this.GG.isVirtual(v)) && positionsAbove.length > 0) {
			positionsAbove.sort(numericSortFunc);
			var middle = Math.ceil(positionsAbove.length / 2);
			if (middle >= positionsAbove.length) {
				middle = positionsAbove.length - 1;
			}
			if (positionsAbove.length % 2 == 0)
				medianAbove = Math.floor((positionsAbove[middle] + positionsAbove[middle - 1]) / 2);
			else
				medianAbove = positionsAbove[middle];
		}
		if ((considerBelow || this.GG.isVirtual(v)) && positionsBelow.length > 0) {
			positionsBelow.sort(numericSortFunc);
			var middle = Math.ceil(positionsBelow.length / 2);
			if (middle >= positionsBelow.length)
				middle = positionsBelow.length - 1;
			if (positionsBelow.length % 2 == 0)
				medianBelow = Math.floor((positionsBelow[middle] + positionsBelow[middle - 1]) / 2);
			else
				medianBelow = positionsBelow[middle];
		}

		if (medianAbove !== undefined && medianBelow !== undefined)
			median = Math.max(medianAbove, medianBelow);
		else if (medianAbove !== undefined)
			median = medianAbove;
		else
			median = medianBelow;

		return Math.ceil(median);
	},

	try_straighten_long_edges: function (longEdges, xcoord) {
		// try to straigten long edges without moving any other vertices
		var improved = false;

		for (var e = 0; e < longEdges.length; ++e) {
			var chain = longEdges[e];
			//console.log("trying to straighten edge " + Helpers.stringifyObject(chain));

			// 1) try to straighten by shifting the head

			// go over all nodes from head to tail looking for a bend and trying
			// to move the head to remove the bend
			var currentCenter = xcoord.xcoord[chain[0]];
			var corridorLeft = xcoord.getLeftMostNoDisturbPosition(chain[0]);
			var corridorRight = xcoord.getRightMostNoDisturbPosition(chain[0]);

			// go over all nodes from head to tail looking for a bend
			for (var i = 1; i < chain.length; ++i) {
				var nextV = chain[i];
				var nextCenter = xcoord.xcoord[nextV];
				if (nextCenter != currentCenter) {
					if (nextCenter >= corridorLeft && nextCenter <= corridorRight) {
						// all the nodes above can be shifted to this location!
						for (var j = 0; j < i; ++j) {
							xcoord.xcoord[chain[j]] = nextCenter;
						}
						improved = true;
						currentCenter = nextCenter;
					}
					else break;
				}
				// narrow the coridor to the common available space including this vertex as well
				corridorLeft = Math.max(corridorLeft, xcoord.getLeftMostNoDisturbPosition(nextV));
				corridorRight = Math.min(corridorRight, xcoord.getRightMostNoDisturbPosition(nextV));
				if (corridorRight < corridorLeft) break;  // no luck, can't straighten
			}

			// 2) try to straighten by shifting the tail

			// go over all nodes from tail to head looking for a bend and trying
			// to move the tail to remove the bend
			var lastNode = chain.length - 1;
			var currentCenter = xcoord.xcoord[chain[lastNode]];
			var corridorLeft = xcoord.getLeftMostNoDisturbPosition(chain[lastNode]);
			var corridorRight = xcoord.getRightMostNoDisturbPosition(chain[lastNode]);

			// go over all nodes from head to tail looking for a bend
			for (var i = lastNode - 1; i >= 0; --i) {
				var nextV = chain[i];
				var nextCenter = xcoord.xcoord[nextV];
				if (nextCenter != currentCenter) {
					if (nextCenter >= corridorLeft && nextCenter <= corridorRight) {
						// all the nodes below can be shifted to this location!
						for (var j = lastNode; j > i; j--) {
							xcoord.xcoord[chain[j]] = nextCenter;
						}
						improved = true;
						currentCenter = nextCenter;
					}
					else break;
				}
				// narrow the coridor to the common available space including this vertex as well
				corridorLeft = Math.max(corridorLeft, xcoord.getLeftMostNoDisturbPosition(nextV));
				corridorRight = Math.min(corridorRight, xcoord.getRightMostNoDisturbPosition(nextV));
				if (corridorRight < corridorLeft) break;  // no luck, can't straighten
			}
		}

		return improved;
	},
	//========================================================================[position]=

	find_long_edges: function () {
		var longEdges = [];

		var maxRealId = this.GG.getMaxRealVertexId();
		var numVert = this.GG.getNumVertices();

		var checked = [];
		for (var v = maxRealId + 1; v < numVert; v++)
			checked[v] = false;

		for (var v = maxRealId + 1; v < numVert; v++) {

			if (checked[v] || this.ranks[v] == 0) continue;

			// find a long edge - an edge connecting real nodes of non-neighbouring ranks,
			// consisting of virtual vertices on intermediate ranks (plus source/target)

			// start from head node - the first virtual node
			var head = v;
			while (this.GG.isVirtual(this.GG.getInEdges(head)[0]))
				head = this.GG.getInEdges(head)[0];

			var chain = [];
			var next = head;

			// go towards the tail through out-edges
			do {
				checked[next] = true;
				chain.push(next);
				next = this.GG.getOutEdges(next)[0];
			}
			while (this.GG.isVirtual(next));
			;

			console.log("Found long edge " + Helpers.stringifyObject(chain));
			longEdges.push(chain);
		}
		return longEdges;
	}
};


//-------------------------------------------------------------

var DISPLAY_POSITIONING_DEBUG = false;
var TIME_DRAWING_DEBUG = 0;

function make_dynamic_positioned_graph(inputG, debugOutput) {
	var horizontalPersonSeparationDist = 10; // same relative units as in inputG.width fields. Min distance between two person nodes
	var horizontalRelSeparationDist = 6;  // same relative units as in inputG.width fields. Min distance between a relationship node and other nodes

	var orderingInitBuckets = 5;             // default: 5. It may take up to ~factorial_of_this_number iterations. See ordering()

	var orderingIterations = 24;            // paper used: 24. Up to so many iterations are spent optimizing initial ordering

	var xcoordIterations = 4;             // default: 8

	var timer = new Helpers.Timer();

	if (debugOutput)
		DISPLAY_POSITIONING_DEBUG = true;
	else
		DISPLAY_POSITIONING_DEBUG = false;
	var drawGraph = new PositionedGraph(inputG,
		horizontalPersonSeparationDist,
		horizontalRelSeparationDist,
		orderingInitBuckets,
		orderingIterations,
		xcoordIterations);  // display debug

	console.log("=== Running time: " + timer.report() + "ms ==========");

	return new DynamicPositionedGraph(drawGraph);
}


// DynamicPositionedGraph adds support for online modifications and provides a convenient API for UI implementations
DynamicPositionedGraph = function (drawGraph) {
	this.DG = drawGraph;

	this._heuristics = new Heuristics(drawGraph);  // heuristics & helper methods separated into a separate class

	this._heuristics.improvePositioning();

	this._onlyProbandGraph = [
		{ name: 'proband' }
	];
};

DynamicPositionedGraph.makeEmpty = function (layoutRelativePersonWidth, layoutRelativeOtherWidth) {
	var baseG = new BaseGraph(layoutRelativePersonWidth, layoutRelativeOtherWidth);
	var positionedG = new PositionedGraph(baseG);
	return new DynamicPositionedGraph(positionedG);
}

DynamicPositionedGraph.prototype = {

	isValidID: function (id) {
		if (id < 0 || id > this.DG.GG.getMaxRealVertexId())
			return false;
		if (!this.DG.GG.isPerson(id) && !this.DG.GG.isRelationship(id))
			return false;
		return true;
	},

	getMaxNodeId: function () {
		return this.DG.GG.getMaxRealVertexId();
	},

	isPersonGroup: function (id) {
		return this.getProperties(id).hasOwnProperty("numPersons");
	},

	isPerson: function (id) {
		return this.DG.GG.isPerson(id);
	},

	isRelationship: function (id) {
		return this.DG.GG.isRelationship(id);
	},

	isPlaceholder: function (id) {
		return this.DG.GG.isPlaceholder(id);
	},

	isAdoptedIn: function (id) {
		if (!this.isPerson(id))
			throw "Assertion failed: isAdopted() is applied to a non-person";
		return this.DG.GG.isAdoptedIn(id);
	},

	isAdoptedOut: function (id) {
		if (!this.isPerson(id))
			throw "Assertion failed: isAdopted() is applied to a non-person";
		return this.DG.GG.isAdoptedOut(id);
	},

	getGeneration: function (id) {
		var minRank = Math.min.apply(null, this.DG.ranks);
		return (this.DG.ranks[id] - minRank) / 2 + 1;
	},

	getOrderWithinGeneration: function (id) {
		if (!this.isPerson(id))
			throw "Assertion failed: getOrderWithinGeneration() is applied to a non-person";

		var order = 0;
		var rank = this.DG.ranks[id];
		for (var i = 0; i < this.DG.order.order[rank].length; i++) {
			var next = this.DG.order.order[rank][i];
			if (this.DG.GG.isPerson(next) && !this.DG.GG.isPlaceholder(next)) order++;
			if (next == id) break;
		}
		return order;
	},

	// returns null if person has no twins
	getTwinGroupId: function (id) {
		return this.DG.GG.getTwinGroupId(id);
	},

	// returns and array of twins, sorted by order left to right. Always contains at least "id" itself
	getAllTwinsSortedByOrder: function (id) {
		var twins = this.DG.GG.getAllTwinsOf(id);
		var vOrder = this.DG.order.vOrder;
		var byOrder = function (a, b) {
			return vOrder[a] - vOrder[b];
		};
		twins.sort(byOrder);
		return twins;
	},

	isChildless: function (id) {
		if (!this.getProperties(id).hasOwnProperty("childlessStatus"))
			return false;
		var res = (this.getProperties(id)["childlessStatus"] !== null);
		//console.log("Childless status of " + id + " : " + res);
		return res;
	},

	isChildlessByChoice: function (id) {
		if (!this.getProperties(id).hasOwnProperty("childlessStatus"))
			return false;
		var res = (this.getProperties(id)["childlessStatus"] == 'Childless');
		return res;
	},

	isInfertile: function (id) {
		if (!this.getProperties(id).hasOwnProperty("childlessStatus"))
			return false;
		var res = (this.getProperties(id)["childlessStatus"] == 'Infertile');
		return res;
	},

	isConsangrRelationship: function (id) {
		if (!this.isRelationship(id))
			throw "Assertion failed: isConsangrRelationship() is applied to a non-relationship";

		return this.DG.consangr.hasOwnProperty(id);
	},

	getProperties: function (id) {
		return this.DG.GG.properties[id];
	},

	setProperties: function (id, newSetOfProperties) {
		this.DG.GG.properties[id] = newSetOfProperties;
	},

	// returns false if this gender is incompatible with this pedigree; true otherwise
	setProbandData: function (patientObject) {
		// Note: we can't blank all patient properties here, since some are pedigree-specific
		// and not available in patient document and should be preserved in saved pedigree JSON

		// Fields which are loaded form the patient document are:
		// - first_name
		// - last_name
		// - sex
		// - date_of_birth
		// - date_of_death
		// - life_status
		// - external_id
		// - features + nonstandard_features
		// - disorders
		// - genes
		// - maternal_ethnicity + paternal_ethnicity (merged with own ethnicities entered in pedigree editor)

		if (patientObject.hasOwnProperty("patient_name")) {
			if (patientObject.patient_name.hasOwnProperty("first_name")) {
				this.DG.GG.properties[0].fName = patientObject.patient_name.first_name;
			} else {
				this.DG.GG.properties[0].fName = "";
			}
			if (patientObject.patient_name.hasOwnProperty("last_name")) {
				this.DG.GG.properties[0].lName = patientObject.patient_name.last_name;
			} else {
				this.DG.GG.properties[0].lName = "";
			}
		}

		var genderOK = true;
		if (patientObject.hasOwnProperty("sex")) {
			var probandSex = patientObject.sex;

			//Added for GEL(GenomicsEngland), this will get the proband Gender regardless of the format
			var genderString = probandSex.toLowerCase();
			if (genderString == "female" || genderString == "f" || genderString == "2")
				probandSex = "F";
			else if (genderString == "male" || genderString == "m" || genderString == "1")
				probandSex = "M";
			else if (genderString == "other" || genderString == "o" || genderString == "9")
				probandSex = "O";


			var possibleGenders = this.getPossibleGenders(0);
			if (!possibleGenders.hasOwnProperty(probandSex) || !possibleGenders[probandSex]) {
				probandSex = 'U';
				genderOK = false;
			}
			this.DG.GG.properties[0].gender = probandSex;
		}

		//commented for GEL(GenomicsEngland) .............................................................................................................
		//We need to load the proband dob and dod externally from import file or backend service
		//the following lines, will keep dob and dod for the proband and don't import new item into it
		//if (patientObject.hasOwnProperty("date_of_birth")) {
		//	var birthDate = new PedigreeDate(patientObject.date_of_birth);
		//	this.DG.GG.properties[0].dob = birthDate.getSimpleObject();
		//} else {
		//	delete this.DG.GG.properties[0].dob;
		//}
		//if (patientObject.hasOwnProperty("date_of_death")) {
		//	var deathDate = new PedigreeDate(patientObject.date_of_death);
		//	this.DG.GG.properties[0].dod = deathDate.getSimpleObject();
		//} else {
		//	delete this.DG.GG.properties[0].dod;
		//}
		if (patientObject.hasOwnProperty("life_status")) {
			var lifeStatus = patientObject["life_status"];
			if (lifeStatus == "Deceased" || lifeStatus == "Alive") {
				this.DG.GG.properties[0].lifeStatus = lifeStatus;
			}
		} else {
			delete this.DG.GG.properties[0].lifeStatus;
		}

		if (patientObject.hasOwnProperty("ethnicity")) {
			// e.g.: "ethnicity":{"maternal_ethnicity":["Yugur"],"paternal_ethnicity":[]}
			var ethnicities = [];
			if (patientObject.ethnicity.hasOwnProperty("maternal_ethnicity")) {
				ethnicities = patientObject.ethnicity.maternal_ethnicity.slice(0);
			}
			if (patientObject.ethnicity.hasOwnProperty("paternal_ethnicity")) {
				ethnicities = ethnicities.concat(patientObject.ethnicity.paternal_ethnicity.slice(0));
			}
			if (ethnicities.length > 0) {
				this.DG.GG.properties[0].ethnicities = Helpers.filterUnique(ethnicities);
			}
		}

		if (patientObject.hasOwnProperty("external_id")) {
			this.DG.GG.properties[0].externalID = patientObject.external_id;
		} else {
			delete this.DG.GG.properties[0].externalID;
		}

		//commented for GEL(GenomicsEngland) .............................................................................................................
		//We need to load the proband detail externally from import file or backend service
		//the following lines, will keep disorder and hpo for the proband and don't import new item into it
		//var hpoTerms = [];
		//if (patientObject.hasOwnProperty("features")) {
		//	// e.g.: "features":[{"id":"HP:0000359","label":"Abnormality of the inner ear","type":"phenotype","observed":"yes"},{"id":"HP:0000639","label":"Nystagmus","type":"phenotype","observed":"yes"}]
		//	for (var i = 0; i < patientObject.features.length; i++) {
		//		if ((patientObject.features[i].observed === true || patientObject.features[i].observed === "yes")
		//			&& patientObject.features[i].type == "phenotype") {
		//			hpoTerms.push(patientObject.features[i].id);
		//		}
		//	}
		//}
		//if (patientObject.hasOwnProperty("nonstandard_features")) {
		//	//e.g.: "nonstandard_features":[{"label":"freetext","type":"phenotype","observed":"yes","categories":[{"id":"HP:0001507","label":"Growth abnormality"},{"id":"HP:0000240","label":"Abnormality of skull size"}]}]
		//	for (var i = 0; i < patientObject.nonstandard_features.length; i++) {
		//		if ((patientObject.nonstandard_features[i].observed === true || patientObject.nonstandard_features[i].observed === "yes")
		//			&& patientObject.nonstandard_features[i].type == "phenotype") {
		//			hpoTerms.push(patientObject.nonstandard_features[i].label);
		//		}
		//	}
		//}
		//if (hpoTerms.length > 0) {
		//	this.DG.GG.properties[0].hpoTerms = hpoTerms;
		//} else {
		//	delete this.DG.GG.properties[0].hpoTerms;
		//}

		//var disorders = [];
		//if (patientObject.hasOwnProperty("disorders")) {
		//	// e.g.: "disorders":[{"id":"MIM:120970","label":"#120970 CONE-ROD DYSTROPHY 2; CORD2 ;;CONE-ROD DYSTROPHY; CORD;; CONE-ROD RETINAL DYSTROPHY; CRD; CRD2;; RETINAL CONE-ROD DYSTROPHY; RCRD2"},{"id":"MIM:190685","label":"#190685 DOWN SYNDROME TRISOMY 21, INCLUDED;; DOWN SYNDROME CHROMOSOME REGION, INCLUDED; DCR, INCLUDED;; DOWN SYNDROME CRITICAL REGION, INCLUDED; DSCR, INCLUDED;; TRANSIENT MYELOPROLIFERATIVE DISORDER OF DOWN SYNDROME, INCLUDED;; LEUKEMIA, MEGAKARYOBLASTIC, OF DOWN SYNDROME, INCLUDED"}]
		//	for (var i = 0; i < patientObject.disorders.length; i++) {
		//		var disorderID = patientObject.disorders[i].id;
		//		var match = disorderID.match(/^MIM:(\d+)$/);
		//		match && (disorderID = match[1]);
		//		disorders.push(disorderID);
		//	}
		//}
		//if (disorders.length > 0) {
		//	this.DG.GG.properties[0].disorders = disorders;
		//} else {
		//	delete this.DG.GG.properties[0].disorders;
		//}
		//.............................................................................................................................................

		var genes = [];
		if (patientObject.hasOwnProperty("genes")) {
			// e.g.: "genes":[{"gene":"E2F2","comments":""}]
			for (var i = 0; i < patientObject.genes.length; i++) {
				genes.push(patientObject.genes[i].gene);
			}
		}
		if (genes.length > 0) {
			this.DG.GG.properties[0].candidateGenes = genes;
		} else {
			delete this.DG.GG.properties[0].candidateGenes;
		}

		//This line is commented by Soheil for GEL(GenomicsEngland)
		//We don't need to validate if the proband Gender is the same as the defined proband
		//return genderOK;
		return true;
	},

	getPosition: function (v) {
		// returns coordinates of node v
		var x = this.DG.positions[v];

		var rank = this.DG.ranks[v];

		var vertLevel = this.DG.GG.isChildhub(v) ? this.DG.vertLevel.childEdgeLevel[v] : 1;

		var y = this.DG.computeNodeY(rank, vertLevel);

		if (this.DG.GG.isVirtual(v)) {
			var relId = this.DG.GG.downTheChainUntilNonVirtual(v);
			var personId = this.DG.GG.upTheChainUntilNonVirtual(v);

			var rankPerson = this.DG.ranks[personId];
			if (rank == rankPerson) {
				var level = this.DG.vertLevel.outEdgeVerticalLevel[personId][relId].verticalLevel;
				y = this.DG.computeRelLineY(rank, 0, level).relLineY;
			}

			var rankRelationship = this.DG.ranks[relId];
			if (rank == rankRelationship) {
				y = this.getPosition(relId).y;
			}
		}
		else if (this.isRelationship(v)) {
			var partners = this.DG.GG.getParents(v);
			var level1 = this.DG.vertLevel.outEdgeVerticalLevel[partners[0]].hasOwnProperty(v) ? this.DG.vertLevel.outEdgeVerticalLevel[partners[0]][v].verticalLevel : 0;
			var level2 = this.DG.vertLevel.outEdgeVerticalLevel[partners[1]].hasOwnProperty(v) ? this.DG.vertLevel.outEdgeVerticalLevel[partners[1]][v].verticalLevel : 0;
			var level = Math.min(level1, level2);
			var attach1 = this.DG.vertLevel.outEdgeVerticalLevel[partners[0]].hasOwnProperty(v) ? this.DG.vertLevel.outEdgeVerticalLevel[partners[0]][v].attachlevel : 0;
			var attach2 = this.DG.vertLevel.outEdgeVerticalLevel[partners[1]].hasOwnProperty(v) ? this.DG.vertLevel.outEdgeVerticalLevel[partners[1]][v].attachlevel : 0;
			var attach = Math.min(attach1, attach2);
			y = this.DG.computeRelLineY(rank, attach, level).relLineY;
		}

		return {"x": x, "y": y};
	},

	getRelationshipChildLastName: function (v) {
		// 1) use father's last name, if available. If not return null.
		// 2) if all children have either no lastNameAtBirth or it matches fathers l-name, return fathers l-name;
		//    otherwise return null.

		if (!this.isRelationship(v))
			throw "Assertion failed: getRelationshipChildLastName() is applied to a non-relationship";

		var fatherLastName = null;

		var parents = this.DG.GG.getParents(v);
		if (this.getGender(parents[0]) == "M") {
			fatherLastName = this.DG.GG.getLastName(parents[0]);
		} else if (this.getGender(parents[1]) == "M") {
			fatherLastName = this.DG.GG.getLastName(parents[1]);
		} else {
			return null;
		}
		if (fatherLastName == "") return null;

		var childhubId = this.DG.GG.getRelationshipChildhub(v);
		var children = this.DG.GG.getOutEdges(childhubId);
		for (var i = 0; i < children.length; i++) {
			var childLastName = this.DG.GG.getLastNameAtBirth(children[i]);
			if (childLastName != "" && childLastName != fatherLastName) {
				return null;
			}
		}
		return fatherLastName;
	},

	getRelationshipChildhubPosition: function (v) {
		if (!this.isRelationship(v))
			throw "Assertion failed: getRelationshipChildhubPosition() is applied to a non-relationship";

		var childhubId = this.DG.GG.getRelationshipChildhub(v);

		return this.getPosition(childhubId);
	},

	getRelationshipLineInfo: function (relationship, person) {
		if (!this.isRelationship(relationship))
			throw "Assertion failed: getRelationshipToPersonLinePosition() is applied to a non-relationship";
		if (!this.isPerson(person))
			throw "Assertion failed: getRelationshipToPersonLinePosition() is applied to a non-person";

		var info = this.DG.vertLevel.outEdgeVerticalLevel[person].hasOwnProperty(relationship) ?
			this.DG.vertLevel.outEdgeVerticalLevel[person][relationship] :
		{ attachlevel: 0, verticalLevel: 0, numAttachLevels: 1 };

		//console.log("Info: " +  Helpers.stringifyObject(info));

		var verticalRelInfo = this.DG.computeRelLineY(this.DG.ranks[person], info.attachlevel, info.verticalLevel);

		var result = {"attachmentPort": info.attachlevel,
			"attachY": verticalRelInfo.attachY,
			"verticalLevel": info.verticalLevel,
			"verticalY": verticalRelInfo.relLineY,
			"numAttachPorts": info.numAttachLevels };

		//console.log("rel: " + relationship + ", person: " + person + " => " + Helpers.stringifyObject(result));
		return result;
	},

	// returns all the children sorted by their order in the graph (left to right)
	getRelationshipChildrenSortedByOrder: function (v) {
		if (!this.isRelationship(v))
			throw "Assertion failed: getRelationshipChildren() is applied to a non-relationship";

		var childhubId = this.DG.GG.getRelationshipChildhub(v);

		var children = this.DG.GG.getOutEdges(childhubId);

		var vOrder = this.DG.order.vOrder;
		var byOrder = function (a, b) {
			return vOrder[a] - vOrder[b];
		};
		children.sort(byOrder);

		return children;
	},

	getAllChildren: function (v) {
		if (!this.isPerson(v) && !this.isRelationship(v))
			throw "Assertion failed: getAllChildren() is applied to a non-person non-relationship node";

		var rels = this.isRelationship(v) ? [v] : this.DG.GG.getAllRelationships(v);

		var allChildren = [];
		for (var i = 0; i < rels.length; i++) {
			var chhub = this.DG.GG.getOutEdges(rels[i])[0];
			var children = this.DG.GG.getOutEdges(chhub);

			allChildren = allChildren.concat(children);
		}
		return allChildren;
	},

	isChildOfProband: function (v) {
		var parents = this.DG.GG.getParents(v);
		if (Helpers.arrayContains(parents, 0)) return true;
		return false;
	},

	isSiblingOfProband: function (v) {
		var siblings = this.DG.GG.getAllSiblingsOf(v);
		if (Helpers.arrayContains(siblings, 0)) return true;
		return false;
	},

	isPartnershipRelatedToProband: function (v) {
		var parents = this.DG.GG.getParents(v);
		if (Helpers.arrayContains(parents, 0)) return true;
		if (v == this.DG.GG.getProducingRelationship(0)) {
			return true;
		}
		return false;
	},

	// returns true iff node v is either a sibling, a child or a parent of proband node
	isRelatedToProband: function (v) {
		var probandRelatedRels = this.getAllRelatedRelationships(0);
		for (var i = 0; i < probandRelatedRels.length; i++) {
			var rel = probandRelatedRels[i];

			var parents = this.DG.GG.getParents(rel);
			if (Helpers.arrayContains(parents, v)) return true;

			var children = this.getAllChildren(rel);
			if (Helpers.arrayContains(children, v)) return true;
		}
		return false;
	},

	// returns all relationships of node v and its parent relationship, if any
	getAllRelatedRelationships: function (v) {
		var allRels = this.DG.GG.getAllRelationships(v);
		var parentRel = this.DG.GG.getProducingRelationship(v);
		if (parentRel != null) {
			allRels.push(parentRel);
		}
		return allRels;
	},

	getAllSiblings: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: getAllSiblings() is applied to a non-person";

		if (this.DG.GG.getInEdges(v).length == 0) {
			return [];
		}

		var chhub = this.DG.GG.getInEdges(v)[0];

		var siblings = this.DG.GG.getOutEdges(chhub).slice(0);

		Helpers.removeFirstOccurrenceByValue(siblings, v);

		return siblings;
	},

	isOnlyChild: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: isOnlyPartnerlessChild() is applied to a non-person";
		if (this.DG.GG.getInEdges(v).length == 0) {
			return false;  // no parents => not a child of anyone
		}
		if (this.getAllSiblings(v).length == 0) {
			return true;  // no parents and no other isblings => only child
		}
		return false;     // has siblings
	},

	hasNonPlaceholderNonAdoptedChildren: function (v) {
		var children = [];
		if (this.isRelationship(v)) {
			children = this.getRelationshipChildrenSortedByOrder(v);
		}
		else if (this.isPerson(v)) {
			children = this.getAllChildren(v);
		}

		//console.log("Childtren: " + children);
		for (var i = 0; i < children.length; i++) {
			var child = children[i];
			if (!this.isPlaceholder(child) && !this.isAdoptedIn(child)) {
				//console.log("child: " + child + ", isAdopted: " + this.isAdopted(child));
				return true;
			}
		}

		return false;
	},

	hasNoNonPlaceholderChildren: function (v) {
		var children = [];
		if (this.isRelationship(v)) {
			children = this.getRelationshipChildrenSortedByOrder(v);
		}
		else if (this.isPerson(v)) {
			children = this.getAllChildren(v);
		}

		//console.log("Childtren: " + children);
		for (var i = 0; i < children.length; i++) {
			var child = children[i];
			if (!this.isPlaceholder(child)) {
				//console.log("child: " + child + ", isAdopted: " + this.isAdopted(child));
				return false;
			}
		}

		return true;
	},

	getParentRelationship: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: getParentRelationship() is applied to a non-person";

		return this.DG.GG.getProducingRelationship(v);
	},

	hasToBeAdopted: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: hasToBeAdopted() is applied to a non-person";

		var parentRel = this.getParentRelationship(v);
		if (parentRel !== null && this.isChildless(parentRel))
			return true;
		return false;
	},

	hasRelationships: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: hasRelationships() is applied to a non-person";

		return (this.DG.GG.v[v].length > 0); // if it had relationships it must have been alive at some point
	},

	getPossibleGenders: function (v) {
		// returns: - any gender if no partners or all partners are of unknown genders;
		//          - opposite of the partner gender if partner genders do not conflict
		//          - "U" if has partners of different genders (for now this is suported)
		var possible = {"M": true, "F": true, "O": true, "U": true};

		var partners = this.DG.GG.getAllPartners(v);

		for (var i = 0; i < partners.length; i++) {
			var partnerGender = this.getGender(partners[i]);
			if (partnerGender != "U" && partnerGender != "O") {
				possible[partnerGender] = false;
			}
		}
		//console.log("Possible genders for " + v + ": " + Helpers.stringifyObject(possible));
		return possible;
	},

	getPossibleChildrenOf: function (v) {
		// all person nodes which are not ancestors of v and which do not already have parents
		var result = [];
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (!this.isPerson(i)) continue;
			if (this.DG.GG.inedges[i].length != 0) continue;
			if (this.DG.ancestors[v].hasOwnProperty(i)) continue;
			result.push(i);
		}
		return result;
	},

	getPossibleSiblingsOf: function (v) {
		// all person nodes which are not ancestors and not descendants
		// if v has parents only nodes without parents are returned
		var hasParents = (this.getParentRelationship(v) !== null);
		var result = [];
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (!this.isPerson(i)) continue;
			if (this.DG.ancestors[v].hasOwnProperty(i)) continue;
			if (this.DG.ancestors[i].hasOwnProperty(v)) continue;
			if (hasParents && this.DG.GG.inedges[i].length != 0) continue;
			result.push(i);
		}
		return result;
	},

	getPossibleParentsOf: function (v) {
		// all person nodes which are not descendants of source node
		var result = [];
		//console.log("Ancestors: " + Helpers.stringifyObject(this.DG.ancestors));
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (!this.isRelationship(i) && !this.isPerson(i)) continue;
			if (this.isPersonGroup(i)) continue;
			if (this.isPlaceholder(i)) continue;
			if (this.DG.ancestors[i].hasOwnProperty(v)) continue;
			if (this.isPerson(i) && this.isAdoptedOut(i)) continue;
			result.push(i);
		}
		return result;
	},

	getPossiblePartnersOf: function (v) {
		// returns all person nodes of the other gender or unknown gender (who are not already partners)
		var oppositeGender = this.DG.GG.getOppositeGender(v);
		var validGendersSet = (oppositeGender == 'U') ? ['M', 'F', 'U', 'O'] : [oppositeGender, 'U', 'O'];

		var result = this._getAllPersonsOfGenders(validGendersSet, true);

		var partners = this.DG.GG.getAllPartners(v);
		partners.push(v);
		for (var i = 0; i < partners.length; i++)
			Helpers.removeFirstOccurrenceByValue(result, partners[i]);

		return result;
	},

	getOppositeGender: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: getOppositeGender() is applied to a non-person";
		return this.DG.GG.getOppositeGender(v);
	},

	getGender: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: getGender() is applied to a non-person";
		return this.DG.GG.getGender(v);
	},

	getLastName: function (v) {
		if (!this.isPerson(v))
			throw "Assertion failed: getLastName() is applied to a non-person";
		return this.DG.GG.getLastName(v);
	},

	getDisconnectedSetIfNodeRemoved: function (v) {
		var removedList = {};
		removedList[v] = true;

		if (this.isPerson(v)) {
			// note: removing the only child should not removes the relationship
			//       (need to convert this child to a placeholder instead)

			// also remove all relationships by this person
			var allRels = this.DG.GG.getAllRelationships(v);
			for (var i = 0; i < allRels.length; i++) {
				removedList[allRels[i]] = true;
			}
		}

		// remove all childhubs of all relationships that need to be removed
		for (var node in removedList) {
			if (removedList.hasOwnProperty(node) && this.isRelationship(node)) {
				var chhubId = this.DG.GG.getOutEdges(node)[0];
				removedList[chhubId] = true;
			}
		}

		// go through all the edges in the tree starting from proband and disregarding any edges going to or from v
		var connected = {};

		var queue = new Queue();
		queue.push(0);

		while (queue.size() > 0) {
			var next = parseInt(queue.pop());

			if (connected.hasOwnProperty(next)) continue;
			connected[next] = true;

			var outEdges = this.DG.GG.getOutEdges(next);
			for (var i = 0; i < outEdges.length; i++) {
				if (!removedList.hasOwnProperty(outEdges[i]))
					queue.push(outEdges[i]);
			}
			var inEdges = this.DG.GG.getInEdges(next);
			for (var i = 0; i < inEdges.length; i++) {
				if (!removedList.hasOwnProperty(inEdges[i]))
					queue.push(inEdges[i]);
			}
		}
		console.log("Connected nodes: " + Helpers.stringifyObject(connected));

		var affected = [];
		for (var i = 0; i < this.DG.GG.getNumVertices(); i++) {
			if (this.isPerson(i) || this.isRelationship(i)) {
				if (!connected.hasOwnProperty(i))
					affected.push(i);
			}
		}

		console.log("Affected nodes: " + Helpers.stringifyObject(affected));
		return affected;
	},

	_debugPrintAll: function (headerMessage) {
		console.log("========== " + headerMessage + " ==========");
		//console.log("== GG:");
		//console.log(Helpers.stringifyObject(this.DG.GG));
		//console.log("== Ranks:");
		//console.log(Helpers.stringifyObject(this.DG.ranks));
		//console.log("== Orders:");
		//console.log(Helpers.stringifyObject(this.DG.order));
		//console.log("== Positions:");
		//console.log(Helpers.stringifyObject(this.DG.positions));
		//console.log("== RankY:");
		//console.log(Helpers.stringifyObject(this.DG.rankY));
	},

	updateAncestors: function ()   // sometimes have to do this after the "adopted" property change
	{
		var ancestors = this.DG.findAllAncestors();
		this.DG.ancestors = ancestors.ancestors;
		this.DG.consangr = ancestors.consangr;

		// after consang has changes a random set or relationships may become/no longer be a consangr. relationship
		var movedNodes = [];
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (!this.isRelationship(i)) continue;
			movedNodes.push(i);
		}

		return { "moved": movedNodes };
	},

	addNewChild: function (childhubId, properties, numTwins) {
		this._debugPrintAll("before");
		var timer = new Helpers.Timer();

		if (!this.DG.GG.isChildhub(childhubId)) {
			if (this.DG.GG.isRelationship(childhubId))
				childhubId = this.DG.GG.getRelationshipChildhub(childhubId);
			else
				throw "Assertion failed: adding children to a non-childhub node";
		}

		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		if (!properties) properties = {};
		if (!numTwins) numTwins = 1;

		var insertRank = this.DG.ranks[childhubId] + 1;

		// find the best order to use for this new vertex: scan all orders on the rank, check number of crossed edges
		var insertOrder = this._findBestInsertPosition(insertRank, childhubId);

		// insert the vertex into the base graph and update ranks, orders & positions
		var newNodeId = this._insertVertex(BaseGraph.TYPE.PERSON, properties, 1.0, childhubId, null, insertRank, insertOrder);

		var newNodes = [newNodeId];
		for (var i = 0; i < numTwins - 1; i++) {
			var changeSet = this.addTwin(newNodeId, properties);
			newNodes.push(changeSet["new"][0]);
		}

		// validate: by now the graph should satisfy all assumptions
		this.DG.GG.validate();

		// fix common layout mistakes (e.g. relationship not right above the only child)
		// and update vertical positioning of all edges
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		// update ancestors
		this.updateAncestors();

		timer.printSinceLast("=== AddChild runtime: ");
		this._debugPrintAll("after");

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore);
		var relationshipId = this.DG.GG.getInEdges(childhubId)[0];
		if (!Helpers.arrayContains(movedNodes, relationshipId))
			movedNodes.push(relationshipId);
		var animateNodes = this.DG.GG.getInEdges(relationshipId);  // animate parents if they move. if not, nothing will be done with them
		return {"new": newNodes, "moved": movedNodes, "animate": animateNodes};
	},

	addNewParents: function (personId) {
		this._debugPrintAll("before");
		var timer = new Helpers.Timer();

		if (!this.DG.GG.isPerson(personId))
			throw "Assertion failed: adding parents to a non-person node";

		if (this.DG.GG.getInEdges(personId).length > 0)
			throw "Assertion failed: adding parents to a person with parents";

		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		// a few special cases which involve not only insertions but also existing node rearrangements:
		this._heuristics.swapBeforeParentsToBringToSideIfPossible(personId);

		var insertChildhubRank = this.DG.ranks[personId] - 1;

		// find the best order to use for this new vertex: scan all orders on the rank, check number of crossed edges
		var insertChildhubOrder = this._findBestInsertPosition(insertChildhubRank, personId);

		// insert the vertex into the base graph and update ranks, orders & positions
		var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, null, personId, insertChildhubRank, insertChildhubOrder);

		var insertParentsRank = this.DG.ranks[newChildhubId] - 1;   // note: rank may have changed since last insertion
		//       (iff childhub was insertion above all at rank 0 - which becomes rank1)

		// find the best order to use for this new vertex: scan all orders on the rank, check number of crossed edges
		var insertParentOrder = this._findBestInsertPosition(insertParentsRank, newChildhubId);

		var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, {}, 1.0, null, newChildhubId, insertParentsRank, insertParentOrder);

		insertParentsRank = this.DG.ranks[newRelationshipId];       // note: rank may have changed since last insertion again
		//       (iff relationship was insertion above all at rank 0 - which becomes rank1)

		var newParent1Id = this._insertVertex(BaseGraph.TYPE.PERSON, {"gender": "F"}, 1.0, null, newRelationshipId, insertParentsRank, insertParentOrder + 1);
		var newParent2Id = this._insertVertex(BaseGraph.TYPE.PERSON, {"gender": "M"}, 1.0, null, newRelationshipId, insertParentsRank, insertParentOrder);

		// validate: by now the graph should satisfy all assumptions
		this.DG.GG.validate();

		// fix common layout mistakes (e.g. relationship not right above the only child)
		// and update vertical positioning of all edges
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		// update ancestors
		this.updateAncestors();

		timer.printSinceLast("=== NewParents runtime: ");
		this._debugPrintAll("after");

		var animateNodes = this.DG.GG.getAllPartners(personId);
		if (animateNodes.length == 1)  // only animate node partners if there is only one - ow it may get too confusing with a lot of stuff animating around
			animateNodes.push(personId);
		else
			animateNodes = [personId];
		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore);
		var newNodes = [newRelationshipId, newParent1Id, newParent2Id];
		return {"new": newNodes, "moved": movedNodes, "highlight": [personId], "animate": animateNodes};
	},

	addNewRelationship: function (personId, childProperties, preferLeft, numTwins) {
		this._debugPrintAll("before");
		var timer = new Helpers.Timer();

		if (!this.DG.GG.isPerson(personId))
			throw "Assertion failed: adding relationship to a non-person node";

		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var consangrBefore = this.DG.consangr;
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		if (!childProperties) childProperties = {};

		if (!numTwins) numTwins = 1;

		var partnerProperties = { "gender": this.DG.GG.getOppositeGender(personId) };

		var insertRank = this.DG.ranks[personId];
		var personOrder = this.DG.order.vOrder[personId];

		var needSwap = true;
		var relProperties = {};
		if (childProperties.hasOwnProperty("placeholder") && childProperties["placeholder"]) {
			relProperties["childlessStatus"] = 'Childless';
			var needSwap = false;
		}

		// a few special cases which involve not only insertions but also existing node rearrangements:
		this._heuristics.swapPartnerToBringToSideIfPossible(personId);   // TODO: only iff "needSwap"?
		this._heuristics.swapTwinsToBringToSideIfPossible(personId);

		// find the best order to use for this new vertex: scan all orders on the rank, check number of crossed edges
		var insertOrder = this._findBestInsertPosition(insertRank, personId, preferLeft);

		console.log("vOrder: " + personOrder + ", inserting @ " + insertOrder);
		console.log("Orders before: " + Helpers.stringifyObject(this.DG.order.order[this.DG.ranks[personId]]));

		var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, relProperties, 1.0, personId, null, insertRank, insertOrder);

		console.log("Orders after: " + Helpers.stringifyObject(this.DG.order.order[this.DG.ranks[personId]]));

		var insertPersonOrder = (insertOrder > personOrder) ? insertOrder + 1 : insertOrder;

		var newPersonId = this._insertVertex(BaseGraph.TYPE.PERSON, partnerProperties, 1.0, null, newRelationshipId, insertRank, insertPersonOrder);

		var insertChildhubRank = insertRank + 1;
		var insertChildhubOrder = this._findBestInsertPosition(insertChildhubRank, newRelationshipId);
		var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, newRelationshipId, null, insertChildhubRank, insertChildhubOrder);

		var insertChildRank = insertChildhubRank + 1;
		var insertChildOrder = this._findBestInsertPosition(insertChildRank, newChildhubId);
		var newChildId = this._insertVertex(BaseGraph.TYPE.PERSON, childProperties, 1.0, newChildhubId, null, insertChildRank, insertChildOrder);

		var newNodes = [newRelationshipId, newPersonId, newChildId];
		for (var i = 0; i < numTwins - 1; i++) {
			var changeSet = this.addTwin(newChildId, childProperties);
			newNodes.push(changeSet["new"][0]);
		}

		console.log("Orders after all: " + Helpers.stringifyObject(this.DG.order.order[this.DG.ranks[personId]]));

		// validate: by now the graph should satisfy all assumptions
		this.DG.GG.validate();

		//this._debugPrintAll("middle");

		// fix common layout mistakes (e.g. relationship not right above the only child)
		// and update vertical positioning of all edges
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		// update ancestors
		this.updateAncestors();

		timer.printSinceLast("=== NewRelationship runtime: ");
		this._debugPrintAll("after");

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, consangrBefore);
		return {"new": newNodes, "moved": movedNodes, "highlight": [personId]};
	},

	assignParent: function (parentId, childId) {
		if (this.isRelationship(parentId)) {
			var childHubId = this.DG.GG.getRelationshipChildhub(parentId);
			var rankChildHub = this.DG.ranks[childHubId];
			var rankChild = this.DG.ranks[childId];

			var otherChildren = this.getAllChildren(parentId);

			var weight = 1;
			this.DG.GG.addEdge(childHubId, childId, weight);

			// this should be done after addEdge(), or the assumption of at least one child will
			// be violated at the time removeNodes() is executed, resulting in a validation failure
			if (otherChildren.length == 1 && this.isPlaceholder(otherChildren[0])) {
				var removeChangeSet = this.removeNodes([otherChildren[0]]);
			}

			var animateList = [childId];

			if (rankChildHub != rankChild - 1) {
				var removedList = removeChangeSet ? removeChangeSet.removed : [];
				return this.redrawAll(removedList, animateList);
			}

			var positionsBefore = this.DG.positions.slice(0);
			var ranksBefore = this.DG.ranks.slice(0);
			var vertLevelsBefore = this.DG.vertLevel.copy();
			var rankYBefore = this.DG.rankY.slice(0);
			var consangrBefore = this.DG.consangr;
			var numNodesBefore = this.DG.GG.getMaxRealVertexId();

			// TODO: move vertex closer to other children, if possible?

			// validate: by now the graph should satisfy all assumptions
			this.DG.GG.validate();

			// update vertical separation for all nodes & compute ancestors
			this._updateauxiliaryStructures(ranksBefore, rankYBefore);

			positionsBefore[parentId] = Infinity; // so that it is added to the list of moved nodes
			var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, consangrBefore);

			if (removeChangeSet) {
				removeChangeSet.moved = removeChangeSet.moved.concat(movedNodes);
				removeChangeSet.moved = Helpers.filterUnique(removeChangeSet.moved);
				removeChangeSet.animate = [childId];
				return removeChangeSet;
			} else {
				return {"moved": movedNodes, "animate": [childId]};
			}
		}
		else {
			var rankParent = this.DG.ranks[parentId];
			var rankChild = this.DG.ranks[childId];

			var partnerProperties = { "gender": this.DG.GG.getOppositeGender(parentId) };

			//console.log("rankParent: " + rankParent + ", rankChild: " + rankChild );

			if (rankParent >= rankChild) {
				var ranksBefore = this.DG.ranks.slice(0);
				// need a complete redraw, since this violates the core layout rule. In this case insert orders do not matter
				var insertChildhubRank = rankChild - 1;
				var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, null, childId, insertChildhubRank, 0);
				var insertParentsRank = this.DG.ranks[newChildhubId] - 1;   // note: rank may have changed since last insertion
				var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, {}, 1.0, null, newChildhubId, insertParentsRank, 0);
				var newParentId = this._insertVertex(BaseGraph.TYPE.PERSON, partnerProperties, 1.0, null, newRelationshipId, insertParentsRank, 0);
				this.DG.GG.addEdge(parentId, newRelationshipId, 1);
				var animateList = [childId, parentId];
				var newList = [newRelationshipId, newParentId];
				return this.redrawAll(null, animateList, newList, ranksBefore);
			}

			// add new childhub     @ rank (rankChild - 1)
			// add new relationship @ rank (rankChild - 2)
			// add new parent       @ rank (rankChild - 2) right next to new relationship
			//                        (left or right depends on if the other parent is right or left)
			// depending on other parent rank either draw a multi-rank relationship edge or regular relationship edge

			this._debugPrintAll("before");
			var timer = new Helpers.Timer();

			var positionsBefore = this.DG.positions.slice(0);
			var ranksBefore = this.DG.ranks.slice(0);
			var vertLevelsBefore = this.DG.vertLevel.copy();
			var rankYBefore = this.DG.rankY.slice(0);
			var consangrBefore = this.DG.consangr;
			var numNodesBefore = this.DG.GG.getMaxRealVertexId();

			var x_parent = this.DG.positions[parentId];
			var x_child = this.DG.positions[childId];

			if (rankParent == rankChild - 2) {
				// the order of new node creation is then:
				// 1) new relationship node
				// 2) new partner
				// 3) new childhub
				var preferLeft = (x_child < x_parent);

				// add same-rank relationship edge
				var insertRelatOrder = this._findBestInsertPosition(rankParent, parentId, preferLeft);
				var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, {}, 1.0, parentId, null, rankParent, insertRelatOrder);

				var newParentOrder = (this.DG.order.vOrder[parentId] > this.DG.order.vOrder[newRelationshipId]) ? insertRelatOrder : (insertRelatOrder + 1);
				var newParentId = this._insertVertex(BaseGraph.TYPE.PERSON, partnerProperties, 1.0, null, newRelationshipId, rankParent, newParentOrder);

				var insertChildhubRank = rankChild - 1;
				var insertChildhubOrder = this._findBestInsertPosition(insertChildhubRank, newRelationshipId);
				var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, newRelationshipId, null, insertChildhubRank, insertChildhubOrder);

				this.DG.GG.addEdge(newChildhubId, childId, 1);
			} else {
				// need to add a multi-rank edge: order of node creation is different:
				// 1) new childhub
				// 2) new relationship node
				// 3) new partner
				// 4) multi-rank edge
				// add a multi-rank relationship edge (e.g. a sequence of edges between virtual nodes on intermediate ranks)

				var insertChildhubRank = rankChild - 1;
				var insertChildhubOrder = this._findBestInsertPosition(insertChildhubRank, childId);
				var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, null, childId, insertChildhubRank, insertChildhubOrder);

				var insertParentsRank = rankChild - 2;

				var insertRelatOrder = this._findBestInsertPosition(insertParentsRank, newChildhubId);
				var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, {}, 1.0, null, newChildhubId, insertParentsRank, insertRelatOrder);

				var newParentOrder = (this.DG.positions[parentId] > this.DG.positions[newRelationshipId]) ? insertRelatOrder : (insertRelatOrder + 1);
				var newParentId = this._insertVertex(BaseGraph.TYPE.PERSON, partnerProperties, 1.0, null, newRelationshipId, insertParentsRank, newParentOrder);

				this._addMultiRankEdge(parentId, newRelationshipId);
			}

			// validate: by now the graph should satisfy all assumptions
			this.DG.GG.validate();

			// fix common layout mistakes (e.g. relationship not right above the only child)
			// and update vertical positioning of all edges
			this._heuristics.improvePositioning(ranksBefore, rankYBefore);

			// update ancestors
			this.updateAncestors();

			timer.printSinceLast("=== DragToParentOrChild runtime: ");
			this._debugPrintAll("after");

			if (this.DG.positions.length >= 31)
				console.log("position of node 32: " + this.DG.positions[32] + ", was: " + positionsBefore[32]);
			var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, consangrBefore);
			var newNodes = [newRelationshipId, newParentId];
			return {"new": newNodes, "moved": movedNodes, "highlight": [parentId, newParentId, childId]};
		}

	},

	assignPartner: function (person1, person2, childProperties) {
		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var consangrBefore = this.DG.consangr;
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		var rankP1 = this.DG.ranks[person1];
		var rankP2 = this.DG.ranks[person2];

		if (rankP1 < rankP2 ||
			(rankP1 == rankP2 && this.DG.order.vOrder[person2] < this.DG.order.vOrder[person1])
			) {
			var tmpPerson = person2;
			person2 = person1;
			person1 = tmpPerson;

			rankP1 = rankP2;
			rankP2 = this.DG.ranks[person2];
		}

		var x_person1 = this.DG.positions[person1];
		var x_person2 = this.DG.positions[person2];

		var weight = 1;

		var preferLeft = (x_person2 < x_person1);
		var insertRelatOrder = (rankP1 == rankP2) ? this._findBestRelationshipPosition(person1, false, person2) :
			this._findBestRelationshipPosition(person1, preferLeft);

		var relProperties = {};
		if (childProperties.hasOwnProperty("placeholder") && childProperties["placeholder"]) {
			relProperties["childlessStatus"] = 'Childless';
		}
		var newRelationshipId = this._insertVertex(BaseGraph.TYPE.RELATIONSHIP, relProperties, weight, person1, null, rankP1, insertRelatOrder);

		var insertChildhubRank = this.DG.ranks[newRelationshipId] + 1;
		var insertChildhubOrder = this._findBestInsertPosition(insertChildhubRank, newRelationshipId);
		var newChildhubId = this._insertVertex(BaseGraph.TYPE.CHILDHUB, {}, 1.0, newRelationshipId, null, insertChildhubRank, insertChildhubOrder);

		var insertChildRank = insertChildhubRank + 1;
		var insertChildOrder = this._findBestInsertPosition(insertChildRank, newChildhubId);
		var newChildId = this._insertVertex(BaseGraph.TYPE.PERSON, childProperties, 1.0, newChildhubId, null, insertChildRank, insertChildOrder);

		if (rankP1 == rankP2) {
			this.DG.GG.addEdge(person2, newRelationshipId, weight);
		} else {
			this._addMultiRankEdge(person2, newRelationshipId);
		}

		// validate: by now the graph should satisfy all assumptions
		this.DG.GG.validate();

		// fix common layout mistakes (e.g. relationship not right above the only child)
		// and update vertical positioning of all edges
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		// update ancestors
		this.updateAncestors();

		this._debugPrintAll("after");

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, consangrBefore);
		var newNodes = [newRelationshipId, newChildId];
		return {"new": newNodes, "moved": movedNodes, "highlight": [person1, person2, newChildId]};
	},

	addTwin: function (personId, properties) {
		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		var parentRel = this.DG.GG.getProducingRelationship(personId);

		var twinGroupId = this.DG.GG.getTwinGroupId(personId);
		if (twinGroupId === null) {
			twinGroupId = this.DG.GG.getUnusedTwinGroupId(parentRel);
			console.log("new twin id: " + twinGroupId);
			this.DG.GG.properties[personId]['twinGroup'] = twinGroupId;
		}
		properties['twinGroup'] = twinGroupId;

		var insertRank = this.DG.ranks[personId];

		// find the best order to use for this new vertex: scan all orders on the rank, check number of crossed edges
		var insertOrder = this.DG.findBestTwinInsertPosition(personId, []);

		// insert the vertex into the base graph and update ranks, orders & positions
		var childhubId = this.DG.GG.getInEdges(personId)[0];
		var newNodeId = this._insertVertex(BaseGraph.TYPE.PERSON, properties, 1.0, childhubId, null, insertRank, insertOrder);

		// validate: by now the graph should satisfy all assumptions
		this.DG.GG.validate();

		// fix common layout mistakes (e.g. relationship not right above the only child)
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore);
		if (!Helpers.arrayContains(movedNodes, parentRel))
			movedNodes.push(parentRel);
		var animateNodes = this.DG.GG.getInEdges(parentRel).slice(0);  // animate parents if they move. if not, nothing will be done with them
		animateNodes.push(personId);
		var newNodes = [newNodeId];
		return {"new": newNodes, "moved": movedNodes, "animate": animateNodes};
	},

	convertPlaceholderTo: function (placeholderId, childParams) {
		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		if (!this.isPlaceholder(placeholderId)) {
			throw "Attemp to access a non-paceholder node as a placeholder";
		}

		if (!childParams.hasOwnProperty("gender")) {
			childParams["gender"] = "U";
		}
		this.setProperties(placeholderId, childParams);

		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		var parentRelationship = this.getParentRelationship(placeholderId);

		// need to redraw (move) the partnership-child line
		var moved = [ parentRelationship ];

		// may also need to redraw all partnership lines on this rank, and
		// some other nodes as well, since person width > placeholder width
		var rank = this.DG.ranks[placeholderId];
		for (var order = 0; order < this.DG.order.order[rank].length - 1; order++) {
			var v = this.DG.order.order[rank][order];

			if (this.DG.GG.isRelationship(v) && !Helpers.arrayContains(moved, v)) {
				moved.push(v);
			}
		}

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore);

		moved = moved.concat(movedNodes);
		moved = Helpers.filterUnique(moved);
		Helpers.removeFirstOccurrenceByValue(moved, placeholderId);

		return {"removed": [ placeholderId ], "new": [ placeholderId ], "moved": moved };
	},

	removeNodes: function (nodeList) {
		this._debugPrintAll("before");

		//var positionsBefore  = this.DG.positions.slice(0);
		//var ranksBefore      = this.DG.ranks.slice(0);
		//var vertLevelsBefore = this.DG.vertLevel.copy();
		//var rankYBefore      = this.DG.rankY.slice(0);
		//var consangrBefore   = this.DG.consangr;
		//var numNodesBefore   = this.DG.GG.getMaxRealVertexId();

		var oldMaxID = this.getMaxNodeId();

		var removed = nodeList.slice(0);
		removed.sort();
		var moved = [];

		for (var i = 0; i < nodeList.length; i++) {
			if (this.isRelationship(nodeList[i])) {
				// also add its childhub
				var chHub = this.DG.GG.getOutEdges(nodeList[i])[0];
				nodeList.push(chHub);
				//console.log("adding " + chHub + " to removal list (chhub of " + nodeList[i] + ")");

				// also add its long multi-rank edges
				var pathToParents = this.getPathToParents(nodeList[i]);
				for (var p = 0; p < pathToParents.length; p++) {
					for (var j = 0; j < pathToParents[p].length; j++)
						if (this.DG.GG.isVirtual(pathToParents[p][j])) {
							//console.log("adding " + pathToParents[p][j] + " to removal list (virtual of " + nodeList[i] + ")");
							nodeList.push(pathToParents[p][j]);
						}
				}
			}
		}

		nodeList.sort(function (a, b) {
			return a - b
		});

		//console.log("nodeList: " + Helpers.stringifyObject(nodeList));

		var changedIDSet = {};

		for (var i = nodeList.length - 1; i >= 0; i--) {
			var v = nodeList[i];
			//console.log("removing: " + v);

			//// add person't relationship to the list of moved nodes
			//if (this.isPerson(v)) {
			//    var rel = this.DG.GG.getProducingRelationship(v);
			//    // rel may have been already removed
			//    if (rel !== null && !Helpers.arrayContains(nodeList, rel))
			//        moved.push(rel);
			//}

			// TODO: if this is one of only two twins remove twinGroupID form the remainin twin as it is no longer a twin

			this.DG.GG.remove(v);
			//console.log("order before: " + Helpers.stringifyObject(this.DG.order));
			this.DG.order.remove(v, this.DG.ranks[v]);
			//console.log("order after: " + Helpers.stringifyObject(this.DG.order));
			this.DG.ranks.splice(v, 1);
			this.DG.positions.splice(v, 1);

			// for each removed node all nodes with higher ids get their IDs shifted down by 1
			for (var u = v + 1; u <= oldMaxID; u++) {
				if (!changedIDSet.hasOwnProperty(u))
					changedIDSet[u] = u - 1;
				else
					changedIDSet[u]--;
			}
		}

		this.DG.maxRank = Math.max.apply(null, this.DG.ranks);

		this.DG.GG.validate();

		// note: do not update rankY, as we do not want to move anything (we know we don't need more Y space after a deletion)
		this.DG.vertLevel = this.DG.positionVertically();
		this.updateAncestors();

		// TODO: for now: redraw all relationships
		for (var i = 0; i <= this.getMaxNodeId(); i++)
			if (this.isRelationship(i))
				moved.push(i);

		// note: _findMovedNodes() does not work when IDs have changed. TODO
		//var movedNodes = this._findMovedNodes( numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore );
		//for (var i = 0; i < moved.length; i++)
		//    if (!Helpers.arrayContains(movedNodes, moved[i]))
		//        movedNodes.push(moved[i]);

		// note: moved now has the correct IDs valid in the graph with all affected nodes removed
		return {"removed": removed, "changedIDSet": changedIDSet, "moved": moved };
	},

	improvePosition: function () {
		//this.DG.positions = this.DG.position(this.DG.horizontalPersonSeparationDist, this.DG.horizontalRelSeparationDist);
		//var movedNodes = this._getAllNodes();
		//return {"moved": movedNodes};
		var positionsBefore = this.DG.positions.slice(0);
		var ranksBefore = this.DG.ranks.slice(0);
		var vertLevelsBefore = this.DG.vertLevel.copy();
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		// fix common layout mistakes (e.g. relationship not right above the only child)
		this._heuristics.improvePositioning(ranksBefore, rankYBefore);

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore);

		return {"moved": movedNodes};
	},

	updateYPositioning: function () {
		var positionsBefore = this.DG.positions; //.slice(0); not changing, no need to copy
		var ranksBefore = this.DG.ranks;     //.slice(0); not changing, no need to copy
		var vertLevelsBefore = this.DG.vertLevel; //.copy();   not changing, no need to copy
		var rankYBefore = this.DG.rankY.slice(0);
		var numNodesBefore = this.DG.GG.getMaxRealVertexId();

		this.DG.rankY = this.DG.computeRankY(ranksBefore, rankYBefore);

		var movedNodes = this._findMovedNodes(numNodesBefore, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, null, true);

		if (movedNodes.length == 0) {
			return {};
		}
		return {"moved": movedNodes};
	},

	clearAll: function () {
		var removedNodes = this._getAllNodes(1);  // all nodes from 1 and up

		var emptyGraph = (this.DG.GG.getNumVertices() == 0);

		var node0properties = emptyGraph ? {} : this.getProperties(0);

		// it is easier to create abrand new graph transferirng node 0 propertie sthna to remove on-by-one
		// each time updating ranks, orders, etc

		var baseGraph = PedigreeImport.initFromPhenotipsInternal(this._onlyProbandGraph);

		this._recreateUsingBaseGraph(baseGraph);

		this.setProperties(0, node0properties);

		if (emptyGraph)
			return {"new": [0], "makevisible": [0]};

		return {"removed": removedNodes, "moved": [0], "makevisible": [0]};
	},

	redrawAll: function (removedBeforeRedrawList, animateList, newList, ranksBefore) {
		var ranksBefore = ranksBefore ? ranksBefore : this.DG.ranks.slice(0);  // sometimes we want to use ranksbefore as they were before some stuff was added to the graph before a redraw

		this._debugPrintAll("before");

		var baseGraph = this.DG.GG.makeGWithCollapsedMultiRankEdges();

		// collect current node ranks so that the new layout can be made more similar to the current one
		var oldRanks = Helpers.clone2DArray(this.DG.order.order);
		for (var i = oldRanks.length - 1; i >= 0; i--) {
			oldRanks[i] = oldRanks[i].filter(this.DG.GG.isPerson.bind(this.DG.GG));
			if (oldRanks[i].length == 0)
				oldRanks.splice(i, 1);
		}

		if (!this._recreateUsingBaseGraph(baseGraph, oldRanks)) return {};  // no changes

		var movedNodes = this._getAllNodes();

		var probandReRankSize = (ranksBefore[0] - this.DG.ranks[0]);
		var reRankedDiffFrom0 = []
		var reRanked = [];
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (this.DG.GG.isPerson(i)) {
				if (this.DG.ranks[i] != ranksBefore[i]) {
					reRanked.push(i);
				}
				if ((ranksBefore[i] - this.DG.ranks[i]) != probandReRankSize) {
					reRankedDiffFrom0.push(i);
				}
			}
		}
		if (reRankedDiffFrom0.length < reRanked.length) {
			reRanked = reRankedDiffFrom0;
		}

		if (!animateList) animateList = [];

		if (!removedBeforeRedrawList) removedBeforeRedrawList = [];

		if (!newList)
			newList = [];
		else {
			// nodes which are force-marked as new can't be in the "moved" list
			for (var i = 0; i < newList.length; i++)
				Helpers.removeFirstOccurrenceByValue(movedNodes, newList[i]);
		}

		this._debugPrintAll("after");

		return { "new": newList,
			"moved": movedNodes,
			"highlight": reRanked,
			"animate": animateList,
			"removed": removedBeforeRedrawList };
	},

	// remove empty-values optional properties, e.g. "fName: ''" or "disorders: []"
	stripUnusedProperties: function () {
		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (this.isPerson(i)) {
				this.deleteEmptyProperty(i, "fName");
				this.deleteEmptyProperty(i, "lName");
				this.deleteEmptyProperty(i, "gestationAgeDays");
				this.deleteEmptyProperty(i, "gestationAgeWeeks");
				this.deleteEmptyProperty(i, "carrierStatus");
				this.deleteEmptyProperty(i, "comments");
				this.deleteEmptyProperty(i, "disorders");
			}
		}
	},

	deleteEmptyProperty: function (nodeID, propName) {
		if (this.DG.GG.properties[nodeID].hasOwnProperty(propName)) {
			if (Object.prototype.toString.call(this.DG.GG.properties[nodeID][propName]) === '[object Array]' &&
				this.DG.GG.properties[nodeID][propName].length == 0) {
				delete this.DG.GG.properties[nodeID][propName];
			} else if (this.DG.GG.properties[nodeID][propName] == "") {
				delete this.DG.GG.properties[nodeID][propName];
			}
		}
	},

	toJSONObject: function () {
		this.stripUnusedProperties();

		//var timer = new Helpers.Timer();
		var output = {};

		// note: when saving positioned graph, need to save the version of the graph which has virtual edge pieces
		output["GG"] = this.DG.GG.serialize();

		output["ranks"] = this.DG.ranks;
		output["order"] = this.DG.order.serialize();
		output["positions"] = this.DG.positions;

		// note: everything else can be recomputed based on the information above

		//console.log("JSON represenation: " + JSON.stringify(output));
		//timer.printSinceLast("=== to JSON: ");

		return output;
	},

	fromJSONObject: function (jsonData) {
		var removedNodes = this._getAllNodes();

		//console.log("Got serialization object: " + Helpers.stringifyObject(jsonData));

		this.DG.GG = PedigreeImport.initFromPhenotipsInternal(jsonData["GG"]);

		this.DG.ranks = jsonData["ranks"];

		this.DG.maxRank = Math.max.apply(null, this.DG.ranks);

		this.DG.order.deserialize(jsonData["order"]);

		this.DG.positions = jsonData["positions"];

		this._updateauxiliaryStructures();

		this.screenRankShift = 0;

		var newNodes = this._getAllNodes();

		return {"new": newNodes, "removed": removedNodes};
	},

	fromImport: function (importString, importType, importOptions) {
		var removedNodes = this._getAllNodes();

		//this._debugPrintAll("before");

		if (importType == "ped") {
			var baseGraph = PedigreeImport.initFromPED(importString, importOptions.acceptUnknownPhenotypes, importOptions.markEvaluated, importOptions.externalIdMark);
			if (!this._recreateUsingBaseGraph(baseGraph)) return null;  // no changes
		} else if (importType == "BOADICEA") {
			var baseGraph = PedigreeImport.initFromBOADICEA(importString, importOptions.externalIdMark);
			if (!this._recreateUsingBaseGraph(baseGraph)) return null;  // no changes
		} else if (importType == "gedcom") {
			var baseGraph = PedigreeImport.initFromGEDCOM(importString, importOptions.markEvaluated, importOptions.externalIdMark);
			if (!this._recreateUsingBaseGraph(baseGraph)) return null;  // no changes
		} else if (importType == "simpleJSON") {
			var baseGraph = PedigreeImport.initFromSimpleJSON(importString);
			if (!this._recreateUsingBaseGraph(baseGraph)) return null;  // no changes
		} else if (importType == "phenotipsJSON") {

			// TODO
		}

		//this._debugPrintAll("after");

		var newNodes = this._getAllNodes();

		//unRendered is passed for GEL(GenomicsEngland) .......................................................
		return {"new": newNodes, "removed": removedNodes, "unRendered": baseGraph.unRenderedNodes};
		//.....................................................................................................
	},

	getPathToParents: function (v) {
		// returns an array with two elements: path to parent1 (excluding v) and path to parent2 (excluding v):
		// [ [virtual_node_11, ..., virtual_node_1n, parent1], [virtual_node_21, ..., virtual_node_2n, parent21] ]
		return this.DG.GG.getPathToParents(v);
	},

	//=============================================================

	// suggestedRanks: when provided, attempt to use the suggested rank for all nodes,
	//                 in order to keep the new layout as close as possible to the previous layout
	_recreateUsingBaseGraph: function (baseGraph, suggestedRanks) {
		try {
			var newDG = new PositionedGraph(baseGraph,
				this.DG.horizontalPersonSeparationDist,
				this.DG.horizontalRelSeparationDist,
				this.DG.maxInitOrderingBuckets,
				this.DG.maxOrderingIterations,
				this.DG.maxXcoordIterations,
				false,
				suggestedRanks);
		} catch (e) {
			return false;
		}

		this.DG = newDG;
		this._heuristics = new Heuristics(this.DG);

		//this._debugPrintAll("before improvement");
		this._heuristics.improvePositioning();
		//this._debugPrintAll("after improvement");

		return true;
	},

	_insertVertex: function (type, properties, edgeWeights, inedge, outedge, insertRank, insertOrder) {
		// all nodes are connected to some other node, so either inedge or outedge should be given
		if (inedge === null && outedge === null)
			throw "Assertion failed: each node should be connected to at least one other node";
		if (inedge !== null && outedge !== null)
			throw "Assertion failed: not clear which edge crossing to optimize, can only insert one edge";

		var inedges = (inedge !== null) ? [inedge] : [];
		var outedges = (outedge !== null) ? [outedge] : [];

		var newNodeId = this.DG.GG.insertVertex(type, properties, edgeWeights, inedges, outedges);

		// note: the graph may be inconsistent at this point, e.g. there may be childhubs with
		// no relationships or relationships without any people attached

		if (insertRank == 0) {
			for (var i = 0; i < this.DG.ranks.length; i++)
				this.DG.ranks[i]++;
			this.DG.maxRank++;

			this.DG.order.insertRank(1);

			insertRank = 1;
		}
		else if (insertRank > this.DG.maxRank) {
			this.DG.maxRank = insertRank;
			this.DG.order.insertRank(insertRank);
		}

		this.DG.ranks.splice(newNodeId, 0, insertRank);

		this.DG.order.insertAndShiftAllIdsAboveVByOne(newNodeId, insertRank, insertOrder);

		// update positions
		this.DG.positions.splice(newNodeId, 0, -Infinity);  // temporary position: will move to the correct location and shift other nodes below

		var nodeToKeepEdgeStraightTo = (inedge != null) ? inedge : outedge;
		this._heuristics.moveToCorrectPositionAndMoveOtherNodesAsNecessary(newNodeId, nodeToKeepEdgeStraightTo);

		return newNodeId;
	},

	_updateauxiliaryStructures: function (ranksBefore, rankYBefore) {
		var timer = new Helpers.Timer();

		// update vertical levels
		this.DG.vertLevel = this.DG.positionVertically();
		this.DG.rankY = this.DG.computeRankY(ranksBefore, rankYBefore);

		// update ancestors
		this.updateAncestors();

		timer.printSinceLast("=== Vertical spacing + ancestors runtime: ");
	},

	_getAllNodes: function (minID, maxID) {
		var nodes = [];
		var minID = minID ? minID : 0;
		var maxID = maxID ? Math.min(maxID, this.DG.GG.getMaxRealVertexId()) : this.DG.GG.getMaxRealVertexId();
		for (var i = minID; i <= maxID; i++) {
			if (this.DG.GG.type[i] == BaseGraph.TYPE.PERSON || this.DG.GG.type[i] == BaseGraph.TYPE.RELATIONSHIP)
				nodes.push(i);
		}
		return nodes;
	},

	_findMovedNodes: function (maxOldID, positionsBefore, ranksBefore, vertLevelsBefore, rankYBefore, consangrBefore, fastCheck) {
		//console.log("Before: " + Helpers.stringifyObject(vertLevelsBefore));
		//console.log("After:  " + Helpers.stringifyObject(this.DG.vertLevel));
		//console.log("Before: " + Helpers.stringifyObject(positionsBefore));
		//console.log("After: " + Helpers.stringifyObject(this.DG.positions));

		// TODO: some heuristics cause this behaviour. Easy to fix by normalization, but better look into root cause later
		// normalize positions: if the leftmost coordinate is now greater than it was before
		// make the old leftmost node keep it's coordinate
		var oldMin = Math.min.apply(Math, positionsBefore);
		var newMin = Math.min.apply(Math, this.DG.positions);
		if (newMin > oldMin) {
			var oldMinNodeID = Helpers.arrayIndexOf(positionsBefore, oldMin);
			if (oldMinNodeID > maxOldID) {
				// minNodeID is a virtual edge, its ID may have increased due to new real node insertions
				oldMinNodeID += (this.DG.GG.getMaxRealVertexId() - maxOldID);
			}
			var newMinValue = this.DG.positions[oldMinNodeID];
			var shiftAmount = newMinValue - oldMin;

			for (var i = 0; i < this.DG.positions.length; i++)
				this.DG.positions[i] -= shiftAmount;
		}


		var result = {};
		for (var i = 0; i <= maxOldID; i++) {
			// this node was moved
			if (this.DG.GG.type[i] == BaseGraph.TYPE.RELATIONSHIP || this.DG.GG.type[i] == BaseGraph.TYPE.PERSON) {
				var rank = this.DG.ranks[i];
				//if (rank != ranksBefore[i]) {
				//    this._addNodeAndAssociatedRelationships(i, result, maxOldID);
				//    continue;
				//}
				if (rankYBefore && this.DG.rankY[rank] != rankYBefore[ranksBefore[i]]) {
					this._addNodeAndAssociatedRelationships(i, result, maxOldID);
					continue;
				}
				if (this.DG.positions[i] != positionsBefore[i]) {
					this._addNodeAndAssociatedRelationships(i, result, maxOldID);
					continue;
				}
				// or it is a relationship with a long edge - redraw just in case since long edges may have complicated curves around other nodes
				if (this.DG.GG.type[i] == BaseGraph.TYPE.RELATIONSHIP) {
					if (consangrBefore && !consangrBefore.hasOwnProperty(i) && this.DG.consangr.hasOwnProperty(i)) {
						result[i] = true;
						continue;
					}
					if (!fastCheck) {
						var inEdges = this.DG.GG.getInEdges(i);
						if (inEdges[0] > this.DG.GG.maxRealVertexId || inEdges[1] > this.DG.GG.maxRealVertexId) {
							result[i] = true;
							continue;
						}
					}
					// check vertical positioning changes
					var parents = this.DG.GG.getParents(i);
					if (vertLevelsBefore.outEdgeVerticalLevel[parents[0]] !== undefined &&    // vertical levels may be outdated if multiple nodes were created in one batch
						vertLevelsBefore.outEdgeVerticalLevel[parents[1]] !== undefined) {
						if (vertLevelsBefore.outEdgeVerticalLevel[parents[0]][i].verticalLevel != this.DG.vertLevel.outEdgeVerticalLevel[parents[0]][i].verticalLevel ||
							vertLevelsBefore.outEdgeVerticalLevel[parents[1]][i].verticalLevel != this.DG.vertLevel.outEdgeVerticalLevel[parents[1]][i].verticalLevel) {
							result[i] = true;
							continue;
						}
					}

					var childHub = this.DG.GG.getRelationshipChildhub(i);
					if (vertLevelsBefore.childEdgeLevel[childHub] !== undefined && vertLevelsBefore.childEdgeLevel[childHub] != this.DG.vertLevel.childEdgeLevel[childHub]) {
						result[i] = true;
						continue;
					}
				}
			}
		}

		// check virtual edges: even if relationshipo node is not moved if the rank on which virtual edges reside moves
		// the relationship should redraw the virtual edges
		for (var i = this.DG.GG.getMaxRealVertexId() + 1; i <= this.DG.GG.getNumVertices(); i++) {
			var rank = this.DG.ranks[i];
			if (rankYBefore && rankYBefore.length >= rank && this.DG.rankY[rank] != rankYBefore[rank]) {
				var relationship = this.DG.GG.downTheChainUntilNonVirtual(i);
				if (relationship <= maxOldID) {
					result[relationship] = true;
				}
			}
		}

		var resultArray = [];
		for (var node in result) {
			if (result.hasOwnProperty(node)) {
				resultArray.push(parseInt(node));
			}
		}

		return resultArray;
	},

	_addNodeAndAssociatedRelationships: function (node, addToSet, maxOldID) {
		addToSet[node] = true;
		if (this.DG.GG.type[node] != BaseGraph.TYPE.PERSON) return;

		var inEdges = this.DG.GG.getInEdges(node);
		if (inEdges.length > 0) {
			var parentChildhub = inEdges[0];
			var parentRelationship = this.DG.GG.getInEdges(parentChildhub)[0];
			if (parentRelationship <= maxOldID)
				addToSet[parentRelationship] = true;
		}

		var outEdges = this.DG.GG.getOutEdges(node);
		for (var i = 0; i < outEdges.length; i++) {
			if (outEdges[i] <= maxOldID)
				addToSet[ outEdges[i] ] = true;
		}
	},

	//=============================================================

	_addMultiRankEdge: function (personId, relationshipId, _weight) {
		var weight = _weight ? _weight : 1.0;

		var rankPerson = this.DG.ranks[personId];
		var rankRelationship = this.DG.ranks[relationshipId];

		if (rankPerson > rankRelationship - 2)
			throw "Assertion failed: attempt to make a multi-rank edge between non-multirank ranks";

		var otherpartner = this.DG.GG.getInEdges(relationshipId)[0];

		var order_person = this.DG.order.vOrder[personId];
		var order_rel = this.DG.order.vOrder[relationshipId];

		var x_person = this.DG.positions[otherpartner];
		var x_relationship = this.DG.positions[relationshipId];

		var prevPieceOrder = (x_person < x_relationship) ? (order_rel + 1) : order_rel;
		var prevPieceId = this._insertVertex(BaseGraph.TYPE.VIRTUALEDGE, {}, weight, null, relationshipId, rankRelationship, prevPieceOrder);

		// TODO: an algorithm which optimizes the entire edge placement globally (not one piece at a time)

		var rankNext = rankRelationship;
		while (--rankNext > rankPerson) {

			var prevNodeX = this.DG.positions[prevPieceId];
			var orderToMakeEdgeStraight = this.DG.order.order[rankNext].length;
			for (var o = 0; o < this.DG.order.order[rankNext].length; o++)
				if (this.DG.positions[this.DG.order.order[rankNext][o]] >= prevNodeX) {
					orderToMakeEdgeStraight = o;
					break;
				}

			console.log("adding piece @ rank: " + rankNext + " @ order " + orderToMakeEdgeStraight);

			prevPieceId = this._insertVertex(BaseGraph.TYPE.VIRTUALEDGE, {}, weight, null, prevPieceId, rankNext, orderToMakeEdgeStraight);
		}

		//connect last piece with personId
		this.DG.GG.addEdge(personId, prevPieceId, weight);
	},


	//=============================================================

	_findBestInsertPosition: function (rank, edgeToV, preferLeft, _fromOrder, _toOrder) {
		// note: does not assert that the graph satisfies all the assumptions in BaseGraph.validate()

		if (rank == 0 || rank > this.DG.maxRank)
			return 0;

		// find the order on rank 'rank' to insert a new vertex so that the edge connecting this new vertex
		// and vertex 'edgeToV' crosses the smallest number of edges.
		var edgeToRank = this.DG.ranks[ edgeToV ];
		var edgeToOrder = this.DG.order.vOrder[edgeToV];

		if (edgeToRank == rank && this.isPerson(edgeToV))
			return this._findBestRelationshipPosition(edgeToV, preferLeft);

		var bestInsertOrder = 0;
		var bestCrossings = Infinity;
		var bestDistance = Infinity;

		var crossingChildhubEdgesPenalty = false;
		if (this.DG.GG.type[edgeToV] == BaseGraph.TYPE.CHILDHUB)
			crossingChildhubEdgesPenalty = true;

		var desiredOrder = 0;

		var edgeToX = this.DG.positions[edgeToV];
		for (var o = 0; o < this.DG.order.order[rank].length; o++) {
			var uAtPos = this.DG.order.order[rank][o];
			var uX = this.DG.positions[uAtPos];
			if (uX < edgeToX) {
				desiredOrder = o + 1;
			}
			else {
				break;
			}
		}

		// when inserting children below childhubs: next to other children
		if (this.DG.GG.type[edgeToV] == BaseGraph.TYPE.CHILDHUB && rank > edgeToRank && this.DG.GG.getOutEdges(edgeToV).length > 0)
			desiredOrder = this._findRightmostChildPosition(edgeToV) + 1;

		var fromOrder = _fromOrder ? Math.max(_fromOrder, 0) : 0;
		var toOrder = _toOrder ? Math.min(_toOrder, this.DG.order.order[rank].length) : this.DG.order.order[rank].length;
		for (var o = fromOrder; o <= toOrder; o++) {

			// make sure not inserting inbetween some twins
			if (o > 0 && o < this.DG.order.order[rank].length) {
				// skip virtual edges which may appear between twins
				var leftNodePos = o - 1;
				while (leftNodePos > 0 && this.DG.GG.isVirtual(this.DG.order.order[rank][leftNodePos]))
					leftNodePos--;
				rightNodePos = o;
				while (rightNodePos < this.DG.order.order[rank].length - 1 && this.DG.GG.isVirtual(this.DG.order.order[rank][rightNodePos]))
					rightNodePos--;
				var nodeToTheLeft = this.DG.order.order[rank][leftNodePos];
				var nodeToTheRight = this.DG.order.order[rank][rightNodePos];

				if (this.isPerson(nodeToTheLeft) && this.isPerson(nodeToTheRight)) {
					var rel1 = this.DG.GG.getProducingRelationship(nodeToTheLeft);
					var rel2 = this.DG.GG.getProducingRelationship(nodeToTheRight);
					if (rel1 == rel2) {
						var twinGroupId1 = this.DG.GG.getTwinGroupId(nodeToTheLeft);
						var twinGroupId2 = this.DG.GG.getTwinGroupId(nodeToTheRight);
						if (twinGroupId1 !== null && twinGroupId1 == twinGroupId2)
							continue;
					}
				}
			}

			var numCrossings = this._edgeCrossingsByFutureEdge(rank, o - 0.5, edgeToRank, edgeToOrder, crossingChildhubEdgesPenalty, edgeToV);

			//console.log("position: " + o + ", numCross: " + numCrossings);

			if (numCrossings < bestCrossings ||                           // less crossings
				(numCrossings == bestCrossings && Math.abs(o - desiredOrder) <= bestDistance )   // closer to desired position
				) {
				bestInsertOrder = o;
				bestCrossings = numCrossings;
				bestDistance = Math.abs(o - desiredOrder);
			}
		}

		//console.log("inserting @ rank " + rank + " with edge from " + edgeToV + " --> " + bestInsertOrder);
		return bestInsertOrder;
	},

	_findRightmostChildPosition: function (vertex) {
		var childrenInfo = this._heuristics.analizeChildren(vertex);
		return childrenInfo.rightMostChildOrder;
	},

	_edgeCrossingsByFutureEdge: function (newVRank, newVOrder, existingURank, existingUOrder, crossingChildhubEdgesPenalty, existingU) {
		// Note: newVOrder is expected to be a number between two existing orders, or higher than all, or lower than all

		// counts how many existing edges a new edge from given rank&order to given rank&order would cross
		// if order is an integer, it is assumed it goes form an existing vertex
		// if order is inbetween two integers, it is assumed it is the position used for a new-to-be-inserted vertex

		// for simplicity (to know if we need to check outEdges or inEdges) get the edge in the correct direction
		// (i.e. from lower ranks to higher ranks)
		var rankFrom = Math.min(newVRank, existingURank);
		var rankTo = Math.max(newVRank, existingURank);
		var orderFrom = (newVRank < existingURank) ? newVOrder : existingUOrder;
		var orderTo = (newVRank < existingURank) ? existingUOrder : newVOrder;

		// for better penalty computation handle the special case of adding a new child to an existing childhub
		var vSibglingInfo = undefined;
		if (this.DG.GG.isChildhub(existingU) && (newVRank > existingURank) &&
			this.DG.GG.getOutEdges(existingU).length > 0) {
			vSibglingInfo = this._heuristics.analizeChildren(existingU);

			if (vSibglingInfo.numWithTwoPartners < vSibglingInfo.orderedChildren.length) {
				// need to insert new node next to a sibling
				var okPosition = false;
				if (newVOrder > 0) {                                         // check left neighbour
					var leftNeighbour = this.DG.order.order[newVRank][ Math.floor(newVOrder)];
					var neighbourInEdges = this.DG.GG.getInEdges(leftNeighbour);
					if (neighbourInEdges.length == 1 && neighbourInEdges[0] == existingU) {
						okPosition = true;  // left neighbour is a sibling
					}
				}
				if (newVOrder < this.DG.order.order[newVRank].length - 1) {  // check right neighbour
					var rightNeighbour = this.DG.order.order[newVRank][ Math.ceil(newVOrder)];
					var neighbourInEdges = this.DG.GG.getInEdges(rightNeighbour);
					if (neighbourInEdges.length == 1 && neighbourInEdges[0] == existingU) {
						okPosition = true;  // right neighbour is a sibling
					}
				}
				if (!okPosition) {
					return Infinity;
				}
			}
		}

		var crossings = 0;

		if (rankFrom == rankTo) throw "TODO: probably not needed";

		// For multi-rank edges, crossing occurs if either
		// 1) there is an edge going from rank[v]-ranked vertex with a smaller order
		//     than v to a rank[targetV]-ranked vertex with a larger order than targetV
		// 2) there is an edge going from rank[v]-ranked vertex with a larger order
		//     than v to a rank[targetV]-ranked vertex with a smaller order than targetV

		var verticesAtRankTo = this.DG.order.order[ rankTo ];

		for (var ord = 0; ord < verticesAtRankTo.length; ord++) {
			if (ord == orderTo) continue;

			var vertex = verticesAtRankTo[ord];

			var inEdges = this.DG.GG.getInEdges(vertex);
			var len = inEdges.length;

			for (var j = 0; j < len; j++) {
				var target = inEdges[j];

				var penalty = 1;
				if (crossingChildhubEdgesPenalty && this.DG.GG.isChildhub(target)) {
					// don't want to insert a node inbetween siblings
					penalty = 100000;
					// ...unless siblings of the inserted node are already inbetween those siblings:
					if (vSibglingInfo) {
						var targetChildren = this._heuristics.analizeChildren(target);

						if (targetChildren.leftMostChildOrder < vSibglingInfo.rightMostChildOrder &&
							targetChildren.rightMostChildOrder > vSibglingInfo.leftMostChildOrder) {
							penalty = 1;
						}
					}
				}

				var orderTarget = this.DG.order.vOrder[target];
				var rankTarget = this.DG.ranks[target];

				if (rankTarget == rankTo) {
					if (ord < orderTo && orderTarget > orderTo ||
						ord > orderTo && orderTarget < orderTo)
						crossings += 2;
				}
				else {
					if (ord < orderTo && orderTarget > orderFrom ||
						ord > orderTo && orderTarget < orderFrom)
						crossings += penalty;
				}
			}
		}

		// try not to insert between a node and it's relationship
		// (for that only need check edges on the insertion rank)
		var verticesAtNewRank = this.DG.order.order[ newVRank ];
		for (var ord = 0; ord < verticesAtNewRank.length; ord++) {
			if (ord == newVOrder) continue;

			var vertex = verticesAtNewRank[ord];

			var outEdges = this.DG.GG.getOutEdges(vertex);
			var len = outEdges.length;

			for (var j = 0; j < len; j++) {
				var target = outEdges[j];

				var orderTarget = this.DG.order.vOrder[target];
				var rankTarget = this.DG.ranks[target];

				if (rankTarget == newVRank) {
					if (newVOrder < ord && newVOrder > orderTarget ||
						newVOrder > ord && newVOrder < orderTarget)
						crossings += 0.1;
				}
			}
		}


		return crossings;
	},

	_findBestRelationshipPosition: function (v, preferLeft, u) {
		// Handles two different cases:
		// 1) both partners are given ("v" and "u"). Then need to insert between v and u
		// 2) only one partner is given ("v"). Then given the choice prefer the left side if "preferleft" is true

		var rank = this.DG.ranks[v];
		var orderR = this.DG.order.order[rank];
		var isTwin = (this.DG.GG.getTwinGroupId(v) != null);
		var vOrder = this.DG.order.vOrder[v];

		var penaltyBelow = [];
		var penaltySameRank = [];
		for (var o = 0; o <= orderR.length; o++) {
			penaltyBelow[o] = 0;
			penaltySameRank[o] = 0;
		}

		// for each order on "rank" compute heuristic penalty for inserting a node before that order
		// based on the structure of nodes below
		for (var o = 0; o < orderR.length; o++) {
			var node = orderR[o];
			if (!this.isRelationship(node)) continue;
			var childrenInfo = this._heuristics.analizeChildren(node);

			// TODO: do a complete analysis without any heuristics
			if (childrenInfo.leftMostHasLParner) {
				penaltyBelow[o] += 1;
				penaltyBelow[o - 1] += 0.25;
			}   // 0.25 is just a heuristic estimation of how busy the level below is.
			if (childrenInfo.rightMostHasRParner) {
				penaltyBelow[o + 1] += 1;
				penaltyBelow[o + 2] += 0.25;
			}
		}

		// for each order on "rank" compute heuristic penalty for inserting a node before that order
		// based on the edges on that rank
		for (var o = 0; o < orderR.length; o++) {
			var node = orderR[o];
			if (!this.isRelationship(node)) continue;

			var relOrder = this.DG.order.vOrder[node];

			var parents = this.DG.GG.getInEdges(node);

			for (var p = 0; p < parents.length; p++) {
				var parent = parents[p];
				if (parent != v && this.DG.ranks[parent] == rank && parent != u) {
					var parentOrder = this.DG.order.vOrder[parent];

					var from = (parentOrder > relOrder) ? relOrder + 1 : parentOrder + 1;
					var to = (parentOrder > relOrder) ? parentOrder : relOrder;
					for (var j = from; j <= to; j++)
						penaltySameRank[j] = Infinity;
				}
			}
		}

		// add penalties for crossing child-to-parent lines, and forbid inserting inbetween twin nodes
		for (var o = 0; o < orderR.length; o++) {
			if (o == vOrder) continue;

			var node = orderR[o];
			if (!this.isPerson(node)) continue;
			var allTwins = this.getAllTwinsSortedByOrder(node);

			// forbid inserting inbetween twins
			if (allTwins.length > 1) {
				var leftMostTwinOrder = this.DG.order.vOrder[ allTwins[0] ];
				var rightMostTwinOrder = this.DG.order.vOrder[ allTwins[allTwins.length - 1] ];
				for (var j = leftMostTwinOrder + 1; j <= rightMostTwinOrder; j++)
					penaltySameRank[j] = Infinity;
				o = rightMostTwinOrder; // skip thorugh all other twins in this group
			}

			// penalty for crossing peron-to-parent line
			if (this.DG.GG.getProducingRelationship(node) != null) {
				if (o < vOrder) {
					for (var j = 0; j <= o; j++)
						penaltySameRank[j]++;
				}
				else {
					for (var j = o + 1; j <= orderR.length; j++)
						penaltySameRank[j]++;
				}
			}
		}

		console.log("Insertion same rank penalties: " + Helpers.stringifyObject(penaltySameRank));
		console.log("Insertion below penalties:     " + Helpers.stringifyObject(penaltyBelow));

		if (u === undefined) {
			if (preferLeft && vOrder == 0) return 0;

			var partnerInfo = this.DG._findLeftAndRightPartners(v);
			var numLeftOf = partnerInfo.leftPartners.length;
			var numRightOf = partnerInfo.rightPartners.length;

			// Note: given everything else being equal, prefer the right side - to move fewer nodes

			console.log("v: " + v + ", vOrder: " + vOrder + ", numL: " + numLeftOf + ", numR: " + numRightOf);

			if (!isTwin && numLeftOf == 0 && (preferLeft || numRightOf > 0)) return vOrder;
			if (!isTwin && numRightOf == 0)                                   return vOrder + 1;

			var bestPosition = vOrder + 1;
			var bestPenalty = Infinity;
			for (var o = 0; o <= orderR.length; o++) {
				var penalty = penaltyBelow[o] + penaltySameRank[o];
				if (o <= vOrder) {
					penalty += numLeftOf + (vOrder - o);        // o == order     => insert immediately to the left of, distance penalty = 0
					if (preferLeft)
						penalty -= 0.5;   // preferLeft => given equal penalty prefer left (0.5 is less than penalty diff due to other factors)
					else
						penalty += 0.5;   //
				}
				else {
					penalty += numRightOf + (o - vOrder - 1);   // o == (order+1) => insert immediately to the right of, distance penalty = 0
				}

				//console.log("order: " + o + ", penalty: " + penalty);
				if (penalty < bestPenalty) {
					bestPenalty = penalty;
					bestPosition = o;
				}
			}
			return bestPosition;
		}

		// for simplicity, lets make sure v is to the left of u
		if (this.DG.order.vOrder[v] > this.DG.order.vOrder[u]) {
			var tmp = u;
			u = v;
			v = tmp;
		}

		var orderV = this.DG.order.vOrder[v];
		var orderU = this.DG.order.vOrder[u];

		var partnerInfoV = this.DG._findLeftAndRightPartners(v);
		var numRightOf = partnerInfoV.rightPartners.length;
		var partnerInfoU = this.DG._findLeftAndRightPartners(u);
		var numLeftOf = partnerInfoU.leftPartners.length;

		if (numRightOf == 0 && numLeftOf > 0)  return orderV + 1;
		if (numRightOf > 0 && numLeftOf == 0) return orderU;

		var bestPosition = orderV + 1;
		var bestPenalty = Infinity;
		for (var o = orderV + 1; o <= orderU; o++) {
			var penalty = penaltyBelow[o] + penaltySameRank[o];

			for (var p = 0; p < partnerInfoV.rightPartners.length; p++) {
				var partner = partnerInfoV.rightPartners[p];
				if (o <= this.DG.order.vOrder[partner]) penalty++;
			}
			for (var p = 0; p < partnerInfoU.leftPartners.length; p++) {
				var partner = partnerInfoU.leftPartners[p];
				if (o > this.DG.order.vOrder[partner]) penalty++;
			}

			//console.log("order: " + o + ", penalty: " + penalty);

			if (penalty <= bestPenalty) {
				bestPenalty = penalty;
				bestPosition = o;
			}
		}
		return bestPosition;
	},

	//=============================================================

	_getAllPersonsOfGenders: function (validGendersSet, excludeAdoptedOut) {
		// all person nodes whose gender matches one of genders in the validGendersSet array

		// validate input genders
		for (var i = 0; i < validGendersSet.length; i++) {
			validGendersSet[i] = validGendersSet[i].toLowerCase();
			if (validGendersSet[i] != 'u' && validGendersSet[i] != 'm' && validGendersSet[i] != 'f' && validGendersSet[i] != 'o') {
				console.log("ERROR: Invalid gender: " + validGendersSet[i]);
				return [];
			}
		}

		var result = [];

		for (var i = 0; i <= this.DG.GG.getMaxRealVertexId(); i++) {
			if (!this.isPerson(i)) continue;
			if (this.isPersonGroup(i)) continue;
			if (this.isPlaceholder(i)) continue;
			if (excludeAdoptedOut && this.isAdoptedOut(i)) continue;
			var gender = this.getProperties(i)["gender"].toLowerCase();
			//console.log("trying: " + i + ", gender: " + gender + ", validSet: " + Helpers.stringifyObject(validGendersSet));
			if (Helpers.arrayContains(validGendersSet, gender))
				result.push(i);
		}

		return result;
	}
};


Heuristics = function (drawGraph) {
	this.DG = drawGraph;
};

Heuristics.prototype = {

	swapPartnerToBringToSideIfPossible: function (personId) {
		// attempts to swap this person with it's existing partner if the swap makes the not-yet-parnered
		// side of the person on the side which favours child insertion (e.g. the side where the child closest
		// to the side has no parners)

		if (this.DG.GG.getTwinGroupId(personId) !== null) return;  // there is a separate heuristic for twin rearrangements

		var rank = this.DG.ranks[personId];
		var order = this.DG.order.vOrder[personId];

		if (order == 0 || order == this.DG.order.order[rank].length - 1) return; // node on one of the sides: can do well without nay swaps

		var parnetships = this.DG.GG.getAllRelationships(personId);
		if (parnetships.length != 1) return;    // only if have exactly one parner
		var relationship = parnetships[0];
		var relOrder = this.DG.order.vOrder[relationship];

		var partners = this.DG.GG.getParents(relationship);
		var partnerId = (partners[0] == personId) ? partners[1] : partners[0];  // the only partner of personId
		var parnerOutEdges = this.DG.GG.getOutEdges(partnerId);
		if (parnerOutEdges.length != 1) return;  // only if parner also has exactly one parner (which is personId)

		if (this.DG.ranks[personId] != this.DG.ranks[partnerId]) return; // different ranks, heuristic does not apply

		var partnerOrder = this.DG.order.vOrder[partnerId];
		if (partnerOrder != order - 2 && partnerOrder != order + 2) return;  // only if next to each other

		// if both have parents do not swap so that parent edges are not crossed
		if (this.DG.GG.getInEdges(personId).length != 0 &&
			this.DG.GG.getInEdges(partnerId).length != 0) return;

		var childhubId = this.DG.GG.getOutEdges(relationship)[0]; // <=> getRelationshipChildhub(relationship)
		var children = this.DG.GG.getOutEdges(childhubId);

		if (children.length == 0) return;

		// TODO: count how many edges will be crossed in each case and also swap if we save a few crossings?

		// idea:
		// if (to the left  of parner && leftmostChild  has parner to the left  && rightmostchid has no parner to the right) -> swap
		// if (to the right of parner && rightmostChild has parner to the right && leftmostchid  has no parner to the left) -> swap

		var toTheLeft = (order < partnerOrder);

		var childrenPartners = this.analizeChildren(childhubId);

		if ((toTheLeft && childrenPartners.leftMostHasLParner && !childrenPartners.rightMostHasRParner) ||
			(!toTheLeft && childrenPartners.rightMostHasRParner && !childrenPartners.leftMostHasLParner) ||
			(order == 2 && childrenPartners.rightMostHasRParner) ||
			(order == this.DG.order.order[rank].length - 3 && childrenPartners.leftMostHasLParner)) {
			this.swapPartners(personId, partnerId, relationship);  // updates orders + positions
		}
	},

	swapTwinsToBringToSideIfPossible: function (personId) {
		var twinGroupId = this.DG.GG.getTwinGroupId(personId);
		if (twinGroupId === null) return;

		//TODO
	},

	analizeChildren: function (childhubId) {
		if (this.DG.GG.isRelationship(childhubId))
			childhubId = this.DG.GG.getOutEdges(childhubId)[0];

		if (!this.DG.GG.isChildhub(childhubId))
			throw "Assertion failed: applying analizeChildren() not to a childhub";

		var children = this.DG.GG.getOutEdges(childhubId);

		if (children.length == 0) return;

		var havePartners = {};
		var numWithPartners = 0;
		var numWithTwoPartners = 0;
		var leftMostChildId = undefined;
		var leftMostChildOrder = Infinity;
		var leftMostHasLParner = false;
		var rightMostChildId = undefined;
		var rightMostChildOrder = -Infinity;
		var rightMostHasRParner = false;

		var onlyPlaceholder = false;
		if (children.length == 1 && this.DG.GG.isPlaceholder(children[0])) {
			onlyPlaceholder = true;
		}

		for (var i = 0; i < children.length; i++) {
			var childId = children[i];
			var order = this.DG.order.vOrder[childId];

			if (order < leftMostChildOrder) {
				leftMostChildId = childId;
				leftMostChildOrder = order;
				leftMostHasLParner = this.hasParnerBetweenOrders(childId, 0, order - 1);  // has partner to the left
			}
			if (order > rightMostChildOrder) {
				rightMostChildId = childId;
				rightMostChildOrder = order;
				rightMostHasRParner = this.hasParnerBetweenOrders(childId, order + 1, Infinity);  // has partner to the right
			}
			if (this.DG.GG.getOutEdges(childId).length > 0) {
				havePartners[childId] = true;
				numWithPartners++;
				if (this.DG.GG.getOutEdges(childId).length > 1) {
					numWithTwoPartners++;
				}
			}
		}

		var orderedChildren = this.DG.order.sortByOrder(children);
		//console.log("ordered ch: " + Helpers.stringifyObject(orderedChildren));

		return {"leftMostHasLParner": leftMostHasLParner,
			"leftMostChildId": leftMostChildId,
			"leftMostChildOrder": leftMostChildOrder,
			"rightMostHasRParner": rightMostHasRParner,
			"rightMostChildId": rightMostChildId,
			"rightMostChildOrder": rightMostChildOrder,
			"withPartnerSet": havePartners,
			"numWithPartners": numWithPartners,
			"numWithTwoPartners": numWithTwoPartners,
			"orderedChildren": orderedChildren,
			"onlyPlaceholder": onlyPlaceholder };
	},

	hasParnerBetweenOrders: function (personId, minOrder, maxOrder) {
		var rank = this.DG.ranks[personId];
		var order = this.DG.order.vOrder[personId];

		var outEdges = this.DG.GG.getOutEdges(personId);

		for (var i = 0; i < outEdges.length; i++) {
			var relationship = outEdges[i];
			var relRank = this.DG.ranks[relationship];
			if (relRank != rank) continue;

			var relOrder = this.DG.order.vOrder[relationship];
			if (relOrder >= minOrder && relOrder <= maxOrder)
				return true;
		}

		return false;
	},

	swapPartners: function (partner1, partner2, relationshipId) {
		var rank = this.DG.ranks[partner1];
		if (this.DG.ranks[partner2] != rank || this.DG.ranks[relationshipId] != rank)
			throw "Assertion failed: swapping nodes of different ranks";

		var order1 = this.DG.order.vOrder[partner1];
		var order2 = this.DG.order.vOrder[partner2];
		var orderRel = this.DG.order.vOrder[relationshipId];

		// normalize: partner1 always to the left pf partner2, relationship in the middle
		if (order1 > order2) {
			var tmpOrder = order1;
			var tmpId = partner1;
			order1 = order2;
			partner1 = partner2;
			order2 = tmpOrder;
			partner2 = tmpId;
		}

		if ((order1 + 1) != orderRel || (orderRel + 1) != order2) return;

		this.DG.order.exchange(rank, order1, order2);

		var widthDecrease = this.DG.GG.getVertexWidth(partner1) - this.DG.GG.getVertexWidth(partner2);

		var pos2 = this.DG.positions[partner2];
		this.DG.positions[partner2] = this.DG.positions[partner1];
		this.DG.positions[partner1] = pos2 - widthDecrease;
		this.DG.positions[relationshipId] -= widthDecrease;
	},

	moveSiblingPlusPartnerToOrder: function (personId, partnerId, partnershipId, newOrder) {
		// transforms this
		//   [partnerSibling1 @ newOrder] ... [partnerSiblingN] [person]--[*]--[partner]
		// into
		//   [person @ newOrder]--[*]--[partner] [partnerSibling1] ... [partnerCiblingN]
		//
		// assumes 1. there are no relationship nodes between partnershipId & newOrder
		//         2. when moving left, partner is the rightmost node of the 3 given,
		//            when moving right partner is the leftmost node of the 3 given

		var rank = this.DG.ranks[partnerId];
		var partnerOrder = this.DG.order.vOrder[partnerId];
		var personOrder = this.DG.order.vOrder[personId];
		var relOrder = this.DG.order.vOrder[partnershipId];

		var moveOrders = newOrder - personOrder;

		var moveDistance = this.DG.positions[this.DG.order.order[rank][newOrder]] - this.DG.positions[personId];

		var moveRight = (newOrder > personOrder);
		var firstSibling = moveRight ? this.DG.order.order[rank][personOrder + 1] : this.DG.order.order[rank][personOrder - 1];
		var moveOtherDist = this.DG.positions[firstSibling] - this.DG.positions[partnerId];

		//console.log("before move: " + Helpers.stringifyObject(this.DG.order));

		this.DG.order.move(rank, personOrder, moveOrders);
		this.DG.order.move(rank, relOrder, moveOrders);
		this.DG.order.move(rank, partnerOrder, moveOrders);

		//console.log("after move: " + Helpers.stringifyObject(this.DG.order));

		this.DG.positions[personId] += moveDistance;
		this.DG.positions[partnerId] += moveDistance;
		this.DG.positions[partnershipId] += moveDistance;

		var minMovedOrder = moveRight ? partnerOrder : newOrder + 3;
		var maxMovedOrder = moveRight ? newOrder - 3 : partnerOrder;
		for (var o = minMovedOrder; o <= maxMovedOrder; o++) {
			var node = this.DG.order.order[rank][o];
			console.log("moving: " + node);
			this.DG.positions[node] -= moveOtherDist;
		}
	},

	swapBeforeParentsToBringToSideIfPossible: function (personId) {
		// used to swap this node AND its only partner to bring the two to the side to clear
		// space above for new parents of this node

		// 1. check that we have exactly one partner and it has parents - if not nothing to move
		var parnetships = this.DG.GG.getAllRelationships(personId);
		if (parnetships.length != 1) return;
		var relationshipId = parnetships[0];

		var partners = this.DG.GG.getParents(relationshipId);
		var partnerId = (partners[0] == personId) ? partners[1] : partners[0];  // the only partner of personId
		if (this.DG.GG.getInEdges(partnerId).length == 0) return; // partner has no parents!

		if (this.DG.ranks[personId] != this.DG.ranks[partnerId]) return; // different ranks, heuristic does not apply

		if (this.DG.GG.getOutEdges(partnerId).length > 1) return; // partner has multiple partnerships, too complicated

		var order = this.DG.order.vOrder[personId];
		var partnerOrder = this.DG.order.vOrder[partnerId];
		if (partnerOrder != order - 2 && partnerOrder != order + 2) return;  // only if next to each other

		var toTheLeft = (order < partnerOrder);

		// 2. check where the partner stands among its siblings
		var partnerChildhubId = this.DG.GG.getInEdges(partnerId)[0];
		var partnerSibglingInfo = this.analizeChildren(partnerChildhubId);

		//if (partnerSibglingInfo.orderedChildren.length == 1) return; // just one sibling, nothing to do
		if (partnerSibglingInfo.orderedChildren.length > 1) {
			// simple cases:  ...
			//                 |
			//       +---------+-----------|
			//       |                     |
			//   [sibling]--[personID]  [sibling]
			if (partnerSibglingInfo.leftMostChildId == partnerId) {
				if (!toTheLeft)
					this.swapPartners(personId, partnerId, relationshipId);
				return;
			}
			if (partnerSibglingInfo.rightMostChildId == partnerId) {
				if (toTheLeft)
					this.swapPartners(personId, partnerId, relationshipId);
				return;
			}
		}

		// ok, partner is in the middle => may need to move some nodes around to place personId in a
		//                                 position where parents can be inserted with least disturbance

		// 2. check how many partners partner's parents have. if both have more than one the case
		//    is too complicated and skip moving nodes around
		var partnerParents = this.DG.GG.getInEdges(this.DG.GG.getInEdges(partnerChildhubId)[0]);
		var order0 = this.DG.order.vOrder[partnerParents[0]];
		var order1 = this.DG.order.vOrder[partnerParents[1]];
		var leftParent = (order0 > order1) ? partnerParents[1] : partnerParents[0];
		var rightParent = (order0 > order1) ? partnerParents[0] : partnerParents[1];
		console.log("parents: " + Helpers.stringifyObject(partnerParents));
		var numLeftPartners = this.DG.GG.getOutEdges(leftParent).length;
		var numRightPartners = this.DG.GG.getOutEdges(rightParent).length;
		console.log("num left: " + numLeftPartners + ", numRight: " + numRightPartners);
		if (numLeftPartners > 1 && numRightPartners > 1) return;

		if (partnerSibglingInfo.orderedChildren.length == 1) {
			if (numLeftPartners == 1 && numRightPartners == 1) {
				// no need to move anything enywhere, we are fine as we are now
				return;
			}
			if (numLeftPartners == 1 && !toTheLeft) {
				this.swapPartners(personId, partnerId, relationshipId);
			}
			if (numRightPartners == 1 && toTheLeft) {
				this.swapPartners(personId, partnerId, relationshipId);
			}
			return; // the rest is for the case of multiple children
		}

		// 3. check how deep the tree below is.
		//    do nothing if any children have partners (too complicated for a heuristic)
		var childHubBelow = this.DG.GG.getRelationshipChildhub(relationshipId);
		var childrenInfo = this.analizeChildren(childHubBelow);
		if (childrenInfo.numWithPartners > 0) return;  // too complicated for a heuristic

		// 4. ok, the tree below is not deep, partner is surrounded by siblings.
		//    check if we can move it right or left easily:
		//    move to the right iff: rightmostchild has no partners && rightParent has no partners
		//    move to the left iff: leftmostchild has no partners && leftParent has no partners
		if (numRightPartners == 1 && !partnerSibglingInfo.rightMostHasRParner) {
			for (var c = partnerSibglingInfo.orderedChildren.length - 1; c >= 0; c--) {
				var sibling = partnerSibglingInfo.orderedChildren[c];
				if (sibling == partnerId) {
					if (toTheLeft)
						this.swapPartners(personId, partnerId, relationshipId);
					this.moveSiblingPlusPartnerToOrder(personId, partnerId, relationshipId, partnerSibglingInfo.rightMostChildOrder);
					return;
				}
				if (partnerSibglingInfo.withPartnerSet.hasOwnProperty(sibling)) break; // does not work on this side
			}
		}
		if (numLeftPartners == 1 && !partnerSibglingInfo.leftMostHasLParner) {
			for (var c = 0; c < partnerSibglingInfo.orderedChildren.length; c++) {
				var sibling = partnerSibglingInfo.orderedChildren[c];
				if (sibling == partnerId) {
					if (!toTheLeft)
						this.swapPartners(personId, partnerId, relationshipId);
					this.moveSiblingPlusPartnerToOrder(personId, partnerId, relationshipId, partnerSibglingInfo.leftMostChildOrder);
					return;
				}
				if (partnerSibglingInfo.withPartnerSet.hasOwnProperty(sibling)) break; // does not work on this side
			}
		}
	},

	improvePositioning: function (ranksBefore, rankYBefore) {
		var timer = new Helpers.Timer();

		//console.log("pre-fix orders: " + Helpers.stringifyObject(this.DG.order.order[2]));
		//var xcoord = new XCoord(this.DG.positions, this.DG);
		//this.DG.displayGraph(xcoord.xcoord, "pre-fix");

		//DEBUG: for testing how layout looks when multi-rank edges are not improved
		//this.DG.vertLevel = this.DG.positionVertically();
		//this.DG.rankY     = this.DG.computeRankY(ranksBefore, rankYBefore);
		//return;

		// given a finished positioned graph (asserts the graph is valid):
		//
		// 1. fix some display requirements, such as relationship lines always going to the right or left first before going down
		//
		// 2. fix some common layout imperfections, such as:
		//    A) the only relationship not right above the only child: can be fixed by
		//       a) moving the child, if possible without disturbiung other nodes
		//       b) moving relationship + one (or both, if possible) partners, if possible without disturbiung other nodes
		//    B) relationship not above one of it's children (preferably one in the middle) and not
		//       right in the midpoint between left and right child: can be fixed by
		//       a) moving relationship + both partners, if possible without disturbiung other nodes
		//    C) not nice long edge crossings (example pending) - TODO
		//    D) a relationship edge can be made shorter and bring two parts of the graph separated by the edge closer together
		//    E) after everything else try to center relationships between the partners (and move children accordingly)

		// 1) improve layout of multi-rank relationships:
		//    relationship lines should always going to the right or left first before going down
		var modified = false;
		for (var parent = 0; parent <= this.DG.GG.getMaxRealVertexId(); parent++) {
			if (!this.DG.GG.isPerson(parent)) continue;

			var rank = this.DG.ranks[parent];
			var order = this.DG.order.vOrder[parent];

			var outEdges = this.DG.GG.getOutEdges(parent);

			var sameRankToTheLeft = 0;
			var sameRankToTheRight = 0;

			var multiRankEdges = [];
			for (var i = 0; i < outEdges.length; i++) {
				var node = outEdges[i];
				if (this.DG.ranks[node] != rank)
					multiRankEdges.push(node);
				else {
					if (this.DG.order.vOrder[node] < order)
						sameRankToTheLeft++;
					else
						sameRankToTheRight++;
				}
			}
			if (multiRankEdges.length == 0) continue;

			// sort all by their xcoordinate if to the left of parent, and in reverse order if to the right of parent
			// e.g. [1] [2] [3] NODE [4] [5] [6] gets sorted into [1,2,3, 6,5,4], so that edges that end up closer
			// to the node can be inserted closer as wel, and end up below other edges thus eliminating any intersections
			var _this = this;
			byXcoord = function (v1, v2) {
				var rel1 = _this.DG.GG.downTheChainUntilNonVirtual(v1);
				var rel2 = _this.DG.GG.downTheChainUntilNonVirtual(v2);
				var position1 = _this.DG.positions[rel1];
				var position2 = _this.DG.positions[rel2];
				var parentPos = _this.DG.positions[parent];
				//console.log("v1: " + v1 + ", pos: " + position1 + ", v2: " + v2 + ", pos: " + position2 + ", parPos: " + parentPos);
				if (position1 >= parentPos && position2 >= parentPos)
					return position2 - position1;
				else
					return position1 - position2;
			};
			multiRankEdges.sort(byXcoord);

			console.log("multi-rank edges: " + Helpers.stringifyObject(multiRankEdges));

			for (var p = 0; p < multiRankEdges.length; p++) {

				var firstOnPath = multiRankEdges[p];

				var relNode = this.DG.GG.downTheChainUntilNonVirtual(firstOnPath);

				// replace the edge from parent to firstOnPath by an edge from parent to newNodeId and
				// from newNodeId to firstOnPath
				var weight = this.DG.GG.removeEdge(parent, firstOnPath);

				var newNodeId = this.DG.GG.insertVertex(BaseGraph.TYPE.VIRTUALEDGE, {}, weight, [parent], [firstOnPath]);

				this.DG.ranks.splice(newNodeId, 0, rank);

				var insertToTheRight = (this.DG.positions[relNode] < this.DG.positions[parent]) ? false : true;

				if (this.DG.positions[relNode] == this.DG.positions[parent]) {
					if (sameRankToTheRight > 0 && sameRankToTheLeft == 0 && multiRankEdges.length == 1) {
						insertToTheRight = false;  // only one long edge and only one other edge: insert on the other side regardless of anything else
					}
				}

				//console.log("inserting " + newNodeId + " (->" + firstOnPath + "), rightSide: " + insertToTheRight + " (pos[relNode]: " + this.DG.positions[relNode] + ", pos[parent]: " + this.DG.positions[parent]);

				var parentOrder = this.DG.order.vOrder[parent]; // may have changed form what it was before due to insertions

				var newOrder = insertToTheRight ? parentOrder + 1 : parentOrder;
				if (insertToTheRight) {
					while (newOrder < this.DG.order.order[rank].length &&
						this.DG.positions[firstOnPath] > this.DG.positions[ this.DG.order.order[rank][newOrder] ])
						newOrder++;

					// fix common imperfection when this edge will cross a node-relationship edge. Testcase 4e covers this case.
					var toTheLeft = this.DG.order.order[rank][newOrder - 1];
					var toTheRight = this.DG.order.order[rank][newOrder];
					if (this.DG.GG.isRelationship(toTheLeft) && this.DG.GG.isPerson(toTheRight) &&
						this.DG.GG.hasEdge(toTheRight, toTheLeft) && this.DG.GG.getOutEdges(toTheRight).length == 1)
						newOrder++;
					if (this.DG.GG.isRelationship(toTheRight) && this.DG.GG.isPerson(toTheLeft) &&
						this.DG.GG.hasEdge(toTheLeft, toTheRight) && this.DG.GG.getOutEdges(toTheLeft).length == 1)
						newOrder--;
				}
				else {
					while (newOrder > 0 &&
						this.DG.positions[firstOnPath] < this.DG.positions[ this.DG.order.order[rank][newOrder - 1] ])
						newOrder--;

					// fix common imprefetion when this edge will cross a node-relationship edge
					var toTheLeft = this.DG.order.order[rank][newOrder - 1];
					var toTheRight = this.DG.order.order[rank][newOrder];
					if (this.DG.GG.isRelationship(toTheRight) && this.DG.GG.isPerson(toTheLeft) &&
						this.DG.GG.hasEdge(toTheLeft, toTheRight) && this.DG.GG.getOutEdges(toTheLeft).length == 1)
						newOrder--;
					if (this.DG.GG.isRelationship(toTheLeft) && this.DG.GG.isPerson(toTheRight) &&
						this.DG.GG.hasEdge(toTheRight, toTheLeft) && this.DG.GG.getOutEdges(toTheRight).length == 1)
						newOrder++;
				}

				this.DG.order.insertAndShiftAllIdsAboveVByOne(newNodeId, rank, newOrder);

				// update positions
				this.DG.positions.splice(newNodeId, 0, -Infinity);  // temporary position: will move to the correct location and shift other nodes below
				//this.DG.positions.splice( newNodeId, 0, 100 );

				var nodeToKeepEdgeStraightTo = firstOnPath;
				this.moveToCorrectPositionAndMoveOtherNodesAsNecessary(newNodeId, nodeToKeepEdgeStraightTo);

				modified = true;
			}
		}

		this.optimizeLongEdgePlacement();

		timer.printSinceLast("=== Long edge handling runtime: ");

		//DEBUG: for testing how layout looks without any improvements
		//this.DG.vertLevel = this.DG.positionVertically();
		//this.DG.rankY     = this.DG.computeRankY(ranksBefore, rankYBefore);
		//return;

		// 2) fix some common layout imperfections
		var xcoord = new XCoord(this.DG.positions, this.DG);
		//this.DG.displayGraph(xcoord.xcoord, "after-long-edge-improvement");

		for (var v = 0; v <= this.DG.GG.getMaxRealVertexId(); v++) {
			if (!this.DG.GG.isRelationship(v)) continue;
			var childhub = this.DG.GG.getRelationshipChildhub(v);
			var relX = xcoord.xcoord[v];
			var childhubX = xcoord.xcoord[childhub];
			if (childhubX != relX) {
				improved = xcoord.moveNodeAsCloseToXAsPossible(childhub, relX);
			}
		}

		// search for gaps between children (which may happen due to deletions) and close them by moving children closer to each other
		for (var v = 0; v <= this.DG.GG.getMaxRealVertexId(); v++) {
			if (!this.DG.GG.isChildhub(v)) continue;
			var children = this.DG.GG.getOutEdges(v);
			if (children.length < 2) continue;

			var orderedChildren = this.DG.order.sortByOrder(children);

			// compress right-side children towards leftmost child, only moving childen withoout relationships
			for (var i = orderedChildren.length - 1; i >= 0; i--) {
				if (i == 0 || this.DG.GG.getOutEdges(orderedChildren[i]).length > 0) {
					for (var j = i + 1; j < orderedChildren.length; j++) {
						xcoord.shiftLeftOneVertex(orderedChildren[j], Infinity);
					}
					break;
				}
			}
			// compress left-side children towards rightmost child, only moving childen without relationships
			for (var i = 0; i < orderedChildren.length; i++) {
				if (i == (orderedChildren.length - 1) || this.DG.GG.getOutEdges(orderedChildren[i]).length > 0) {
					for (var j = i - 1; j >= 0; j--) {
						xcoord.shiftRightOneVertex(orderedChildren[j], Infinity);
					}
					break;
				}
			}
		}

		//this.DG.displayGraph(xcoord.xcoord, "after-basic-improvement");

		this._compactGraph(xcoord, 5);

		//this.DG.displayGraph(xcoord.xcoord, "after-compact1");

		var orderedRelationships = this.DG.order.getLeftToRightTopToBottomOrdering(BaseGraph.TYPE.RELATIONSHIP, this.DG.GG);
		//console.log("Ordered rels: " + Helpers.stringifyObject(orderedRelationships));

		var iter = 0;
		var improved = true;
		while (improved && iter < 20) {
			improved = false;
			iter++;
			//console.log("iter: " + iter);

			// fix relative positioning of relationships to their children
			for (var k = 0; k < orderedRelationships.length; k++) {
				var v = orderedRelationships[k];

				var parents = this.DG.GG.getInEdges(v);
				var childhub = this.DG.GG.getRelationshipChildhub(v);

				var relX = xcoord.xcoord[v];
				var childhubX = xcoord.xcoord[childhub];

				var childInfo = this.analizeChildren(childhub);

				//if (childInfo.onlyPlaceholder) continue;

				var misalignment = 0;

				// First try easy options: moving nodes without moving any other nodes (works in most cases and is fast)

				// relationship withone child: special case for performance reasons
				if (childInfo.orderedChildren.length == 1) {
					var childId = childInfo.orderedChildren[0];
					if (xcoord.xcoord[childId] == childhubX) continue;

					improved = xcoord.moveNodeAsCloseToXAsPossible(childId, childhubX);
					//console.log("moving " + childId + " to " + xcoord.xcoord[childId]);

					if (xcoord.xcoord[childId] == childhubX) continue; // done

					// ok, we can't move the child. Try to move the relationship & the parent(s)
					misalignment = xcoord.xcoord[childId] - childhubX;
				}
				// relationships with many children: want to position in the "middle" inbetween the left and right child
				//  (for one of the two definitionsof middle: exact center betoween leftmost and rightmost, or
				//   right above the central child, e.g. 2nd of the 3)
				else {
					var positionInfo = this._computeDesiredChildhubLocation(childInfo, xcoord);

					// no need to move anything when parent line is either above the mid-point between the leftmost and rightmost child
					// or above the middle child of the three
					if (positionInfo.minPreferred <= childhubX && childhubX <= positionInfo.maxPreferred) continue;

					// of the two "OK" points pick the one which requires less movement
					var shiftToX = (childhubX > positionInfo.maxPreferred) ? positionInfo.maxPreferred : positionInfo.minPreferred;

					var needToShift = childhubX - shiftToX;

					if (childInfo.numWithPartners == 0) {
						// can shift children easily
						if (needToShift < 0) {  // need to shift children left
							var leftMost = childInfo.leftMostChildId;
							var leftSlack = xcoord.getSlackOnTheLeft(leftMost);
							var haveSlack = Math.min(Math.abs(needToShift), leftSlack);
							if (haveSlack > 0) {
								for (var i = 0; i < childInfo.orderedChildren.length; i++)
									xcoord.xcoord[childInfo.orderedChildren[i]] -= haveSlack;
								improved = true;
								needToShift += haveSlack;
							}
						}
						else {  // need to shift children right
							var rightMost = childInfo.rightMostChildId;
							var rightSlack = xcoord.getSlackOnTheRight(rightMost);
							var haveSlack = Math.min(needToShift, rightSlack);
							if (haveSlack > 0) {
								for (var i = 0; i < childInfo.orderedChildren.length; i++)
									xcoord.xcoord[childInfo.orderedChildren[i]] += haveSlack;
								improved = true;
								needToShift -= haveSlack;
							}
						}
					}
					misalignment = -needToShift;
				}

				if (misalignment == 0) continue;

				// OK, harder case: either move the parents or the children (with whatever nodes are connected to them, in both cases).
				// (need to make sure we do not break what has already been good, or we may be stuck in an infinite improvement loop)

				// try to either shift the entire distance (misalignment) or (if that fails) at least
				// as far as parents can go without pushing other nodes

				//var id = id ? (id+1) : 1; // DEBUG
				//console.log("Analizing for childhub " + childhub);

				var leftParent = (xcoord.xcoord[parents[0]] < xcoord.xcoord[parents[1]]) ? parents[0] : parents[1];
				var rightParent = (xcoord.xcoord[parents[0]] < xcoord.xcoord[parents[1]]) ? parents[1] : parents[0];

				var shiftList = [v, childhub];
				if (this.DG.order.vOrder[leftParent] == this.DG.order.vOrder[v] - 1 && !this.DG.GG.isVirtual(leftParent)) {
					if (misalignment > 0 || xcoord.getSlackOnTheLeft(v) < -misalignment)
						shiftList.unshift(leftParent);
				}
				if (this.DG.order.vOrder[rightParent] == this.DG.order.vOrder[v] + 1 && !this.DG.GG.isVirtual(rightParent)) {
					if (misalignment < 0 || xcoord.getSlackOnTheRight(v) < misalignment)
						shiftList.push(rightParent);
				}
				var noUpSet = {};
				noUpSet[v] = true;
				// findAffectedSet: function(v_list, dontmove_set, noUp_set, noDown_set, forbidden_set, shiftSize, xcoord, stopAtVirtual, minimizeMovement, stopAtPersons, stopAtRels)
				var affectedInfoParentShift = this._findAffectedSet(shiftList, {}, noUpSet, Helpers.toObjectWithTrue(shiftList), Helpers.toObjectWithTrue(childInfo.orderedChildren),
					misalignment, xcoord, true, false, 7, 3);

				var shiftList = childInfo.orderedChildren;
				var forbiddenList = [v, childhub];
				var affectedInfoChildShift = this._findAffectedSet(shiftList, {}, Helpers.toObjectWithTrue(childInfo.orderedChildren), {}, Helpers.toObjectWithTrue(forbiddenList),
					-misalignment, xcoord, true, false, 7, 3);

				var parentShiftAcceptable = this._isShiftSizeAcceptable(affectedInfoParentShift, false, 7, 3);
				var childShiftAcceptable = this._isShiftSizeAcceptable(affectedInfoChildShift, false, 7, 3);
				//console.log("["+id+"] affectedInfoParentShift: " + Helpers.stringifyObject(affectedInfoParentShift) + ", acceptable: " + parentShiftAcceptable);
				//console.log("["+id+"] affectedInfoChildShift:  " + Helpers.stringifyObject(affectedInfoChildShift) + ", acceptable: " + childShiftAcceptable);

				if (parentShiftAcceptable || childShiftAcceptable) {
					improved = true;   // at least one of the shifts is OK

					// pick which one to use
					if (parentShiftAcceptable &&
						(!childShiftAcceptable || this._isShiftBetter(affectedInfoParentShift, affectedInfoChildShift))) {
						var nodes = affectedInfoParentShift.nodes;
						//console.log("["+id+"] Shifting parents by [" + misalignment + "]: " + Helpers.stringifyObject(nodes));
						for (var i = 0; i < nodes.length; i++)
							xcoord.xcoord[nodes[i]] += misalignment;
					} else {
						var nodes = affectedInfoChildShift.nodes;
						//console.log("["+id+"] Shifting children by [" + misalignment + "]: " + Helpers.stringifyObject(nodes));
						for (var i = 0; i < nodes.length; i++)
							xcoord.xcoord[nodes[i]] -= misalignment;
					}

					//xcoord.normalize();  // DEBUG
					//this.DG.displayGraph(xcoord.xcoord, "shift-"+id);
					continue;
				}

				// ok, can't move all the way: see if we can move parents at least a little in the desired direction
				if (misalignment < 0) {
					var leftShiftingNode = (this.DG.order.vOrder[leftParent] == this.DG.order.vOrder[v] - 1) ? leftParent : v;
					var smallShift = Math.max(-xcoord.getSlackOnTheLeft(leftShiftingNode), misalignment);
					if (smallShift == 0 || smallShift == misalignment) continue;
				} else {
					var rightShiftingNode = (this.DG.order.vOrder[rightParent] == this.DG.order.vOrder[v] + 1) ? rightParent : v;
					var smallShift = Math.min(xcoord.getSlackOnTheLeft(rightShiftingNode), misalignment);
					if (smallShift == 0 || smallShift == misalignment) continue;
				}

				var shiftList = [v, childhub];
				if (this.DG.order.vOrder[leftParent] == this.DG.order.vOrder[v] - 1 && !this.DG.GG.isVirtual(leftParent))
					shiftList.unshift(leftParent);
				if (this.DG.order.vOrder[rightParent] == this.DG.order.vOrder[v] + 1 && !this.DG.GG.isVirtual(rightParent))
					shiftList.push(rightParent);
				var noUpSet = {};
				noUpSet[v] = true;
				var affectedInfoParentShift = this._findAffectedSet(shiftList, {}, noUpSet, Helpers.toObjectWithTrue(shiftList), Helpers.toObjectWithTrue(childInfo.orderedChildren),
					smallShift, xcoord, true, false, 3, 2);

				if (this._isShiftSizeAcceptable(affectedInfoParentShift, false, 3, 2)) {
					var nodes = affectedInfoParentShift.nodes;
					//console.log("["+id+"] Small-shifting parents by [" + smallShift + "]: " + Helpers.stringifyObject(nodes));
					for (var i = 0; i < nodes.length; i++)
						xcoord.xcoord[nodes[i]] += smallShift;

					//xcoord.normalize();  // DEBUG
					//this.DG.displayGraph(xcoord.xcoord, "shift-"+id);
					continue;
				}
				//----------------------------------------------------------------
			}
		}

		// 2D) check if there is any extra whitespace in the graph, e.g. if a subgraph can be
		//     moved closer to the rest of the graph by shortening some edges (this may be
		//     the case after some imperfect insertion heuristics move stuff too far).
		//     E.g. see Testcase 5g with/without compacting
		//this.DG.displayGraph(xcoord.xcoord, "before-compact2");

		this._compactGraph(xcoord);

		//this.DG.displayGraph(xcoord.xcoord, "after-compact2");

		// 2E) center relationships between partners. Only do it if children-to-relationship positioning does not get worse
		//     (e.g. if it was centrered then if children can be shifted to stay centered)
		var iter = 0;
		var improved = true;
		while (improved && iter < 20) {
			improved = false;
			iter++;
			for (var k = 0; k < orderedRelationships.length; k++) {
				var v = orderedRelationships[k];

				var parents = this.DG.GG.getInEdges(v);
				var orderedParents = this.DG.order.sortByOrder(parents);

				// only shift rel if partners are next to each other with only this relationship in between
				if (Math.abs(this.DG.order.vOrder[parents[0]] - this.DG.order.vOrder[parents[1]]) != 2) continue;

				var leftParentRightSide = xcoord.getRightEdge(orderedParents[0]);
				var rightParentLeftSide = xcoord.getLeftEdge(orderedParents[1]);

				var relX = xcoord.xcoord[v];
				var midX = Math.floor((leftParentRightSide + rightParentLeftSide) / 2);

				if (relX == midX) continue;

				//xcoord.normalize();  // DEBUG
				//this.DG.displayGraph(xcoord.xcoord, "pre-imnprove");

				var childhub = this.DG.GG.getRelationshipChildhub(v);

				var shiftSize = (midX - relX);
				var shiftList = [v, childhub];
				var noUpSet = {};
				noUpSet[v] = true;
				var affectedInfo = this._findAffectedSet(shiftList, {}, noUpSet, {}, {}, shiftSize, xcoord, true, false, 5, 3, this.DG.ranks[v]);

				// need to check minAffectedRank to make sure we don't move relationships with lower ranks, which are supposedly well-positioned already
				if (this._isShiftSizeAcceptable(affectedInfo, false, 5, 3) && affectedInfo.minAffectedRank > this.DG.ranks[v]) {
					var nodes = affectedInfo.nodes;
					//console.log("Middle-positioning relationship by [" + shiftSize + "]: " + Helpers.stringifyObject(nodes));
					for (var i = 0; i < nodes.length; i++)
						xcoord.xcoord[nodes[i]] += shiftSize;
					improved = true;
				}
			}
		}

		//xcoord.normalize();

		this.DG.positions = xcoord.xcoord;

		timer.printSinceLast("=== Improvement runtime: ");

		this.DG.vertLevel = this.DG.positionVertically();
		this.DG.rankY = this.DG.computeRankY(ranksBefore, rankYBefore);

		timer.printSinceLast("=== Vertical spacing runtime: ");
	},

	_compactGraph: function (xcoord, maxComponentSize) {
		// tries to shorten edges that can be shortened (thus compacting the graph)
		//
		// for each node checks if it has "slack" on the left and right, and iff slack > 0 computes
		// the disconnected components resulting from removal of all edges spanning the larger-than-necessary gap.
		// if components can be moved close to each other (because all nodes on the "edge" also have slack) does so.
		//
		// stops component computation when component size is greater than `maxComponentSize` (and does not move that component)
		// (for performance reasons: there is a small pass with a small value to fix minor imperfections before a lot
		// of other heuristics are applied, and then a pass with unlimited component size if performed at the end

		if (!maxComponentSize) maxComponentSize = Infinity;

		//console.log("---[maxCompSize: " + maxComponentSize  + "]---");

		var iter = 0;
		var improved = true;
		while (improved && iter < 20) {
			improved = false;
			iter++;

			// go rank-by-rank, node-by-node
			for (var rank = 1; rank < this.DG.order.order.length; rank++) {
				for (var order = 0; order < this.DG.order.order[rank].length - 1; order++) {
					var v = this.DG.order.order[rank][order];

					if (this.DG.GG.isChildhub(v)) break; // skip childhub level entirely

					var slack = xcoord.getSlackOnTheRight(v);
					//console.log("V = " + v + ", slack: " + slack);
					if (slack == 0) continue;

					// so, v has some slack on the right
					// let see if we can shorten the distance between v and its right neighbour (by shortening
					// all edges spanning the gap between v and its right neighbour - without bumping any nodes
					// connected by all other edges into each other)

					var DG = this.DG;
					var excludeEdgesSpanningOrder = function (from, to) {
						// filter to exclude all edges spanning the gap between v and its right neighbour
						if (DG.ranks[from] == rank && DG.ranks[to] == rank) {
							var orderFrom = DG.order.vOrder[from];
							var orderTo = DG.order.vOrder[to];
							if ((orderFrom <= order && orderTo > order) ||
								(orderTo <= order && orderFrom > order)) {
								return false;
							}
						}
						return true;
					};

					var rightNeighbour = this.DG.order.order[rank][order + 1];

					// either move V and nodes connected to V left, or rightNeighbour and nodes connected to it right
					// (in both cases "connected" means "connected not using edges spanning V-rightNeighbour gap")
					// If maxComponentSize is not limited, then no point to analize other component, since
					var stopSet = {};
					stopSet[rightNeighbour] = true;
					var component = this.DG.findConnectedComponent(v, excludeEdgesSpanningOrder, stopSet, maxComponentSize);
					var leftSide = true;

					if (component.stopSetReached) continue; // can't shorten here: nodes are firmly connected via other edges

					if (component.size > maxComponentSize) {
						// can't move component on the left - it is too big. Check the right side
						component = this.DG.findConnectedComponent(rightNeighbour, excludeEdgesSpanningOrder, {}, maxComponentSize);
						if (component.size > maxComponentSize) continue;  // can't move component on the right - too big as well
						leftSide = false;
					}

					slack = leftSide ? xcoord.findVertexSetSlacks(component.component).rightSlack // slack on the right side of left component
						: -xcoord.findVertexSetSlacks(component.component).leftSlack;

					if (slack == 0) continue;
					console.log("Moving: " + Helpers.stringifyObject(component.component) + " by " + slack);

					improved = true;

					for (var node in component.component) {
						if (component.component.hasOwnProperty(node)) {
							xcoord.xcoord[node] += slack;
						}
					}
				}
			}

			if (!isFinite(maxComponentSize)) {
				// after all other types of nodes have been moved check if childhub nodes need any movement as well
				// this is similar to relationship-to-children positioning but is done globally not locally
				for (var rank = 1; rank < this.DG.order.order.length; rank++) {
					for (var order = 0; order < this.DG.order.order[rank].length; order++) {
						var v = this.DG.order.order[rank][order];
						if (this.DG.GG.isPerson(v)) break;        // wrong rank
						if (this.DG.GG.isRelationship(v)) break;  // wrong rank
						if (!this.DG.GG.isChildhub(v)) continue;  // childhub rank may have long edges in addition to childhubs

						var childhubX = xcoord.xcoord[v];

						var childInfo = this.analizeChildren(v);
						var childPositionInfo = this._computeDesiredChildhubLocation(childInfo, xcoord);
						if (childhubX >= childPositionInfo.leftX && childhubX <= childPositionInfo.rightX) continue;

						var shiftChhub = (childhubX > childPositionInfo.maxPreferred) ?
							(childPositionInfo.maxPreferred - childhubX) :
							(childPositionInfo.minPreferred - childhubX);

						// either move childhub and nodes connected to it towards the children, or children
						// and nodes connected to it towards the childhub

						var noChildEdges = function (from, to) {
							if (from == v) return false;
							return true;
						};
						var stopSet = Helpers.toObjectWithTrue(this.DG.GG.getOutEdges(v));
						var component = this.DG.findConnectedComponent(v, noChildEdges, stopSet, Infinity);
						if (component.stopSetReached) continue; // can't shorten here: nodes are firmly connected via other edges

						var slack = (shiftChhub > 0) ? Math.min(shiftChhub, xcoord.findVertexSetSlacks(component.component).rightSlack) // slack on the right side of component
							: Math.max(shiftChhub, -xcoord.findVertexSetSlacks(component.component).leftSlack);
						if (slack == 0) continue;
						console.log("Moving chhub: " + Helpers.stringifyObject(component.component) + " by " + slack);

						improved = true;

						for (var node in component.component) {
							if (component.component.hasOwnProperty(node)) {
								xcoord.xcoord[node] += slack;
							}
						}
					}
				}
			}
		}
	},

	_findAffectedSet: function (v_list, dontmove_set, noUp_set, noDown_set, forbidden_set, shiftSize, xcoord, stopAtVirtual, minimizeMovement, stopAtPersons, stopAtRels, stopAtRank) {
		// Given a list of nodes (v_list) and how much we want to move them (same amount for all the nodes, shiftSize)
		// figure out how many nodes would have to be moved to accomodate the desired movement.
		//
		// dontmove_set: nodes which should not be moved unless their neighbours push them.
		//
		// noUp_set: in-edges of nodes in the set willnot be followed when propagaitng movement
		//
		// noDown_set: out-edges of nodes in the set willnot be followed when propagaitng movement
		//
		// forbidden_set: if a node in the set has to move (due to any reason, e..g pushed by a neighbour or
		//                due to movement propagation in some other way) propagation stops and
		//                `forbiddenMoved` key is set to true in the return value
		//
		// stopAtVirtual: if `true` once a virtual node is found movement propagation is stopped
		//
		// stopAtPersons, stopAtRels: movement propagation stops once more than the given number of
		//                            persons/relationships has been added to the move set
		//
		// minimizeMovement: minimal propagation is used, and all nodes on the same rank opposite to the
		//                   movement direction are added to the dontmove_set

		var nodes = Helpers.toObjectWithTrue(v_list);

		var initialNodes = Helpers.toObjectWithTrue(v_list);

		// for each ignored node: add all nodes on the same rank which are to the left (if shifting right)
		// or to the right of (if shifting left) the node

		if (minimizeMovement) {
			for (var i = 0; i < v_list.length; i++) {
				noUp_set  [v_list[i]] = true;
				noDown_set[v_list[i]] = true;
			}
			for (var node in dontmove_set) {
				if (dontmove_set.hasOwnProperty(node)) {
					var rank = this.DG.ranks[node];
					var order = this.DG.order.vOrder[node];

					var from = (shiftSize > 0) ? 0 : order + 1;
					var to = (shiftSize > 0) ? order : this.DG.order.order[rank].length;

					for (var i = from; i < to; i++) {
						var u = this.DG.order.order[rank][i];
						dontmove_set[u] = true;
						noUp_set[u] = true;
						noDown_set[u] = true;
					}
				}
			}
		}

		var numPersons = 0;  // number of moved nodes (excluding nodes in the original list)
		var numRels = 0;
		var numVirtual = 0;
		var minRank = Infinity;
		var forbiddenMoved = false;

		var toMove = new Queue();
		toMove.setTo(v_list);

		while (toMove.size() > 0) {
			if (stopAtPersons && numPersons > stopAtPersons) break;  // stop early and dont waste time if the caller already does not care
			if (stopAtRels && numRels > stopAtRels)    break;

			var nextV = toMove.pop();

			if (forbidden_set && forbidden_set.hasOwnProperty(nextV)) {
				forbiddenMoved = true;
				break;
			}

			if (shiftSize > 0) {
				var slack = xcoord.getSlackOnTheRight(nextV);
				if (slack < shiftSize) {
					var rightNeighbour = this.DG.order.getRightNeighbour(nextV, this.DG.ranks[nextV]);
					if (!nodes.hasOwnProperty(rightNeighbour)) {
						nodes[rightNeighbour] = true;
						toMove.push(rightNeighbour);
					}
				}
			} else {
				var slack = xcoord.getSlackOnTheLeft(nextV);
				if (slack < -shiftSize) {
					var leftNeighbour = this.DG.order.getLeftNeighbour(nextV, this.DG.ranks[nextV]);
					if (!nodes.hasOwnProperty(leftNeighbour)) {
						nodes[leftNeighbour] = true;
						toMove.push(leftNeighbour);
					}
				}
			}

			// if we should ignore both in- and out-edges for the node - nothing else to do
			if (noUp_set.hasOwnProperty(nextV) && noDown_set.hasOwnProperty(nextV)) continue;

			if (this.DG.ranks[nextV] < minRank && !initialNodes.hasOwnProperty(nextV)) {
				minRank = this.DG.ranks[nextV];
				if (stopAtRank && minRank < stopAtRank) break;
			}

			if (this.DG.GG.isRelationship(nextV)) {
				if (!initialNodes.hasOwnProperty(nextV)) numRels++;

				var chhub = this.DG.GG.getOutEdges(nextV)[0];
				if (!nodes.hasOwnProperty(chhub)) {
					nodes[chhub] = true;
					toMove.push(chhub);
				}

				if (minimizeMovement || noUp_set.hasOwnProperty(nextV)) continue;

				var parents = this.DG.GG.getInEdges(nextV);
				for (var i = 0; i < parents.length; i++) {
					if (!dontmove_set.hasOwnProperty(parents[i]) && !nodes.hasOwnProperty(parents[i])) {
						if ((this.DG.order.vOrder[parents[i]] == this.DG.order.vOrder[nextV] + 1 && shiftSize < 0) ||  // if shiftSize > 0 it will get pushed anyway
							(this.DG.order.vOrder[parents[i]] == this.DG.order.vOrder[nextV] - 1 && shiftSize > 0)) {
							nodes[parents[i]] = true;
							toMove.push(parents[i]);
						}
					}
				}
			}
			else if (this.DG.GG.isChildhub(nextV)) {
				var rel = this.DG.GG.getInEdges(nextV)[0];
				if (!nodes.hasOwnProperty(rel)) {
					nodes[rel] = true;
					toMove.push(rel);
				}

				if (minimizeMovement || noDown_set.hasOwnProperty(nextV)) continue;

				// move children as not to break the supposedly nice layout
				var childInfo = this.analizeChildren(nextV);
				var positionInfo = this._computeDesiredChildhubLocation(childInfo, xcoord, nodes, shiftSize);

				// no need to move anything else when parent line is either above the mid-point between the leftmost and rightmost child
				// or above the middle child of the three
				var childhubX = xcoord.xcoord[nextV];
				var shiftedChildhubX = childhubX + shiftSize;
				if (shiftedChildhubX == positionInfo.minPreferredWithShift || shiftedChildhubX == positionInfo.maxPreferredWithShift) continue;

				// if we improve compared to what was before - also accept
				if (childhubX < positionInfo.minPreferredWithShift && shiftSize > 0 && shiftedChildhubX < positionInfo.minPreferredWithShift) continue;
				if (childhubX > positionInfo.maxPreferredWithShift && shiftSize < 0 && shiftedChildhubX > positionInfo.maxPreferredWithShift) continue;

				var children = this.DG.GG.getOutEdges(nextV);
				for (var j = 0; j < children.length; j++) {
					if (!dontmove_set.hasOwnProperty(children[j]) && !nodes.hasOwnProperty(children[j])) {
						nodes[children[j]] = true;
						toMove.push(children[j]);
					}
				}
			}
			else if (this.DG.GG.isPerson(nextV)) {
				if (!initialNodes.hasOwnProperty(nextV) && !this.DG.GG.isPlaceholder(nextV)) numPersons++;

				if (!noDown_set.hasOwnProperty(nextV)) {
					var rels = this.DG.GG.getOutEdges(nextV);
					for (var j = 0; j < rels.length; j++) {
						if (!dontmove_set.hasOwnProperty(rels[j]) && !nodes.hasOwnProperty(rels[j])) {
							if ((this.DG.order.vOrder[rels[j]] == this.DG.order.vOrder[nextV] + 1 && shiftSize < 0) ||  // if shiftSize > 0 it will get pushed anyway
								(this.DG.order.vOrder[rels[j]] == this.DG.order.vOrder[nextV] - 1 && shiftSize > 0)) {

								// if there is already a long edge it is ok to make it longer. if not, try to keep stuff compact
								if ((shiftSize > 0 && xcoord.getSlackOnTheLeft(nextV) == 0) ||
									(shiftSize < 0 && xcoord.getSlackOnTheRight(nextV) == 0)) {
									nodes[rels[j]] = true;
									toMove.push(rels[j]);
								}
							}
						}
					}
				}

				// move twins
				var twins = this.DG.GG.getAllTwinsOf(nextV);
				if (twins.length > 1) {
					for (var t = 0; t < twins.length; t++) {
						var twin = twins[t];
						if (dontmove_set.hasOwnProperty(twin) || nodes.hasOwnProperty(twin)) continue;
						toMove.push(twin);
					}
				}

				//if (noUp_set.hasOwnProperty(nextV) || this.DG.GG.isPlaceholder(nextV)) continue;
				if (noUp_set.hasOwnProperty(nextV)) continue;

				// TODO: commenting out the piece below produces generally better layout, but for some reason
				//       adds too much space in some cases, e.g. check testcase 4F (or MS_004, where layout
				//       is better, but node "w1" is moved when it should not be
				var inEdges = this.DG.GG.getInEdges(nextV);
				if (inEdges.length > 0) {
					var chhub = inEdges[0];

					// check if we should even try to move chhub
					if (dontmove_set.hasOwnProperty(chhub) || nodes.hasOwnProperty(chhub)) continue;

					var childInfo = this.analizeChildren(chhub);
					var positionInfo = this._computeDesiredChildhubLocation(childInfo, xcoord, nodes, shiftSize);
					var childhubX = xcoord.xcoord[chhub];
					// if it will become OK - no move
					if (childhubX == positionInfo.minPreferredWithShift || childhubX == positionInfo.maxPreferredWithShift) continue;
					// if we improve compared to what was before - also accept
					if (childhubX < positionInfo.minPreferred && shiftSize < 0 && childhubX < positionInfo.minPreferredWithShift) continue;
					if (childhubX > positionInfo.maxPreferred && shiftSize > 0 && childhubX > positionInfo.maxPreferredWithShift) continue;

					nodes[chhub] = true;
					toMove.push(chhub);
				}
				/**/
			}
			else if (this.DG.GG.isVirtual(nextV)) {
				if (!initialNodes.hasOwnProperty(nextV)) numVirtual++;

				if (stopAtVirtual && numVirtual > 0) break;

				if (!noUp_set.hasOwnProperty(nextV)) {
					var v1 = this.DG.GG.getInEdges(nextV)[0];
					if (!this.DG.GG.isPerson(v1) && !nodes.hasOwnProperty(v1) && !dontmove_set.hasOwnProperty(v1)) {
						nodes[v1] = true;
						toMove.push(v1);
					}
				}
				if (!noDown_set.hasOwnProperty(nextV)) {
					var v2 = this.DG.GG.getOutEdges(nextV)[0];
					if (!this.DG.GG.isRelationship(v2) && !nodes.hasOwnProperty(v2) && !dontmove_set.hasOwnProperty(v2)) {
						nodes[v2] = true;
						toMove.push(v2);
					}
				}
			}
		}

		var affectedNodes = [];
		for (var node in nodes) {
			if (nodes.hasOwnProperty(node)) {
				affectedNodes.push(node);
			}
		}
		return { "nodes": affectedNodes, "numPersons": numPersons, "numRelationships": numRels, "numVirtual": numVirtual,
			"minAffectedRank": minRank, "forbiddenMoved": forbiddenMoved };
	},

	_computeDesiredChildhubLocation: function (childInfo, xcoord, nodesThatShift, shiftSize) {
		var leftMost = childInfo.leftMostChildId;
		var rightMost = childInfo.rightMostChildId;

		var leftX = xcoord.xcoord[leftMost];
		var rightX = xcoord.xcoord[rightMost];
		var middle = (leftX + rightX) / 2;
		var median = (childInfo.orderedChildren.length == 3) ? xcoord.xcoord[childInfo.orderedChildren[1]] : middle;
		var minIntervalX = Math.min(middle, median);
		var maxIntervalX = Math.max(middle, median);

		var result = {"leftX": leftX, "rightX": rightX, "middle": middle, "median": median,
			"minPreferred": minIntervalX, "maxPreferred": maxIntervalX };

		if (nodesThatShift) {
			var leftXShifted = leftX + (nodesThatShift.hasOwnProperty(leftMost) ? shiftSize : 0);
			var rightXShifted = rightX + (nodesThatShift.hasOwnProperty(rightMost) ? shiftSize : 0);
			var middleShifted = (leftXShifted + rightXShifted) / 2;
			var medianShifted = (childInfo.orderedChildren.length == 3)
				? (xcoord.xcoord[childInfo.orderedChildren[1]] + (nodesThatShift.hasOwnProperty(childInfo.orderedChildren[1]) ? shiftSize : 0))
				: middleShifted;
			var minIntervalXShifted = Math.min(middleShifted, medianShifted);
			var maxIntervalXShifted = Math.max(middleShifted, medianShifted);

			result["minPreferredWithShift"] = minIntervalXShifted;
			result["maxPreferredWithShift"] = maxIntervalXShifted;
		}

		return result;
	},

	//=============================================================
	optimizeLongEdgePlacement: function () {
		// 1) decrease the number of crossed edges
		// TODO

		// 2) straighten long edges
		var xcoord = new XCoord(this.DG.positions, this.DG);
		//this.DG.displayGraph(xcoord.xcoord, "pre-long-improve");

		var longEdges = this.DG.find_long_edges();
		this.DG.try_straighten_long_edges(longEdges, xcoord);   // does so without moving other nodes

		var stillNotStraight = this.straighten_long_edges(longEdges, xcoord);   // attempts to straigthen more agressively

		this.DG.try_straighten_long_edges(stillNotStraight, xcoord);

		//this.DG.displayGraph(xcoord.xcoord, "past-long-improve");
		this.DG.positions = xcoord.xcoord;
	},

	// Straigthen edges more agressively that DG.try_straighten_long_edges(), willing to move
	// some nodes to make long edges look better (as when they don't, it looks more ugly than a regular non-straight edge)
	straighten_long_edges: function (longEdges, xcoord) {
		var stillNotStraight = [];

		for (var e = 0; e < longEdges.length; e++) {
			var chain = longEdges[e];
			//this.DG.displayGraph(xcoord.xcoord, "pre-straighten-"+Helpers.stringifyObject(chain));
			//console.log("trying to force-straighten edge " + Helpers.stringifyObject(chain));

			//var person = this.DG.GG.getInEdges(chain[0])[0];
			do {
				var improved = false;
				var headCenter = xcoord.xcoord[chain[0]];
				// go over all nodes from head to tail looking for a bend
				for (var i = 1; i < chain.length; i++) {
					var nextV = chain[i];
					var nextCenter = xcoord.xcoord[nextV];
					if (nextCenter != headCenter) {
						// try to shift either the head or the tail of the edge, if the amount of movement is not too big
						var head = chain.slice(0, i);
						var tail = chain.slice(i);

						var shiftHeadSize = nextCenter - headCenter;
						var dontmove = Helpers.toObjectWithTrue(tail);
						var affectedInfoHeadShift = this._findAffectedSet(head, dontmove, {}, {}, {}, shiftHeadSize, xcoord, true, true, 5, 3);

						var shiftTailSize = headCenter - nextCenter;
						var dontmove = Helpers.toObjectWithTrue(head);
						var affectedInfoTailShift = this._findAffectedSet(tail, dontmove, {}, {}, {}, shiftTailSize, xcoord, true, true, 5, 3);

						if (!this._isShiftSizeAcceptable(affectedInfoHeadShift, false, 5, 3) && !this._isShiftSizeAcceptable(affectedInfoTailShift, false, 5, 3)) {
							stillNotStraight.push(chain);
							break;  // too much distortion and/or distorting other virtual edges
						}

						improved = true;   // at least one of the shifts is OK

						// ok, pick which one to use
						if (this._isShiftBetter(affectedInfoTailShift, affectedInfoHeadShift)) {
							// use tail shift
							var nodes = affectedInfoTailShift.nodes;
							for (var i = 0; i < nodes.length; i++)
								xcoord.xcoord[nodes[i]] += shiftTailSize;
						} else {
							// use head shift
							var nodes = affectedInfoHeadShift.nodes;
							for (var i = 0; i < nodes.length; i++)
								xcoord.xcoord[nodes[i]] += shiftHeadSize;
						}
						break;
					}
				}
			} while (improved);
		}

		return stillNotStraight;
	},

	_isShiftSizeAcceptable: function (shiftInfo, allowShiftVirtual, maxPersonNodes, maxRelNodes) {
		if (shiftInfo.forbiddenMoved) return false;
		if (!allowShiftVirtual && shiftInfo.numVirtual > 0) return false;
		if (shiftInfo.numPersons > maxPersonNodes) return false;
		if (shiftInfo.numRelationships > maxRelNodes) return false;
		return true;
	},

	_isShiftBetter: function (shiftInfo1, shiftInfo2) {
		// the one shifting less virtual nodes is better
		if (shiftInfo2.numVirtual > shiftInfo1.numVirtual) return true;
		if (shiftInfo2.numVirtual < shiftInfo1.numVirtual) return false;

		// the one shifting fewer person nodes is better
		if (shiftInfo2.numPersons > shiftInfo1.numPersons) return true;
		if (shiftInfo2.numPersons < shiftInfo1.numPersons) return false;

		// the one shifting fewer rel nodes (and everything else being equal) is better
		if (shiftInfo2.numRelationships > shiftInfo1.numRelationships) return true;
		return false;
	},
	//=============================================================

	moveToCorrectPositionAndMoveOtherNodesAsNecessary: function (newNodeId, nodeToKeepEdgeStraightTo) {
		// Algorithm:
		//
		// Initially pick the new position for "newNodeId," which keeps the edge to node-"nodeToKeepEdgeStraightTo"
		// as straight as possible while not moving any nodes to the left of "newNodeId" in the current ordering.
		//
		// This new position may force the node next in the ordering to move further right to make space, in
		// which case that node is added to the queue and then the following heuristic is applied:
		//  while queue is not empty:
		//
		//  - pop a node form the queue and move it right just enough to have the desired spacing between the node
		//    and it's left neighbour. Check which nodes were affected because of this move:
		//    nodes to the right, parents & children. Shift those affected accordingly (see below) and add them to the queue.
		//
		//    The rules are:
		//    a) generally all shifted nodes will be shifted the same amount to keep the shape of
		//       the graph as unmodified as possible, with a few exception below
		//    b) all childhubs should stay right below their relationship nodes
		//    c) childhubs wont be shifted while they ramain between the leftmost and rightmost child
		//    d) when a part of the graph needs to be stretched prefer to strech relationship edges
		//       to the right of relationship node. Some of the heuristics below assume that this is the
		//       part that may have been stretched
		//
		// note: does not assert the graph satisfies all the assumptions in BaseGraph.validate(),
		//       in particular this can be called after a childhub was added but before it's relationship was added

		//console.log("Orders: " + Helpers.stringifyObject(this.DG.order));
		console.log("========== PLACING " + newNodeId);

		var originalDisturbRank = this.DG.ranks[newNodeId];

		var xcoord = new XCoord(this.DG.positions, this.DG);

		//console.log("Orders at insertion rank: " + Helpers.stringifyObject(this.DG.order.order[this.DG.ranks[newNodeId]]));
		//console.log("Positions of nodes: " + Helpers.stringifyObject(xcoord.xcoord));

		var leftBoundary = xcoord.getLeftMostNoDisturbPosition(newNodeId);
		var rightBoundary = xcoord.getRightMostNoDisturbPosition(newNodeId);

		var desiredPosition = this.DG.positions[nodeToKeepEdgeStraightTo];             // insert right above or right below

		if (nodeToKeepEdgeStraightTo != newNodeId) {
			if (this.DG.ranks[nodeToKeepEdgeStraightTo] == originalDisturbRank) {     // insert on the same rank: then instead ot the left or to the right
				if (this.DG.order.vOrder[newNodeId] > this.DG.order.vOrder[nodeToKeepEdgeStraightTo])
					desiredPosition = xcoord.getRightEdge(nodeToKeepEdgeStraightTo) + xcoord.getSeparation(newNodeId, nodeToKeepEdgeStraightTo) + xcoord.halfWidth[newNodeId];
				else {
					desiredPosition = xcoord.getLeftEdge(nodeToKeepEdgeStraightTo) - xcoord.getSeparation(newNodeId, nodeToKeepEdgeStraightTo) - xcoord.halfWidth[newNodeId];
					if (desiredPosition > rightBoundary)
						desiredPosition = rightBoundary;
				}
			}
			else if (this.DG.GG.isPerson(newNodeId) && desiredPosition > rightBoundary)
				desiredPosition = rightBoundary;
		}

		var insertPosition = ( desiredPosition < leftBoundary ) ? leftBoundary : desiredPosition;

		xcoord.xcoord[newNodeId] = insertPosition;

		var shiftAmount = 0;
		if (insertPosition > desiredPosition)
			shiftAmount = (insertPosition - desiredPosition);

		// find which nodes we need to shift to accomodate this insertion via "domino effect"

		// each entry in the queue is a pair [node, moveAmount]. Once a node is popped from the queue
		// some of the linked nodes are moved the same amount to keep the existing shape of the graph.
		// That movement may in turn trigger anothe rmovement of the original node, so the same
		// node may appear more than once in the queue at the same itme, with different corresponding
		// move amounts. In theory there should be no circular dependencies (e.g. moving A requires moving B
		// which requires moving A again), but in case there is a mistake there is a check which terminates
		// the process after some time.
		var disturbedNodes = new Queue();
		disturbedNodes.push([newNodeId, shiftAmount]);

		var iterOuter = 0;
		var iter = 0;

		var doNotTouch = {};
		var ancestors = this.DG.GG.getAllAncestors(newNodeId);
		for (var node in ancestors) {
			doNotTouch[node] = true;
			var rank = this.DG.ranks[node];
			var order = this.DG.order.vOrder[node];
			for (var i = 0; i < order; i++) {
				var u = this.DG.order.order[rank][i];
				doNotTouch[u] = true;
			}
		}
		//console.log("V:" + newNodeId + " -> DoNotTouch: " + Helpers.stringifyObject(doNotTouch));

		var totalMove = {};   // for each node: how much the node has been moved by this function

		// The movement algorithm is two-step:
		//  1) first nodes "firmly" linked to each other are moved in the inner while loop
		//  2) then some childhubs get moved depending on which of their children have been shifted -
		//     which may trigger move moves in the inner loop

		// Outer loop. Repeat at most 5 times, as more is likely a run-away algo due to some unexpected circular dependency
		while (disturbedNodes.size() > 0 && iterOuter < 5) {
			iterOuter++;

			var childrenMoved = {};   // for each childhub: which children have been moved (we only move a chldhub if all its children were moved)

			var numNodes = this.DG.ranks.length;
			var maxExpectedMovements = numNodes * 5;

			// inner loop: shift all vertices except childhubs, which only shift if all their children shift
			while (disturbedNodes.size() > 0 && iter < maxExpectedMovements) {
				iter++;  // prevent unexpected run-away due to some weird circular dependency (should not happen but TODO: check)

				//console.log("Disturbed nodes: " + Helpers.stringifyObject(disturbedNodes.data));

				var next = disturbedNodes.pop();
				var v = next[0];
				shiftAmount = next[1];

				//console.log("Processing: " + v + " @position = " + xcoord.xcoord[v]);

				var type = this.DG.GG.type[v];
				var vrank = this.DG.ranks[v];
				var vorder = this.DG.order.vOrder[v];

				var position = xcoord.xcoord[v];
				var rightMostOK = xcoord.getRightMostNoDisturbPosition(v);

				if (position > rightMostOK) {
					// the node to the right was disturbed: shift it
					var rightDisturbed = this.DG.order.order[vrank][vorder + 1];

					var toMove = position - rightMostOK;

					xcoord.xcoord[rightDisturbed] += toMove;
					totalMove[rightDisturbed] = totalMove.hasOwnProperty(rightDisturbed) ? totalMove[rightDisturbed] + toMove : toMove;
					disturbedNodes.push([rightDisturbed, toMove]);
					//console.log("addRNK: " + rightDisturbed + " (toMove: " + toMove + " -> " + xcoord.xcoord[rightDisturbed] + ")");
				}

				if (v == newNodeId && type != BaseGraph.TYPE.VIRTUALEDGE) continue;

				//if (type == BaseGraph.TYPE.VIRTUALEDGE && rank > 2) continue; // TODO: DEBUG: remove - needed for testing of edge-straightening algo

				var inEdges = this.DG.GG.getInEdges(v);
				var outEdges = this.DG.GG.getOutEdges(v);

				// go though out- and in- edges and propagate the movement
				//---------
				var skipInEdges = false;
				if ((type == BaseGraph.TYPE.PERSON || type == BaseGraph.TYPE.VIRTUALEDGE) && v == newNodeId) {
					skipInEdges = true;
				}
				if (type == BaseGraph.TYPE.VIRTUALEDGE) {
					var inEdgeV = inEdges[0];
					if (this.DG.ranks[inEdgeV] == vrank)
						skipInEdges = true;
				}
				// if we need to strech something -> stretch relationship edges to the right of
				if (type == BaseGraph.TYPE.RELATIONSHIP) {
					skipInEdges = true;
					// except the case when inedge comes from a vertex to the left with no other in- or out-edges (a node connected only to this reltionship)
					if (inEdges.length == 2) {
						var parent0 = inEdges[0];
						var parent1 = inEdges[1];
						var order0 = this.DG.order.vOrder[parent0];
						var order1 = this.DG.order.vOrder[parent1];
						if (order0 == vorder - 1 && this.DG.GG.getOutEdges(parent0).length == 1 &&
							this.DG.GG.getInEdges(parent0).length == 0 && !doNotTouch.hasOwnProperty(parent0)) {
							if (!totalMove.hasOwnProperty(parent0) || totalMove[parent0] < totalMove[v]) {
								xcoord.xcoord[parent0] += shiftAmount;  // note: we can avoid adding this node to any queues as it is only connected to v
								totalMove[parent0] = totalMove.hasOwnProperty(parent0) ? totalMove[parent0] + shiftAmount : shiftAmount;
							}
						}
						else if (order1 == vorder - 1 && this.DG.GG.getOutEdges(parent1).length == 1 &&
							this.DG.GG.getInEdges(parent1).length == 0 && !doNotTouch.hasOwnProperty(parent1)) {
							if (!totalMove.hasOwnProperty(parent1) || totalMove[parent1] < totalMove[v]) {
								xcoord.xcoord[parent1] += shiftAmount;  // note: we can avoid adding this node to any queues as it is only connected to v
								totalMove[parent1] = totalMove.hasOwnProperty(parent1) ? totalMove[parent1] + shiftAmount : shiftAmount;
							}
						}
					}
				}

				if (!skipInEdges) {
					for (var i = 0; i < inEdges.length; i++) {
						var u = inEdges[i];
						var typeU = this.DG.GG.type[u];

						if (doNotTouch.hasOwnProperty(u)) continue;
						if (totalMove.hasOwnProperty(u) && totalMove[u] >= totalMove[v]) continue;

						if (type == BaseGraph.TYPE.PERSON && typeU == BaseGraph.TYPE.CHILDHUB) {
							if (childrenMoved.hasOwnProperty(u)) {
								childrenMoved[u]++;
							}
							else {
								childrenMoved[u] = 1;
							}

							continue;
						}

						if (typeU == BaseGraph.TYPE.VIRTUALEDGE && xcoord.xcoord[u] == xcoord.xcoord[v]) continue;

						var shiftU = totalMove.hasOwnProperty(u) ? Math.min(shiftAmount, Math.max(totalMove[v] - totalMove[u], 0)) : shiftAmount;

						xcoord.xcoord[u] += shiftU;
						totalMove[u] = totalMove.hasOwnProperty(u) ? totalMove[u] + shiftU : shiftU;
						disturbedNodes.push([u, shiftU]);
						//console.log("addINN: " + u + " (shift: " + shiftU + " -> " + xcoord.xcoord[u] + ")");
					}
				}
				//---------

				//---------
				if (type == BaseGraph.TYPE.CHILDHUB) {
					var rightMostChildPos = 0;
					for (var i = 0; i < outEdges.length; i++) {
						var u = outEdges[i];
						var pos = xcoord.xcoord[u];
						if (pos > rightMostChildPos)
							rightMostChildPos = pos;
					}
					if (rightMostChildPos >= xcoord.xcoord[v]) continue; // do not shift children if we are not creating a "bend"
				}

				for (var i = 0; i < outEdges.length; i++) {
					var u = outEdges[i];

					var shiftU = totalMove.hasOwnProperty(u) ? Math.min(shiftAmount, Math.max(totalMove[v] - totalMove[u], 0)) : shiftAmount;

					if (doNotTouch.hasOwnProperty(u)) continue;
					if (totalMove.hasOwnProperty(u) && totalMove[u] >= totalMove[v]) continue;

					if (this.DG.ranks[u] == vrank) continue;   // vertices on the same rank will only be shifted if pushed on the right by left neighbours

					if (type == BaseGraph.TYPE.RELATIONSHIP || type == BaseGraph.TYPE.VIRTUALEDGE) {
						var diff = xcoord.xcoord[v] - xcoord.xcoord[u];
						if (diff <= 0) continue;
						if (diff < shiftU)
							shiftU = diff;
					}

					xcoord.xcoord[u] += shiftU;
					totalMove[u] = totalMove.hasOwnProperty(u) ? totalMove[u] + shiftU : shiftU;
					disturbedNodes.push([u, shiftU]);
					//console.log("addOUT: " + u + " (shift: " + shiftU + " -> " + xcoord.xcoord[u] + ")");
				}
				//---------
			}


			// small loop 2: shift childhubs, if necessary
			for (var chhub in childrenMoved) {
				if (childrenMoved.hasOwnProperty(chhub)) {
					chhub = parseInt(chhub);
					if (doNotTouch.hasOwnProperty(chhub)) continue;
					var children = this.DG.GG.getOutEdges(chhub);
					//if (children.length == 1 && this.DG.GG.isPlaceholder(children[0])) {
					//    continue;
					//}
					if (children.length > 0 && children.length == childrenMoved[chhub]) {
						var minShift = Infinity;
						for (var j = 0; j < children.length; j++) {
							if (totalMove[children[j]] < minShift)
								minShift = totalMove[children[j]];
						}
						if (totalMove.hasOwnProperty(chhub)) {
							if (totalMove[chhub] > minShift) continue;
							minShift -= totalMove[chhub];
						}
						xcoord.xcoord[chhub] += minShift;
						totalMove[chhub] = totalMove.hasOwnProperty(chhub) ? totalMove[chhub] + minShift : minShift;
						disturbedNodes.push([chhub, minShift]);
						//console.log("childhub: " + chhub + " (shift: " + minShift + ")");
					}
				}
			}

		} // big outer while()

		//this.DG.displayGraph(xcoord.xcoord, "after-insert-"+newNodeId);

		this.DG.positions = xcoord.xcoord;

		//console.log("Positions: 5-6-7: " + this.DG.positions[5] + " / " + this.DG.positions[6] + " / " + this.DG.positions[7]);
		console.log("PLACED/MOVED: " + newNodeId + " @ position " + this.DG.positions[newNodeId]);
	}
};

/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
 plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {
		}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function (view) {
		var
			get_class = function (object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function (type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
				).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
			;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function (uri) {
				var
					uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
					;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function (blob) {
			var
				type = blob.type
				, data_URI_header
				;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				}
				if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function (object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function (data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
					;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function (type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function () {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function (start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function () {
			return "[object Blob]";
		};
		FB_proto.close = function () {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function (blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				builder.append(blobParts[i]);
			}
		}
		return builder.getBlob(type);
	};
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

/* FileSaver.js
 *  A saveAs() & saveTextAs() FileSaver implementation.
 *  2014-06-24
 *
 *  Modify by Brian Chen
 *  Author: Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs = saveAs
	// IE 10+ (native saveAs)
	|| (typeof navigator !== "undefined" &&
		navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
	// Everyone else
	|| (function (view) {
		"use strict";
		// IE <10 is explicitly unsupported
		if (typeof navigator !== "undefined" &&
			/MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var
			doc = view.document
		// only get URL when necessary in case Blob.js hasn't overridden it yet
			, get_URL = function () {
				return view.URL || view.webkitURL || view;
			}
			, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
			, can_use_save_link = !view.externalHost && "download" in save_link
			, click = function (node) {
				var event = doc.createEvent("MouseEvents");
				event.initMouseEvent(
					"click", true, false, view, 0, 0, 0, 0, 0
					, false, false, false, false, 0, null
				);
				node.dispatchEvent(event);
			}
			, webkit_req_fs = view.webkitRequestFileSystem
			, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
			, throw_outside = function (ex) {
				(view.setImmediate || view.setTimeout)(function () {
					throw ex;
				}, 0);
			}
			, force_saveable_type = "application/octet-stream"
			, fs_min_size = 0
			, deletion_queue = []
			, process_deletion_queue = function () {
				var i = deletion_queue.length;
				while (i--) {
					var file = deletion_queue[i];
					if (typeof file === "string") { // file is an object URL
						get_URL().revokeObjectURL(file);
					} else { // file is a File
						file.remove();
					}
				}
				deletion_queue.length = 0; // clear queue
			}
			, dispatch = function (filesaver, event_types, event) {
				event_types = [].concat(event_types);
				var i = event_types.length;
				while (i--) {
					var listener = filesaver["on" + event_types[i]];
					if (typeof listener === "function") {
						try {
							listener.call(filesaver, event || filesaver);
						} catch (ex) {
							throw_outside(ex);
						}
					}
				}
			}
			, FileSaver = function (blob, name) {
				// First try a.download, then web filesystem, then object URLs
				var
					filesaver = this
					, type = blob.type
					, blob_changed = false
					, object_url
					, target_view
					, get_object_url = function () {
						var object_url = get_URL().createObjectURL(blob);
						deletion_queue.push(object_url);
						return object_url;
					}
					, dispatch_all = function () {
						dispatch(filesaver, "writestart progress write writeend".split(" "));
					}
				// on any filesys errors revert to saving with object URLs
					, fs_error = function () {
						// don't create more object URLs than needed
						if (blob_changed || !object_url) {
							object_url = get_object_url(blob);
						}
						if (target_view) {
							target_view.location.href = object_url;
						} else {
							window.open(object_url, "_blank");
						}
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
					}
					, abortable = function (func) {
						return function () {
							if (filesaver.readyState !== filesaver.DONE) {
								return func.apply(this, arguments);
							}
						};
					}
					, create_if_not_found = { create: true, exclusive: false }
					, slice
					;
				filesaver.readyState = filesaver.INIT;
				if (!name) {
					name = "download";
				}
				if (can_use_save_link) {
					object_url = get_object_url(blob);
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					return;
				}
				// Object and web filesystem URLs have a problem saving in Google Chrome when
				// viewed in a tab, so I force save with application/octet-stream
				// http://code.google.com/p/chromium/issues/detail?id=91158
				if (view.chrome && type && type !== force_saveable_type) {
					slice = blob.slice || blob.webkitSlice;
					blob = slice.call(blob, 0, blob.size, force_saveable_type);
					blob_changed = true;
				}
				// Since I can't be sure that the guessed media type will trigger a download
				// in WebKit, I append .download to the filename.
				// https://bugs.webkit.org/show_bug.cgi?id=65440
				if (webkit_req_fs && name !== "download") {
					name += ".download";
				}
				if (type === force_saveable_type || webkit_req_fs) {
					target_view = view;
				}
				if (!req_fs) {
					fs_error();
					return;
				}
				fs_min_size += blob.size;
				req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
					fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
						var save = function () {
							dir.getFile(name, create_if_not_found, abortable(function (file) {
								file.createWriter(abortable(function (writer) {
									writer.onwriteend = function (event) {
										target_view.location.href = file.toURL();
										deletion_queue.push(file);
										filesaver.readyState = filesaver.DONE;
										dispatch(filesaver, "writeend", event);
									};
									writer.onerror = function () {
										var error = writer.error;
										if (error.code !== error.ABORT_ERR) {
											fs_error();
										}
									};
									"writestart progress write abort".split(" ").forEach(function (event) {
										writer["on" + event] = filesaver["on" + event];
									});
									writer.write(blob);
									filesaver.abort = function () {
										writer.abort();
										filesaver.readyState = filesaver.DONE;
									};
									filesaver.readyState = filesaver.WRITING;
								}), fs_error);
							}), fs_error);
						};
						dir.getFile(name, { create: false }, abortable(function (file) {
							// delete file if it already exists
							file.remove();
							save();
						}), abortable(function (ex) {
							if (ex.code === ex.NOT_FOUND_ERR) {
								save();
							} else {
								fs_error();
							}
						}));
					}), fs_error);
				}), fs_error);
			}
			, FS_proto = FileSaver.prototype
			, saveAs = function (blob, name) {
				return new FileSaver(blob, name);
			}
			;
		FS_proto.abort = function () {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;

		FS_proto.error =
			FS_proto.onwritestart =
				FS_proto.onprogress =
					FS_proto.onwrite =
						FS_proto.onabort =
							FS_proto.onerror =
								FS_proto.onwriteend =
									null;

		view.addEventListener("unload", process_deletion_queue, false);
		saveAs.unload = function () {
			process_deletion_queue();
			view.removeEventListener("unload", process_deletion_queue, false);
		};
		return saveAs;
	}(
			typeof self !== "undefined" && self
			|| typeof window !== "undefined" && window
			|| this.content
	));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

var saveTextAs = saveTextAs
	|| (function (textContent, fileName, charset) {
		fileName = fileName || 'pedigree.txt';
		charset = charset || 'utf-8';
		textContent = (textContent || '').replace(/\r?\n/g, "\r\n");
		if (saveAs && Blob) {
			var blob = new Blob([textContent], { type: "text/plain;charset=" + charset });
			saveAs(blob, fileName);
			return true;
		} else {//IE9-
			var saveTxtWindow = window.frames.saveTxtWindow;
			if (!saveTxtWindow) {
				saveTxtWindow = document.createElement('iframe');
				saveTxtWindow.id = 'saveTxtWindow';
				saveTxtWindow.style.display = 'none';
				document.body.insertBefore(saveTxtWindow, null);
				saveTxtWindow = window.frames.saveTxtWindow;
				if (!saveTxtWindow) {
					saveTxtWindow = window.open('', '_temp', 'width=100,height=100');
					if (!saveTxtWindow) {
						window.alert('Sorry, download file could not be created.');
						return false;
					}
				}
			}

			var doc = saveTxtWindow.document;
			doc.charset = charset;
			if (browser.versionMajor <= 8) {
				doc.open('text/plain', 'replace');
			} else {
				doc.open();
			}
			doc.write(textContent);
			doc.close();
			fileName += '.txt';
			var retValue = doc.execCommand('SaveAs', null, fileName);
			saveTxtWindow.close();
			return retValue;
		}
	})

var FileSaver = {};
FileSaver.saveAs = saveAs;
FileSaver.saveTextAs = saveTextAs;

/**
 * NodeMenu is a UI Element containing options for AbstractNode elements
 *
 * @class NodeMenu
 * @constructor
 * @param {Array} data Contains objects corresponding to different menu items
 *
 {
 [
    {
        'name' : the name of the menu item,
        'label' : the text label above this menu option,
        'type' : the type of form input. (eg. 'radio', 'date-picker', 'text', 'textarea', 'disease-picker', 'select'),
        'values' : [
                    {'actual' : actual value of the option, 'displayed' : the way the option will be seen in the menu} ...
                    ]
    }, ...
 ]
 }

 Note: when an item is specified as "inactive" it is completely removed from the menu; when it
 is specified as "disabled" it is greyed-out and does not allow selection, but is still visible.
 */
NodeMenu = Class.create({
	initialize: function (data, tabs, otherCSSClass) {
		//console.log("nodeMenu initialize");
		this._justOpened = false;
		this.canvas = editor.getWorkspace().canvas || $('body');
		var cssClass = 'menu-box';
		if (otherCSSClass) cssClass += " " + otherCSSClass;
		this.menuBox = new Element('div', {'class': cssClass});

		this.closeButton = new Element('span', {'class': 'close-button'}).update(' ');
		this.menuBox.insert({'top': this.closeButton});
		this.closeButton.observe('click', this.hide.bindAsEventListener(this));

		this.form = new Element('form', {'method': 'get', 'action': '', 'class': 'tabs-content'});

		this.tabs = {};
		this.tabHeaders = {};
		if (tabs && tabs.length > 0) {
			this.tabTop = new Element('dl', {'class': 'tabs'});
			for (var i = 0; i < tabs.length; i++) {
				var tabName = tabs[i];
				var activeClass = (i == 0) ? "active" : "";
				this.tabs[tabName] = new Element('div', {'id': 'tab_' + tabName, 'class': 'content ' + activeClass});
				this.form.insert(this.tabs[tabName]);

				this.tabHeaders[tabName] = new Element('dd', {"class": activeClass}).insert("<a>" + tabName + "</a>");
				var _this = this;
				var switchTab = function (tabName) {
					return function () {
						for (var tab in _this.tabs) {
							if (_this.tabs.hasOwnProperty(tab)) {
								if (tab != tabName) {
									_this.tabs[tab].className = "content";
									_this.tabHeaders[tab].className = "";
								} else {
									_this.tabs[tab].className = "content active";
									_this.tabHeaders[tab].className = "active";
								}
							}
						}
						_this.reposition();
					}
				}
				this.tabHeaders[tabName].observe('click', switchTab(tabName));
				this.tabTop.insert(this.tabHeaders[tabName]);
			}
			var div = new Element('div', {'class': 'tabholder'}).insert(this.tabTop).insert(this.form);
			this.menuBox.insert({'bottom': div});
		} else {
			this.singleTab = new Element('div', {'class': 'tabholder'}).insert(this.form);
			this.menuBox.insert({'bottom': this.singleTab});
			this.closeButton.addClassName("close-button-old");
			this.form.addClassName("content");
		}

		this.fieldMap = {};
		// Generate fields
		var _this = this;
		data.each(function (d) {
			if (typeof (_this._generateField[d.type]) == 'function') {
				var insertLocation = _this.form;
				if (d.tab && _this.tabs.hasOwnProperty(d.tab)) {
					insertLocation = _this.tabs[d.tab];
				}
				insertLocation.insert(_this._generateField[d.type].call(_this, d));
			}
		});

		// Insert in document
		this.hide();
		editor.getWorkspace().getWorkArea().insert(this.menuBox);

		this._onClickOutside = this._onClickOutside.bindAsEventListener(this);

		// Attach pickers and suggest widgets
		this._generatePickersAndSuggests();

		// Update disorder colors
		this._updateDisorderColor = function (id, color) {
			this.menuBox.select('.field-disorders li input[value="' + id + '"]').each(function (item) {
				var colorBubble = item.up('li').down('.abnormality-color');
				if (!colorBubble) {
					colorBubble = new Element('span', {'class': 'abnormality-color'});
					item.up('li').insert({top: colorBubble});
				}
				colorBubble.setStyle({background: color});
			});
		}.bind(this);
		document.observe('disorder:color', function (event) {
			if (!event.memo || !event.memo.id || !event.memo.color) {
				return;
			}
			_this._updateDisorderColor(event.memo.id, event.memo.color);
		});
		//this._setFieldValue['disease-picker'].bind(this);

		// Update gene colors
		this._updateGeneColor = function (id, color) {
			this.menuBox.select('.field-candidate_genes li input[value="' + id + '"]').each(function (item) {
				var colorBubble = item.up('li').down('.abnormality-color');
				if (!colorBubble) {
					colorBubble = new Element('span', {'class': 'abnormality-color'});
					item.up('li').insert({top: colorBubble});
				}
				colorBubble.setStyle({background: color});
			});
		}.bind(this);
		document.observe('gene:color', function (event) {
			if (!event.memo || !event.memo.id || !event.memo.color) {
				return;
			}
			_this._updateGeneColor(event.memo.id, event.memo.color);
		});
	},

	_generatePickersAndSuggests: function () {
		// date
		this.form.select('.fuzzy-date').each(function (item) {
			if (!item.__datePicker) {
				var inputMode = editor.getPreferencesManager().getConfigurationOption("dateEditFormat");
				//added by Soheil for GEL
				item.__datePicker = new PedigreeFuzzyDatePicker(item, inputMode);
			}
		});
		//added for GEL(GenomicsEngland)
		var FORM = this.form;
		// disease
		this.form.select('input.suggest-omim').each(function (item) {
			if (!item.hasClassName('initialized')) {
				// Create the Suggest.
				item._suggest = new PhenoTips.widgets.Suggest(item, {
					//added for GEL(GenomicsEngland)....................
					scriptFunction: function(){
						//find disorderType
						if (FORM.select("select[name='disorderType']").length > 0){
							var select = FORM.select("select[name='disorderType']")[0];
							var disorderType = select.options[select.selectedIndex].value;
							return Disorder.getServiceURL(disorderType)+ "&";
						}else{
							return Disorder.getServiceURL("OMIM") + "&";
						}
					},//..................................................
					resultUsePagination: function(){
						var select = FORM.select("select[name='disorderType']")[0];
						var disorderType = select.options[select.selectedIndex].value;
						if(disorderType == "SnomedCT"){
							return true;
						}
						return false;
					},
					script: Disorder.getServiceURL("OMIM") + "&",

					varname: "query",
					minchars: 3, //Added for GEL(GenomicsEngland)
					noresults: "No matching terms",
					json: true,
					resultsParameter: function(){
						console.log("results param")
						var select = FORM.select("select[name='disorderType']")[0];
						var disorderType = select.options[select.selectedIndex].value;
						if(disorderType == "GEL"){
							return "resultFlat";
						}
						return "hits";
					},
					resultId: function(){
						var select = FORM.select("select[name='disorderType']")[0];
						var disorderType = select.options[select.selectedIndex].value;
						if(disorderType == "GEL"){
							return "disorderIdWithTag";
						}
						return "code";
					},
					resultValue : function(){
						var select = FORM.select("select[name='disorderType']")[0];
						var disorderType = select.options[select.selectedIndex].value;
						if(disorderType == "GEL"){
							return "disorderName";
						}
						return "display";//"fullDetail"
					},
					resultInfo: {},
					displaySuggestItemFunction : function(searchTerm, data, pedigreeWidget){
						//console.log(searchTerm, data,pedigreeWidget)
						if(!data.valueAll){
							return null;
						}
						var select = FORM.select("select[name='disorderType']")[0];
						var disorderType = select.options[select.selectedIndex].value;
						return null;
					},
					canSelectInputTerm: function(){
						return false;
					},
					enableHierarchy: false,
					fadeOnClear: false,
					timeout: 30000,
					parentContainer: $('body')
					//showKey:true,	   	  // added for GEL
				});
				if (item.hasClassName('multi') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
					item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
						'showKey': false,
						'showTooltip': false,
						'showDeleteTool': true,
						'enableSort': false,
						'showClearTool': true,
						'inputType': 'hidden',
						'listInsertionElt': 'input',
						'listInsertionPosition': 'after',
						'acceptFreeText': true,
						'name':'disorder',
						//'showKey':true,        // added for GEL
						'showDisorderType':true,  // added for GEL
						customizeItemDisplay : function(key, value, valueAll, displayedValue, options){
							console.log("testaaa",key,value,valueAll,displayedValue)
							if(options.showDisorderType){
								// insert the displayed value
                                var select = FORM.select("select[name='disorderType']")[0];
                                var disorderType = select.options[select.selectedIndex].value;
                                console.log("DDD", disorderType, valueAll.disorderType, valueAll.disorderType != undefined)
                                if(valueAll != undefined && valueAll.disorderType != undefined){
                                	console.log("enter")
									disorderType = valueAll.disorderType;
								}
                                valueAll.disorderType = disorderType;
								
								if(value != "Affected") {
									var disorderTypeContainer = new Element('span', {'class': 'disorder-disorder-type'}).insert("(").insert(disorderType).insert(")");
									displayedValue.insert("").insert(disorderTypeContainer);

                                    if(valueAll != undefined && valueAll.diagnosisCertainty != undefined && valueAll.diagnosisCertainty.length > 0){
                                        var diagnosisCertainty = valueAll.diagnosisCertainty;
                                        var diagnosisCertaintyContainer = new Element('span','').insert(", ").insert(new Element('span', {'class': 'disorder-age-of-onset'}).insert(diagnosisCertainty).insert(""));
                                        displayedValue.insert("").insert(diagnosisCertaintyContainer);
                                    }
								}
							}
						},
						acceptsDuplicate: function(){
							var select = FORM.select("select[name='disorderType']")[0];
							var disorderType = select.options[select.selectedIndex].value;
							if(disorderType == "ICD10" || disorderType == "SnomedCT"){
								return true;
							}
							return false;
						}
					});
				}
				item.addClassName('initialized');
				document.observe('ms:suggest:containerCreated', function (event) {
					if (event.memo && event.memo.suggest === item._suggest) {
						item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
					}
				});
			}
		});
		// ethnicities
        var webService = new WebService();

        this.form.select('input.suggest-ethnicity').each(function (item) {
			if (!item.hasClassName('initialized')) {
				//var ethnicityServiceURL = new XWiki.Document('EthnicitySearch', 'PhenoTips').getURL("get", "outputSyntax=plain")
				//console.log("Ethnicity URL: " + ethnicityServiceURL);
				item._suggest = new PhenoTips.widgets.Suggest(item, {
					script: webService.getEthnicityLookupPath() + "&",
					varname: "q",
					noresults: "No matching terms",
					json: true,
                    resultsParameter: function(){
                        return "hits";
                    },
                    resultId: function(){
                        return "code";
                    },
                    resultValue : function(){
                        return "display";//"fullDetail"
                    },
                    resultInfo: {},
                    resultParent: "is_a",
                    resultAltName: "synonym",
                    resultCategory: "term_category",
					enableHierarchy: false,
					fadeOnClear: false,
                    minchars: 3, //Added for GEL(GenomicsEngland)
                    timeout: 30000,
					parentContainer: $('body'),
                    displaySuggestItemFunction : function(searchTerm, data, pedigreeWidget){
                        //console.log("suggestItem Function", searchTerm, data,pedigreeWidget)
                        if(!data.valueAll){
                            return null;
                        }
                        var select = FORM.select("select[name='disorderType']")[0];
                        var disorderType = select.options[select.selectedIndex].value;
                        return null;
                    },
                    canSelectInputTerm: function(){
                        return false;
                    }
				});
                if (item.hasClassName('multi') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
                    item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
                        'showKey': false,
                        'showTooltip': false,
                        'showDeleteTool': true,
                        'enableSort': false,
                        'showClearTool': true,
                        'inputType': 'hidden',
                        'listInsertionElt': 'input',
                        'listInsertionPosition': 'after',
                        'acceptFreeText': true,
                        'name':'ethnicity',
                        customizeItemDisplay : function(key, value, valueAll, displayedValue, options){
                            console.log("item display", valueAll, value)
                                // insert the displayed value
                                var hpoPresent = "";
                                if(valueAll != undefined){
                                    hpoPresent = valueAll.hpoPresent ? valueAll.hpoPresent : "unknown";
                                }else{
                                    hpoPresent = "unknown";
                                }
                                var hpoPresentContainer = new Element('span', {'class': 'hpo-present'}).insert("(").insert(hpoPresent).insert(")");
                                displayedValue.insert("").insert(hpoPresentContainer);

                        },
                        acceptsDuplicate: function(){
                            return false;
                        }
                    });
                }
				item.addClassName('initialized');
				document.observe('ms:suggest:containerCreated', function (event) {
					if (event.memo && event.memo.suggest === item._suggest) {
						item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
					}
				});
			}
		});
		// genes
		this.form.select('input.suggest-genes').each(function (item) {
			if (!item.hasClassName('initialized')) {
				var geneServiceURL = new XWiki.Document('GeneNameService', 'PhenoTips').getURL("get", "outputSyntax=plain")
				//console.log("GeneService URL: " + geneServiceURL);
				item._suggest = new PhenoTips.widgets.Suggest(item, {
					script: geneServiceURL + "&json=true&",
					varname: "query",
					noresults: "No matching terms",
					resultsParameter: "docs",
					json: true,
					resultId: "symbol",
					resultValue: "symbol",
					resultInfo: {},
					enableHierarchy: false,
					tooltip: 'gene-info',
					fadeOnClear: false,
					timeout: 30000,
					parentContainer: $('body')
				});
				if (item.hasClassName('multi') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
					item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
						'showKey': false,
						'showTooltip': false,
						'showDeleteTool': true,
						'enableSort': false,
						'showClearTool': true,
						'inputType': 'hidden',
						'listInsertionElt': 'input',
						'listInsertionPosition': 'after',
						'acceptFreeText': true
					});
				}
				item.addClassName('initialized');
				document.observe('ms:suggest:containerCreated', function (event) {
					if (event.memo && event.memo.suggest === item._suggest) {
						item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
					}
				});
			}
		});
		// HPO terms
		this.form.select('input.suggest-hpo').each(function (item) {
			//console.log("itemZZZZ",item)
			if (!item.hasClassName('initialized')) {
 				//console.log("HPO\SOLR URL: " + solrServiceURL);
				item._suggest = new PhenoTips.widgets.Suggest(item, {
					script: webService.getHPOLookupPath() + "&",
					varname: "query",
					noresults: "No matching terms",
					json: true,
					resultsParameter: function(){return "hits"},
					resultId: function(){return "code"},
					resultValue: function(){return "display"},
					resultAltName: "synonym",
					resultCategory: "term_category",
					resultInfo: {},
					enableHierarchy: false,
					resultParent: "is_a",
					//tooltip: 'phenotype-info', //commented for GEL
					fadeOnClear: false,
					timeout: 30000,
					minchars: 3, //Added for GEL(GenomicsEngland)
					parentContainer: $("body"),
					canSelectInputTerm: function(){
						return false;
					},
                    displaySuggestItemFunction : function(searchTerm, data, pedigreeWidget){
                        //console.log(searchTerm, data,pedigreeWidget)
                        if(!data.valueAll){
                            return null;
                        }
                        var select = FORM.select("select[name='disorderType']")[0];
                        var disorderType = select.options[select.selectedIndex].value;
                        if(disorderType == "GEL"){
                            var newDataValue = pedigreeWidget.highLightSearchResult(data.value.escapeHTML(), searchTerm);
                            var suggestedValue = new Element('span', {'class': 'suggestValue'}).update(newDataValue);
                            var diseaseGroup   = new Element('span').update("<br><br> Group: " + "<span style='font-size: 11px'>" +  pedigreeWidget.highLightSearchResult(data.valueAll.groupName, searchTerm) + "</span>" );
                            var diseaseSubGroup= new Element('span').update("<br> SubGroup: "  + "<span style='font-size: 11px'>" +  pedigreeWidget.highLightSearchResult(data.valueAll.subGroupName, searchTerm) + "</span>" );
                            //var hpoModifiers= new Element('span').update("<br> Modifiers: "  + "<span style='font-size: 11px'><input type=\"text\" value=\"sadfa\"</span>" );

                            suggestedValue.insert(diseaseGroup);
                            suggestedValue.insert(diseaseSubGroup);

                            //suggestedValue.insert(hpoModifiers);


                            return suggestedValue;
                        }
                        return null;
                    },
				});
				var vAll = {};
				if (item.hasClassName('multi') && !item.hasClassName('initialized')  && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
					item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
						'showKey': false,
						'showTooltip': false,
						'showDeleteTool': true,
						'enableSort': false,
						'showClearTool': true,
						'inputType': 'hidden',
						'listInsertionElt': 'input',
						'listInsertionPosition': 'after',
						'acceptFreeText': true,
						'name':'hpo',
						'showHPOPresentStatus':true,
						customizeItemDisplay : function(key, value, valueAll, displayedValue, options){
							console.log("valueALLL",valueAll)
							vAll = valueAll;

                            if(options.showHPOPresentStatus){
								// insert the displayed value
								var hpoPresent = "";
								if(valueAll != undefined){
									hpoPresent = valueAll.hpoPresent ? valueAll.hpoPresent : "unknown";
								}else{
									hpoPresent = "unknown";
								}
								var hpoPresentContainer = new Element('span', {'class': 'hpo-present'}).insert(hpoPresent);
                                //var hpoModifiers = [];
                                displayedValue.insert("").insert(hpoPresentContainer);

								if(valueAll.hpoModifiers != undefined  && valueAll.hpoModifiers.length > 0) {
                                        var hpoModifier = new Element('span').update("<br>HPO Modifiers: "  + "<span style='font-size: 11px'><input type=\"text\" style=\"display:block !important;visibility:visible;\"  class=\"suggest multi suggest-hpo-modifier accept-value\" name=\"hpo_modifier\" value=\"\"/></span>" );
                                        displayedValue.insert(hpoModifier);
                                }
                                else {
                                    //test that this will actually apply correctly
                                    //valueAll.hpoModifiers = [];
                                    var hpoModifier = new Element('span').update("<br> Modifiers: " + "<span style='font-size: 11px'><input type=\"text\" class=\"suggest multi suggest-hpo-modifier accept-value\" name=\"hpo_modifier\" value=\"\"/></span>");
                                    //hpoModifier.className
                                    displayedValue.insert(hpoModifier);
                                    item.addClassName('initialized');
                                }

                                setTimeout(function() {
                                        item.parentElement.select('input.suggest-hpo-modifier').each(function (hpoModifierItem) {
                                            if (!hpoModifierItem.hasClassName('initialized')) {
                                                hpoModifierItem._suggest = new PhenoTips.widgets.Suggest(hpoModifierItem, {
                                                    script: webService.getHPOModifierLookupPath() + "&",
                                                    varname: "query",
                                                    noresults: "No matching terms",
                                                    json: true,
                                                    resultsParameter: function () {
                                                        return "hits";
                                                    },
                                                    resultId: function () {
                                                        return "code";
                                                    },
                                                    resultValue: function () {
                                                        return "display";
                                                    },
                                                    resultAltName: "synonym",
                                                    resultCategory: "term_category",
                                                    resultInfo: {},
                                                    enableHierarchy: false,
                                                    resultParent: "is_a",
                                                    //tooltip: 'phenotype-info', //commented for GEL
                                                    fadeOnClear: false,
                                                    timeout: 30000,
                                                    minchars: 3, //Added for GEL(GenomicsEngland)
                                                    parentContainer: $("body"),
                                                    canSelectInputTerm: function () {
                                                        return false;
                                                    },
                                                    displaySuggestItemFunction: function (searchTerm, data, pedigreeWidget) {
                                                        if (!data.valueAll) {
                                                            return null;
                                                        }
                                                        return null;
                                                    }
                                                });
                                                if ( hpoModifierItem.hasClassName('multi') && hpoModifierItem.hasClassName('suggest-hpo-modifier') && !hpoModifierItem.hasClassName('initialized') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
                                                    console.log("TZZZZ",hpoModifierItem._suggest, hpoModifierItem._suggest.fld.disabled)
                                                	hpoModifierItem._suggestPicker = new PhenoTips.widgets.SuggestPicker(hpoModifierItem, hpoModifierItem._suggest, {
                                                    	'showKey': false,
                                                        'showTooltip': false,
                                                        'showDeleteTool': false,//!hpoModifierItem._suggest.fld.disabled,
                                                        'enableSort': false,
                                                        'showClearTool': true,
                                                        'inputType': 'hidden',
                                                        'listInsertionElt': 'input',
                                                        'listInsertionPosition': 'after',
                                                        'acceptFreeText': true,
                                                        'name': 'hpo-modifier',
														customizeItemDisplay: function (key, value, valueAll, displayedValue, options) {

                                                        },
                                                        acceptsDuplicate: function () {
                                                            return false;
                                                        }
                                                    });
                                                }
                                                var target = hpoModifierItem
                                                if (target ){

                                                    var targetz = hpoModifierItem.parentNode.parentNode.parentNode;
                                                    //console.log("tgtg",targetz)



                                                    // if(true){
                                                        //console.log("AZAAA",container)
                                                    //    console.log("TZT",targetz.select('input[type=hidden][name=hpo_positive]'));
                                                    targetz.select('input[type=hidden][name=hpo_positive]').each(function (item) {
														//	console.log("Zoitem:",item)
                                                        //target._suggestPicker.addItem(v.code, v.display, '', null, v.valueAll);


                                                        var li = item.up("li");
                                                      //  console.log("aa1", li)
                                                        var valueAll;
                                                        if (li != undefined) {
                                                            valueAll = li.retrieve("valueAll");
                                                            var hpoPresent = document.getElementsByName("hpoPresent")[0].value
															/*if(!valueAll.hpoPresent) {
                                                                valueAll.hpoPresent = hpoPresent;
                                                            }*/
                                                            if(valueAll && valueAll.hpoModifiers && valueAll.hpoModifiers.length > 0){
                                                                valueAll.hpoModifiers.forEach(function(v){
                                                                 //   console.log("Vg",v);
                                                                    target._suggestPicker.addItem(v.code, v.display, '', null, v.valueAll);

                                                                });
                                                            }
                                                        }
                                                        });
                                                    }

                                                hpoModifierItem.addClassName('initialized');
                                            }
                                        });
                                    },0);

								//}
							}
						},
						acceptsDuplicate: function(){
							return false;
						}
					});
				}
				item.addClassName('initialized');
				document.observe('ms:suggest:containerCreated', function (event) {
					if (event.memo && event.memo.suggest === item._suggest) {
						item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
					}
				});
			}
		});

        this.form.select('input.suggest-hpo').each(function (item) {
            if (!item.hasClassName('initialized')) {
                //console.log("HPO\SOLR URL: " + solrServiceURL);
                item._suggest = new PhenoTips.widgets.Suggest(item, {
                    script: webService.getHPOLookupPath() + "&",
                    varname: "query",
                    noresults: "No matching terms",
                    json: true,
                    resultsParameter: function(){return "hits"},
                    resultId: function(){return "code"},
                    resultValue: function(){return "display"},
                    resultAltName: "synonym",
                    resultCategory: "term_category",
                    resultInfo: {},
                    enableHierarchy: false,
                    resultParent: "is_a",
                    //tooltip: 'phenotype-info', //commented for GEL
                    fadeOnClear: false,
                    timeout: 30000,
                    minchars: 3, //Added for GEL(GenomicsEngland)
                    parentContainer: $("body"),
                    canSelectInputTerm: function(){
                        return false;
                    },
                    displaySuggestItemFunction : function(searchTerm, data, pedigreeWidget){
                       // console.log(searchTerm, data,pedigreeWidget)
                        if(!data.valueAll){
                            return null;
                        }
                        return null;
                    },
                });
                if (item.hasClassName('multi') && item.hasClassName('suggest-hpo') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
                    item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
                        'showKey': false,
                        'showTooltip': false,
                        'showDeleteTool': true,
                        'enableSort': false,
                        'showClearTool': true,
                        'inputType': 'hidden',
                        'listInsertionElt': 'input',
                        'listInsertionPosition': 'after',
                        'acceptFreeText': true,
                        'name':'hpo',
                        'showHPOPresentStatus':true,
                        customizeItemDisplay : function(key, value, valueAll, displayedValue, options){
                            if(options.showHPOPresentStatus){
                                // insert the displayed value
                                var hpoPresent = "";
                                if(valueAll != undefined){
                                    hpoPresent = valueAll.hpoPresent ? valueAll.hpoPresent : "unknown";
                                }else{
                                    hpoPresent = "unknown";
                                }
                                var hpoPresentContainer = new Element('span', {'class': 'hpo-present'}).insert("(").insert(hpoPresent).insert(")");
                                displayedValue.insert("").insert(hpoPresentContainer);
                            }
                        },
                        acceptsDuplicate: function(){
                            return false;
                        }
                    });
                }
                item.addClassName('initialized');
                document.observe('ms:suggest:containerCreated', function (event) {
                    if (event.memo && event.memo.suggest === item._suggest) {
                        item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
                    }
                });
            }
        });
        /*hpo modifier */
        this.form.select('input.suggest-hpo-modifier').each(function (item) {
            if (!item.hasClassName('initialized')) {
                //console.log("HPO\SOLR URL: " + solrServiceURL);
                item._suggest = new PhenoTips.widgets.Suggest(item, {
                    script: webService.getHPOModifierLookupPath() + "&",
                    varname: "query",
                    noresults: "No matching terms",
                    json: true,
                    resultsParameter: function(){return "hits"},
                    resultId: function(){return "code"},
                    resultValue: function(){return "display"},
                    resultAltName: "synonym",
                    resultCategory: "term_category",
                    resultInfo: {},
                    enableHierarchy: false,
                    resultParent: "is_a",
                    //tooltip: 'phenotype-info', //commented for GEL
                    fadeOnClear: false,
                    timeout: 30000,
                    minchars: 3, //Added for GEL(GenomicsEngland)
                    parentContainer: $("body"),
                    canSelectInputTerm: function(){
                        return false;
                    },
                    displaySuggestItemFunction : function(searchTerm, data, pedigreeWidget){
                       // console.log(searchTerm, data,pedigreeWidget)
                        if(!data.valueAll){
                            return null;
                        }
                        return null;
                    },
                });
                if (item.hasClassName('multi') && item.hasClassName('suggest-hpo') && typeof(PhenoTips.widgets.SuggestPicker) != "undefined") {
                    item._suggestPicker = new PhenoTips.widgets.SuggestPicker(item, item._suggest, {
                        'showKey': false,
                        'showTooltip': false,
                        'showDeleteTool': false,
                        'enableSort': false,
                        'showClearTool': true,
                        'inputType': 'hidden',
                        'listInsertionElt': 'input',
                        'listInsertionPosition': 'after',
                        'acceptFreeText': true,
                        'name':'hpo',
                        'showHPOPresentStatus':true,
                        customizeItemDisplay : function(key, value, valueAll, displayedValue, options){
                            if(options.showHPOPresentStatus){
                                // insert the displayed value
                                var hpoPresent = "";
                                if(valueAll != undefined){
                                    hpoPresent = valueAll.hpoPresent ? valueAll.hpoPresent : "unknown";
                                }else{
                                    hpoPresent = "unknown";
                                }
                                var hpoPresentContainer = new Element('span', {'class': 'hpo-present'}).insert("(").insert(hpoPresent).insert(")");
                                displayedValue.insert("").insert(hpoPresentContainer);
                            }
                        },
                        acceptsDuplicate: function(){
                            return false;
                        }
                    });
                }
                item.addClassName('initialized');
                document.observe('ms:suggest:containerCreated', function (event) {
                    if (event.memo && event.memo.suggest === item._suggest) {
                        item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
                    }
                });
            }
        });
        /*//hpo modifier */

		// patient selector
		this.form.select('input.suggest-patients').each(function (item) {
			if (!item.hasClassName('initialized')) {
				var patientSuggestURL = new XWiki.Document('SuggestPatientsService', 'PhenoTips').getURL("get", "outputSyntax=plain") + "&permission=edit&";
				//console.log("PatientSuggest URL: " + patientSuggestURL);
				item._suggest = new PhenoTips.widgets.Suggest(item, {
					script: patientSuggestURL,
					varname: "input",
					noresults: "No matching patients",
					json: false,
					resultsParameter: "rs",
					resultId: "id",
					resultValue: "name",
					resultInfo: "info",
					enableHierarchy: false,
					fadeOnClear: false,
					timeout: 30000,
                    parentContainer: $("body")
				});
				item.addClassName('initialized');
				document.observe('ms:suggest:containerCreated', function (event) {
					if (event.memo && event.memo.suggest === item._suggest) {
						item._suggest.container.setStyle({'overflow': 'auto', 'maxHeight': document.viewport.getHeight() - item._suggest.container.cumulativeOffset().top + 'px'})
					}
				});
			}
		});
	},

	_generateEmptyField: function (data) {

		//Added for GEL(GenomicsEngland)
		//we can add extra class to the field if it has 'class' field ..................................................
		//var result = new Element('div', {'class': 'field-box field-' + data.name});
		var cssClass = 'field-box field-' + data.name;
		if(data.class){
			cssClass = 'field-box field-' + data.name + " " + data.class;
		}
		//..............................................................................................................

		var result = new Element('div', {'class': cssClass});
		var fieldNameClass = 'field-name';
		//Added for GEL(GenomicsEngland)................................................................................
		//if type is label (a new type introduced for GEL), then user 'field-label' class
		if(data.type == "label"){
			fieldNameClass = "field-label";
		}
		///.............................................................................................................
		if (data.type == "radio") {
			fieldNameClass += ' field-no-user-select';
		}
		if (data.addCSS && typeof data.addCSS === 'object') {
			for (var styleName in data.addCSS) {
				result.style[styleName] = data.addCSS[styleName];
			}
		}
		var label = new Element('label', {'class': fieldNameClass}).update(data.label);
		result.inputsContainer = new Element('div', {'class': 'field-inputs'});
		//Added for GEL(GenomicsEngland)................................................................................
		//if it is NOT a label type, then add inputsContainer, otherwise do not add it .................................
		if(data.type != 'label') {
			result.insert(label).insert(result.inputsContainer);
		}else{
			result.insert(label);
		}
		this.fieldMap[data.name] = {
			'type': data.type,
			'element': result,
			'default': data["default"] || '',
			'crtValue': data["default"] || '',
			'function': data['function'],
			'disabled' : data['disabled'] || false,
			'isMultipleSelect' : data['isMultipleSelect'] || false, //added for GEL(GenomicsEngland), 'isMultipleSelect' is true when the select is a 'multiple' select
			'inactive': false
		};
		return result;
	},

	_attachFieldEventListeners: function (field, eventNames, values) {
		var _this = this;
		eventNames.each(function (eventName) {
			field.observe(eventName, function (event) {
				_this._saveCursorPositionIfNecessary(field);
				if (_this._updating) return; // otherwise a field change triggers an update which triggers field change etc
				var target = _this.targetNode;
				if (!target) return;

				//commented by Soheil for GEL(GenomicsEngland) ....................................................................
				//_this.fieldMap[field.name].crtValue = field._getValue && field._getValue()[0];
				//added for GEL(GenomicsEngland), if the element is a select element with 'isMultipleSelect' equals to true
				//we need to load all the values, not just the first item in the list
				if(_this.fieldMap[field.name].isMultipleSelect == undefined || _this.fieldMap[field.name].isMultipleSelect == false) {
					_this.fieldMap[field.name].crtValue = field._getValue && field._getValue()[0];
				}else{
					_this.fieldMap[field.name].crtValue = field._getValue && field._getValue();
				}
				//.................................................................................................................

				var method = _this.fieldMap[field.name]['function'];

				if (target.getSummary()[field.name].value == _this.fieldMap[field.name].crtValue) {
					return;
				}

				if (method.indexOf("set") == 0 && typeof(target[method]) == 'function') {
					var properties = {};
					properties[method] = _this.fieldMap[field.name].crtValue;
					var event = { "nodeID": target.getID(), "properties": properties };
					document.fire("pedigree:node:setproperty", event);
				} else {
					var properties = {};
					properties[method] = _this.fieldMap[field.name].crtValue;
					var event = { "nodeID": target.getID(), "modifications": properties };
					document.fire("pedigree:node:modify", event);
				}
				field.fire('pedigree:change');
			});
		});
	},

	_saveCursorPositionIfNecessary: function (field) {
		this.__lastSelectedField = field.name;
		this.__lastNodeID = this.targetNode;
		// for text fields in all browsers, and textarea only in IE9
		if (field.type == "text" || (document.selection && field.type == "textarea")) {
			this.__lastCursorPosition = GraphicHelpers.getCaretPosition(field);
		}
	},

	_restoreCursorPositionIfNecessary: function (field) {
		if (this.targetNode == this.__lastNodeID &&
			field != undefined &&
			field.name == this.__lastSelectedField) {
			// for text fields in all browsers, and textarea only in IE9
			if (field.type == "text" || (document.selection && field.type == "textarea")) {
				GraphicHelpers.setCaretPosition(field, this.__lastCursorPosition);
			}
		}
	},

	update: function (newTarget) {
		//console.log("Node menu: update");
		if (newTarget)
			this.targetNode = newTarget;

		if (this.targetNode) {
			this._updating = true;   // needed to avoid infinite loop: update -> _attachFieldEventListeners -> update -> ...
			this._setCrtData(this.targetNode.getSummary());
			//this.reposition();
			delete this._updating;
		}
	},

	_attachDependencyBehavior: function (field, data) {
		if (data.dependency) {
			var dependency = data.dependency.split(' ', 3);
			var element = this.fieldMap[dependency[0]].element;
			dependency[0] = this.form[dependency[0]];
			if(data.dependencyShowInline != undefined && data.dependencyShowInline == true) {
				element.inputsContainer.insert(field.up());
			}
			this.fieldMap[field.name].element = element;
			this._updatedDependency(field, dependency);
			dependency[0].observe('pedigree:change', function () {
				this._updatedDependency(field, dependency);
				field.value = '';
				//console.log("dependency observed: " + field + ", dep: " + dependency);
			}.bindAsEventListener(this));
		}
	},

	_updatedDependency: function (field, dependency) {
		switch (dependency[1]) {
			case '!=':
				field.disabled = (dependency[0].value == dependency[2]);
				break;
			default:
				field.disabled = (dependency[0].value != dependency[2]);
				break;
		}
	},

	_generateField: {
		'radio': function (data) {
			var result = this._generateEmptyField(data);
			var columnClass = data.columns ? "field-values-" + data.columns + "-columns" : "field-values";
			columnClass += " field-no-user-select";
			var values = new Element('div', {'class': columnClass});
			result.inputsContainer.insert(values);
			var _this = this;
			var _generateRadioButton = function (v) {
				var radioLabel = new Element('label', {'class': data.name + '_' + v.actual}).update(v.displayed);
				if (v.hasOwnProperty("columnshiftPX")) {
					radioLabel.setStyle({"marginLeft": "" + v.columnshiftPX + "px"});
				}
				var radioButton = new Element('input', {type: 'radio', name: data.name, value: v.actual});
				radioLabel.insert({'top': radioButton});
				radioButton._getValue = function () {
					return [this.value];
				}.bind(radioButton);
				values.insert(radioLabel);
				_this._attachFieldEventListeners(radioButton, ['click']);
				_this._attachDependencyBehavior(radioButton, data);
			};
			if (data.hasOwnProperty("valuesIE9") && navigator && navigator.appVersion.indexOf("MSIE 9") != -1) {
				data.valuesIE9.each(_generateRadioButton);
			} else {
				data.values.each(_generateRadioButton);
			}

			return result;
		},
		'checkbox': function (data) {
			var result = this._generateEmptyField(data);
			var checkbox = new Element('input', {type: 'checkbox', name: data.name, value: '1'});
			result.down('label').insert({'top': checkbox});
			checkbox._getValue = function () {
				return [this.checked];
			}.bind(checkbox);
			this._attachFieldEventListeners(checkbox, ['click']);
			return result;
		},
		//Added for GEL(GenomicsEngland).......................................................................................
		//This will create a new type known as 'label' where it can be used as a simple text in the UI like age_of_death_guide
		'label': function (data) {
			var result = this._generateEmptyField(data);
			result.addClassName("field-label");

			return result;
		},
		'text': function (data) {
			var result = this._generateEmptyField(data);
			var text = new Element('input', {type: 'text', name: data.name});
			if (data.tip) {
				text.placeholder = data.tip;
			}
			result.inputsContainer.insert(text);
			text.wrap('span');
			text._getValue = function () {
				return [this.value];
			}.bind(text);
			//this._attachFieldEventListeners(text, ['keypress', 'keyup'], [true]);
			this._attachFieldEventListeners(text, ['keyup'], [true]);
			this._attachDependencyBehavior(text, data);
			return result;
		},
		'textarea': function (data) {
			var result = this._generateEmptyField(data);
			var properties = {name: data.name};
			properties["class"] = "textarea-" + data.rows + "-rows"; // for compatibiloity with older browsers not accepting {class: ...}
			var text = new Element('textarea', properties);
			result.inputsContainer.insert(text);
			//text.wrap('span');
			text._getValue = function () {
				return [this.value];
			}.bind(text);
			this._attachFieldEventListeners(text, ['keyup'], [true]);
			this._attachDependencyBehavior(text, data);
			return result;
		},
		'date-picker': function (data) {
			var result = this._generateEmptyField(data);
			var datePicker = new Element('input', {type: 'text', 'class': 'fuzzy-date', name: data.name, 'title': data.format || '', alt: '' });
			result.inputsContainer.insert(datePicker);
			datePicker._getValue = function () { /*console.log("DATE UPDATE: " + this.value);*/
				return [new PedigreeDate(JSON.parse(this.value))];
			}.bind(datePicker);
			this._attachFieldEventListeners(datePicker, ['xwiki:date:changed']);
			return result;
		},
		'disease-picker': function (data) {
			var result = this._generateEmptyField(data);
			//added for GEL........
			//if element has style in its definition, then use it
			var style = data.style ? data.style : "";
			var diseasePicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-omim', name: data.name, 'style': style});
			result.insert(diseasePicker);
			diseasePicker._getValue = function () {
				var results = [];
				var container = this.up('.field-box');
				if (container) {
					container.select('input[type=hidden][name=' + data.name + ']').each(function (item) {
						//commented and replaced by the following for GEL(GenomicsEngland) .........................
						//results.push(new Disorder(item.value, item.next('.value') && item.next('.value').firstChild.nodeValue || item.value));
						var li = item.up("li");
						var valueAll;
						if(li != undefined){
							valueAll = li.retrieve("valueAll");
						}
						results.push(new Disorder(item.value, item.next('.value') && item.next('.value').firstChild.nodeValue || item.value, valueAll.ageOfOnset, valueAll.diagnosisCertainty, valueAll.codeSystemUri, valueAll.versionNumber, valueAll.disorderType,valueAll));
					});
				}
				return [results];
			}.bind(diseasePicker);
			// Forward the 'custom:selection:changed' to the input
			var _this = this;
			document.observe('custom:selection:changed', function (event) {
				if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {

                    //Added for GEL..........................................................
                    if (_this.form.select("select[name='diagnosisCertainty']").length > 0){
                        var diagnosisCertainty = (_this.form.select("select[name='diagnosisCertainty']")[0]).getValue();
                        var valueAll  =  event.memo.customElement.retrieve("valueAll");
                        if(valueAll != undefined){
                            valueAll.diagnosisCertainty = diagnosisCertainty;
                        }
                    }
					//........................................................................
					Event.fire(event.memo.trigger, 'custom:selection:changed');
					_this.reposition();
				}
			});
			this._attachFieldEventListeners(diseasePicker, ['custom:selection:changed']);
			return result;
		},
		'ethnicity-picker': function (data) {
			var result = this._generateEmptyField(data);
			var ethnicityPicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-ethnicity', name: data.name});
			result.insert(ethnicityPicker);
			ethnicityPicker._getValue = function () {
				var results = [];
				var container = this.up('.field-box');

				if (container) {
					container.select('input[type=hidden][name=' + data.name + ']').each(function (item) {
                        var li = item.up("li");
                        var valueAll;
                        if(li != undefined){
                            valueAll = li.retrieve("valueAll");
                        }
                        var ethnicity = {
                            "code":item.next('.value') && item.next('.value').firstChild.nodeValue || item.value,
                            "display":item.value,
							"valueAll":valueAll.uid

                        };
						//results.push(ethnicity(;))
                        results.push(new Ethnicity(item.value, item.next('.value') && item.next('.value').firstChild.nodeValue || item.value, valueAll.uid, valueAll));

                       // results.push(item.next('.value') && item.next('.value').firstChild.nodeValue || item.value);
					});
				}
				return [results];
			}.bind(ethnicityPicker);
			// Forward the 'custom:selection:changed' to the input
			var _this = this;
			document.observe('custom:selection:changed', function (event) {
				if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {
					Event.fire(event.memo.trigger, 'custom:selection:changed');
					_this.reposition();
				}
			});
			this._attachFieldEventListeners(ethnicityPicker, ['custom:selection:changed']);
			return result;
		},
		'hpo-picker': function (data) {
			var result = this._generateEmptyField(data);
			var hpoPicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-hpo', name: data.name});
			result.insert(hpoPicker);
			hpoPicker._getValue = function () {
				var results = [];
				var container = this.up('.field-box');
				if (container) {
					container.select('input[type=hidden][name=' + data.name + ']').each(function (item) {
						//commented and replaced by the following for GEL(GenomicsEngland) .........................
						//results.push(new HPOTerm(item.value, item.next('.value') && item.next('.value').firstChild.nodeValue || item.value));
						var li = item.up("li");
						var valueAll;
						if(li != undefined){
							valueAll = li.retrieve("valueAll");
						}
						results.push(new HPOTerm(item.value, item.next('.value') && item.next('.value').firstChild.nodeValue || item.value, valueAll.hpoPresent, valueAll.hpoModifiers, valueAll));
					});
				}
				return [results];
			}.bind(hpoPicker);
			// Forward the 'custom:selection:changed' to the input
			var _this = this;
			document.observe('custom:selection:changed', function (event) {
				if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {
					//Added for GEL.....................................................................................
					if (_this.form.select("select[name='hpoPresent']").length > 0){
						var hpoPresent = (_this.form.select("select[name='hpoPresent']")[0]).getValue();
						var valueAll  =  event.memo.customElement.retrieve("valueAll");
						if(valueAll != undefined && !valueAll.hpoPresent){
                                valueAll.hpoPresent = hpoPresent;
						}
					}
					//..................................................................................................
					Event.fire(event.memo.trigger, 'custom:selection:changed');
					_this.reposition();
				}
			});
			this._attachFieldEventListeners(hpoPicker, ['custom:selection:changed']);
			return result;
		},
        'hpo-modifier-picker': function (data) {
            var result = this._generateEmptyField(data);
            var hpoModifierPicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-hpo-modifier', name: data.name});
            result.insert(hpoModifierPicker);
            hpoModifierPicker._getValue = function () {
                var results = [];
                return [results];
            }.bind(hpoModifierPicker);
            // Forward the 'custom:selection:changed' to the input
            var _this = this;
            document.observe('custom:selection:changed', function (event) {
                if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {
                    //Added for GEL.....................................................................................
                    if (_this.form.select("select[name='hpoPresent']").length > 0){
                        var hpoPresent = (_this.form.select("select[name='hpoPresent']")[0]).getValue();
                        var valueAll  =  event.memo.customElement.retrieve("valueAll");
                        if(valueAll != undefined && !valueAll.hpoPresent){
                            valueAll.hpoPresent = hpoPresent;
                        }
                    }
                    //..................................................................................................
                    Event.fire(event.memo.trigger, 'custom:selection:changed');
                    _this.reposition();
                }
            });
            this._attachFieldEventListeners(hpoModifierPicker, ['custom:selection:changed']);
            return result;
        },
		'phenotipsid-picker': function (data) {
			var result = this._generateEmptyField(data);
			var patientPicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-patients', name: data.name});
			result.insert(patientPicker);
			patientPicker._getValue = function () {
				var results = [];
				var container = this.up('.field-box');
				if (container) {
					container.select('input[type=hidden][name=' + data.name + ']').each(function (item) {
						results.push(item.next('.value') && item.next('.value').firstChild.nodeValue || item.value);
					});
				}
				return [results];
			}.bind(patientPicker);
			// Forward the 'custom:selection:changed' to the input
			var _this = this;
			document.observe('custom:selection:changed', function (event) {
				if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {
					Event.fire(event.memo.trigger, 'custom:selection:changed');
					_this.reposition();
				}
			});
			this._attachFieldEventListeners(patientPicker, ['custom:selection:changed']);
			return result;
		},
		'gene-picker': function (data) {
			var result = this._generateEmptyField(data);
			var genePicker = new Element('input', {type: 'text', 'class': 'suggest multi suggest-genes', name: data.name});
			result.insert(genePicker);
			genePicker._getValue = function () {
				var results = [];
				var container = this.up('.field-box');
				if (container) {
					container.select('input[type=hidden][name=' + data.name + ']').each(function (item) {
						results.push(item.next('.value') && item.next('.value').firstChild.nodeValue || item.value);
					});
				}
				return [results];
			}.bind(genePicker);
			// Forward the 'custom:selection:changed' to the input
			var _this = this;
			document.observe('custom:selection:changed', function (event) {
				if (event.memo && event.memo.fieldName == data.name && event.memo.trigger && event.findElement() != event.memo.trigger && !event.memo.trigger._silent) {
					Event.fire(event.memo.trigger, 'custom:selection:changed');
					_this.reposition();
				}
			});
			this._attachFieldEventListeners(genePicker, ['custom:selection:changed']);
			return result;
		},
		'select': function (data) {
			var result = this._generateEmptyField(data);
			var span = new Element('span');
			//added for GEL........
			//if element has style in its definition, then use it
			var style = data.style ? data.style : "";
			//added for GEL........
			//check if the select is a 'multiple' select
			var isMultipleSelect = data.isMultipleSelect ? data.isMultipleSelect : "";
			var multiple = "";
			if(isMultipleSelect != undefined && isMultipleSelect == true){
				multiple = "multiple";
			}
			// using raw HTML for options for performace reasons: generating e.g. 50 different gestation week
			// options is noticeably slow when using more generic methods (e.g. new Element("option"))
			var optionHTML = '<select name="' + data.name + '" style="' + style +'" ' + multiple + '>';
			var _generateSelectOption = function (v) {
				optionHTML += '<option value="' + v.actual + '">' + v.displayed + '</option>';
			};
            var _generateSelectOptionForLookup = function (code, display) {
                optionHTML += '<option value="' + code + '">' + display+ '</option>';
            };
			if (data.nullValue) {
				_generateSelectOption({'actual': '', displayed: '-'});
			}
			if(data.name == 'ethnicity'){
				// It has been initialized because I have made the call required prior to the pedigree
				// being initialized(unless that code has been refactored since)
				//TODO : JG Check this. Confirm with Kevin. It is fairly possible that ajax call to load ethnicityList has not returned by this time
				// It is an async call
				if (PedigreeEditorTool.ethnicityList){
					PedigreeEditorTool.ethnicityList.hits.forEach(function(hit){
						_generateSelectOptionForLookup(hit.code, hit.display)
					});
				}
				
            }
			else if (data.values) {
				data.values.each(_generateSelectOption);
			} else if (data.range) {
				$A($R(data.range.start, data.range.end)).each(function (i) {
					_generateSelectOption({'actual': i, 'displayed': i + ' ' + data.range.item[+(i != 1)]})
				});
			}
			optionHTML += "</select>";
			span.innerHTML = optionHTML;
			select = span.firstChild;
			result.inputsContainer.insert(span);
			select._getValue = function () {
				//commented by Soheil for GEL(GenomicsEngland) ......................................................
				//return [(this.selectedIndex >= 0) && this.options[this.selectedIndex].value || ''];
				//if the select element is a 'multiple' element, then we need to get all the selected options and return all
				if(isMultipleSelect == undefined || isMultipleSelect == false){
					return [(this.selectedIndex >= 0) && this.options[this.selectedIndex].value || ''];
				}
				//ie 11 issues
				else if (this.selectedOptions){
					var selected = [];
					for(var i = 0; i < this.selectedOptions.length ; i++){
						selected.push(this.selectedOptions[i].value);
					}
					return selected;
				}else{
				    return [(this.selectedIndex >= 0) && this.options[this.selectedIndex].value || ''];
				}
				//....................................................................................................
			}.bind(select);
			this._attachFieldEventListeners(select, ['change']);
			return result;
		},
		'cancerlist': function (data) {
			//var timer = new Helpers.Timer();
			var result = this._generateEmptyField(data);
			var cancerList = editor.getCancerLegend()._getAllSupportedCancers();

			var tableHeaderRow = new Element('tr', {'class': 'cancer_field cancer-header field-no-user-select'});
			var label1 = new Element('td').insert(new Element('label', {'class': 'cancer_label_field'}).update("Name"));
			var label2 = new Element('td').insert(new Element('label', {'class': 'cancer_status_select'}).update("Status"));
			var label3 = new Element('td').insert(new Element('label', {'class': 'cancer_age_select'}).update("As of"));
			tableHeaderRow.insert(label1).insert(label2).insert(label3);
			var table = new Element('table');
			table.insert(tableHeaderRow);

			// create once and clone for each cancer - it takes too much time to create all elements anew each time
			// (Note1: for performace reasons also using raw HTML for options)
			// (Note2: using span around select because IE9 does not allow setting innerHTML of <select>-s)
			var maxAge = 100;
			var minAge = 1;
			var majorStepSize = 10;
			var spanAgeProto = new Element('span');
			var optionsHTML = '<select name="' + data.name + '" class="cancer_age_select field-no-user-select"><option value=""></option>';
			optionsHTML += '<option value="before_' + minAge + '">before ' + minAge + '</option>';
			for (var age = minAge; age <= maxAge; age++) {
				if (age % majorStepSize == 0) {
					optionsHTML += '<option value="before_' + age + '">' + (age - majorStepSize + 1) + '-' + age + '</option>';
				}
				optionsHTML += '<option value="' + age + '">' + age + '</option>';
			}
			optionsHTML += '<option value="after_' + maxAge + '">after ' + maxAge + '</option></select>';
			spanAgeProto.innerHTML = optionsHTML;

			var spanSelectProto = new Element('span');
			spanSelectProto.innerHTML = "<select name='" + data.name + "' class='cancer_status_select field-no-user-select'>" +
				"<option value=''></option>" +
				"<option value='Affected'>Affected</option>" +
				"<option value='Unaffected'>Unaffected</option></select>";

			var cancersUIElements = [];
			for (var i = 0; i < cancerList.length; i++) {
				var cancerName = cancerList[i];
				var tableRow = new Element('tr', {'class': 'cancer_field'});
				var label = new Element('td').insert(new Element('label', {'class': 'cancer_label_field'}).update(cancerName));

				var spanAge = spanAgeProto.cloneNode(true);
				var selectAge = spanAge.firstChild;
				selectAge.disable();
				selectAge.id = "cancer_age_" + cancerName;

				var spanSelect = spanSelectProto.cloneNode(true);
				var select = spanSelect.firstChild;
				select.id = "cancer_status_" + cancerName;

				var textInput = new Element('textArea', {'type': 'text', 'name': data.name}).hide();
				textInput.disabled = true;
				textInput.id = "cancer_notes_" + cancerName;
				var expandNotes = new Element('label', {'class': 'clickable cancer-notes', 'for': textInput.id}).update("<span class='fa fa-file-text-o'></span>");

				var toggleNotes = (function (textInput, expandNotes) {
					return function () {
						if (textInput.disabled == true) {
							textInput.disabled = false;
							textInput.show();
							expandNotes.hide();
						} else if (textInput.value == "") {
							textInput.hide();
							textInput.disabled = true;
							expandNotes.show()
						}
					};
				})(textInput, expandNotes);

				var enableNotes = (function (expandNotes, textInput, toggleNotes) {
					return function () {
						expandNotes.observe('click', toggleNotes);
						textInput.observe('blur', toggleNotes);
						expandNotes.removeClassName('disabled');
					};
				})(expandNotes, textInput, toggleNotes);

				var disableNotes = (function (expandNotes, textInput, toggleNotes) {
					return function () {
						expandNotes.stopObserving('click', toggleNotes);
						textInput.stopObserving('blur', toggleNotes);
						textInput.value = "";
						textInput.hide();
						textInput.disabled = true;
						expandNotes.show()
						expandNotes.addClassName('disabled');
					};
				})(expandNotes, textInput, toggleNotes);

				expandNotes.enableNotes = enableNotes;
				expandNotes.disableNotes = disableNotes;

				cancersUIElements.push({"name": cancerName, "status": select, "age": selectAge, "notes": textInput, "enableNotes": enableNotes});

				select._getValue = function () {
					var data = {};
					for (var i = 0; i < cancersUIElements.length; i++) {
						var nextCancer = cancersUIElements[i];

						var statusTxt = (nextCancer.status.selectedIndex >= 0) ? nextCancer.status.options[nextCancer.status.selectedIndex].value : '';
						var ageTxt = (nextCancer.age.selectedIndex >= 0) ? nextCancer.age.options[nextCancer.age.selectedIndex].value : '';
						var notesTxt = nextCancer.notes.value;

						if (statusTxt && statusTxt != "") {

							var status = (statusTxt == "affected") ? true : false;

							var ageNumeric = 0;
							if (Helpers.isInt(ageTxt)) {
								ageNumeric = parseInt(ageTxt);
							} else {
								var before = ageTxt.match(/before_(\d+)/);
								if (before) {
									ageNumeric = before[1] - 5;
									if (ageNumeric < 0) ageNumeric = 0;
								}
								var after = ageTxt.match(/after_(\d+)/);
								if (after) {
									ageNumeric = after[1];
								}
							}

							data[nextCancer.name] = { "Affected": status,
								"ageAtDiagnosis": ageTxt,
								"numericAgeAtDiagnosis": ageNumeric,
								"notes": notesTxt};
						}
					}
					return [ data ];
				};
				selectAge._getValue = textInput._getValue = select._getValue;

				this._attachFieldEventListeners(select, ['change']);
				this._attachFieldEventListeners(selectAge, ['change']);
				this._attachFieldEventListeners(textInput, ['change', 'keyup']);

				var genSelectFunction = function (select, selectAge, enableNotes, disableNotes) {
					return function () {
						if (select.selectedIndex > 0) {
							selectAge.enable();
							enableNotes();
						} else {
							selectAge.selectedIndex = 0;
							selectAge.disable();
							disableNotes();
						}
					}
				}
				var events = ['change'];
				browser.isGecko && events.push('keyup');
				events.each(function (eventName) {
					var selFunc = genSelectFunction(select, selectAge, enableNotes, disableNotes);
					select.observe(eventName, function () {
						selFunc();
					});
				});
				tableRow.insert(label)
					.insert(new Element('td').insert(spanSelect))
					.insert(new Element('td').insert(spanAge))
					.insert(new Element('td').insert(expandNotes));
				table.insert(tableRow)
					.insert(new Element('tr', {'class': 'cancer_textarea'}).insert(new Element('td', {'colspan': 3}).insert(textInput)));
				result.inputsContainer.insert(table);

			}

			var buttonContainer = new Element('div', { 'class': 'button-container'});
			var classes = 'patient-menu-button patient-no-cancers-button';
			var noneButton = new Element('span', {'class': classes}).update("None of the above as of today");
			var nameHolder = new Element('input', {'type': 'hidden', 'name': data.name});
			var _this = this;
			noneButton.observe('click', function (event) {
				for (var i = 0; i < cancersUIElements.length; i++) {
					// clear age if previous value was not "unaffected". If it is "unaffected"
					// already it will get overwritten by current age if age is known, or stay as it currently is otherwise
					if (cancersUIElements[i].status.value != "unaffected") {
						cancersUIElements[i].age.value = "";
					}
					cancersUIElements[i].status.value = "unaffected";
					cancersUIElements[i].enableNotes();
					cancersUIElements[i].age.enable();
					var birthDate = _this.targetNode.getBirthDate();
					if (birthDate) {
						var age = getAge(birthDate, _this.targetNode.getDeathDate(), true);
						cancersUIElements[i].age.value = age;
					}
				}
				Event.fire(nameHolder, 'custom:selection:changed');
				_this.reposition();
			});
			nameHolder._getValue = cancersUIElements[0].status._getValue;
			this._attachFieldEventListeners(nameHolder, ['custom:selection:changed']);
			buttonContainer.update(noneButton).insert(nameHolder);
			result.inputsContainer.insert(buttonContainer);

			//console.log( "=== Generate cancers time: " + timer.report() + "ms ==========" );
			return result;
		},
		'hidden': function (data) {
			var result = this._generateEmptyField(data);
			result.addClassName('hidden');
			var input = new Element('input', {type: 'hidden', name: data.name, value: ''});
			result.update(input);
			return result;
		}
	},

	show: function (node, x, y) {
		var me = this;
		this._justOpened = true;
		setTimeout(function () {
			me._justOpened = false;
		}, 150);

		this._onscreen = true;
		//console.log("nodeMenu show");
		this.targetNode = node;
		this._setCrtData(node.getSummary());
		this.menuBox.show();
		this.reposition(x, y);

		//Set clinicalIndicationName for currentNode
        var clinicalIndicationNames = document.getElementsByName("clinicalIndicationName");
        var clinicalIndicationValue = document.getElementById("clinical-indication-name").innerHTML.split('<span')[0];

        //IE11/Edge Issues : NodeList cannot be iterated upon.
        if (clinicalIndicationNames && !clinicalIndicationNames.forEach){
            clinicalIndicationNames = [].slice.call(clinicalIndicationNames);
        }

        clinicalIndicationNames.forEach(function(clinicalIndicationName){
            clinicalIndicationName.value = clinicalIndicationValue;
        });

		document.observe('mousedown', this._onClickOutside);
	},

	hide: function () {
		if (this._justOpened) {
			return;
		}
		this.hideSuggestPicker();
		this._onscreen = false;
		//console.log("nodeMenu hide");
		document.stopObserving('mousedown', this._onClickOutside);
		if (this.targetNode) {
			this.targetNode.onWidgetHide();
			delete this.targetNode;
		}
		this.menuBox.hide();
		this._clearCrtData();
	},

	hideSuggestPicker: function () {
		this.form.select('input.suggest').each(function (item) {
			if (item._suggest) {
				item._suggest.clearSuggestions();
			}
		});
	},

	isVisible: function () {
		return this._onscreen;
	},

	_onClickOutside: function (event) {
		//console.log("nodeMenu clickoutside");
		if (!event.findElement('.suggestItems')) {
			this.hideSuggestPicker();
		}
		if (!event.findElement('.menu-box') && !event.findElement('.suggestItems')) {
			this.hide();
		}
	},

	reposition: function (x, y) {
		x = Math.floor(x);
		if (x !== undefined && isFinite(x)) {
			if (this.canvas && x + this.menuBox.getWidth() > (this.canvas.getWidth() + 10)) {
				var delta = x + this.menuBox.getWidth() - this.canvas.getWidth();
				editor.getWorkspace().panByX(delta, true);
				x -= delta;
			}
			this.menuBox.style.left = x + 'px';
		}

		this.menuBox.style.height = '';
		var height = '';
		var top = '';
		if (y !== undefined && isFinite(y)) {
			y = Math.floor(y);
		} else {
			if (this.menuBox.style.top.length > 0) {
				try {
					y = parseInt(this.menuBox.style.top.match(/^(\d+)/g)[0]);
				} catch (err) {
					// ignore: strange style or negative y, y will b set to 0
				}
			}
		}
		if (y === undefined || !isFinite(y) || y < 0) {
			y = 0;
		}

		// Make sure the menu fits inside the screen
		if (this.canvas && this.menuBox.getHeight() >= (this.canvas.getHeight() - 1)) {
			// menu is too big to fit the screen
			top = 0;
			height = (this.canvas.getHeight() - 1) + 'px';
		} else if (this.canvas.getHeight() < y + this.menuBox.getHeight() + 1) {
			// menu fits the screen, but have to move it higher for that
			var diff = y + this.menuBox.getHeight() - this.canvas.getHeight() + 1;
			var position = (y - diff);
			if (position < 0) {
				top = 0;
				height = (this.canvas.getHeight() - 1) + 'px';
			} else {
				top = position + 'px';
				height = '';
			}
		} else {
			top = y + 'px';
			height = '';
		}

		this.menuBox.style.top = top;
		this.menuBox.style.height = height;
		this.menuBox.style.overflow = 'auto';
	},

	_clearCrtData: function () {
		var _this = this;
		Object.keys(this.fieldMap).each(function (name) {
			_this.fieldMap[name].crtValue = _this.fieldMap[name]["default"];
			_this._setFieldValue[_this.fieldMap[name].type].call(_this, _this.fieldMap[name].element, _this.fieldMap[name].crtValue);
			_this.fieldMap[name].inactive = false;
		});
	},

	_setCrtData: function (data) {
		var _this = this;
		Object.keys(this.fieldMap).each(function (name) {
			//Added for GEL(GenomicsEngland)............................................................................
			//if type is a label(newly added type for GEL), then do not process any event or value for that
			if(_this.fieldMap[name].type == "label"){
				if(data[name]){
					//find if the label should be hidden/shown, use inactive field for that
					//as we use 'inactive' field, then in Person.getSummary, we fill it with true/false
					//in case of 'age_of_death_guide', we need to hide it if person status is one of these ['unborn', 'aborted', 'miscarriage', 'stillborn'] or actually this.isFetus() == true
					_this.fieldMap[name].inactive = (data && data[name] && (typeof(data[name].inactive) == 'boolean' || typeof(data[name].inactive) == 'object')) ? data[name].inactive : _this.fieldMap[name].inactive;
					_this._setFieldInactive[_this.fieldMap[name].type].call(_this, _this.fieldMap[name].element, _this.fieldMap[name].inactive);
				}
				return;
			}
			//..........................................................................................................
			_this.fieldMap[name].crtValue = data && data[name] && typeof(data[name].value) != "undefined" ? data[name].value : _this.fieldMap[name].crtValue || _this.fieldMap[name]["default"];
			_this.fieldMap[name].inactive = (data && data[name] && (typeof(data[name].inactive) == 'boolean' || typeof(data[name].inactive) == 'object')) ? data[name].inactive : _this.fieldMap[name].inactive;
			_this.fieldMap[name].disabled = (data && data[name] && (typeof(data[name].disabled) == 'boolean' || typeof(data[name].disabled) == 'object')) ? data[name].disabled : _this.fieldMap[name].disabled;
			_this._setFieldValue[_this.fieldMap[name].type].call(_this, _this.fieldMap[name].element, _this.fieldMap[name].crtValue);
			_this._setFieldInactive[_this.fieldMap[name].type].call(_this, _this.fieldMap[name].element, _this.fieldMap[name].inactive);
			_this._setFieldDisabled[_this.fieldMap[name].type].call(_this, _this.fieldMap[name].element, _this.fieldMap[name].disabled);
			//_this._updatedDependency(_this.fieldMap[name].element, _this.fieldMap[name].element);
		});
	},

	_setFieldValue: {
		'radio': function (container, value) {
			var target = container.down('input[type=radio][value=' + value + ']');
			if (target) {
				target.checked = true;
			}
		},
		'checkbox': function (container, value) {
			var checkbox = container.down('input[type=checkbox]');
			if (checkbox) {
				checkbox.checked = value;
			}
		},
		'text': function (container, value) {
			var target = container.down('input[type=text]');
			if (target) {
				target.value = value;
			}
			this._restoreCursorPositionIfNecessary(target);
		},
		//Added for GEL(GenomicsEngland).......................................................................................
		//This will create a new type known as 'label' where it can be used as a simple text in the UI like age_of_death_guide
		'label': function (container, value) {

		},
		'textarea': function (container, value) {
			var target = container.down('textarea');
			if (target) {
				target.value = value;
			}
			this._restoreCursorPositionIfNecessary(target);
		},
		'date-picker': function (container, value) {
			if (!value) {
				value = {"decade": "", "year": "", "month": "", "day": ""};
			}

			var year = "";
			var month = "";
			var day = "";
			// there is no separate "decade" selector, need to handle the case of decade only separately
			if (value.decade && !value.year) {
				year = value.decade;
			} else {
				if (value.year) {
					year = value.year.toString();
				}
			}

			var dateEditFormat = editor.getPreferencesManager().getConfigurationOption("dateEditFormat");
			var dmyInputMode = (dateEditFormat == "DMY" || dateEditFormat == "MY");
			if ((dmyInputMode || value.year) && value.month) {
				month = value.month.toString();
			}
			if ((dmyInputMode || (value.year && value.month)) && value.day) {
				day = value.day.toString();
			}

			var updated = false;
			var yearSelect = container.down('select.year');
			if (yearSelect) {
				var option = yearSelect.down('option[value=' + year + ']');
				if (!option) {
					option = new Element("option", {"value": year}).update(year.toString());
					yearSelect.insert(option);
				}
				if (option && !option.selected) {
					option.selected = true;
					updated = true;
				}
			}
			var monthSelect = container.down('select.month');
			if (monthSelect) {
				var option = monthSelect.down('option[value=' + month + ']');
				if (option && !option.selected) {
					option.selected = true;
					updated = true;
				}
			}
			var daySelect = container.down('select.day');
			if (daySelect) {
				var option = daySelect.down('option[value=' + day + ']');
				if (option && !option.selected) {
					option.selected = true;
					updated = true;
				}
			}
			// TODO: replace the code above with an even request to change year-month-date
			if (updated) {
				var updateElement = container.down('.fuzzy-date-picker');
				if (updateElement) {
					Event.fire(updateElement, 'datepicker:date:changed');
				}
			}
		},
		'disease-picker': function (container, values) {
			var _this = this;
			var target = container.down('input[type=text].suggest-omim');
			if (target && target._suggestPicker) {
				target._silent = true;
				target._suggestPicker.clearAcceptedList();
				if (values) {
					values.each(function (v) {
						//v.valueAll is passed for GEL..........................................................
						target._suggestPicker.addItem(v.id, v.value, '', null, v.valueAll);
						_this._updateDisorderColor(v.id, editor.getDisorderLegend().getObjectColor(v.id));
						//......................................................................................
					})
				}
				target._silent = false;
			}
		},
		'ethnicity-picker': function (container, values) {
			var _this = this;
			var target = container.down('input[type=text].suggest-ethnicity');
			if (target && target._suggestPicker) {
				target._silent = true;
				target._suggestPicker.clearAcceptedList();
				if (values) {
					values.each(function (v) {
						target._suggestPicker.addItem(v, v, '');
					})
				}
				target._silent = false;
			}
		},
		'hpo-picker': function (container, values) {
			//console.log("begin hpo-picker", container, values)
			var _this = this;
			var target = container.down('input[type=text].suggest-hpo');
			//console.log("tgtg",target)
			if (target && target._suggestPicker) {
				target._silent = true;
                target._suggestPicker.clearAcceptedList();

                var targetModifier = container.down('input[type=text].suggest-hpo-modifier');
               // console.log(targetModifier)
               /* if (targetModifier && targetModifier._suggestPicker) {
                    targetModifier._suggestPicker.clearAcceptedList();
                    var target = hpoModifierItem
                    if (target ){
                        if (values[0].valueAll.hpoModifiers) {
                            valueAll.hpoModifiers.each(function (v) {
                                console.log("VV",v);
                                targetModifier._suggestPicker.addItem(v.code, v.display, '', null, v.valueAll);
                            })
                        }
                }*/
				if (values) {
					values.each(function (v) {
						//console.log("AZAV",v,v.valueAll);
						//v.valueAll is passed for GEL........................................
						target._suggestPicker.addItem(v.id, v.value, '', null, v.valueAll);
						//....................................................................
					})
				}
				target._silent = false;
			}


		},
        'hpo-modifier-picker': function (container, values) {
		//	console.log("begin hpo-modifier-picker",container, values, "also clears accepted list")
            var _this = this;
            var target = container.down('input[type=text].suggest-hpo-modifier');
            if (target && target._suggestPicker) {
                target._silent = true;
                target._suggestPicker.clearAcceptedList();
               // console.log("xaaaz",values);
                if (values) {
                    values.each(function (v) {
                        //v.valueAll is passed for GEL........................................
                        target._suggestPicker.addItem(v.id, v.value, '', null, v.valueAll);
                        //....................................................................
                    })
                }
                target._silent = false;
            }
        },
		'gene-picker': function (container, values) {
			var _this = this;
			var target = container.down('input[type=text].suggest-genes');
			if (target && target._suggestPicker) {
				target._silent = true;
				target._suggestPicker.clearAcceptedList();
				if (values) {
					values.each(function (v) {
						target._suggestPicker.addItem(v, v, '');
						_this._updateGeneColor(v, editor.getGeneLegend().getObjectColor(v));
					})
				}
				target._silent = false;
			}
		},
		'phenotipsid-picker': function (container, values) {
			var _this = this;
			var target = container.down('input[type=text].suggest-genes');
			if (target && target._suggestPicker) {
				target._silent = true;
				target._suggestPicker.clearAcceptedList();
				if (values) {
					values.each(function (v) {
						target._suggestPicker.addItem(v, v, '');
					})
				}
				target._silent = false;
			}
		},
		'select': function (container, value) {
			//added by Soheil for GEL(GenomicsEngland) .................................................................
			//check if the element is a 'multiple' element and then mark all of the selected options
			//else if it is not a 'multiple' element, then just set one option
			if(container.down('select').multiple == undefined || container.down('select').multiple == false){
				var target = container.down('select option[value=' + value + ']');
				if (target) {
					target.selected = 'selected';
				}
			}else{
				//guard against value being null preventing context menu from loading
				if (!(value && value.length)){
				    return;
				}
				for(var i = 0; i < value.length ; i++){
					var target = container.down('select option[value=' + value[i] + ']');
					if (target) {
						target.selected = 'selected';
					}
				}
			}
			//..........................................................................................................

		},
		'cancerlist': function (container, value) {
			var cancerList = editor.getCancerLegend()._getAllSupportedCancers();

			for (var i = 0; i < cancerList.length; i++) {
				var cancerName = cancerList[i];

				var statusSelect = container.down('select[id="cancer_status_' + cancerName + '"]');
				var ageSelect = container.down('select[id="cancer_age_' + cancerName + '"]');
				var notesInput = container.down('"#cancer_notes_' + cancerName + '"');
				var enableNotesIcon = container.down("label[for=" + notesInput.id + "]");

				if (!statusSelect) {
					// unsupported cancer?
					alert("This patient is reported to have an unsupported cancer '" + cancerName + "'");
					continue;
				}

				if (value.hasOwnProperty(cancerName)) {
					if (value[cancerName].hasOwnProperty("Affected") && value[cancerName].affected) {
						var optionStatus = statusSelect.down('option[value="Affected"]');
					} else {
						var optionStatus = statusSelect.down('option[value="Unaffected"]');
					}

					if (value[cancerName].hasOwnProperty("ageAtDiagnosis")) {
						var ageOption = ageSelect.down('option[value="' + value[cancerName].ageAtDiagnosis + '"]');
					} else {
						var ageOption = ageSelect.down('option[value=""]');
					}

					if (value[cancerName].hasOwnProperty("notes") && value[cancerName].notes != "") {
						notesInput.value = value[cancerName].notes;
						notesInput.show();
						notesInput.disabled = false;
						enableNotesIcon.hide();
					} else if (value[cancerName].hasOwnProperty("notes") && value[cancerName].notes == "") {
						//In case the notes were blank but the cancer was selected, the enableNotes function must be called to add toggle behaviour
						enableNotesIcon.enableNotes();
					} else {
						notesInput.hide();
						notesInput.disabled = true;
						enableNotesIcon.show();
						enableNotesIcon.removeClassName('disabled');
					}

					ageSelect.enable();
				} else {
					var optionStatus = statusSelect.down('option[value=""]');

					var ageOption = ageSelect.down('option[value=""]');

					ageSelect.disable();

					notesInput.value = "";
					notesInput.hide();
					notesInput.disabled = true;
					if (enableNotesIcon) {
						enableNotesIcon.disableNotes();
					}
					;
				}
				if (optionStatus) {
					optionStatus.selected = 'selected';
				}
				if (ageOption) {
					ageOption.selected = 'selected';
				}
			}
		},
		'hidden': function (container, value) {
			var target = container.down('input[type=hidden]');
			if (target) {
				target.value = value;
			}
		}
	},

	_toggleFieldVisibility: function (container, doHide) {
		if (doHide) {
			container.addClassName('hidden');
		} else {
			container.removeClassName('hidden');
		}
	},

	_setFieldInactive: {
		//Added for GEL(GenomicsEngland) to support hide/show for 'label' type ..............
		'label': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		//....................................................................................
		'radio': function (container, inactive) {
			if (inactive === true) {
				container.addClassName('hidden');
			} else {
				container.removeClassName('hidden');
				container.select('input[type=radio]').each(function (item) {
					if (inactive && Object.prototype.toString.call(inactive) === '[object Array]') {
						var disableViaOpacity = (inactive.indexOf("disableViaOpacity") >= 0);
						if (inactive.indexOf(item.value) >= 0) {
							item.disable();
							if (disableViaOpacity) {
								Element.setOpacity(item.up(), 0);
							} else {
								item.up().addClassName('hidden');
							}
						}
						else {
							item.enable();
							if (disableViaOpacity) {
								Element.setOpacity(item.up(), 1);
							} else {
								item.up().removeClassName('hidden');
							}
						}
					} else if (!inactive) {
						item.enable();
						Element.setOpacity(item.up(), 1);
						item.up().removeClassName('hidden');
					}
				});
			}
		},
		'checkbox': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'text': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'textarea': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'date-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'disease-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'ethnicity-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'hpo-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
        'hpo-modifier-picker': function (container, inactive) {
            this._toggleFieldVisibility(container, inactive);
        },
		'gene-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'phenotipsid-picker': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'select': function (container, inactive) {
			if (inactive === true) {
				container.addClassName('hidden');
			} else {
				container.removeClassName('hidden');
				container.select('option').each(function (item) {
					if (inactive && Object.prototype.toString.call(inactive) === '[object Array]') {
						if (inactive.indexOf(item.value) >= 0)
							item.addClassName('hidden');
						else
							item.removeClassName('hidden');
					} else if (!inactive) {
						item.removeClassName('hidden');
					}
				});
			}
		},
		'cancerlist': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		},
		'hidden': function (container, inactive) {
			this._toggleFieldVisibility(container, inactive);
		}
	},

	_setFieldDisabled: {
		'radio': function (container, disabled) {
			if (disabled) {
				if (Object.prototype.toString.call(disabled) === '[object Array]') {
					container.select('input[type=radio]').each(function (item) {
						item.disabled = (disabled.indexOf(item.value) >= 0);
					});
				} else if (disabled === true || disabled === false) {
					container.select('input[type=radio]').each(function (item) {
						item.disabled = disabled;
					});
				}
			}
		},
		'checkbox': function (container, disabled) {
			var target = container.down('input[type=checkbox]');
			if (target) {
				target.disabled = disabled;
			}
		},
		'text': function (container, disabled) {
			var target = container.down('input[type=text]');
			if (target) {
				target.disabled = disabled;
			}
		},
		//Added for GEL(GenomicsEngland).......................................................................................
		//This will create a new type known as 'label' where it can be used as a simple text in the UI like age_of_death_guide
		'label': function (container, disabled) {
			
		},
		'textarea': function (container, inactive) {
			//console.log('container', container)
			//console.log(container.down("textarea"))
            var target = container.down('textarea');
            if (target) {
                target.disabled = inactive;
            }
		},
		'date-picker': function (container, disabled) {
			Element.select(container, 'select').forEach(function (element) {
				if (disabled) {
					// IE9 & IE10 do not support "pointer-events:none" (and IE11 does not seem to support this for <select>)
					// so add some JS to prevent clicks on disabled select
					Helpers.disableMouseclicks(element);
					element.addClassName('disabled-select');
					element.addClassName('no-mouse-interaction');
				} else {
					// emove IE-specific workaround handler
					Helpers.enableMouseclicks(element);
					element.removeClassName('disabled-select');
					element.removeClassName('no-mouse-interaction');
				}
			});
		},
		'disease-picker': function (container, disabled) {
			this.__disableEnableSuggestModification(container, disabled);
		},
		'ethnicity-picker': function (container, disabled) {
            this.__disableEnableSuggestModification(container, disabled);
		},
		'hpo-picker': function (container, disabled) {
			this.__disableEnableSuggestModification(container, disabled);
		},
        'hpo-modifier-picker': function (container, disabled) {
            this.__disableEnableSuggestModification(container, disabled);
        },
		'gene-picker': function (container, disabled) {
			this.__disableEnableSuggestModification(container, disabled);
		},
		'phenotipsid-picker': function (container, inactive) {
			// FIXME: Not implemented
		},
		'select': function (container, inactive) {
			//Added for GEL(GenomicsEngland) .........................................................
			Element.select(container, 'select').forEach(function (element) {
				if (inactive) {
					// IE9 & IE10 do not support "pointer-events:none" (and IE11 does not seem to support this for <select>)
					// so add some JS to prevent clicks on disabled select
					Helpers.disableMouseclicks(element);
					element.addClassName('disabled-select');
					element.addClassName('no-mouse-interaction');
				} else {
					// emove IE-specific workaround handler
					Helpers.enableMouseclicks(element);
					element.removeClassName('disabled-select');
					element.removeClassName('no-mouse-interaction');
				}
			});
			//..........................................................................................
		},
		'cancerlist': function (container, inactive) {
			// FIXME: Not implemented
		},
		'hidden': function (container, inactive) {
			// FIXME: Not implemented
		}
	},

	// Either enables a suggest picker, or disables/hides all input fields while leaving
	// the list of current selections visible, with "delete" tool disabled
	__disableEnableSuggestModification: function (container, disabled) {
		var numElements = 0;
		Element.select(container, '.delete-tool').forEach(function (element) {
			numElements++;
			if (disabled) {
				element.addClassName('hidden');
			} else {
				element.removeClassName('hidden');
			}
		});
		Element.select(container, 'input').forEach(function (element) {
			element.disabled = disabled;
			if (disabled) {
				if (numElements > 1) {  // 1 for delete all; if there is more than one no need to display empty input box
					// if there are selections show the list of selections and hide the input field completely
					element.addClassName('hidden');
				} else {
					// if there are no selections show "none" in the (disabled) input field
					element.placeholder = "none";
				}
			} else {
				element.removeClassName('hidden');
				element.placeholder = "";
			}
		});
	}
});

/**
 * The UI element ("bubble") that contains options for the creation of a new node.
 *
 * @class NodetypeSelectionBubble
 * @constructor
 */
var NodetypeSelectionBubble = Class.create({

	//The skeleton for the bubble contents
	buttonsDefs: [
		{
			key: "M",
			type: "person",
			label: "Male",
			tip: "Create a person of male gender",
			symbol: "<span></span>",
			cssclass: "square",
			callback: "CreateChild",
			params: { parameters: {"gender": "M"} },
			inSiblingMode: true
		},
		{
			key: "F",
			type: "person",
			label: "Female",
			tip: "Create a person of female gender",
			symbol: "<span></span>",
			cssclass: "circle",
			callback: "CreateChild",
			params: { parameters: {"gender": "F"} },
			inSiblingMode: true
		},
		{
			key: "O",
			type: "person",
			label: "Other",
			tip: "Create a person of indeterminate gender",
			symbol: "<span></span>",
			cssclass: "diamond",
			callback: "CreateChild",
			params: { parameters: {"gender": "O"} },
			inSiblingMode: true
		},
		{
			key: "U",
			type: "person",
			label: "Unknown",
			tip: "Create a person of unknown gender",
			symbol: "<span></span>",
			cssclass: "diamond",
			callback: "CreateChild",
			params: { parameters: {"gender": "U"} },
			inSiblingMode: true
		},
		{
			key: "P",
			type: "person",
			label: "Pregnancy",
			tip: "Create a pregnancy",
			symbol: "<span></span><strong>P</strong>",
			cssclass: "diamond text-in-middle",
			callback: "CreateChild",
			params: { "parameters": {"lifeStatus": "Unborn"} },
			inSiblingMode: true
		},
		{
			key: "T",
			type: "person",
			label: "Twins",
			tip: "Create twins (expandable to triplets or more)",
			symbol: '&#8896;',//\u22C0',
			cssclass: "",
			callback: "CreateChild",
			params: { "twins": true, "parameters": {"gender": "U"} },
			expandsTo: 'expandTwins',
			inSiblingMode: true
		},
		{
			key: "m",
			type: "person",
			label: "Multiple",
			tip: "Create a node representing multiple siblings",
			symbol: "<span></span><strong>n</strong>",
			cssclass: "diamond text-in-middle",
			callback: "CreateChild",
			params: { "group": true },
			expandsTo: "expandPersonGroup",
			inSiblingMode: true
		},
		{
			type: "separator"
		},
		{
			key: "n",
			type: "marker",
			label: "No children",
			tip: "Mark as Childless by choice",
			symbol: "&#9524;",//\u2534",
			cssclass: "",
			callback: "setProperty",
			params: { setChildlessStatus: "Childless" },
			inSiblingMode: false
		},
		{
			key: "i",
			type: "marker",
			label: "Infertile",
			tip: "Mark as Infertile",
			symbol: "&#9575;",//\u2567",
			cssclass: "",
			callback: "setProperty",
			params: { setChildlessStatus: "Infertile" },
			inSiblingMode: false
		}
	],

	initialize: function (siblingMode) {
		this._siblingMode = siblingMode;

		this.element = new Element('div', {'class': 'callout'});
		this.element.insert(new Element('span', {'class': 'callout-handle'}));

		var container = new Element('div', {'class': 'node-type-options field-no-user-select'});
		this.expandedOptionsContainer = new Element('div', {'class': 'node-type-options-extended field-no-user-select'});
		this.element.insert(container);
		this.element.insert(this.expandedOptionsContainer);

		var _this = this;
		this.buttonsDefs.each(function (def) {
			if (!siblingMode || (def.hasOwnProperty("inSiblingMode") && def.inSiblingMode))
				container.insert(def.type == 'separator' ? _this._generateSeparator() : _this._createOption(def));
		});
		this.element.hide();
		editor.getWorkspace().getWorkArea().insert(this.element);

		this._onClickOutside = this._onClickOutside.bindAsEventListener(this);

		this.resetParameters();
	},

	resetParameters: function () {
		this.numPersonsInGroup = 1;
		this.numTwinNodes = 2;
	},

	/**
	 * Creates a button in the bubble corresponding do the definition from the skeleton
	 *
	 * @method _createOption
	 * @param data The definition object from the bubble skeleton
	 * @return {HTMLElement} The span containing the button
	 * @private
	 */
	_createOption: function (data) {
		var i = 1;
		if (!data) {
			return null;
		}
		var expandablePrefix = (typeof this[data.expandsTo] == "function") ? "expandable-" : "";
		var o = new Element('a', {
			'class': data.cssclass + ' ' + expandablePrefix + 'node-type-option ' + (data.type || '') + '-type-option node-type-' + data.key,
			'title': data.tip,
			'href': '#'
		}).update(data.symbol);
		var _this = this;
		o.observe('click', function (event) {
			event.stop();
			if (!_this._node) return;
			console.log("observe nodetype click: " + data.callback);
			if (data.callback == "setProperty") {
				var event = { "nodeID": _this._node.getID(), "properties": data.params };
				document.fire("pedigree:node:setproperty", event);
			}
			else if (data.callback == "CreateChild") {
				_this.handleCreateAction(data);
			}
			_this.hide();
		});
		var container = new Element("span");
		container.insert(o);
		expandablePrefix && container.insert(this.generateExpandArrow(data));
		return container;
	},

	handleCreateAction: function (data) {
		var id = this._node.getID();
		var nodeType = this._node.getType();
		if (nodeType == "Person") {
			var event = { "personID": id, "childParams": data.params.parameters, "preferLeft": false };
			if (data.params.twins) {
				event["twins"] = this.numTwinNodes;
			}
			if (data.params.group) {
				event["groupSize"] = this.numPersonsInGroup;
			}

			if (this._siblingMode)
				document.fire("pedigree:person:newsibling", event);
			else
				document.fire("pedigree:person:newpartnerandchild", event);
		}
		else if (nodeType == "Partnership") {
			var event = { "partnershipID": id, "childParams": data.params.parameters };
			if (data.params.twins) {
				event["twins"] = this.numTwinNodes;
			}
			if (data.params.group) {
				event["groupSize"] = this.numPersonsInGroup;
			}
			document.fire("pedigree:partnership:newchild", event);
		}
		this.hide();
	},

	/**
	 * Creates an arrow button that expands or shrinks the bubble
	 *
	 * @method generateExpandArrow
	 * @param data The definition object from the bubble skeleton
	 * @return {HTMLElement} The span containing the button
	 */
	generateExpandArrow: function (data) {
		var expandArrow = new Element('span', {
			'class': 'expand-arrow collapsed',
			'title': "show more options",
			'href': '#'
		}).update('&#9662;');//\u25BE');
			//.update("▾");

		expandArrow.expand = function () {
			$$(".expand-arrow").forEach(function (arrow) {
				arrow.collapse()
			});
			this[data.expandsTo](data);
			expandArrow.update('&#9652;');//\u25B4');
			Element.removeClassName(expandArrow, "collapsed");
		}.bind(this);

		expandArrow.collapse = function () {
			this.expandedOptionsContainer.update("");
			expandArrow.update('&#9662;');//\u25BE');
			Element.addClassName(expandArrow, "collapsed");
		}.bind(this);

		expandArrow.observe("click", function () {
			console.log("observe2");
			if (expandArrow.hasClassName("collapsed")) {
				expandArrow.expand();
			}
			else {
				expandArrow.collapse();
			}
		});
		return expandArrow;
	},

	/**
	 * Creates a line to separate buttons in the bubble
	 *
	 * @method _generateSeparator
	 * @return {HTMLElement}
	 * @private
	 */
	_generateSeparator: function () {
		return new Element('span', {'class': 'separator'}).update(' | ');
	},

	/**
	 * Repositions the bubble to the given coordinates coordinates
	 *
	 * @method _positionAt
	 * @param {Number} x The x coordinate in the viewport
	 * @param {Number} y The y coordinate in the viewport
	 * @private
	 */
	_positionAt: function (x, y) {
		y = Math.round(y);
		if (y + this.element.getHeight() > editor.getWorkspace().getWorkArea().getHeight()) {
			this.element.addClassName("upside");
			y = Math.round(y - this.element.getHeight());
		}
		this.element.style.top = y + "px";
		var dx = Math.round(this.element.getWidth() / 2);
		if (x - dx + this.element.getWidth() > editor.getWorkspace().getWorkArea().getWidth()) {
			dx = Math.round(this.element.getWidth() - (editor.getWorkspace().getWorkArea().getWidth() - x));
		} else if (dx > x) {
			dx = Math.round(x);
		}
		this.element.down('.callout-handle').style.left = dx + "px";
		this.element.style.left = Math.round(x - dx) + "px";
	},

	/**
	 * Displays the bubble for the specified node
	 *
	 * @method show
	 * @param {AbstractNode} node The node for which the bubble is displayed
	 * @param {Number} x The x coordinate in the viewport
	 * @param {Number} y The y coordinate in the viewport
	 */
	show: function (node, x, y) {
		this._node = node;
		if (!this._node) return;
		//console.log("show widget");
		this._node.onWidgetShow();

		// TODO decide which options to display, depending on the source node's status
        // If node is Proband, hide 'mark as childless' and 'mark as infertile' since
        // 1. Proband data is solely based on genomic record
        // 2. Setting it will only get it overridden by genomic record
        // 3. Proband is readonly in pedigree

		if (this._node._isProband || this._node._ngisRegisteredPatientUid){
		    this.element.select('.node-type-n').invoke('hide');
		    this.element.select('.node-type-i').invoke('hide');
		}
		else{
		    this.element.select('.node-type-n').invoke('show');
            this.element.select('.node-type-i').invoke('show');
		}

		if (this._node._type == "Partnership" && this._node._childlessStatus == "Childless"){
		    this.element.select('.node-type-T').invoke('hide');
            this.element.select('.node-type-m').invoke('hide');
            this.element.select('.node-type-n').invoke('hide');
             this.element.select('.node-type-i').invoke('hide');
        }else{
            this.element.select('.node-type-T').invoke('show');
            this.element.select('.node-type-m').invoke('show');
            this.element.select('.node-type-n').invoke('show');
            this.element.select('.node-type-i').invoke('show');
        }

		this.element.show();
		this.expandedOptionsContainer.update("");
		this._positionAt(x, y);
		document.observe('mousedown', this._onClickOutside);
	},

	/**
	 * Hides the bubble from the viewport
	 *
	 * @method hide
	 */
	hide: function () {
		//console.log("hide1");
		document.stopObserving('mousedown', this._onClickOutside);
		$$(".expand-arrow").forEach(function (arrow) {
			arrow.collapse();
		});
		if (this._node) {
			this._node.onWidgetHide();
			delete this._node;
			// reset the state
			this.element.select('.node-type-option').invoke('show');
			this.element.removeClassName("upside");
		}
		this.element.hide();
		this.resetParameters();  // reset number of twins/number of persons
	},

	/**
	 * Hides the bubble if the user clicks outside
	 *
	 * @method _onClickOutside
	 * @param {Event} event
	 * @private
	 */
	_onClickOutside: function (event) {
		//console.log("observe clickoutside nodetype");
		if (!event.findElement('.callout')) {
			this.hide();
		}
	},

	/**
	 * Decrement the number of nodes to be created
	 *
	 * @method _decrementNumNodes
	 * @return {Number} The resulting number of nodes to be created
	 * @private
	 */
	_decrementNumNodes: function () {
		return this.numPersonsInGroup > 1 ? --this.numPersonsInGroup : this.numPersonsInGroup;
	},

	/**
	 * Increment the number of nodes to be created
	 *
	 * @method _incrementNumNodes
	 * @return {Number} The resulting number of nodes to be created
	 * @private
	 */
	_incrementNumNodes: function () {
		return this.numPersonsInGroup < 9 ? ++this.numPersonsInGroup : this.numPersonsInGroup;
	},

	/**
	 * Decrement the number of twins to be created
	 *
	 * @method _decrementNumTwins
	 * @return {Number} The resulting number of twins to be created
	 * @private
	 */
	_decrementNumTwins: function () {
		return this.numTwinNodes > 2 ? --this.numTwinNodes : this.numTwinNodes;
	},

	/**
	 * Increment the number of twins to be created
	 *
	 * @method _incrementNumTwins
	 * @return {Number} The resulting number of twins to be created
	 * @private
	 */
	_incrementNumTwins: function () {
		return this.numTwinNodes < 9 ? ++this.numTwinNodes : this.numTwinNodes;
	},

	/**
	 * Expand the bubble and show additional options for creation of PersonGroup nodes
	 *
	 * @method expandPersonGroup
	 */
	expandPersonGroup: function (personGroupMenuInfo) {
		//create rhombus icon
		// put counter on top of rhombus
		//add plus minus buttons on the sides
		//add ok button
		//var icon = '<svg <desc>Number of children</desc><text x="250" y="150" font-family="Verdana" font-size="12" fill="blue" >n</text></svg>';
		var me = this;
		var generateIcon = function () {
			var iconText = (me.numPersonsInGroup > 1) ? String(me.numPersonsInGroup) : "n";
			return '<svg version="1.1" viewBox="0.0 0.0 100.0 100.0" width=50 height=50 fill="none" stroke="none" stroke-linecap="square" stroke-miterlimit="10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><clipPath id="p.0"><path d="m0 0l960.0 0l0 720.0l-960.0 0l0 -720.0z" clip-rule="nonzero"></path></clipPath><g clip-path="url(#p.0)"><path fill="#000000" fill-opacity="0.0" d="m0 0l960.0 0l0 720.0l-960.0 0z" fill-rule="nonzero"></path><path fill="#cfe2f3" d="m1.2283465 49.97113l48.53543 -48.535435l48.53543 48.535435l-48.53543 48.53543z" fill-rule="nonzero"></path><path stroke="#000000" stroke-width="2.0" stroke-linejoin="round" stroke-linecap="butt" d="m1.2283465 49.97113l48.53543 -48.535435l48.53543 48.535435l-48.53543 48.53543z" fill-rule="nonzero"></path><path fill="#000000" fill-opacity="0.0" d="m20.661417 22.068241l58.204727 0l0 48.000004l-58.204727 0z" fill-rule="nonzero"></path></g><desc>Number of children</desc><text x="35" y="60" font-family="Verdana" font-size="40" fill="black">'
				+ iconText + '</text></svg>';

		};
		var createBtn = new Element("input", {'type': 'button', 'value': 'create', 'class': 'button'});
		var svgContainer = new Element('span').update(generateIcon());
		var minusBtn = new Element("span", {
			"class": 'minus-button value-control-button'
		}).update("-");
		var plusBtn = new Element("span", {
			"class": 'plus-button value-control-button'
		}).update("+");
		minusBtn.observe("click", function () {
			me._decrementNumNodes();
			svgContainer.update(generateIcon())
		});
		plusBtn.observe("click", function () {
			me._incrementNumNodes();
			svgContainer.update(generateIcon())
		});
		createBtn.observe("click", function () {
			//console.log("observeCreate1");
			me.handleCreateAction(personGroupMenuInfo);
		});
		this.expandedOptionsContainer.insert(minusBtn);
		this.expandedOptionsContainer.insert(svgContainer);
		this.expandedOptionsContainer.insert(plusBtn);
		this.expandedOptionsContainer.insert(createBtn);
	},

	/**
	 * Expand the bubble and show additional options for creation of twin nodes
	 *
	 * @method expandTwins
	 */
	expandTwins: function (twinMenuInfo) {
		var me = this;
		var generateIcon = function () {
			var oneTwinMode = me._siblingMode && (me._node.getType() != "Partnership");
			var displayNumber = oneTwinMode ? (me.numTwinNodes - 1) : me.numTwinNodes;
			return '<svg version="1.1" viewBox="0.0 0.0 100.0 100.0" width=50 height=50 fill="none" stroke="none" stroke-linecap="square" stroke-miterlimit="10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><clipPath id="p.0"><path d="m0 0l960.0 0l0 720.0l-960.0 0l0 -720.0z" clip-rule="nonzero"></path></clipPath><g clip-path="url(#p.0)"><path fill="#000000" fill-opacity="0.0" d="m0 0l960.0 0l0 720.0l-960.0 0z" fill-rule="nonzero"></path><path fill="#cfe2f3" d="m1.2283465 49.97113l48.53543 -48.535435l48.53543 48.535435l-48.53543 48.53543z" fill-rule="nonzero"></path><path stroke="#000000" stroke-width="2.0" stroke-linejoin="round" stroke-linecap="butt" d="m1.2283465 49.97113l48.53543 -48.535435l48.53543 48.535435l-48.53543 48.53543z" fill-rule="nonzero"></path><path fill="#000000" fill-opacity="0.0" d="m20.661417 22.068241l58.204727 0l0 48.000004l-58.204727 0z" fill-rule="nonzero"></path></g><desc>Number of children</desc><text x="35" y="60" font-family="Verdana" font-size="40" fill="black">'
				+ displayNumber + '</text></svg>';
		};
		if (this._siblingMode) {
			var createBtn = new Element("input", {'type': 'button', 'value': 'add twins', 'class': 'button'});
		} else {
			var createBtn = new Element("input", {'type': 'button', 'value': 'create twins', 'class': 'button'});
		}
		var svgContainer = new Element('span').update(generateIcon());
		var minusBtn = new Element("span", {
			"class": 'minus-button value-control-button'
		}).update("-");
		var plusBtn = new Element("span", {
			"class": 'plus-button value-control-button'
		}).update("+");
		minusBtn.observe("click", function () {
			me._decrementNumTwins();
			svgContainer.update(generateIcon())
		});
		plusBtn.observe("click", function () {
			me._incrementNumTwins();
			svgContainer.update(generateIcon())
		});
		createBtn.observe("click", function () {
			me.handleCreateAction(twinMenuInfo);
		});
		this.expandedOptionsContainer.insert(minusBtn);
		this.expandedOptionsContainer.insert(svgContainer);
		this.expandedOptionsContainer.insert(plusBtn);
		this.expandedOptionsContainer.insert(createBtn);
	}
});
/**
 * Returns a raphael element representing a Pi-Chart-like slice of the icon representing the given gender
 *
 * @param canvas Raphael paper object
 * @param {Number} xPosition
 * @param {Number} yPosition
 * @param {Number} radius Radius of the associated shape
 * @param {String} gender Can be "M", "F" or "U"
 * @param {Number} startAngle Has to be equal or greater than 0
 * @param {Number} endAngle
 * @param {String} color CSS color
 * @return {Raphael.el}
 */
var GraphicHelpers = {};

GraphicHelpers.sector = function (canvas, xPosition, yPosition, radius, gender, startAngle, endAngle, color) {
	var sectorPath,
		gen = gender,
		cx = xPosition,
		cy = yPosition,
		r = radius,
		paper = canvas,
		rad = Math.PI / 180,
		shapeAttributes = {fill: color, 'stroke-width': .0 };

	//returns coordinates of the point on the circle (with radius = _radius) at angle alpha
	var circleCoordinate = function (alpha) {
		var x = cx + r * Math.cos(-alpha * rad),
			y = cy + r * Math.sin(-alpha * rad);
		return [x, y];
	};

	if (gen === 'F') {
		if (endAngle - startAngle == 360) {
			return paper.circle(cx, cy, r).attr(shapeAttributes);
		}
		var x1 = circleCoordinate(startAngle)[0],
			x2 = circleCoordinate(endAngle)[0],
			y1 = circleCoordinate(startAngle)[1],
			y2 = circleCoordinate(endAngle)[1];

		return paper.path(["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"]).attr(shapeAttributes);
	}
	else if (gen === 'M') {
		//returns the side of the square on which the coordinate exists. Sides are numbered 0-3 counter-clockwise,
		//starting with the right side
		function sideAtAngle(angle) {
			return (((angle + 45) / 90).floor()) % 4;
		}

		//returns the tangent value of the parameter degrees
		function tanOfDegrees(degrees) {
			var radians = degrees * Math.PI / 180;
			return Math.tan(radians);
		}

		//returns the coordinate of point at angle alpha on the square
		function getCoord(alpha) {
			var side = sideAtAngle(alpha);
			var result = {};
			var xFactor = (side % 2);
			var yFactor = (1 - side % 2);
			var sideFactor = side % 3 ? -1 : 1;

			result.angle = (alpha - side * 90 - ((side == 0 && alpha > 45) ? 360 : 0)) * (side < 2 ? -1 : 1);
			// Find the distance from the middle of the line
			var d = r * tanOfDegrees(result.angle);
			// Compute the coordinates
			result.x = cx + xFactor * d + yFactor * sideFactor * r;
			result.y = cy + yFactor * d + xFactor * sideFactor * r;
			return result;
		}

		//returns the coordinate of the next corner (going counter-clockwise, and starting with side given in the
		//parameter
		function getNextCorner(side) {
			var factorA = (side % 3) ? -1 : 1,
				factorB = (side < 2) ? -1 : 1,
				result = {};
			result.x = cx + factorA * r;
			result.y = cy + factorB * r;
			return result;
		}

		var startSide = sideAtAngle(startAngle),
			endSide = sideAtAngle(endAngle);
		if (endSide == 0 && endAngle > startAngle) {
			endSide = (startAngle >= 315) ? 0 : 4;
		}
		var numSides = endSide - startSide;

		var startCoord = getCoord(startAngle),
			endCoord = getCoord(endAngle),
			sectorPathData = ["M", endCoord.x, endCoord.y, "L", cx, cy, "L", startCoord.x, startCoord.y],
			currentSide = startSide;

		while (numSides > 0) {
			sectorPathData.push("L", getNextCorner(currentSide).x + " " + getNextCorner(currentSide).y);
			currentSide = (++currentSide) % 4;
			numSides--;
		}
		sectorPathData.push("L", endCoord.x, endCoord.y, "z");
		return paper.path(sectorPathData).attr(shapeAttributes);
	}
	else {
		var shape = GraphicHelpers.sector(paper, cx, cy, r * (Math.sqrt(3) / 2), "M", startAngle, endAngle, color);
		shape.transform(["...r-45,", cx , cy]).attr(shapeAttributes);
		return shape;
	}
}

/**
 * Creates a 3D looking orb
 *
 * @method generateOrb
 * @param canvas Raphael paper
 * @param {Number} x X coordinate for the orb
 * @param {Number} y Y coordinate for the orb
 * @param {Number} r Radius of the orb
 * @param {Number} hue Hue value between 0 and 1
 * @return {Raphael.st}
 */
GraphicHelpers.generateOrb = function (canvas, x, y, r, gender) {
	if (!gender || gender == 'F') {
		return canvas.set(
			canvas.ellipse(x, y, r, r),
			canvas.ellipse(x, y, r - r / 5, r - r / 20).attr({stroke: "none", fill: "r(.5,.1)#ccc-#ccc", opacity: 0})
		);
	}

	if (gender == "M") {
		var rr = r - 1;
		return canvas.set(
			canvas.rect(x - rr, y - rr, rr * 2, rr * 2, 0),
			canvas.rect(x - rr, y - rr, rr * 2, rr * 2, 1).attr({stroke: "none", fill: "330-#ccc-#ccc", opacity: 0})
		);
	}

	if (gender == "U") {
		var rr = (r - 1) * 0.9;
		return canvas.set(
			canvas.rect(x - rr, y - rr, rr * 2, rr * 2, 0).attr({transform: "r45"}),
			canvas.rect(x - rr, y - rr, rr * 2, rr * 2, 1).attr({stroke: "none", fill: "330-#ccc-#ccc", opacity: 0}).attr({transform: "r45"})
		);
	}
}

/**
 * Draws a quarter-circle-like curve connecting xFrom,Yfrom and xTo,yTo
 * with the given attributes and bend (upwars or downwards)
 *
 * Iff "doubleCurve" is true, cones the curve and shifts one curve by (shiftx1, shifty1) and the other by (shiftx2, shifty2)
 */
GraphicHelpers.drawCornerCurve = function (xFrom, yFrom, xTo, yTo, bendDown, attr, doubleCurve, shiftx1, shifty1, shiftx2, shifty2) {
	var xDistance = xTo - xFrom;
	var yDistance = yFrom - yTo;

	var dist1x = xDistance / 2;
	var dist2x = xDistance / 10;
	var dist1y = yDistance / 2;
	var dist2y = yDistance / 10;

	var curve;

	if (bendDown) {
		var raphaelPath = "M " + (xFrom) + " " + (yFrom) +
			" C " + (xFrom + dist1x) + " " + (yFrom + dist2y) +
			" " + (xTo + dist2x) + " " + (yTo + dist1y) +
			" " + (xTo) + " " + (yTo);
		curve = editor.getPaper().path(raphaelPath).attr(attr).toBack();
	} else {
		var raphaelPath = "M " + (xFrom) + " " + (yFrom) +
			" C " + (xFrom - dist2x) + " " + (yFrom - dist1y) +
			" " + (xTo - dist1x) + " " + (yTo - dist2y) +
			" " + (xTo) + " " + (yTo);
		curve = editor.getPaper().path(raphaelPath).attr(attr).toBack();
	}

	if (doubleCurve) {
		var curve2 = curve.clone().toBack();
		curve.transform("t " + shiftx1 + "," + shifty1 + "...");
		curve2.transform("t " + shiftx2 + "," + shifty2 + "...");
	}
}

GraphicHelpers.drawLevelChangeCurve = function (xFrom, yFrom, xTo, yTo, attr, doubleCurve, shiftx1, shifty1, shiftx2, shifty2) {
	var xDistance = xTo - xFrom;
	var dist1x = xDistance / 2;

	var raphaelPath = " M " + (xFrom) + " " + yFrom;
	raphaelPath += " C " + (xFrom + dist1x) + " " + (yFrom) +
		" " + (xTo - dist1x) + " " + (yTo) +
		" " + (xTo) + " " + (yTo);

	curve = editor.getPaper().path(raphaelPath).attr(attr).toBack();
	if (doubleCurve) {
		var curve2 = curve.clone().toBack();
		curve.transform("t " + shiftx1 + "," + shifty1 + "...");
		curve2.transform("t " + shiftx2 + "," + shifty2 + "...");
	}
}

/**
 * Computes the intersection point between a horizontal line @ y == crossY and a line from x1,y1 to x2,y2
 */
GraphicHelpers.findXInterceptGivenLineAndY = function (crossY, x1, y1, x2, y2) {
	// y = ax + b
	if (x1 == x2) return x1;
	var a = (y1 - y2) / (x1 - x2);
	var b = y1 - a * x1;
	var interceptX = (crossY - b) / a;
	return interceptX;
}

GraphicHelpers.getElementHalfHeight = function (t) {
	return Math.floor(t.getBBox().height / 2);
}

GraphicHelpers.getCaretPosition = function (elem) {
	if (typeof elem.selectionEnd !== "undefined") {
		return elem.selectionEnd;
	} else if (elem.createTextRange && document.selection) {
		var r = document.selection.createRange();
		r.moveStart('character', -elem.value.length);
		return r.text.length;
	} else return null;
}

GraphicHelpers.setCaretPosition = function (ctrl, pos) {
	if (pos == null || pos <= 0) {
		return;
	}
	if (ctrl.setSelectionRange) {
		ctrl.focus();
		ctrl.setSelectionRange(pos, pos);
	}
	else if (ctrl.createTextRange) {
		var range = ctrl.createTextRange();
		range.collapse(true);
		range.moveEnd('character', pos);
		range.moveStart('character', pos);
		range.select();
	}
}

/**
 * Joins all the subsets into one set and returns it.
 * @return {Raphael.st}
 */
Raphael.st.flatten = function () {
	var flattenedSet = new Raphael.st.constructor();
	this.forEach(function (element) {
		flattenedSet = flattenedSet.concat(element.flatten());
	});
	return flattenedSet;
};

/**
 * Returns set containing the given element
 * @return {Raphael.st}
 */
Raphael.el.flatten = function () {
	return this.paper.set(this);
};

/**
 * Returns a set containing the elements of this set and the given set. Doesn't modify the original sets.
 * @param {Raphael.st} set
 * @return {Raphael.st}
 */
Raphael.st.concat = function (set) {
	var newSet = this.copy();
	if (typeof(set.forEach) == 'function') {
		set.forEach(function (element) {
			newSet.push(element);
		});
	}
	else {
		newSet.push(set);
	}
	return newSet;
};

/**
 * Returns True if this set contains target. Target has to be directly in this set, and not in a subset.
 *
 * @param {Raphael.st|Raphael.el} target
 * @return {boolean}
 */
Raphael.st.contains = function (target) {
	var found = false;
	this.forEach(function (element) {
		if (element == target) {
			found = true;
		}
	});
	return found;
};

/**
 * Returns a new set containing the same elements as this set
 * @return {Raphael.st}
 */
Raphael.st.copy = function () {
	var newSet = new Raphael.st.constructor();
	this.forEach(function (element) {
		newSet.push(element);
	});
	return newSet;
};

//Animation helpers
window.requestAnimFrame = (function () {
	return  window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function (callback) {
			window.setTimeout(callback, 1000 / 60);
		};
})();
/**
 * Base class for various "legend" widgets
 *
 * @class Legend
 * @constructor
 */

var Legend = Class.create({

	//initiallyHide: is passed for GEL(GenomicsEngland), if true, it means that the menu in legend box should be hidden initially
	initialize: function (title, allowDrop, initiallyHide) {
		//Added for GEL(GenomicsEngland)
		this._initiallyHide = initiallyHide;

		this._affectedNodes = {};     // for each object: the list of affected person nodes

		this._objectColors = {};       // for each object: the corresponding object color

		this._preferredColors = {};    // in the future we'll have the ability to specify color
		// schemes, e.g. "green" for "that and that cancer", even
		// if that particular cancer is not yet present on the pedigree;
		// also used to assign the same disorder colors after save and load
		this._previousHighightedNode = null;

        var legendContainer = $('legend-container');
        if (legendContainer == undefined) {
			if (!editor.isReadOnlyMode()) {
				this._legendInfo = new Element('div', {'class': 'legend-box legend-info', id: 'legend-info'}).insert(
					new Element('div', {'class': 'infomessage'}).insert(
						"You can drag and drop all items from the list(s) below onto individuals in the pedigree to mark them as affected.")
				);
				this.closeButton = new Element('span', {'class': 'close-button'}).update(' ');
				this.closeButton.observe('click', this.hideDragHint.bindAsEventListener(this));
				this._legendInfo.insert({'top': this.closeButton});
				this._legendInfo.hide();
			}
			var legendContainer = new Element('div', {'class': 'legend-container', 'id': 'legend-container'}).insert(this._legendInfo);
			editor.getWorkspace().getWorkArea().insert(legendContainer);
		} else {
			if (!editor.isReadOnlyMode()) {
				this._legendInfo = legendContainer.down('#legend-info');
			}
		}

		this._legendBox = new Element('div', {'class': 'legend-box', id: this._getPrefix() + '-legend-box'});
		this._legendBox.hide();
		legendContainer.insert(this._legendBox);



		var showMoreIcon = new Element('i',{'class':'fa  rightIcon'});
		if(this._initiallyHide === true){
			showMoreIcon.addClassName("fa-angle-double-down");
		}else{
			showMoreIcon.addClassName("fa-angle-double-up");
		}



		//Commented for GEL(GenomicsEngland)
		//These lines are commented and replaced with the following lines
		//var legendTitle = new Element('h2', {'class': 'legend-title'}).update(title);
		//var divTitle = new Element('div', {'class': ''}).update(legendTitle);


		//Added for GEL(GenomicsEngland) to add a show/hide button in the tab title ....................................
		var plusElement = new Element('span', {style:'cursor:pointer;font-size: 90%;'}).insert(title).insert(showMoreIcon);// + '<i class="fa fa-angle-double-down rightIcon"></i>');
		var legendTitle = new Element('h2', {'class': 'legend-title'}).update(plusElement);
		var divTitle = new Element('div', {'class': ''}).update(legendTitle);
		var self = this;
		showMoreIcon.on("click",function(event){
			if(this.hasClassName('fa-angle-double-down')) {
				var nextUL = $$('ul.' + self._getPrefix() + '-list');
				if (nextUL.length > 0) {
					nextUL[0].show();
				}
				this.removeClassName('fa-angle-double-down');
				this.addClassName('fa-angle-double-up');
			}else{
				var nextUL = $$('ul.' + self._getPrefix() + '-list');
				if (nextUL.length > 0) {
					nextUL[0].hide();
				}
				this.addClassName('fa-angle-double-down');
				this.removeClassName('fa-angle-double-up');
			}
		});
		this._legendBox.insert(divTitle);
		//..............................................................................................................



		this._list = new Element('ul', {'class': this._getPrefix() + '-list abnormality-list'});
		this._legendBox.insert(this._list);

		//Added for GEL(GenomicsEngland), to hide the list if initiallyHide is True
		if(this._initiallyHide === true){
			this._list.hide();
		}
		//..............................................................................................................


		Element.observe(this._legendBox, 'mouseover', function () {
			$$('.menu-box').invoke('setOpacity', .1);
		});
		Element.observe(this._legendBox, 'mouseout', function () {
			$$('.menu-box').invoke('setOpacity', 1);
		});

		if (allowDrop) {
			Droppables.add(editor.getWorkspace().canvas, {accept: 'drop-' + this._getPrefix(), onDrop: this._onDropWrapper.bind(this), onHover: this._onHoverWrapper.bind(this)});
		}
	},

	/**
	 * Returns the prefix to be used on elements related to the object
	 * (of type tracked by this legend) with the given id.
	 *
	 * @method _getPrefix
	 * @param {String|Number} id ID of the object
	 * @return {String} some identifier which should be a valid HTML id value (e.g. no spaces)
	 */
	_getPrefix: function (id) {
		// To be overwritten in derived classes
		throw "prefix not defined";
	},

	hideDragHint: function () {
		editor.getPreferencesManager().setConfigurationOption("user", "hideDraggingHint", true);
		this._legendInfo.hide();
	},

	/**
	 * Retrieve the color associated with the given object
	 *
	 * @method getObjectColor
	 * @param {String|Number} id ID of the object
	 * @return {String} CSS color value for the object, displayed on affected nodes in the pedigree and in the legend
	 */
	getObjectColor: function (id) {
		if (!this._objectColors.hasOwnProperty(id))
			return "#ff0000";
		return this._objectColors[id];
	},

	/*
	 * Returns the map id->color of all the currently used colors.
	 */
	getAllColors: function () {
		return this._objectColors;
	},

	/**
	 * Sets all preferred colors at once
	 */
	setAllPreferredColors: function (allColors) {
		for (id in allColors) {
			if (allColors.hasOwnProperty(id)) {
				this.addPreferredColor(id, allColors[id]);
			}
		}
	},

	/**
	 * Set the preferred color for object with the given id. No check is performed to make
	 * sure colors are unique.
	 */
	addPreferredColor: function (id, color) {
		this._preferredColors[id] = color;
	},

	/**
	 * Get the preferred color for object with the given id. If the color is already
	 * there is no guarantee as to what color will be used.
	 */
	getPreferedColor: function (id) {
		if (this._preferredColors.hasOwnProperty(id)) {
			return this._preferredColors[id];
		}
		return null;
	},

	/**
	 * Returns True if there are nodes reported to have the object with the given id
	 *
	 * @method _hasAffectedNodes
	 * @param {String|Number} id ID of the object
	 * @private
	 */
	_hasAffectedNodes: function (id) {
		return this._affectedNodes.hasOwnProperty(id);
	},

	/**
	 * Registers an occurrence of an object type being tracked by this legend.
	 *
	 * @method addCase
	 * @param {String|Number} id ID of the object
	 * @param {String} Name The description of the object to be displayed
	 * @param {Number} nodeID ID of the Person who has this object associated with it
	 */
	//valueAll is passed for GEL(GenomicsEngland)
	addCase: function(id, name, valueAll, nodeID) {
		if (Object.keys(this._affectedNodes).length == 0) {
			this._legendBox.show();
			!editor.getPreferencesManager().getConfigurationOption("hideDraggingHint") &&
			this._legendInfo && this._legendInfo.show();
		}
		if (!this._hasAffectedNodes(id)) {
			this._affectedNodes[id] = [nodeID];
			//valueAll is passed for GEL(GenomicsEngland)
			var listElement = this._generateElement(id, name, valueAll);
			this._list.insert(listElement);
		}
		else {
			this._affectedNodes[id].push(nodeID);
		}
		this._updateCaseNumbersForObject(id);
	},

	/**
	 * Removes an occurrence of an object, if there are any. Removes the object
	 * from the 'Legend' box if this object is not registered in any individual any more.
	 *
	 * @param {String|Number} id ID of the object
	 * @param {Number} nodeID ID of the Person who has/is affected by this object
	 */
	removeCase: function (id, nodeID) {
		if (this._hasAffectedNodes(id)) {
			this._affectedNodes[id] = this._affectedNodes[id].without(nodeID);
			if (this._affectedNodes[id].length == 0) {
				delete this._affectedNodes[id];
				delete this._objectColors[id];

				var htmlElement = this._getListElementForObjectWithID(id)
				htmlElement.remove();
				if (Object.keys(this._affectedNodes).length == 0) {
					this._legendBox.hide();
					if (this._legendBox.up().select('.abnormality').size() == 0) {
						this._legendInfo && this._legendInfo.hide();
					}
				}
			}
			else {
				this._updateCaseNumbersForObject(id);
			}
		}
	},

	/**
	 * Updates internal references to nodes when node ids is/are changed (e.g. after a node deletion)
	 */
	replaceIDs: function (changedIdsSet) {
		for (var abnormality in this._affectedNodes) {
			if (this._affectedNodes.hasOwnProperty(abnormality)) {

				var affectedList = this._affectedNodes[abnormality];

				for (var i = 0; i < affectedList.length; i++) {
					var oldID = affectedList[i];
					var newID = changedIdsSet.hasOwnProperty(oldID) ? changedIdsSet[oldID] : oldID;
					affectedList[i] = newID;
				}
			}
		}
	},

	_getListElementForObjectWithID: function (id) {
		var HTMLid = Helpers.isInt(id) ? id : this._hashID(id);
		return $(this._getPrefix() + '-' + HTMLid);
	},

	/**
	 * Updates the displayed number of nodes assocated with/affected by the object
	 *
	 * @method _updateCaseNumbersForObject
	 * @param {String|Number} id ID of the object
	 * @private
	 */
	_updateCaseNumbersForObject: function (id) {
		var HTMLid = Helpers.isInt(id) ? id : this._hashID(id);
		var label = this._legendBox.down('li#' + this._getPrefix() + '-' + HTMLid + ' .abnormality-cases');
		if (label) {
			var cases = this._affectedNodes.hasOwnProperty(id) ? this._affectedNodes[id].length : 0;
			label.update(cases + "&nbsp;case" + ((cases - 1) && "s" || ""));
		}
	},

	/**
	 * Generate the element that will display information about the given object in the legend
	 *
	 * @method _generateElement
	 * @param {String|Number} id ID of the object
	 * @param {String} name The human-readable object name or description
	 * @return {HTMLLIElement} List element to be insert in the legend
	 */
	//valueAll is passed for GEL(GenomicsEngland)
	_generateElement: function(id, name, valueAll) {
		var color = this.getObjectColor(id);
		var HTMLid = Helpers.isInt(id) ? id : this._hashID(id);
		var item = new Element('li', {'class': 'abnormality ' + 'drop-' + this._getPrefix(), 'id': this._getPrefix() + '-' + HTMLid}).update(new Element('span', {'class': 'disorder-name'}).update(name.escapeHTML()));
		item.store("valueAll",valueAll);
		item.insert(new Element('input', {'type': 'hidden', 'value': id}));
		var bubble = new Element('span', {'class': 'abnormality-color'});
		bubble.style.backgroundColor = color;
		item.insert({'top': bubble});
		var countLabel = new Element('span', {'class': 'abnormality-cases'});
		var countLabelContainer = new Element('span', {'class': 'abnormality-cases-container'}).insert("(").insert(countLabel).insert(")");
		item.insert(" ").insert(countLabelContainer);
		var me = this;
		Element.observe(item, 'mouseover', function () {
			//item.setStyle({'text-decoration':'underline', 'cursor' : 'default'});
			item.down('.disorder-name').setStyle({'background': color, 'cursor': 'default'});
			me._highlightAllByItemID(id, true);
		});
		Element.observe(item, 'mouseout', function () {
			//item.setStyle({'text-decoration':'none'});
			item.down('.disorder-name').setStyle({'background': '', 'cursor': 'default'});
			me._highlightAllByItemID(id, false);
		});
		new Draggable(item, {
			revert: true,
			reverteffect: function (segment) {
				// Reset the in-line style.
				segment.setStyle({
					height: '',
					left: '',
					position: '',
					top: '',
					zIndex: '',
					width: ''
				});
			},
			ghosting: true
		});
		return item;
	},

	_highlightAllByItemID: function (id, highlight) {
		if (editor.getView().getCurrentDraggable() == null) {
			this._affectedNodes[id] && this._affectedNodes[id].forEach(function (nodeID) {
				var node = editor.getNode(nodeID);
				if (node) {
					if (highlight) {
						node.getGraphics().highlight();
					} else {
						node.getGraphics().unHighlight()
					}
				}
			});
		}
	},

	/**
	 * Callback for dragging an object from the legend onto nodes. Converts canvas coordinates
	 * to nodeID and calls the actual drop holder once the grunt UI work is done.
	 *
	 * @method _onDropWrapper
	 * @param {HTMLElement} [label]
	 * @param {HTMLElement} [target]
	 * @param {Event} [event]
	 * @private
	 */
	_onDropWrapper: function (label, target, event) {
		if (editor.isReadOnlyMode()) {
			return;
		}
		editor.getView().setCurrentDraggable(null);
		//Added for GEL(GenomicsEngland), load valueAll from the label
		var valueAll = label.retrieve("valueAll");
		var id = label.select('input')[0].value;
		this._highlightAllByItemID(id, false); // remove highlight
		this._unhighlightAfterDrag();
		var divPos = editor.getWorkspace().viewportToDiv(event.pointerX(), event.pointerY());
		var pos = editor.getWorkspace().divToCanvas(divPos.x, divPos.y);
		var node = editor.getView().getPersonNodeNear(pos.x, pos.y);
		//console.log("Position x: " + pos.x + " position y: " + pos.y);
		if (node) {
			//Add "node.isRegistered())" into the condition for GEL(GenomicsEngland)
			//This will prevent dropping un-Assigned nodes into a destination node in the UI when participant has GEL participant Id
			if (node.isProband() || node.isRegistered()) {
				// TODO: fix this once family-studies are merged in
				return;
			}
			//Added for GEL(GenomicsEngland), pass valueAll into the drop event (mainly used in drag/drop unRendered nodes)
			//this._onDropObject(node, id);
			this._onDropObject(node, id, valueAll);
		}
	},

	_onFailedDrag: function (node, message, title) {
		editor.getOkCancelDialogue().showCustomized(message, title, "OK", function () {
			node.getGraphics().getHoverBox().animateHideHoverZone();
		});
	},

	/**
	 * Callback for moving around/hovering an object from the legend over nodes. Converts canvas coordinates
	 * to nodeID and calls the actual drop holder once the grunt UI work is done.
	 *
	 * @method _onHoverWrapper
	 * @param {HTMLElement} [label]
	 * @param {HTMLElement} [target]
	 * @param {int} [the percentage of overlapping]
	 * @private
	 */
	_onHoverWrapper: function (label, target, overlap, event) {
		if (editor.isReadOnlyMode()) {
			return;
		}
		editor.getView().setCurrentDraggable(-1); // in drag mode but with no target
		var divPos = editor.getWorkspace().viewportToDiv(event.pointerX(), event.pointerY());
		var pos = editor.getWorkspace().divToCanvas(divPos.x, divPos.y);
		var node = editor.getView().getPersonNodeNear(pos.x, pos.y);
		if (node) {
			//Add "node.isRegistered())" into the condition for GEL(GenomicsEngland)
			//This will prevent displaying the green margin around the destination node when hovering the dragged un-Assigned nodes over a destination node in the UI
			//when participant has GEL participant Id
			if (node.isProband() || node.isRegistered()) {
				// TODO: fix this once family-studies are merged in
				return;
			}
			node.getGraphics().getHoverBox().animateHideHoverZone();
			node.getGraphics().getHoverBox().setHighlighted(true);
			this._previousHighightedNode = node;
		} else {
			this._unhighlightAfterDrag();
		}
	},

	_unhighlightAfterDrag: function () {
		if (this._previousHighightedNode) {
			this._previousHighightedNode.getGraphics().getHoverBox().setHighlighted(false);
			this._previousHighightedNode = null;
		}
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String|Number} id ID of the object
	 */
	_onDropObject: function (node, objectID) {
		throw "drop functionality is not defined";
	},

	/*
	 * IDs are used as part of HTML IDs in the Legend box, which breaks when IDs contain some non-alphanumeric symbols.
	 * For that purpose these symbols in IDs are converted in memory (but not in the stored pedigree) to a numeric value.
	 *
	 * @method _hashID
	 * @param {id} ID string to be converted
	 * @return {int} Hashed integer representation of input string
	 */
	_hashID: function (s) {
		s.toLowerCase();
		if (!Array.prototype.reduce) {
			var n = 0;
			for (var i = 0; i < s.length; i++) {
				n += s.charCodeAt(i);
			}
			return "c" + n;
		}
		return "c" + s.split("").reduce(function (a, b) {
			a = ((a << 5) - a) + b.charCodeAt(0);
			return a & a;
		}, 0);
	}
});
/*
 * Disorder is a class for storing genetic disorder info and loading it from the
 * the OMIM database. These disorders can be attributed to an individual in the Pedigree.
 *
 * @param disorderID the id number for the disorder, taken from the OMIM database
 * @param name a string representing the name of the disorder e.g. "Down Syndrome"
 */
var Disorder = Class.create({

	//pass valueAll
	//this parameter is added by Soheil for GEL(GenomicsEngland)
	initialize: function(disorderId, name, ageOfOnset, diagnosisCertainty, codeSystemUri, versionNumber, disorderType, valueAll, callWhenReady) {
		// user-defined disorders
		if (name == null && !Helpers.isInt(disorderId)) {
			name = disorderId;
		}

		//Added by Soheil for GEL(GenomicsEngland)
		if(valueAll == null || valueAll == undefined){
			valueAll = {};
		}
		this.valueAll = valueAll;
		this.codeSystemUri = codeSystemUri;
        this.versionNumber = versionNumber;
        this.disorderId = disorderId;
        this.ageOfOnset = ageOfOnset;

        this.name = name ? name : "loading...";

		if(this.valueAll && this.valueAll.ageOfOnset == undefined){
			this.valueAll.ageOfOnset = ageOfOnset;
		}

        if(this.valueAll && this.valueAll.diagnosisCertainty == undefined){
            this.valueAll.diagnosisCertainty = diagnosisCertainty;
        }
        this.diagnosisCertainty = diagnosisCertainty;


        if(this.valueAll && this.valueAll.codeSystemUri == undefined){
            this.valueAll.codeSystemUri = codeSystemUri;
        }

        if(this.valueAll && this.valueAll.versionNumber == undefined){
            this.valueAll.versionNumber = versionNumber;
        }

		if(this.valueAll && this.valueAll.disorderType == undefined){
			this.valueAll.disorderType = disorderType;
		}
		this.disorderType = disorderType;


		if (!name && callWhenReady)
			this.load(callWhenReady);
	},

	/*
	 * Returns the disorderId of the disorder
	 */
	getDisorderId: function () {
		return this.disorderId;
	},

	/*
	 * Returns the name of the disorder
	 */
	getName: function () {
		return this.name;
	},


	getValueAll: function () {
		return this.valueAll;
	},

	load: function (callWhenReady) {
		//Comment added by Soheil for GEL(GenomicsEngland)
		//if we are here, it means that, the disorder details ie valueAll is not available
		//and the disorder list just has OMIM codes, so we will load the details from OMIM service
		var baseOMIMServiceURL = Disorder.getServiceURL("OMIM");
		var queryURL           = baseOMIMServiceURL + "&id=" + this.disorderId;
		console.log("loading....")
		//console.log("queryURL: " + queryURL);
		new Ajax.Request(queryURL, {
			method: "GET",
			onSuccess: this.onDataReady.bind(this),
			//onComplete: complete.bind(this)
			onComplete: callWhenReady ? callWhenReady : {}
		});
	},

	onDataReady: function (response) {
        console.log("33",response);
        try {
			var parsed = JSON.parse(response.responseText);
			this.convertToDisorderFormat(parsed);
			//console.log(Helpers.stringifyObject(parsed));
			console.log("LOADED DISORDER: disorder id = " + this.disorderId + ", name = " + parsed.rows[0].name);
			this.name = parsed.rows[0].name;
			//Added by Soheil for GEL(GenomicsEngland)
			this.valueAll = parsed.rows[0];
		} catch (err) {
			console.log("[LOAD DISORDER] Error: " + err);
		}
	},
	convertToDisorderFormat: function(response){
		console.log("ondr:",response);

	}
});

//Added by Soheil for GEL(GenomicsEngland)
Disorder.getServiceURL = function(disorderType){
	var webservice = new WebService();

	if(disorderType == "OMIM"){
		return webservice.getOmimLookupPath();
	}else if(disorderType == "ICD10"){
		return webservice.getOmimLookupPath();
	}else if(disorderType == "SnomedCT"){
		return webservice.getOmimLookupPath();
	}else if(disorderType == "GEL"){
		return webservice.getOmimLookupPath();
	}else if(disorderType == "Orphanet"){
        return webservice.getOmimLookupPath();
        //return webservice.getOrphanetLookupPath();
    }else{
		return webservice.getOmimLookupPath();
	}
};

/**
 * Class responsible for keeping track of disorders and their properties, and for
 * caching disorders data as loaded from the OMIM database.
 * This information is graphically displayed in a 'Legend' box.
 *
 * @class DisorderLegend
 * @constructor
 */
var DisorderLegend = Class.create(Legend, {

	initialize: function ($super) {
		$super('Disorders', true);

		this._disorderCache = {};
	},

	_getPrefix: function (id) {
		return "disorder";
	},

	/**
	 * Returns the disorder object with the given ID. If object is not in cache yet
	 * returns a newly created one which may have the disorder name & other attributes not loaded yet
	 *
	 * @method getDisorder
	 * @return {Object}
	 */
	getDisorder: function (disorderID) {
		if (!this._disorderCache.hasOwnProperty(disorderID)) {
			var whenNameIsLoaded = function () {
				this._updateDisorderName(disorderID);
			}
			this._disorderCache[disorderID] = new Disorder(disorderID, null, null, null, null, null, null, whenNameIsLoaded.bind(this));
		}
		return this._disorderCache[disorderID];
	},

	/**
	 * Returns a map disorderID -> disorderName
	 */
	getAllNames: function () {
		var result = {};
		for (var disorderID in this._affectedNodes) {
			if (this._affectedNodes.hasOwnProperty(disorderID)) {
				result[disorderID] = this.getDisorder(disorderID).getName();
			}
		}
		return result;
	},

	/**
	 * Registers an occurrence of a disorder. If disorder hasn't been documented yet,
	 * designates a color for it.
	 *
	 * @method addCase
	 * @param {Number|String} disorderID ID for this disorder taken from the OMIM database
	 * @param {String} disorderName The name of the disorder
	 * @param {Number} nodeID ID of the Person who has this disorder
	 */
	//Added by Soheil
	//valueAll is passed for GEL(GenomicsEngland)
	addCase: function($super, disorderID, disorderName, valueAll, nodeID) {

		//Added by Soheil for GEL(GenomicsEngland)
		//Age_of_Onset should not be copied from DisorderLegend into the target dropped node
		//So we clone it and mark ageOfOnset as empty
		var valueAll_WithoutAgeOfOnset = Object.clone(valueAll);
		valueAll_WithoutAgeOfOnset.ageOfOnset = "";
		
		if (!this._disorderCache.hasOwnProperty(disorderID))
		//valueAll is passed for GEL(GenomicsEngland)
			this._disorderCache[disorderID] = new Disorder(disorderID, disorderName, "", "", "", "", valueAll_WithoutAgeOfOnset.disorderType, valueAll_WithoutAgeOfOnset);
		//valueAll is passed for GEL(GenomicsEngland)
		$super(disorderID, disorderName, valueAll_WithoutAgeOfOnset, nodeID);
	},

	/**
	 * Updates the displayed disorder name for the given disorder
	 *
	 * @method _updateDisorderName
	 * @param {Number} disorderID The identifier of the disorder to update
	 * @private
	 */
	_updateDisorderName: function (disorderID) {
		//console.log("updating disorder display for " + disorderID + ", name = " + this.getDisorder(disorderID).getName());
		var name = this._legendBox.down('li#' + this._getPrefix() + '-' + disorderID + ' .disorder-name');
		name.update(this.getDisorder(disorderID).getName());
	},

	/**
	 * Generate the element that will display information about the given disorder in the legend
	 *
	 * @method _generateElement
	 * @param {Number} disorderID The id for the disorder, taken from the OMIM database
	 * @param {String} name The human-readable disorder name
	 * @return {HTMLLIElement} List element to be insert in the legend
	 */
	//pass valueAll for GEL(GenomicsEngland)...........
	_generateElement: function($super, disorderID, name, valueAll) {
		if (!this._objectColors.hasOwnProperty(disorderID)) {
			var color = this._generateColor(disorderID, valueAll);

			//Added by Soheil for GEL(GenomicsEngland) 01.10.2016
			//We need to show color for just GEL disorders,
			//for other disorders types such as OMIM, IDC10, SnomedCT we just use WHITE color ..........................

			/* This is being commented out to allow all diagnosis to generate a color */
			/*
			if(valueAll != undefined){
				if(valueAll.disorderType != "GEL") {
					color = "#FFF";
				}
			}else{
				color = "#FFF";
			}*/
			//..........................................................................................................

			this._objectColors[disorderID] = color;
			document.fire('disorder:color', {'id': disorderID, color: color});
		}

		//Added by Soheil for Gel(GenomicsEngland) to include (disorderType) in disorderLegend
		var item = $super(disorderID, name, valueAll);
		var disorderType = "";
		if(valueAll != undefined){
			disorderType = valueAll.disorderType;
		}else{
			disorderType = "OMIM";
		}
		if(name != "affected") {
			var disorderTypeContainer = new Element('span', {'class': 'disorder-disorder-type'}).insert("(").insert(disorderType).insert(")");
			item.down('.disorder-name').insert(" ").insert(disorderTypeContainer);
		}

		return item;
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String|Number} id ID of the disorder being dropped
	 */
	_onDropObject: function (node, disorderID) {
		var currentDisorders = node.getDisorders().slice(0);
		if (currentDisorders.indexOf(disorderID) == -1) {   // only if the node does not have this disorder yet
			currentDisorders.push(disorderID);
			editor.getView().unmarkAll();
			var properties = { "setDisorders": currentDisorders };
			var event = { "nodeID": node.getID(), "properties": properties };
			document.fire("pedigree:node:setproperty", event);
		} else {
			this._onFailedDrag(node, "This person already has the selected disorder", "Can't drag this disorder to this person");
		}
	},

	/**
	 * Generates a CSS color.
	 * Has preference for some predefined colors that can be distinguished in gray-scale
	 * and are distint from gene colors.
	 *
	 * @method generateColor
	 * @return {String} CSS color
	 */
	_generateColor: function (disorderID) {
		if (this._objectColors.hasOwnProperty(disorderID)) {
			return this._objectColors[disorderID];
		}

		var usedColors = Object.values(this._objectColors),
		// [red/yellow]           prefColors = ["#FEE090", '#f8ebb7', '#eac080', '#bf6632', '#9a4500', '#a47841', '#c95555', '#ae6c57'];
		// [original yellow/blue] prefColors = ["#FEE090", '#E0F8F8', '#8ebbd6', '#4575B4', '#fca860', '#9a4500', '#81a270'];
		// [green]                prefColors = ['#81a270', '#c4e8c4', '#56a270', '#b3b16f', '#4a775a', '#65caa3'];
		//#E0F8F8
			prefColors = ['#D1E9E9', '#92c0db', '#4575B4', '#949ab8', "#FEE090", '#bf6632', '#fca860', '#9a4500', '#d12943', '#00a2bf'];
		if (disorderID == "affected") {
			prefColors = ["#FEE090", "#dbad71"];
		}
		if (this.getPreferedColor(disorderID) !== null) {
			prefColors.unshift(this.getPreferedColor(disorderID));
		}
		usedColors.each(function (color) {
			prefColors = prefColors.without(color);
		});
		if (prefColors.length > 0) {
			return prefColors[0];
		}
		else {
			var randomColor = Raphael.getColor();
			while (randomColor == "#ffffff" || usedColors.indexOf(randomColor) != -1) {
				randomColor = "#" + ((1 << 24) * Math.random() | 0).toString(16);
			}
			return randomColor;
		}
	}
});

/*
 * HPOTerm is a class for storing phenotype information and loading it from the
 * the HPO database. These phenotypes can be attributed to an individual in the Pedigree.
 *
 * @param hpoId the id number for the HPO term, taken from the HPO database
 * @param name a string representing the name of the term e.g. "Abnormality of the eye"
 */
var HPOTerm = Class.create({

	initialize: function (hpoId, name, hpoPresent, hpoModifiers, valueAll, callWhenReady) {
		// user-defined terms
		if (name == null && !HPOTerm.isValidID(hpoId)) {
			name = hpoId;
		}


		//Added by Soheil for GEL(GenomicsEngland)
		if(valueAll == null || valueAll == undefined){
			valueAll = {};
		}
		this.valueAll = valueAll;
		this.hpoId = hpoId;
		this.name = name ? name : "loading...";

	this.hpoModifiers = hpoModifiers;
	this.valueAll.hpoModifiers = hpoModifiers;

	/*if(this.valueAll && this.valueAll.hpoModifiers == undefined){
		this.valueAll.hpoModifiers = hpoModifiers;
	}
	else{
        this.valueAll.hpoModifiers = [];
	}*/

    if(this.valueAll && this.valueAll.hpoPresent == undefined){
		this.valueAll.hpoPresent = hpoPresent;
	}
	this.hpoPresent = hpoPresent;



	if (!name && callWhenReady)
		this.load(callWhenReady);
	},



	/*
	 * Returns the hpoId of the phenotype
	 */
	getID: function () {
		return this.hpoId;
	},

	getValueAll: function () {
		return this.valueAll;
	},
	/*
	 * Returns the name of the term
	 */
	getName: function () {
		return this.name;
	},

	load: function (callWhenReady) {
		//Comment added by Soheil for GEL(GenomicsEngland)
		//if we are here, it means that, the HPO details ie valueAll is not available
		//so we will load the details from HPO service
		var webService = new WebService();
		var baseOMIMServiceURL = webService.getHPOLookupPath();
		var queryURL           = baseOMIMServiceURL + "id=" + this.hpoId;

		//console.log("QueryURL: " + queryURL);
		new Ajax.Request(queryURL, {
			method: "GET",
			onSuccess: this.onDataReady.bind(this),
			//onComplete: complete.bind(this)
			onComplete: callWhenReady ? callWhenReady : {}
		});
	},

	onDataReady: function (response) {
		try {
			var parsed = JSON.parse(response.responseText);
			//console.log(Helpers.stringifyObject(parsed));
			console.log("LOADED HPO TERM: id = " + this.hpoId + ", name = " + parsed.rows[0].name);
			this.name = parsed.rows[0].name;
			//Added by Soheil for GEL(GenomicsEngland)
			this.valueAll = parsed.rows[0];
		} catch (err) {
			console.log("[LOAD HPO TERM] Error: " + err);
		}
	}
});

HPOTerm.isValidID = function (id) {
	var pattern = /^HP\:(\d)+$/i;
	return pattern.test(id);
}

/**
 * Class responsible for keeping track of HPO terms and their properties, and for
 * caching disorders data as loaded from the OMIM database.
 * This information is graphically displayed in a 'Legend' box
 *
 * @class HPOLegend
 * @constructor
 */
var HPOLegend = Class.create(Legend, {

	initialize: function ($super) {
		$super("Phenotypes", true);

		this._termCache = {};
	},

	_getPrefix: function (id) {
		return "phenotype";
	},

	/**
	 * Returns the HPOTerm object with the given ID. If object is not in cache yet
	 * returns a newly created one which may have the term name & other attributes not loaded yet
	 *
	 * @method getTerm
	 * @return {Object}
	 */
	getTerm: function (hpoID) {
		if (!this._termCache.hasOwnProperty(hpoID)) {
			var whenNameIsLoaded = function () {
				this._updateTermName(hpoID);
			};
			//commented for GEL(GenomicsEngland) ......................................................
			//this._termCache[hpoID] = new HPOTerm(hpoID, null, whenNameIsLoaded.bind(this));
			this._termCache[hpoID] = new HPOTerm(hpoID, null, null, null, null, whenNameIsLoaded.bind(this));
			//..........................................................................................
		}
		return this._termCache[hpoID];
	},

	/**
	 * Retrieve the color associated with the given object
	 *
	 * @method getObjectColor
	 * @param {String|Number} id ID of the object
	 * @return {String} CSS color value for that disorder
	 */
	getObjectColor: function (id) {
		return "#CCCCCC";
	},

	/**
	 * Registers an occurrence of a phenotype.
	 *
	 * @method addCase
	 * @param {Number|String} id ID for this term taken from the HPO database
	 * @param {String} name The description of the phenotype
	 * @param {Number} nodeID ID of the Person who has this phenotype
	 * @valueAll added for GEL(GenomicsEngland)
	 */
	addCase: function ($super, id, name, valueAll, nodeID) {
		//if (!this._termCache.hasOwnProperty(id))
			this._termCache[id] = new HPOTerm(id, name, valueAll.hpoPresent, valueAll.hpoModifiers, valueAll); //commented for GEL(GenomicsEngland) this._termCache[id] = new HPOTerm(id, name);

		$super(id, name, valueAll, nodeID); //commented for GEL(GenomicsEngland) $super(id, name, nodeID);
	},

	/**
	 * Updates the displayed phenotype name for the given phenotype
	 *
	 * @method _updateTermName
	 * @param {Number} id The identifier of the phenotype to update
	 * @private
	 */
	_updateTermName: function (id) {
		//console.log("updating phenotype display for " + id + ", name = " + this.getTerm(id).getName());
		var _this = this;
		var name = this._legendBox.down('li#' + this._getPrefix() + '-' + _this._hashID(id) + ' .disorder-name');
		name.update(this.getTerm(id).getName());
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String|Number} id ID of the phenotype being dropped
	 */
	_onDropObject: function (node, hpoID) {
		if (node.isPersonGroup()) {
			return;
		}
		var currentHPO = node.getHPO().slice(0);
		if (currentHPO.indexOf(hpoID) == -1) {
			currentHPO.push(hpoID);
			editor.getView().unmarkAll();
			var properties = { "setHPO": currentHPO };
			var event = { "nodeID": node.getID(), "properties": properties };
			document.fire("pedigree:node:setproperty", event);
		} else {
			this._onFailedDrag(node, "This person already has the selected phenotype", "Can't drag this phenotype to this person");
		}
	},
	//This method is added for GEL(GenomicsEngland).............................................................
	//actually to override _generateElement and call the super _generateElement
	_generateElement: function($super, disorderID, name, valueAll) {
		//Added by Soheil for Gel(GenomicsEngland) to include (disorderType) in disorderLegend
		var item = $super(disorderID, name, valueAll);
		return item;
	}
	//...........................................................................................................
});

/**
 * Class responsible for keeping track of candidate genes.
 * This information is graphically displayed in a 'Legend' box.
 *
 * @class GeneLegend
 * @constructor
 */
var GeneLegend = Class.create(Legend, {

	initialize: function ($super) {
		$super('Candidate Genes', true);
	},

	_getPrefix: function (id) {
		return "gene";
	},

	/**
	 * Generate the element that will display information about the given disorder in the legend
	 *
	 * @method _generateElement
	 * @param {String} geneID The id for the gene
	 * @param {String} name The human-readable gene description
	 * @return {HTMLLIElement} List element to be insert in the legend
	 */
	_generateElement: function ($super, geneID, name) {
		if (!this._objectColors.hasOwnProperty(geneID)) {
			var color = this._generateColor(geneID);
			this._objectColors[geneID] = color;
			document.fire('gene:color', {'id': geneID, color: color});
		}

		return $super(geneID, name);
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String|Number} id ID of the gene being dropped
	 */
	_onDropObject: function (node, geneID) {
		if (node.isPersonGroup()) {
			return;
		}
		var currentGenes = node.getGenes().slice(0);
		if (currentGenes.indexOf(geneID) == -1) {   // only if the node does not have this gene yet
			currentGenes.push(geneID);
			editor.getView().unmarkAll();
			var properties = { "setGenes": currentGenes };
			var event = { "nodeID": node.getID(), "properties": properties };
			document.fire("pedigree:node:setproperty", event);
		} else {
			this._onFailedDrag(node, "This person already has the selected candidate gene", "Can't drag this gene to this person");
		}
	},

	/**
	 * Generates a CSS color.
	 * Has preference for some predefined colors that can be distinguished in gray-scale
	 * and are distint from disorder colors.
	 *
	 * @method generateColor
	 * @return {String} CSS color
	 */
	_generateColor: function (geneID) {
		if (this._objectColors.hasOwnProperty(geneID)) {
			return this._objectColors[geneID];
		}

		var usedColors = Object.values(this._objectColors),
		// green palette
			prefColors = ['#81a270', '#c4e8c4', '#56a270', '#b3b16f', '#4a775a', '#65caa3'];
		if (this.getPreferedColor(geneID) !== null) {
			prefColors.unshift(this.getPreferedColor(geneID));
		}
		usedColors.each(function (color) {
			prefColors = prefColors.without(color);
		});
		if (prefColors.length > 0) {
			return prefColors[0];
		}
		else {
			var randomColor = Raphael.getColor();
			while (randomColor == "#ffffff" || usedColors.indexOf(randomColor) != -1) {
				randomColor = "#" + ((1 << 24) * Math.random() | 0).toString(16);
			}
			return randomColor;
		}
	}
});
/**
 * This class is added by Soheil for GEL(GenomicsEngland) 05.09.2016
 * This will help to present UnRendered nodes in a legend
 * This is a copy of hpoLegend.js and then modified and added new methods such as addNode
 * @class Legend
 * @constructor
 */

var unRenderedLegendSuper = Class.create(Legend, {


	/**
	 * Added by Soheil for GEL(GenomicsEngland)
	 * Add a node into unRenderedNode legend
	 *
	 * @param id
	 * @param name
	 * @param nodeID
	 * @param node
	 */
	addNode: function(node) {
		var id = Object.keys(this._affectedNodes).length;
		if (Object.keys(this._affectedNodes).length == 0) {
			this._legendBox.show();
			!editor.getPreferencesManager().getConfigurationOption("hideDraggingHint") &&
			this._legendInfo && this._legendInfo.show();
		}
		if (!this._hasAffectedNodes(id)) {
			this._affectedNodes[id] = [id];
			var listElement = this._generateNode(id, node);
			this._list.insert(listElement);
		}

		this._updateCaseNumbersForObject(id);
	},

	/**
	 * Add the array of nodes in bulk
	 * @param nodes
	 */
	addAllNodes: function(nodes) {
		for(var i = 0; nodes && i < nodes.length;i++){
			this.addNode(nodes[i]);
		}
	},

	/**
	 * Remove all nodes in unRendered legend list
	 */
	removeAllNodes: function () {
		var currentNodesLength = Object.keys(this._affectedNodes).length;
		for(var i = 0; i < currentNodesLength; i++){
			var htmlElement = $(this._getPrefix() + i);
			htmlElement.remove();
		}

		this._legendBox.hide();
		if (this._legendBox.up().select('.abnormality').size() == 0) {
			this._legendInfo && this._legendInfo.hide();
		}

		this._affectedNodes = {};
		this._objectColors  = {};

	},

	/**
	 * Added by Soheil for GEL(GenomicsEngland)
	 *
	 * @param id
	 * @param name
	 * @param nodeID
	 * @param node
	 * @returns {*}
	 * @private
	 */
	_generateNode: function(id, node ) {

		var color = this.getObjectColor(id);
		var HTMLContent = (node.ngisRegisteredPatientUid != "" ? "NGIS ID: " + node.ngisRegisteredPatientUid : "NON NGIS ID: " +node.nonNgisPatientStableUid) + "<br>";

		var item = new Element('li', {'class': 'UnRendered-legend-box-item abnormality ' + 'drop-' + this._getPrefix(), 'id': this._getPrefix() + id}).update(HTMLContent);//new Element('span', {'class': 'disorder-name'}).update("ID"));
		//Add an internal id to the node to find out where in the list it's located
		node.unRenderedIndex = id;
		item.store("valueAll", node);

		item.insert(new Element('span', {class: 'unRenderedItemName'}).update("NHS#: "));
		item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.NHSNumber));
		item.insert(new Element('span', {}).update("<br>"));


		if(node.chiNumber && node.chiNumber.length > 0) {
			item.insert(new Element('span', {class: 'unRenderedItemName'}).update("CHI#: "));
			item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.chiNumber));
			item.insert(new Element('span', {}).update("<br>"));
		}


		item.insert(new Element('span', {class: 'unRenderedItemName'}).update("Forenames: "));
		item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.firstName));
		item.insert(new Element('span', {}).update("<br>"));


		item.insert(new Element('span', {class: 'unRenderedItemName'}).update("Surname: "));
		item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.lastName));
		item.insert(new Element('span', {}).update("<br>"));


		item.insert(new Element('span', {class: 'unRenderedItemName'}).update("Gender: "));
		var genderDisplayText = Helpers.getGenderDisplayText(node.sex);
		item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(genderDisplayText));

		item.insert(new Element('span', {}).update("<br>"));


		item.insert(new Element('span', {class:'unRenderedItemName'}).update("BirthDate: "));
		var dob = "";
		if(node.birthDate) {
			var dob = node.birthDate.day + "/" + node.birthDate.month + "/" + node.birthDate.year;
		}
		item.insert(new Element('span', {class:'unRenderedItemValue'}).update(dob));
		item.insert(new Element('span', {}).update("<br>"));


		item.insert(new Element('span', {class: 'unRenderedItemName'}).update("Relation: "));
		item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.relationshipToProband));
		item.insert(new Element('span', {}).update("<br>"));

    item.insert(new Element('span', {class: 'unRenderedItemName'}).update("NGISPatientID: "));
    item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.ngisRegisteredPatientUid));
    item.insert(new Element('span', {}).update("<br>"));

    /* Removed for GEL 
    item.insert(new Element('span', {class: 'unRenderedItemName'}).update("NonNGISPatientID: "));
    item.insert(new Element('span', {class: 'unRenderedItemValue'}).update(node.nonNgisPatientStableUid));
    item.insert(new Element('span', {}).update("<br>"));
    */


		//Hidden elements should has .unRenderedHidden CSS Class ......................................................
		item.insert(new Element('span', {class:'unRenderedItemName unRenderedHidden'}).update("KaryotypicSex: "));
		item.insert(new Element('span', {class:'unRenderedItemValue unRenderedHidden'}).update(node.karyotypicSex));
		item.insert(new Element('span', {class:'unRenderedHidden'}).update("<br>"));

		if(node.disordersFullDetails) {
			item.insert(new Element('span', {class: 'unRenderedItemName unRenderedHidden'}).update("Disorders:"));
			item.insert(new Element('span', {class: 'unRenderedHidden'}).update("<br>"));
			for (var i = 0; i < node.disordersFullDetails.length; i++) {
				item.insert(new Element('span', {class: 'unRenderedHidden unRendered-disorder-item'}).update("&bull;&nbsp;" + node.disordersFullDetails[i].name));
				item.insert(new Element('span', {class: 'unRenderedHidden'}).update("<br>"));
			}
		}

		if(node.hpoTermsFullDetails) {
			item.insert(new Element('span', {class: 'unRenderedItemName unRenderedHidden'}).update("HPO:"));
			item.insert(new Element('span', {class: 'unRenderedHidden'}).update("<br>"));
			for (var i = 0; i < node.hpoTermsFullDetails.length; i++) {
				item.insert(new Element('span', {class: 'unRenderedHidden unRendered-disorder-item'}).update("&bull;&nbsp;" + node.hpoTermsFullDetails[i].
					hpoID + "&nbsp;" + node.hpoTermsFullDetails[i].name));
				item.insert(new Element('span', {class: 'unRenderedHidden'}).update("<br>"));
			}
		}
		//.............................................................................................................


		var moreValuesDots = new Element('span', {class:'moreValueDots'}).update("...&nbsp;");
		var plusElement = new Element('span', {style:'cursor:pointer;font-size: 90%;'}).insert(moreValuesDots).insert('<i class="fa fa-plus-square-o" aria-hidden="true"></i>');
		item.insert(plusElement);


		item.select("span.unRenderedHidden").each(Element.hide);

		plusElement.observe('click', function(event) {
			var plusIcon = this.select("i")[0];
			if(plusIcon.hasClassName('fa-plus-square-o')){
				plusIcon.removeClassName('fa-plus-square-o');
				plusIcon.addClassName('fa-minus-square-o');
				//SHOW THE VALUES
				item.select("span.unRenderedHidden").each(Element.show);
				moreValuesDots.hide();
			}else{
				plusIcon.addClassName('fa-plus-square-o');
				plusIcon.removeClassName('fa-minus-square-o');
				//HIDE THE VALUES
				item.select("span.unRenderedHidden").each(Element.hide);
				moreValuesDots.show();
			}
		});


 		item.insert(new Element('input', {'type': 'hidden', 'value': id}));

		var bubble = new Element('span', {'class': 'UnRendered-abnormality-color'});
		bubble.style.backgroundColor = color;
		item.insert({'top': bubble});

		var countLabelContainer = new Element('span', {'class': 'abnormality-cases-container'});
		item.insert(" ").insert(countLabelContainer);

		new Draggable(item, {
			revert: true,
			reverteffect: function (segment) {
				// Reset the in-line style.
				segment.setStyle({
					height: '',
					left: '',
					position: '',
					top: '',
					zIndex: '',
					width: ''
				});
			},
			ghosting: true
		});

		return item;
	}

});
/**
 * Class responsible for keeping track of HPO terms and their properties, and for
 * caching disorders data as loaded from the OMIM database.
 * This information is graphically displayed in a 'Legend' box
 *
 * @class HPOLegend
 * @constructor
 */
var unRenderedLegend = Class.create(unRenderedLegendSuper, {

	initialize: function ($super) {

		//commented for GEL(GenomicsEngland)
		//$super("Unassigned participants", true);
		//Added for GEL(GenomicsEngland), we need to pass initiallyHide=true to hide the list of items for UnRendered nodes
		var initiallyHide = true;
		$super("Unassigned participants", true, initiallyHide);

		// Added for GEL to add the info box about what to do with the unassigned participants
		this._unrenderedLegendInfo = new Element('div', {'class': 'legend-box legend-info', id: 'extra-legend-info'}).insert(
			new Element('div', {'class': 'infomessage'}).insert(
				"Please drag & drop all 'unassigned' participants from the list below into the correct position in the pedigree.")
		);
		this.unrenderedCloseButton = new Element('span', {'class': 'close-button'}).update('x');
		this.unrenderedCloseButton.observe('click', this.hideUnRenderedHint.bindAsEventListener(this));
		this._unrenderedLegendInfo.insert({'top': this.unrenderedCloseButton});

		this._list.insert(this._unrenderedLegendInfo);

		this._termCache = {};
	},

	hideUnRenderedHint: function () {
		editor.getPreferencesManager().setConfigurationOption("user", "hideDraggingHint", true);
		this._unrenderedLegendInfo.hide();
	},

	_getPrefix: function (id) {
		return "UnRendered";
	},

	/**
	 * Retrieve the color associated with the given object
	 *
	 * @method getObjectColor
	 * @param {String|Number} id ID of the object
	 * @return {String} CSS color value for that disorder
	 */
	getObjectColor: function (id) {
		return "#CCCCCC";
	},

	/**
	 * Registers an occurrence of a phenotype.
	 *
	 * @method addCase
	 * @param {Number|String} id ID for this term taken from the HPO database
	 * @param {String} name The description of the phenotype
	 * @param {Number} nodeID ID of the Person who has this phenotype
	 */
	addCase: function ($super, id, name, nodeID) {
		if (!this._termCache.hasOwnProperty(id))
			this._termCache[id] = new HPOTerm(id, name);

		$super(id, name, nodeID);
	},

	addNode: function ($super, id, name, nodeID, node) {
		if (!this._termCache.hasOwnProperty(id))
			this._termCache[id] = { id:id, name:name};//new HPOTerm(id, name);

		$super(id, name, nodeID, node);
	},

	/**
	 * Updates the displayed phenotype name for the given phenotype
	 *
	 * @method _updateTermName
	 * @param {Number} id The identifier of the phenotype to update
	 * @private
	 */
	_updateTermName: function (id) {
		//console.log("updating phenotype display for " + id + ", name = " + this.getTerm(id).getName());
		var _this = this;
		var name = this._legendBox.down('li#' + this._getPrefix() + '-' + _this._hashID(id) + ' .disorder-name');
		name.update(this.getTerm(id).getName());
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String|Number} id ID of the phenotype being dropped
	 */
	_onDropObject: function (node, hpoID, valueAll) {
		var self = this;

		if (node.isPersonGroup()) {
			return;
		}

		//if destination node has ParticipantId, we can NOT drop an unRendered node into it! so show a proper error message
		var participantId = node.getParticipantId();
		if(participantId && participantId.trim().length > 0){
			var closeFunction = function () {
				this.dialog.show();
			};
			editor.getOkCancelDialogue().showCustomized('You can not assign to a node that has Participant Id.',
				"Genomics England",
				"Close", closeFunction,
				null, null,
				null, null, true);
			return;
		}

		//if current code contains
		var nodeArray = editor.getGraph()._getAllNodes();

		var alreadyInGraph = false;

		for (i=0; i<nodeArray.length; i++){

            var nodeValue = nodeArray[i];
		    var currentNode = editor.getNode(nodeValue);

		    if (currentNode._ngisRegisteredPatientUid && valueAll.ngisRegisteredPatientUid){
		        if (currentNode._ngisRegisteredPatientUid == valueAll.ngisRegisteredPatientUid){
		            alreadyInGraph = true;
		            break;
		        }
		    }
		}

		if (alreadyInGraph){
		    var closeFunction = function () {
            				this.dialog.show();
            			};
            			editor.getOkCancelDialogue().showCustomized('This node has been already assigned to another node',
            				"Genomics England",
            				"Close", closeFunction,
            				null, null,
            				null, null, true);
            			return;
		}

		//the YesFunction when the user confirms that the copy should be done
		var yesFunction = function(){
			//copy all unRendered node values (valueAll) into the destination node (node)
			Person.copyUnassignedNode(node, valueAll);

			//successfully assigned the value into the destination node, so now change the color of the un-Rendered node in the list
			//now change its color to a gray
			var HTMLId = self._getPrefix() + valueAll.unRenderedIndex;
			var unRenderedNode = editor._unRenderedLegend._legendBox.select("#" + HTMLId);
			if(unRenderedNode.length > 0){
				unRenderedNode = unRenderedNode[0];
			}
			if(unRenderedNode) {
				unRenderedNode.removeClassName('UnRendered-legend-box-item');
				unRenderedNode.addClassName('UnRendered-legend-box-item-selected');
			}
		};
		//get confirmation
		editor.getOkCancelDialogue().showCustomized('Are you sure you want to assign the values to this node?',
			"Genomics England",
			"Yes", yesFunction,
			"No", closeFunction,
			null, true);
	}

});

/**
 * SaveLoadIndicator is a window that notifies the user of loading and saving progress.
 *
 * @class SaveLoadIndicator
 * @constructor
 */
var SaveLoadIndicator = Class.create({

	initialize: function () {
		var me = this;
		var mainDiv = new Element('div', {'class': 'load-status-container'});
		this._isHidden = true;
		this.dialog = new PhenoTips.widgets.ModalPopup(mainDiv, false, {extraClassName: "loading-indicator", displayCloseButton: false});
		document.observe("pedigree:load:start", function (event) {
			if (me._isHidden) {
				me.show();
			}
		});
		document.observe("pedigree:load:finish", function (event) {
			if (!me._isHidden) {
				me.hide();
			}
		});
	},

	/**
	 * Displays the the loading window
	 * @method show
	 */
	show: function () {
		this.dialog.show();
		this._isHidden = false;
	},

	/**
	 * Hides the the loading window
	 * @method hide
	 */
	hide: function () {
		this.dialog.close();
		this._isHidden = true;
	}
});
/**
 * The UI Element for browsing and selecting pre-defined Pedigree templates
 *
 * @class TemplateSelector
 * @constructor
 * @param {Boolean} isStartupTemplateSelector Set to True if no pedigree has been loaded yet
 */
var TemplateSelector = Class.create({

	initialize: function (isStartupTemplateSelector) {
		this._isStartupTemplateSelector = isStartupTemplateSelector;
		this.mainDiv = new Element('div', {'class': 'template-picture-container'});
		this.mainDiv.update("Loading list of templates...");
		var closeShortcut = isStartupTemplateSelector ? [] : ['Esc'];
		this.dialog = new PhenoTips.widgets.ModalPopup(this.mainDiv, {close: {method: this.hide.bind(this), keys: closeShortcut}}, {extraClassName: "pedigree-template-chooser", title: "Please select a pedigree template", displayCloseButton: !isStartupTemplateSelector, verticalPosition: "top"});
		isStartupTemplateSelector && this.show();
		//Commented by Soheil for GEL(GenomicsEngland)
		//ge the right path instead of using xWiki path
		//new Ajax.Request(new XWiki.Document('WebHome').getRestURL('objects/PhenoTips.PedigreeClass/index.xml').substring(1), {
		var webService = new WebService();
		var editorPath = webService.getPathToEditorFiles();
		var newURL = editorPath + new XWiki.Document('WebHome').getRestURL('objects/PhenoTips.PedigreeClass/index.xml').substring(1);
		new Ajax.Request(newURL , {
			method: 'GET',
			onSuccess: this._onTemplateListAvailable.bind(this)
		});
	},

	/**
	 * Returns True if this template selector is the one displayed on startup
	 *
	 * @method isStartupTemplateSelector
	 * @return {Boolean}
	 */
	isStartupTemplateSelector: function () {
		return this._isStartupTemplateSelector;
	},

	/**
	 * Displays the templates once they have been downloaded
	 *
	 * @param response
	 * @private
	 */
	_onTemplateListAvailable: function (response) {
		this.mainDiv.update();
		var objects = response.responseXML.documentElement.getElementsByTagName('objectSummary');
		for (var i = 0; i < objects.length; ++i) {
			var pictureBox = new Element('div', {'class': 'picture-box'});
			pictureBox.update("Loading...");
			this.mainDiv.insert(pictureBox);
			var href = getSelectorFromXML(objects[i], "link", "rel", "http://www.xwiki.org/rel/properties").getAttribute("href");
			// Use only the path, since the REST module returns the wrong host behind a reverse proxy
			var path = href.substring(href.indexOf("/", href.indexOf("//") + 2));
			var newURL = "rest" + path;

			var webService = new WebService();
			var editorPath = webService.getPathToEditorFiles();
			var templatePath = editorPath + newURL;

			//new Ajax.Request(href, {
			new Ajax.Request(templatePath, {
				method: 'GET',
				onSuccess: this._onTemplateAvailable.bind(this, pictureBox)
			});
		}
	},

	/**
	 * Creates a clickable template thumbnail once the information has been downloaded
	 *
	 * @param pictureBox
	 * @param response
	 * @private
	 */
	_onTemplateAvailable: function (pictureBox, response) {
		pictureBox.innerHTML = getSubSelectorTextFromXML(response.responseXML, "property", "name", "image", "value").replace(/&amp;/, '&');
		pictureBox.pedigreeData = getSubSelectorTextFromXML(response.responseXML, "property", "name", "data", "value");
		pictureBox.type = 'internal';
		pictureBox.description = getSubSelectorTextFromXML(response.responseXML, "property", "name", "description", "value");
		pictureBox.title = pictureBox.description;

		//console.log("[Data from Template] - " + Helpers.stringifyObject(pictureBox.pedigreeData));

		// TODO: render images with JavaScript instead
		if (window.SVGSVGElement &&
			document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1")) {
			pictureBox.update(getSubSelectorTextFromXML(response.responseXML, "property", "name", "image", "value"));
		} else {
			pictureBox.innerHTML = "<table bgcolor='#FFFAFA'><tr><td><br>&nbsp;" + pictureBox.description + "&nbsp;<br><br></td></tr></table>";
		}
		pictureBox.observe('click', this._onTemplateSelected.bindAsEventListener(this, pictureBox));
	},

	/**
	 * Loads the template once it has been selected
	 *
	 * @param event
	 * @param pictureBox
	 * @private
	 */
	_onTemplateSelected: function (event, pictureBox) {
		//console.log("observe onTemplateSelected");
		this.dialog.close();
		if (pictureBox.type == 'internal') {
			editor.getSaveLoadEngine().createGraphFromSerializedData(pictureBox.pedigreeData, false /* add to undo stack */, true /*center around 0*/);
		} else if (pictureBox.type == 'simpleJSON') {
			editor.getSaveLoadEngine().createGraphFromImportData(pictureBox.pedigreeData, 'simpleJSON', {}, false /* add to undo stack */, true /*center around 0*/);
		}
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	show: function () {
		var availableHeight = document.viewport.getHeight() - 80;
		this.mainDiv.setStyle({'max-height': availableHeight + 'px', 'overflow-y': 'auto'});
		this.dialog.show();
	},

	/**
	 * Removes the the template selector
	 *
	 * @method hide
	 */
	hide: function () {
		this.dialog.closeDialog();
	}
});


// TODO: replace XML loading with a service providing JSONs

function unescapeRestData(data) {
	// http://stackoverflow.com/questions/4480757/how-do-i-unescape-html-entities-in-js-change-lt-to
	var tempNode = document.createElement('div');
	tempNode.innerHTML = data.replace(/&amp;/, '&');
	return tempNode.innerText || tempNode.text || tempNode.textContent;
}

function getSelectorFromXML(responseXML, selectorName, attributeName, attributeValue) {
	if (responseXML.querySelector) {
		// modern browsers
		return responseXML.querySelector(selectorName + "[" + attributeName + "='" + attributeValue + "']");
	} else {
		// IE7 && IE8 && some other older browsers
		// http://www.w3schools.com/XPath/xpath_syntax.asp
		// http://msdn.microsoft.com/en-us/library/ms757846%28v=vs.85%29.aspx
		var query = ".//" + selectorName + "[@" + attributeName + "='" + attributeValue + "']";
		try {
			return responseXML.selectSingleNode(query);
		} catch (e) {
			// Firefox v3.0-
			alert("your browser is unsupported");
			window.stop && window.stop();
			throw "Unsupported browser";
		}
	}
}

function getSubSelectorTextFromXML(responseXML, selectorName, attributeName, attributeValue, subselectorName) {
	var selector = getSelectorFromXML(responseXML, selectorName, attributeName, attributeValue);

	var value = selector.innerText || selector.text || selector.textContent;

	if (!value)     // fix IE behavior where (undefined || "" || undefined) == undefined
		value = "";

	return value;
}
/**
 * The UI Element for displaying prompts to the user in a movable/semi-transparent dialogue
 *
 * @class OkCancelDialogue
 */
var OkCancelDialogue = Class.create({

	initialize: function () {
		var _this = this;

		this._onButtonActions = [undefined, undefined, undefined];
		this._buttons = [undefined, undefined, undefined];

		var mainDiv = new Element('div', {'class': 'ok-cancel-dialogue'});

		this._promptBody = new Element('div', {'class': 'ok-cancel-body'});
		mainDiv.insert(this._promptBody);

		this._buttons[0] = new Element('input', {type: 'button', name: 'ok', 'value': 'OK', 'class': 'button min-width80px', 'id': 'OK_button'});
		this._buttons[1] = new Element('input', {type: 'button', name: 'cancel', 'value': 'Cancel', 'class': 'button secondary min-width80px'});
		this._buttons[2] = new Element('input', {type: 'button', name: 'other', 'value': 'Other', 'class': 'button secondary min-width80px'});

		var buttons = new Element('div', {'class': 'buttons import-block-bottom'});
		for (var i = 0; i < this._buttons.length; i++) {
			buttons.insert(this._buttons[i].wrap('span', {'class': 'buttonwrapper'}));
			this._buttons[i].index = i;
			this._buttons[i].observe('click', function (event) {
				_this.hide();
				_this._onButtonActions[this.index] && _this._onButtonActions[this.index]();
			});
		}
		mainDiv.insert(buttons);

		var closeShortcut = ['Esc'];
		this.dialog = new PhenoTips.widgets.ModalPopup(mainDiv, {close: {method: this.hide.bind(this), keys: closeShortcut}}, {extraClassName: "pedigree-okcancel", title: "?", displayCloseButton: false});
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	show: function (message, title, onOKFunction, onCancelFunction) {
		this.showCustomized(message, title, "OK", onOKFunction, "Cancel", onCancelFunction);
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	showCustomized: function (message, title, button1title, on1Function, button2title, on2Function, button3title, on3Function, bottomRight) {
		this._configButton(0, button1title, on1Function);
		this._configButton(1, button2title, on2Function);
		this._configButton(2, button3title, on3Function, bottomRight);
		this._promptBody.update(message);
		this.dialog.show();
		this.dialog.dialogBox.down("div.msdialog-title").update(title);  // this.dialog.dialogBox is available only after show()
	},

	/**
	 * Removes the the template selector
	 *
	 * @method hide
	 */
	hide: function () {
		this.dialog.closeDialog();
	},

	_configButton: function (buttonID, buttonTitle, actionFunction, bottomRightButton) {
		if (!buttonTitle || buttonTitle == "") {
			this._buttons[buttonID].hide();
		} else {
			this._buttons[buttonID].show();
			this._buttons[buttonID].writeAttribute("value", buttonTitle);
			this._onButtonActions[buttonID] = actionFunction;
		}
		if (bottomRightButton) {
			this._buttons[buttonID].setStyle({"marginLeft": "-200px", "marginRight": "10px", "float": "right"});
		} else {
			this._buttons[buttonID].setStyle({"marginLeft": "0px", "marginRight": "0px", "float": "none"});
		}
	}
});
/**
 * The UI Element for importing pedigrees from text representationin various formats
 *
 * @class ImportSelector
 */
var ImportSelector = Class.create({

	initialize: function () {
		if (editor.isReadOnlyMode()) return;

		var _this = this;

		var mainDiv = new Element('div', {'class': 'import-selector'});

		var promptImport = new Element('div', {'class': 'import-section'}).update("Import data:");
		this.importValue = new Element("textarea", {"id": "import", "value": "", "class": "import-textarea"});
		mainDiv.insert(promptImport).insert(this.importValue);

		if (!!window.FileReader && !!window.FileList) {
			// only show the upload link if browser supports FileReader/DOM File API
			// Of the browsers suported by pedigree editor, IE9 and Safari 4 & 5 do not support file API
			var uploadFileSelector = new Element('input', {"type": "file", "id": 'pedigreeInputFile', "style": 'display:none'});
			uploadFileSelector.observe('change', function (event) {
				_this.handleFileUpload(this.files);
				try {
					this.value = "";  // clear file selector
				} catch (err) {
					// some older browsers do not allow setting value of a file input element and may generate a security error
				}
			})
			var uploadButton = new Element('input', {type: 'button', 'value': 'Select a local file to be imported', 'class': 'button'}).wrap('span', {'class': 'buttonwrapper'});
			uploadButton.observe('click', function (event) {
				var fileElem = document.getElementById("pedigreeInputFile");
				fileElem.click();
			})
			mainDiv.insert(uploadFileSelector).insert(uploadButton);
		}

		var _addTypeOption = function (checked, labelText, value) {
			var optionWrapper = new Element('tr');
			var input = new Element('input', {"type": "radio", "value": value, "name": "select-type"});
			input.observe('click', _this.disableEnableOptions);
			if (checked) {
				input.checked = true;
			}
			var label = new Element('label', {'class': 'import-type-label'}).insert(input).insert(labelText);
			optionWrapper.insert(label.wrap('td'));
			return optionWrapper;
		};
		var typeListElement = new Element('table');
		//TODO: typeListElement.insert(_addTypeOption(true,  "Autodetect", "auto"));
		//Commented for GEK(GenomicsEngland)......................................................................
		//typeListElement.insert(_addTypeOption(true, "PED or LINKAGE (pre- or post- makeped)", "ped"));
		//typeListElement.insert(_addTypeOption(false, "GEDCOM", "gedcom"));
		//typeListElement.insert(_addTypeOption(false, "BOADICEA", "BOADICEA"));
		//........................................................................................................
		typeListElement.insert(_addTypeOption(true, "Simple JSON", "simpleJSON"));
		//TODO: typeListElement.insert(_addTypeOption(false, "Phenotips Pedigree JSON", "phenotipsJSON"));

		var promptType = new Element('div', {'class': 'import-section'}).update("Data format:");
		var dataSection2 = new Element('div', {'class': 'import-block'});
		dataSection2.insert(promptType).insert(typeListElement);
		mainDiv.insert(dataSection2);

		var _addConfigOption = function (checked, labelText, value) {
			var optionWrapper = new Element('tr');
			var input = new Element('input', {"type": "radio", "value": value, "name": "select-options" });
			if (checked) {
				input.checked = true;
			}
			var label = new Element('label', {'class': 'import-config-label'}).insert(input).insert(labelText);
			optionWrapper.insert(label.wrap('td'));
			return optionWrapper;
		};
		var configListElement = new Element('table', {id: 'import-type'});
		configListElement.insert(_addConfigOption(true, "Treat non-standard phenotype values as new disorders", "accept"));
		configListElement.insert(_addConfigOption(false, "Treat non-standard phenotype values as \"no information\"", "dontaccept"));

		var markEvaluated = new Element('input', {"type": "checkbox", "value": "1", "name": "mark-evaluated"});
		var markLabel1 = new Element('label', {'class': 'import-mark-label1'}).insert(markEvaluated).insert("Mark all patients with known disorder status with 'documented evaluation' mark").wrap('td').wrap('tr');
		configListElement.insert(markLabel1);
		var markExternal = new Element('input', {"type": "checkbox", "value": "1", "name": "mark-external"});
		markExternal.checked = true;
		var markLabel2 = new Element('label', {'class': 'import-mark-label2'}).insert(markExternal).insert("Save individual IDs as given in the input data as 'external ID'").wrap('td').wrap('tr');
		configListElement.insert(markLabel2);
		//Commented for GEK(GenomicsEngland)
		//var promptConfig = new Element('div', {'class': 'import-section'}).update("Options:");
		var dataSection3 = new Element('div', {'class': 'import-block'});
		//Commented for GEK(GenomicsEngland)
		//dataSection3.insert(promptConfig).insert(configListElement);
		mainDiv.insert(dataSection3);

		//TODO: [x] auto-combine multiple unaffected children when the number of children is greater than [5]

		var buttons = new Element('div', {'class': 'buttons import-block-bottom'});
		buttons.insert(new Element('input', {type: 'button', name: 'import', 'value': 'Import', 'class': 'button', 'id': 'import_button'}).wrap('span', {'class': 'buttonwrapper'}));
		buttons.insert(new Element('input', {type: 'button', name: 'cancel', 'value': 'Cancel', 'class': 'button secondary'}).wrap('span', {'class': 'buttonwrapper'}));
		mainDiv.insert(buttons);

		var cancelButton = buttons.down('input[name="cancel"]');
		cancelButton.observe('click', function (event) {
			_this.hide();
		})
		var importButton = buttons.down('input[name="import"]');
		importButton.observe('click', function (event) {
			_this._onImportStarted();
		})

		var closeShortcut = ['Esc'];
		this.dialog = new PhenoTips.widgets.ModalPopup(mainDiv, {close: {method: this.hide.bind(this), keys: closeShortcut}}, {extraClassName: "pedigree-import-chooser", title: "Pedigree import", displayCloseButton: true});
	},

	/*
	 * Populates the text input box with the selected file content (asynchronously)
	 */
	handleFileUpload: function (files) {
		for (var i = 0, numFiles = files.length; i < numFiles; i++) {
			var nextFile = files[i];
			console.log("loading file: " + nextFile.name + ", size: " + nextFile.size);

			var _this = this;
			var fr = new FileReader();
			fr.onload = function (e) {
				_this.importValue.value = e.target.result;  // e.target.result should contain the text
			};
			fr.readAsText(nextFile);
		}
	},

	/*
	 * Disables unapplicable options on input type selection
	 */
	disableEnableOptions: function () {
		var importType = $$('input:checked[type=radio][name="select-type"]')[0].value;
		//console.log("Import type: " + importType);
		var pedOnlyOptions = $$('input[type=radio][name="select-options"]');
		for (var i = 0; i < pedOnlyOptions.length; i++) {
			if (importType != "ped") {
				pedOnlyOptions[i].disabled = true;
			} else {
				pedOnlyOptions[i].disabled = false;
			}
		}
		var pedAndGedcomOption = $$('input[type=checkbox][name="mark-evaluated"]')[0];
		if (importType != "ped" && importType != "gedcom") {
			pedAndGedcomOption.disabled = true;
		} else {
			pedAndGedcomOption.disabled = false;
		}

		var saveExternalID = $$('input[type=checkbox][name="mark-external"]')[0];
		if (importType == "simpleJSON") {
			saveExternalID.disabled = true;
		} else {
			saveExternalID.disabled = false;
		}
	},

	/**
	 * Loads the template once it has been selected
	 *
	 * @param event
	 * @param pictureBox
	 * @private
	 */
	_onImportStarted: function () {
		var importValue = this.importValue.value;
		console.log("Importing:\n" + importValue);

		this.hide();

		if (!importValue || importValue == "") {
			alert("Nothing to import!");
			return;
		}

		var importType = $$('input:checked[type=radio][name="select-type"]')[0].value;
		console.log("Import type: " + importType);

		//commented for GEL(GenomicsEngland), as options are removed form UI and we just support JSON import
		var importMark = [];//$$('input[type=checkbox][name="mark-evaluated"]')[0].checked;

		//commented for GEL(GenomicsEngland), as options are removed form UI and we just support JSON import
		var externalIdMark = [];//$$('input[type=checkbox][name="mark-external"]')[0].checked;

		//commented for GEL(GenomicsEngland), as options are removed form UI and we just support JSON import
		//var optionSelected = $$('input:checked[type=radio][name="select-options"]')[0].value;

		//commented for GEL(GenomicsEngland), as options are removed form UI and we just support JSON import
		var acceptUnknownPhenotypes =[];// (optionSelected == "accept");

		var importOptions = { "markEvaluated": importMark, "externalIdMark": externalIdMark, "acceptUnknownPhenotypes": acceptUnknownPhenotypes };

		editor.getSaveLoadEngine().createGraphFromImportData(importValue, importType, importOptions,
			false /* add to undo stack */, true /*center around 0*/);
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	show: function () {
		this.dialog.show();
	},

	/**
	 * Removes the the template selector
	 *
	 * @method hide
	 */
	hide: function () {
		this.importValue.value = "";
		this.dialog.closeDialog();
	}
});
/**
 * The UI Element for exporting pedigrees
 *
 * @class ExportSelector
 */
var ExportSelector = Class.create({

	initialize: function () {
		var _this = this;

		var mainDiv = new Element('div', {'class': 'import-selector'});

		var _addTypeOption = function (checked, labelText, value) {
			var optionWrapper = new Element('tr');
			var input = new Element('input', {"type": "radio", "value": value, "name": "export-type"});
			input.observe('click', _this.disableEnableOptions);
			if (checked) {
				input.checked = true;
			}
			var label = new Element('label', {'class': 'import-type-label'}).insert(input).insert(labelText);
			optionWrapper.insert(label.wrap('td'));
			return optionWrapper;
		};
		var typeListElement = new Element('table');
		typeListElement.insert(_addTypeOption(true, "Simple JSON", "simpleJSON"));
		//Commented for GEK(GenomicsEngland)
		//typeListElement.insert(_addTypeOption(false, "PED", "ped"));
		//Commented for GEK(GenomicsEngland)
		//typeListElement.insert(_addTypeOption(false, "BOADICEA", "BOADICEA"));
		//TODO: typeListElement.insert(_addTypeOption(false, "Phenotips Pedigree JSON", "phenotipsJSON"));

		var fileDownload = new Element('a', {"id": 'downloadLink', "style": 'display:none'});
		mainDiv.insert(fileDownload);

		var promptType = new Element('div', {'class': 'import-section'}).update("Data format:");
		var dataSection2 = new Element('div', {'class': 'import-block'});
		dataSection2.insert(promptType).insert(typeListElement);
		mainDiv.insert(dataSection2);

		var _addConfigOption = function (checked, name, cssClass, labelText, value) {
			var optionWrapper = new Element('tr');
			var input = new Element('input', {"type": "radio", "value": value, "name": name });
			if (checked) {
				input.checked = true;
			}
			var label = new Element('label', {'class': cssClass}).insert(input).insert(labelText);
			optionWrapper.insert(label.wrap('td'));
			return optionWrapper;
		};
		var configListElementJSON = new Element('table', {"id": "jsonOptions", "style": 'display:none'});
		configListElementJSON.insert(_addConfigOption(true, "export-options", "import-config-label", "All data", "all"));
		configListElementJSON.insert(_addConfigOption(false, "export-options", "import-config-label", "Remove personal information (name and age)", "nopersonal"));
		configListElementJSON.insert(_addConfigOption(false, "export-options", "import-config-label", "Remove personal information and free-form comments", "minimal"));

		var configListElementPED = new Element('table', {"id": "pedOptions"});
		var label = new Element('label', {'class': 'export-config-header'}).insert("How should person IDs be assigned in the generated file?");
		configListElementPED.insert(label.wrap('td').wrap('tr'));
		configListElementPED.insert(_addConfigOption(true, "ped-options", "export-subconfig-label", "Using External IDs (when available)", "external"));
		configListElementPED.insert(_addConfigOption(false, "ped-options", "export-subconfig-label", "Generate new numeric IDs", "newid"));
		configListElementPED.insert(_addConfigOption(false, "ped-options", "export-subconfig-label", "Using Names (when available)", "name"));

		var promptConfig = new Element('div', {'class': 'import-section'}).update("Options:");
		var dataSection3 = new Element('div', {'class': 'import-block'});
		dataSection3.insert(promptConfig).insert(configListElementJSON).insert(configListElementPED);
		mainDiv.insert(dataSection3);

		var buttons = new Element('div', {'class': 'buttons import-block-bottom'});
		buttons.insert(new Element('input', {type: 'button', name: 'export', 'value': 'Export', 'class': 'button', 'id': 'export_button'}).wrap('span', {'class': 'buttonwrapper'}));
		buttons.insert(new Element('input', {type: 'button', name: 'cancel', 'value': 'Cancel', 'class': 'button secondary'}).wrap('span', {'class': 'buttonwrapper'}));
		mainDiv.insert(buttons);

		var cancelButton = buttons.down('input[name="cancel"]');
		cancelButton.observe('click', function (event) {
			_this.hide();
		})
		var exportButton = buttons.down('input[name="export"]');
		exportButton.observe('click', function (event) {
			_this._onExportStarted();
		})

		var closeShortcut = ['Esc'];
		this.dialog = new PhenoTips.widgets.ModalPopup(mainDiv, {close: {method: this.hide.bind(this), keys: closeShortcut}}, {extraClassName: "pedigree-import-chooser", title: "Pedigree export", displayCloseButton: true});
	},

	/*
	 * Disables unapplicable options on input type selection
	 */
	disableEnableOptions: function () {
		var exportType = $$('input:checked[type=radio][name="export-type"]')[0].value;

		var pedOptionsTable = $("pedOptions");
		var jsonOptionsTable = $("jsonOptions");

		if (exportType == "ped" || exportType == "BOADICEA") {
			pedOptionsTable.show();
			var idgenerator = $$('input[type=radio][name="ped-options"]')[2];
			// disable using names as IDs - not necessary for BOADICEA which suports a dedicated column for the name
			if (exportType == "BOADICEA") {
				if (idgenerator.checked) {
					$$('input[type=radio][name="ped-options"]')[0].checked = true;
				}
				idgenerator.up().hide();
			} else {
				idgenerator.up().show();
			}
			jsonOptionsTable.hide();
		} else {
			pedOptionsTable.hide();
			jsonOptionsTable.show();
		}
	},

	/**
	 * Loads the template once it has been selected
	 *
	 * @param event
	 * @param pictureBox
	 * @private
	 */
	_onExportStarted: function () {
		this.hide();

		var webService = new WebService();
		var patientDocument = webService.getParticipantId();//XWiki.currentDocument.page + "_pedigree";
		if(patientDocument == null || patientDocument == undefined){
			patientDocument = "participant";
		}

		var exportType = $$('input:checked[type=radio][name="export-type"]')[0].value;
		//console.log("Import type: " + exportType);

		if (exportType == "simpleJSON") {
			var privacySetting = $$('input:checked[type=radio][name="export-options"]')[0].value;
			var exportString = PedigreeExport.exportAsSimpleJSON(editor.getGraph().DG, privacySetting);
			var fileName = patientDocument + "_pedigree.json";
			var mimeType = "application/json";
		} else {
			var idGenerationSetting = $$('input:checked[type=radio][name="ped-options"]')[0].value;
			if (exportType == "ped") {
				var exportString = PedigreeExport.exportAsPED(editor.getGraph().DG, idGenerationSetting);
				var fileName = patientDocument + ".ped";
			} else if (exportType == "BOADICEA") {
				var exportString = PedigreeExport.exportAsBOADICEA(editor.getGraph(), idGenerationSetting);
				var fileName = patientDocument + ".txt";
			}
			var mimeType = "text/plain";
		}

		console.log("Export data: >>" + exportString + "<<");
		if (exportString != "") {
			FileSaver.saveTextAs(exportString, fileName);
		}
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	show: function () {
		this.dialog.show();
	},

	/**
	 * Removes the the template selector
	 *
	 * @method hide
	 */
	hide: function () {
		this.dialog.closeDialog();
	}
});

/**
 * AbstractHoverbox is an abstract class for all the UI elements and graphics surrounding a node on the canvas (a Person
 * or a partnership). This includes the box that appears around the node when it's hovered by a mouse, as
 * well as the handles used for creating connections and creating new nodes.
 *
 * @class AbstractHoverbox
 * @constructor
 * @param {AbstractNode} node The node Person or Partnership for which the hoverbox is drawn
 * @param {Number} x The x coordinate for the hoverbox
 * @param {Number} y The y coordinate for the hoverbox
 * @param {Number} width The width in pixels
 * @param {Number} height The height in pixels
 * @param {Number} nodeX The x coordinate of the node for which the hoverbox is drawn
 * @param {Number} nodeY The y coordinate of the node for which the hoverbox is drawn
 * @param {Raphael.st} nodeShapes Raphaël set containing the graphical elements that make up the node
 */
var AbstractHoverbox = Class.create({

	initialize: function (node, shiftX, shiftY, width, height, nodeX, nodeY, nodeShapes) {
		//var timer = new Helpers.Timer();
		var me = this;
		this._node = node;
		this._relativeX = shiftX;
		this._relativeY = shiftY;
		this._nodeX = nodeX;
		this._nodeY = nodeY;
		this._hidden = true;
		this._enabled = false;
		this._width = width;
		this._height = height;
		this._isHovered = false;
		this._currentHandles = null;
		this._currentOrbs = null;
		this._currentButtons = null;
		this._handlesZoomSz = null;
		this._boxOnHover = editor.getPaper().rect(this.getX(), this.getY(), this._width, this._height, 5).attr(PedigreeEditorParameters.attributes.boxOnHover);
		this._boxOnHover.node.setAttribute("class", "pedigree-hoverbox");
		this._backElements = editor.getPaper().set(this._boxOnHover);
		this._mask = this._boxOnHover.clone().attr({fill: 'green', opacity: 0});
		this._frontElements = editor.getPaper().set().push(this._mask);

		var nodeShapeSet = nodeShapes.flatten();
		this._backElements.insertBefore(nodeShapeSet);
		this._frontElements.insertAfter(nodeShapeSet);

		this.animateDrawHoverZone = this.animateDrawHoverZone.bind(this);
		this.animateHideHoverZone = this.animateHideHoverZone.bind(this);
		// hide initially
		this.getBoxOnHover().attr({opacity: 0});
		this.enable();
		//timer.printSinceLast("=== abstract howerbox runtime: ");
		this._isMenuToggled = false;
		this._justClosedMenu = false;
	},

	/**
	 * Returns the x coordinate of the hoverbox
	 *
	 * @method getX
	 * @return {Number} The x coordinate in pixels
	 */
	getX: function () {
		return this.getNodeX() + this._relativeX;
	},

	/**
	 * Returns the y coordinate of the hoverbox
	 *
	 * @method getY
	 * @return {Number} The y coordinate in pixels
	 */
	getY: function () {
		return this.getNodeY() + this._relativeY;
	},

	/**
	 * Returns the x coordinate of the attached node
	 *
	 * @method getNodeX
	 * @return {Number} The x coordinate in pixels
	 */
	getNodeX: function () {
		// note: during construction getGraphics() isnot yet available, so need to store nodeX.
		//       however node may have been moved later, in which case we need to use current graphics X
		var nodeGraphics = this.getNode().getGraphics();
		if (nodeGraphics)
			this._nodeX = nodeGraphics.getX();
		return this._nodeX;
	},

	/**
	 * Returns the y coordinate of the attached node
	 *
	 * @method getNodeY
	 * @return {Number} The y coordinate in pixels
	 */
	getNodeY: function () {
		var nodeGraphics = this.getNode().getGraphics();
		if (nodeGraphics)
			this._nodeY = nodeGraphics.getY();
		return this._nodeY;
	},

	/**
	 * Returns the width of the hoverbox
	 *
	 * @method getWidth
	 * @return {Number} The width in pixels
	 */
	getWidth: function () {
		return this._width;
	},

	/**
	 * Returns the height of the hoverbox
	 *
	 * @method getHeight
	 * @return {Number} The height in pixels
	 */
	getHeight: function () {
		return this._height;
	},

	/**
	 * Returns the node for which the hoverbox is drawn
	 *
	 * @method getNode
	 * @return {AbstractNode} Can be either a Partnership or a Person
	 */
	getNode: function () {
		return this._node;
	},

	/**
	 * Creates the buttons used in this hoverbox
	 *
	 * @method generateButtons
	 * @return {Raphael.st} A set of buttons
	 */
	generateButtons: function () {
		if (this._currentButtons !== null) return;
		this._currentButtons = [];
	},

	regenerateButtons: function () {
		this.removeButtons();
		this.generateButtons();
	},

	removeButtons: function () {
		if (!this._currentButtons) return;

		var enableState = this._enabled;

		enableState && this.disable();
		for (var i = 0; i < this._currentButtons.length; i++) {
			this.getFrontElements().exclude(this._currentButtons[i]);
			this._currentButtons[i].remove();
		}
		this._currentButtons = null;
		enableState && this.enable();
	},

	hideButtons: function () {
		if (!this._currentButtons) return;
		for (var i = 0; i < this._currentButtons.length; i++) {
			if (this._currentButtons[i].hasOwnProperty("mask")) {
				this._currentButtons[i].mask.attr(PedigreeEditorParameters.attributes.btnMaskHoverOff);
			}
			this._currentButtons[i].hide();
		}
	},

	showButtons: function () {
		if (!this._currentButtons) return;
		for (var i = 0; i < this._currentButtons.length; i++) {
			this._currentButtons[i].show();
		}
	},

	/**
	 * Returns Raphael set of the buttons in this hoverbox
	 *
	 * @method getCurrentButtons
	 * @return {Raphael.st} A set of buttons
	 */
	getCurrentButtons: function () {
		return this._currentButtons;
	},

	/**
	 * Removes all handles currently used in this hoverbox
	 *
	 * @method removeHandles
	 */
	removeHandles: function () {
		if (!this._currentHandles) return;

		var enableState = this._enabled;
		enableState && this.disable();
		for (var i = 0; i < this._currentOrbs.length; i++)
			this.getFrontElements().exclude(this._currentOrbs[i]);
		this._currentOrbs = null;
		enableState && this.enable();

		for (var i = 0; i < this._currentHandles.length; i++)
			this._currentHandles[i].remove();
		this._currentHandles = null;
	},

	hideHandles: function () {
		if (!this._currentHandles) return;
		for (var i = 0; i < this._currentHandles.length; i++)
			this._currentHandles[i].hide();
	},

	showHandles: function () {
		if (!this._currentHandles) return;
		for (var i = 0; i < this._currentHandles.length; i++)
			this._currentHandles[i].show();
	},

	/**
	 * Creates the handles used in this hoverbox. Returns a list of handles
	 *
	 * @method generateHandles
	 */
	generateHandles: function () {
		if (this._currentHandles !== null) return;
		this._currentHandles = [];
		this._currentOrbs = [];
		this._handlesZoomSz = editor.getWorkspace().getCurrentZoomLevel();
	},

	/**
	 * Iff handles are present, removes all and creates new set of handles
	 *
	 * @method regenerateHandles
	 */
	regenerateHandles: function () {
		if (this._currentHandles)
			this.removeHandles();
		if (!this._hidden || this.isMenuToggled())
			this.generateHandles();
	},

	/**
	 * Generates a button and places it on the hoverbox
	 *
	 * @method createButton
	 * @param {Number} x The x coordinate of the button
	 * @param {Number} y The y coordinate of the button
	 * @param {String|Array} svgPath The svg path for the button (correctly scaled)
	 * @param {Object} svgPathBBox The BBox for the svg path. Precomputed for performance reasons
	 * @param attributes The svg attributes
	 * @param {Function} onClick Callback for the button
	 * @param {String} className The class attribute for the button
	 *
	 * @return {Raphael.st} The generated button
	 */
	createButton: function (x, y, svgPath, svgPathBBox, attributes, onClick, className, title) {
		var icon = editor.getPaper().path(svgPath).attr(attributes);
		icon.transform(["t" , x , y]);

		// manually compute the size of the mask because Raphael.transform() is exptremely slow
		var xShift = svgPathBBox.width / 4;
		var yShift = svgPathBBox.height / 4;
		var newWidth = svgPathBBox.width * 1.5;
		var newHeight = svgPathBBox.height * 1.5;
		var mask = editor.getPaper().rect(x + svgPathBBox.x - xShift, y + svgPathBBox.y - yShift, newWidth, newHeight, 1);
		mask.attr({fill: 'gray', opacity: 0, "stroke-width": 0});

		var button = editor.getPaper().set(mask, icon).toFront();

		var me = this;
		var clickFunct = function () {
			if (me._hidden) {
				button.isClicked = false;
				return;
			}
			button.isClicked = !button.isClicked;
			if (button.isClicked) {
				mask.attr(PedigreeEditorParameters.attributes.btnMaskClick);
			}
			else {
				mask.attr(PedigreeEditorParameters.attributes.btnMaskHoverOn);
			}
			onClick && onClick();
		};
		button.click(clickFunct);
		button.mousedown(function () {
			mask.attr(PedigreeEditorParameters.attributes.btnMaskClick)
		});
		button.hover(function () {
				//console.log("button hover");
				mask.attr(PedigreeEditorParameters.attributes.btnMaskHoverOn);
				if (title)
					mask.attr({"title": title});
			},
			function () {
				//console.log("button unhover");
				mask.attr(PedigreeEditorParameters.attributes.btnMaskHoverOff);
			});
		className && button.forEach(function (element) {
			element.node.setAttribute('class', className);
		});
		button.icon = icon;
		button.mask = mask;
		if (this._hidden && !this.isMenuToggled())
			button.hide();

		this._currentButtons.push(button);
		this.disable();
		this.getFrontElements().push(button);
		this.enable();
	},

	/**
	 * Creates a show-menu button
	 *
	 * @method generateMenuBtn
	 * @return {Raphael.st} The generated button
	 */
	generateMenuBtn: function () {
		var me = this;
		var action = function () {
			me.toggleMenu(!me.isMenuToggled());
		};
		var attributes = PedigreeEditorParameters.attributes.menuBtnIcon;
		var x = this.getX() + this.getWidth() - 20 - this.getWidth() / 40;
		var y = this.getY() + this.getHeight() / 40;
		this.createButton(x, y, editor.getView().__menuButton_svgPath, editor.getView().__menuButton_BBox,
			attributes, action, "menu-trigger", "node properties");

	},
	/**
	 * Creates and returns a delete button (big red X).
	 *
	 * @method generateDeleteBtn
	 * @return {Raphael.st} the generated button
	 */
	generateDeleteBtn: function () {
		var me = this;
		var action = function () {
			me.animateHideHoverZone();
			var event = { "nodeID": me.getNode().getID() };
			document.fire("pedigree:node:remove", event);
		};
		var attributes = PedigreeEditorParameters.attributes.deleteBtnIcon;
		var x = this.getX() + this.getWidth() - 20 - this.getWidth() / 40;
		var y = this.getY() + this.getHeight() / 40;
		this.createButton(x, y, editor.getView().__deleteButton_svgPath, editor.getView().__deleteButton_BBox,
			attributes, action, "delete", "remove node");
	},

	/**
	 * Returns the gray box that appears when the node is hovered
	 *
	 * @method getBoxOnHover
	 * @return {Raphael.el} Raphael rectangle element
	 */
	getBoxOnHover: function () {
		return this._boxOnHover;
	},

	/**
	 * Returns true box if the hoverbox is currently hovered
	 *
	 * @method isHovered
	 * @return {Boolean} Raphael rectangle element
	 */
	isHovered: function () {
		return this._isHovered;
	},

	/**
	 * Sets the hovered property to isHovered.
	 * @method setHovered
	 * @param {Boolean} isHovered Set to true if the box is hovered
	 */
	setHovered: function (isHovered) {
		this._isHovered = isHovered;
	},

	/**
	 * Enbales or disables the highlighting of the node
	 * @method setHighlighted
	 * @param {Boolean} isHighlighted Set to true enables green highlight box, false disables it
	 */
	setHighlighted: function (isHighlighted) {
		// autoimaticaly highlight and unhighlight the node being dragged over
		if (isHighlighted) {
			this.getBoxOnHover().attr(PedigreeEditorParameters.attributes.boxOnHover);
			this.getBoxOnHover().attr("fill", "green");
		}
		else {
			this.getBoxOnHover().attr(PedigreeEditorParameters.attributes.boxOnHover).attr('opacity', 0);
		}
	},

	/**
	 * Returns the invisible mask layer in front of the hoverbox
	 *
	 * @method getHoverZoneMask
	 * @return {Raphael.el} Raphael rectangle
	 */
	getHoverZoneMask: function () {
		return this._mask;
	},

	/**
	 * Returns a Raphael set containing all hoverbox elements that are layered
	 * in front of the node graphics
	 *
	 * @method getFrontElements
	 * @return {Raphael.st} set of Raphael elements
	 */
	getFrontElements: function () {
		return this._frontElements;
	},

	/**
	 * Returns a Raphael set containing all hoverbox elements that are layered
	 * behind of the node graphics
	 *
	 * @method getBackElements
	 * @return {Raphael.st} set of Raphael elements
	 */
	getBackElements: function () {
		return this._backElements;
	},

	/**
	 * Creates a handle with a blue orb from the center of the node and places it behind the node icon
	 *
	 * @method generateHandle
	 * @param {String} type Should be 'parent', 'child' or 'partner'
	 * @param {Number} orbX The x coordinate of the orb
	 * @param {Number} orbY The y coordinate of the orb
	 * @return {Raphael.st} Raphael set of elements that make up the handle
	 */
	generateHandle: function (type, startX, startY, orbX, orbY, title, orbShapeGender, toHide) {
		if (!orbShapeGender)
			orbShapeGender = "F";
		var strokeWidth = editor.getWorkspace().getSizeNormalizedToDefaultZoom(PedigreeEditorParameters.attributes.handleStrokeWidth);
		var path = [
			["M", startX, startY],
			["L", orbX, orbY]
		];
		var connection = editor.getPaper().path(path).attr({"stroke-width": strokeWidth, stroke: "gray"}).toBack();
		connection.oPath = path;

		var touchPresent = "createTouch" in document;

		var orbRadius = touchPresent ? PedigreeEditorParameters.attributes.touchOrbRadius : PedigreeEditorParameters.attributes.orbRadius;
		var orbHue = PedigreeEditorParameters.attributes.orbHue;

		var normalOrbAttr = (orbShapeGender != "F") ? {fill: "0-hsb(" + orbHue + ", 1, .75)-hsb(" + orbHue + ", .5, .25)", stroke: "#555", "stroke-width": "0.75"}
			: {fill: "r(.5,.9)hsb(" + orbHue + ", 1, .75)-hsb(" + orbHue + ", .5, .25)", stroke: "none"};
		var selectedOrbAttr = (orbShapeGender != "F") ? {fill: "0-hsb(" + (orbHue + .36) + ", 1, .75)-hsb(" + (orbHue + .36) + ", .5, .25)"}
			: {fill: "r(.5,.9)hsb(" + (orbHue + .36) + ", 1, .75)-hsb(" + (orbHue + .36) + ", .5, .25)"};
		var orbAttrX = (orbShapeGender != "F") ? "x" : "cx";
		var orbAttrY = (orbShapeGender != "F") ? "y" : "cy";

		var orb = GraphicHelpers.generateOrb(editor.getPaper(), orbX, orbY, orbRadius * 1.1, orbShapeGender).attr("cursor", "pointer");
		orb[0].attr(normalOrbAttr);

		var handle = editor.getPaper().set().push(connection, orb);
		handle.type = type;
		connection.insertBefore(this.getHoverZoneMask());
		orb.toFront();

		var me = this;
		var inHoverMode = false;
		var interactionStarted = false;

		var onDragHandle = function () {
			if (!inHoverMode) {
				//console.log("on drag");
				inHoverMode = true;
				if (editor.getView().getCurrentDraggable() !== null)
					editor.getView().enterHoverMode(me.getNode(), type);
				toHide && toHide.hide();
			}
		};

		// is true when any button other than the left mouse button is presses
		var wrongClick = false;
		var start = function (x, y, e) {
			if (interactionStarted) return;
			interactionStarted = true;

			//console.log("handle: start: " + e.button);
			wrongClick = false;
			if (e.button != 0) {
				interactionStarted = false;
				wrongClick = true;
				return;
			}
			connection.toFront();
			orb.stop();
			orb.toFront();
			inHoverMode = false;
			me.disable();
			me.getFrontElements().toFront();
			if (!orb.ot) {
				orb.ot = orb[0].transform();
				orb.ox = orb[0].attr(orbAttrX);
				orb.oy = orb[0].attr(orbAttrY);
			} else {
				// revert to base transformation if next click started while "end" animation was still running
				orb.transform("");
				orb.attr(orbAttrX, orb.ox);
				orb.attr(orbAttrY, orb.oy);
				orb.transform(orb.ot);
			}
			connection.ox = connection.oPath[1][1];
			connection.oy = connection.oPath[1][2];
			handle.isDragged = false;
			editor.getView().setCurrentDraggable(me.getNode().getID());
			// highlight valid targets (after a small delay - so that nothing gets annoyingly highlighted
			// and instantly un-highlighted if the person just clicks the orb without dragging)
			setTimeout(onDragHandle, 100);
		};
		var move = function (dx, dy) {
			if (wrongClick) return;
			if (!interactionStarted) return;
			//console.log("handle: move");
			onDragHandle();
			dx = dx / editor.getWorkspace().zoomCoefficient;
			dy = dy / editor.getWorkspace().zoomCoefficient;
			(orb.ot.length > 0) && orb.transform("");
			orb.attr(orbAttrX, orb.ox + dx);
			orb.attr(orbAttrY, orb.oy + dy);
			(orb.ot.length > 0) && orb.transform(orb.ot);
			connection.oPath[1][1] = connection.ox + dx;
			connection.oPath[1][2] = connection.oy + dy;
			connection.attr("path", connection.oPath);
			if (dx > 1 || dx < -1 || dy > 1 || dy < -1) {
				handle.isDragged = true;
			}
			//console.log("currentHover: " + editor.getView()._currentHoveredNode + ", currentDrag: " + editor.getView()._currentDraggable);
		};
		var end = function () {
			inHoverMode = false;
			interactionStarted = false;
			if (wrongClick) return;

			var curHoveredId = editor.getView().getCurrentHoveredNode();

			editor.getView().setCurrentDraggable(null);
			editor.getView().exitHoverMode();

			if (handle.isDragged) {
				if (orb.ot.length == 0) {
					var finalPosition = {};
					finalPosition[orbAttrX] = orb.ox;
					finalPosition[orbAttrY] = orb.oy;
					orb.animate(finalPosition, 1000, "elastic", function () {
					});
				}
				else {
					// animation for shapes with transformations (movement and animation via transform() could have been
					// used in all cases, but works noticeably slower than plain coordinate manipulation in some browsers)
					var dx = orb.ox - orb[0].attr(orbAttrX);
					var dy = orb.oy - orb[0].attr(orbAttrY);
					orb.animate({"transform": "T" + dx + "," + dy + "R45"}, 1000, "elastic", function () {
						orb.transform("");
						orb.attr(orbAttrX, orb.ox);
						orb.attr(orbAttrY, orb.oy);
						orb.transform(orb.ot);
					});
				}
			}

			console.log("handle.isDragged: " + handle.isDragged + ", currentHover: " + curHoveredId);
			connection.oPath[1][1] = connection.ox;
			connection.oPath[1][2] = connection.oy;
			connection.animate({"path": connection.oPath}, 1000, "elastic");
			orb[0].attr(normalOrbAttr);
			connection.insertBefore(me.getHoverZoneMask());

			me.enable();

			if (!handle.isDragged || curHoveredId != null)
				me.handleAction(handle.type, handle.isDragged, curHoveredId);
		};

		orb.drag(move, start, end);
		orb.hover(function () {
				//console.log("orbon hover");
				orb[0].attr(selectedOrbAttr);
				if (title) {
					orb[0].attr({"title": title});
					orb[1].attr({"title": title});
				}
			},
			function () {
				orb[0].attr(normalOrbAttr);
			});

		this._currentOrbs.push(orb[0]);
		this._currentOrbs.push(orb[1]);
		this.disable();
		//this.getFrontElements().forEach(function(el) { console.log("o"); });
		//console.log("Orb: " + orb);
		this.getFrontElements().push(orb[0]);
		this.getFrontElements().push(orb[1]);
		//this.getFrontElements().forEach(function(el) { console.log("*"); });
		this.enable();

		//handle.getType = function() {
		//    return type;
		//};
		return handle;
	},

	/**
	 * Returns true if the menu for this node is open
	 *
	 * @method isMenuToggled
	 * @return {Boolean}
	 */
	isMenuToggled: function () {
		return false;
	},

	/*
	 * Fades the hoverbox graphics in
	 *
	 * @method animateDrawHoverZone
	 */
	animateDrawHoverZone: function () {
		if (editor.getView().getCurrentDraggable() !== null) return; // do not redraw when dragging
		this._hidden = false;
		//console.log("node: " + this.getNode().getID() + " -> show HB");

		this.getNode().getGraphics().setSelected(true);
		this.getBoxOnHover().stop().animate({opacity: 0.7}, 200);

		this.generateButtons();
		this.showButtons();
		this.getCurrentButtons().forEach(function (button) {
			if (button.hasOwnProperty("icon")) {
				button.icon.stop().animate({opacity: 1}, 200);
			}
		});

		if (this._handlesZoomSz != editor.getWorkspace().getCurrentZoomLevel())
			this.removeHandles();
		this.generateHandles();
		this.showHandles();
	},

	/**
	 * Fades the hoverbox graphics out
	 *
	 * @method animateHideHoverZone
	 */
	animateHideHoverZone: function () {
		if (editor.getView().getCurrentDraggable() !== null) return; // do not hide when dragging
		this._hidden = true;
		//console.log("node: " + this.getNode().getID() + " -> hide HB");

		this.getNode().getGraphics().setSelected(false);
		this.getBoxOnHover().stop().animate({opacity: 0}, 200);

		this.hideButtons();
		//this.removeHandles();  // does not work, since hideHoverZone is triggered when a mouse is over an orb (to fix?)
		this.hideHandles();
	},

	/**
	 * Stops the hoverbox from responding to mouseovers
	 *
	 * @method disable
	 */
	disable: function () {
		//console.log("disable HB");
		this._enabled = false;
		this.getFrontElements().unhover(this.animateDrawHoverZone, this.animateHideHoverZone);
	},

	/**
	 * Attaches onMouseOver behavior to the hoverbox
	 *
	 * @method enable
	 */
	enable: function () {
		this._enabled = true;
		//console.log("enable HB");
		//this.getFrontElements().forEach(function(el) { console.log("."); });
		this.getFrontElements().hover(this.animateDrawHoverZone, this.animateHideHoverZone);
	},

	/**
	 * Deletes the hoverbox
	 *
	 * @method remove
	 */
	remove: function () {
		this.disable();
		this.removeButtons();
		this.removeHandles();
		this.getBackElements().remove();
		this.getFrontElements().remove();
	},

	/**
	 * Updates the hoverbox behavior after a widget (like the menu) is closed
	 *
	 * @method onWidgetHide
	 */
	onWidgetHide: function () {
		this._isMenuToggled = false;
		// prevent menu from closing and opening right away upon a click on the menu button while menu is open
		this._justClosedMenu = true;
		var me = this;
		setTimeout(function () {
			me._justClosedMenu = false;
		}, 100);

		if (this._hidden)
			this.animateHideHoverZone();
		else
			this.animateDrawHoverZone();
	},

	onWidgetShow: function () {
		this._isMenuToggled = true;
	}
});

/**
 * A stub hoverbox used when generating read-only pedigrees
 */
var ReadOnlyHoverbox = Class.create(AbstractHoverbox, {

	initialize: function ($super, node, x, y, shapes) {
		this._node = node;
		this._nodeX = x;
		this._nodeY = y;
		this._shapes = editor.getPaper().set();
	},

	getWidth: function () {
		return 0;
	},

	getHeight: function () {
		return 0;
	},

	getNode: function () {
		return this._node;
	},

	generateButtons: function () {
	},

	removeButtons: function () {
	},

	hideButtons: function () {
	},

	showButtons: function () {
	},

	getCurrentButtons: function () {
		return this._currentButtons;
	},

	removeHandles: function () {
	},

	hideHandles: function () {
	},

	showHandles: function () {
	},

	generateHandles: function () {
	},

	regenerateHandles: function () {
	},

	getBoxOnHover: function () {
		return null;
	},

	isHovered: function () {
		return false;
	},

	setHovered: function (isHovered) {
	},

	setHighlighted: function (isHighlighted) {
	},

	getHoverZoneMask: function () {
		return null;
	},

	getFrontElements: function () {
		return this._shapes;
	},

	getBackElements: function () {
		return this._shapes;
	},

	isMenuToggled: function () {
		return false;
	},

	animateDrawHoverZone: function () {
	},

	animateHideHoverZone: function () {
	},

	disable: function () {
	},

	enable: function () {
	},

	remove: function () {
	},

	onWidgetHide: function () {
	},

	onWidgetShow: function () {
	}
});

/**
 * PartnershipHoverbox is a class for all the UI elements and graphics surrounding a Partnership node and
 * its labels. This includes the box that appears around the node when it's hovered by a mouse, as
 * well as the handles used for creating connections and creating new nodes.
 *
 * @class PartnershipHoverbox
 * @extends AbstractHoverbox
 * @constructor
 * @param {Partnership} partnership The Partnership for which the hoverbox is drawn
 * @param {Number} junctionX The x coordinate around which the partnership bubble is centered
 * @param {Number} junctionY The y coordinate around which the partnership bubble is centered
 * @param {Raphael.st} shapes Raphaël set containing the graphical elements that make up the node
 */
var PartnershipHoverbox = Class.create(AbstractHoverbox, {

	initialize: function ($super, partnership, junctionX, junctionY, nodeShapes) {
		var radius = PedigreeEditorParameters.attributes.radius;
		$super(partnership, -radius * 0.65, -radius * 0.8, radius * 1.3, radius * 2.3, junctionX, junctionY, nodeShapes);
		this._isMenuToggled = false;
	},

	/**
	 * Creates the handles used in this hoverbox
	 *
	 * @method generateHandles
	 * @return {Raphael.st} A set of handles
	 */
	generateHandles: function ($super) {
		if (this._currentHandles !== null) return;
		$super();

		if (this.getNode().getChildlessStatus() == 'Infertile') return;

		var x = this.getNodeX();
		var y = this.getNodeY();
		var strokeWidth = editor.getWorkspace().getSizeNormalizedToDefaultZoom(PedigreeEditorParameters.attributes.handleStrokeWidth);

		editor.getPaper().setStart();
		//static part (going right below the node)
		var path = [
			["M", x, y],
			["L", x, y + PedigreeEditorParameters.attributes.partnershipHandleBreakY]
		];
		editor.getPaper().path(path).attr({"stroke-width": strokeWidth, stroke: "gray"}).insertBefore(this.getNode().getGraphics().getJunctionShape());
		this.generateHandle('child', x, y + PedigreeEditorParameters.attributes.partnershipHandleBreakY, x, y + PedigreeEditorParameters.attributes.partnershipHandleLength);

		this._currentHandles.push(editor.getPaper().setFinish());
	},

	/**
	 * Creates the buttons used in this hoverbox
	 *
	 * @method generateButtons
	 */
	generateButtons: function ($super) {
		if (this._currentButtons !== null) return;
		$super();
		this.generateDeleteBtn();
		this.generateMenuBtn();
	},

	/**
	 * Creates a node-shaped show-menu button
	 *
	 * @method generateMenuBtn
	 * @return {Raphael.st} The generated button
	 */
	generateMenuBtn: function () {
		var me = this;
		var action = function () {
			me.toggleMenu(!me.isMenuToggled());
		};
		var junctionShapedButton = this.getNode().getGraphics().getJunctionShape().clone();
		junctionShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOffPartner);
		junctionShapedButton.click(action);
		junctionShapedButton.hover(function () {
				junctionShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOnPartner)
			},
			function () {
				junctionShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOffPartner)
			});
		junctionShapedButton.attr("cursor", "pointer");
		this._currentButtons.push(junctionShapedButton);
		this.disable();
		this.getFrontElements().push(junctionShapedButton);
		this.enable();
	},

	/**
	 * Returns true if the menu is toggled for this partnership node
	 *
	 * @method isMenuToggled
	 * @return {Boolean}
	 */
	isMenuToggled: function () {
		return this._isMenuToggled;
	},

	/**
	 * Shows/hides the menu for this partnership node
	 *
	 * @method toggleMenu
	 * @param {Boolean} isMenuToggled Set to True to make the menu visible
	 */
	toggleMenu: function (isMenuToggled) {
		if (this._justClosedMenu) return;
		this._isMenuToggled = isMenuToggled;
		if (isMenuToggled) {
			var optBBox = this.getBoxOnHover().getBBox();
			var x = optBBox.x2;
			var y = optBBox.y;
			var position = editor.getWorkspace().canvasToDiv(x + 5, y);
			editor.getPartnershipMenu().show(this.getNode(), position.x, position.y);
		}
	},

	/**
	 * Hides the hoverbox with a fade out animation
	 *
	 * @method animateHideHoverZone
	 */
	animateHideHoverZone: function ($super) {
		this._hidden = true;
		if (!this.isMenuToggled()) {
			$super();
		}
	},

	/**
	 * Displays the hoverbox with a fade in animation
	 *
	 * @method animateDrawHoverZone
	 */
	animateDrawHoverZone: function ($super) {
		this._hidden = false;
		if (!this.isMenuToggled()) {
			$super();
		}
	},

	/**
	 * Performs the appropriate action for clicking on the handle of type handleType
	 *
	 * @method handleAction
	 * @param {String} handleType Can be either "child", "partner" or "parent"
	 * @param {Boolean} isDrag Set to True if the handle is being dragged at the time of the action
	 */
	handleAction: function (handleType, isDrag, curHoveredId) {
		if (isDrag && curHoveredId != null) {
			if (handleType == "child") {
				var event = { "personID": curHoveredId, "parentID": this.getNode().getID() };
				document.fire("pedigree:person:drag:newparent", event);
			}
		}
		else if (!isDrag && handleType == "child") {
			var position = editor.getWorkspace().canvasToDiv(this.getNodeX(), (this.getNodeY() + PedigreeEditorParameters.attributes.partnershipHandleLength + 15));
			var canBeChildless = !editor.getGraph().hasNonPlaceholderNonAdoptedChildren(this.getNode().getID());
			if (canBeChildless)
				editor.getNodetypeSelectionBubble().show(this.getNode(), position.x, position.y);
			else
				editor.getSiblingSelectionBubble().show(this.getNode(), position.x, position.y);
			// if user selects anything the bubble will fire an even on its own
		}
		this.animateHideHoverZone();
	}
});
/**
 * PersonHoverbox is a class for all the UI elements and graphics surrounding a Person node and
 * its labels. This includes the box that appears around the node when it's hovered by a mouse, as
 * well as the handles used for creating connections and creating new nodes.
 *
 * @class PersonHoverbox
 * @extends AbstractHoverbox
 * @constructor
 * @param {Person} personNode The person for whom this hoverbox is being drawn.
 * @param {Number} centerX The X coordinate for the center of the hoverbox
 * @param {Number} centerY The Y coordinate for the center of the hoverbox
 * @param {Raphael.st} nodeShapes All shapes associated with the person node
 */
var PersonHoverbox = Class.create(AbstractHoverbox, {

	initialize: function ($super, personNode, centerX, centerY, nodeShapes) {
		var radius = PedigreeEditorParameters.attributes.personHoverBoxRadius;
		$super(personNode, -radius, -radius, radius * 2, radius * 2, centerX, centerY, nodeShapes);
	},

	/**
	 * Creates the handles used in this hoverbox
	 *
	 * @method generateHandles
	 * @return {Raphael.st} A set of handles
	 */
	generateHandles: function ($super) {
		if (this._currentHandles !== null) return;
		$super();

		//var timer = new Helpers.Timer();

		var x = this.getNodeX();
		var y = this.getNodeY();
		var node = this.getNode();
		var nodeShapes = node.getGraphics().getGenderGraphics().flatten();

		editor.getPaper().setStart();

		if (PedigreeEditorParameters.attributes.newHandles) {
			var strokeWidth = editor.getWorkspace().getSizeNormalizedToDefaultZoom(PedigreeEditorParameters.attributes.handleStrokeWidth);

			var partnerGender = 'U';
			if (node.getGender() == 'F') partnerGender = 'M';
			if (node.getGender() == 'M') partnerGender = 'F';

			// static part (2 lines: going above the node + going to the right)
			var splitLocationY = y - PedigreeEditorParameters.attributes.personHandleBreakY - 4;
			var path = [
				["M", x, y],
				["L", x, splitLocationY],
				["L", x + PedigreeEditorParameters.attributes.personSiblingHandleLengthX, splitLocationY]
			];
			editor.getPaper().path(path).attr({"stroke-width": strokeWidth, stroke: "gray"}).insertBefore(nodeShapes);

			// sibling handle
			this.generateHandle('sibling', x + PedigreeEditorParameters.attributes.personSiblingHandleLengthX - strokeWidth / 3, splitLocationY, x + PedigreeEditorParameters.attributes.personSiblingHandleLengthX - strokeWidth / 2, splitLocationY + PedigreeEditorParameters.attributes.personSiblingHandleLengthY,
				"Click to create a sibling or drag to an existing parentless person (valid choices will be highlighted in green)", "U");

			if (editor.getGraph().getParentRelationship(node.getID()) === null) {
				// hint for the parent handle
				var topHandleHint = undefined;
				if (PedigreeEditorParameters.attributes.enableHandleHintImages) {
					var hintSize = PedigreeEditorParameters.attributes.radius / 2;
					var path = [
						["M", x - hintSize, y - PedigreeEditorParameters.attributes.personHandleLength],
						["L", x + hintSize, y - PedigreeEditorParameters.attributes.personHandleLength]
					];
					var line1 = editor.getPaper().path(path).attr({"stroke-width": strokeWidth / 3, stroke: "#555555"}).toBack();
					var father = editor.getPaper().rect(x - hintSize - 11, y - PedigreeEditorParameters.attributes.personHandleLength - 5.5, 11, 11).attr({fill: "#CCCCCC"}).toBack();
					var mother = editor.getPaper().circle(x + hintSize + 6, y - PedigreeEditorParameters.attributes.personHandleLength, 6).attr({fill: "#CCCCCC"}).toBack();
					var topHandleHint = editor.getPaper().set().push(line1, father, mother);
				}
				// parent handle
				this.generateHandle('parent', x, splitLocationY, x, y - PedigreeEditorParameters.attributes.personHandleLength,
					"Click to create new nodes for the parents or drag to an existing person or partnership (valid choices will be highlighted in green). Dragging to a person will create a new relationship.", "F", topHandleHint);
			}

			if (!node.isFetus() && node.getAdopted() != "adoptedOut") {

				if (node.getChildlessStatus() === null) {
					// children handle
					//static part (going right below the node)
					var path = [
						["M", x, y],
						["L", x, y + PedigreeEditorParameters.attributes.personHandleBreakX]
					];
					editor.getPaper().path(path).attr({"stroke-width": strokeWidth, stroke: "gray"}).insertBefore(nodeShapes);
					this.generateHandle('child', x, y + PedigreeEditorParameters.attributes.personHandleBreakX - 2, x, y + PedigreeEditorParameters.attributes.personHandleLength,
						"Click to create a new child node or drag to an existing parentless person (valid choices will be highlighted in green)", "U");
				}

				// partner handle
				var vertPosForPartnerHandles = y;
				//static part (going left form the node)
				var path = [
					["M", x, vertPosForPartnerHandles],
					["L", x - PedigreeEditorParameters.attributes.personHandleBreakX, vertPosForPartnerHandles]
				];
				editor.getPaper().path(path).attr({"stroke-width": strokeWidth, stroke: "gray"}).insertBefore(nodeShapes);
				this.generateHandle('partnerR', x - PedigreeEditorParameters.attributes.personHandleBreakX + 2, vertPosForPartnerHandles, x - PedigreeEditorParameters.attributes.personHandleLength, vertPosForPartnerHandles,
					"Click to create a new partner node or drag to an existing node (valid choices will be highlighted in green)", partnerGender);
			}
		}
		else {
			if (editor.getGraph().getParentRelationship(node.getID()) === null)
				this.generateHandle('parent', x, y, x, y - PedigreeEditorParameters.attributes.personHandleLength, "Click to create new nodes for the parents or drag to an existing person or partnership (valid choices will be highlighted in green)");

			if (!node.isFetus() && node.getAdopted() != "adoptedOut") {
				if (node.getChildlessStatus() === null)
					this.generateHandle('child', x, y, x, y + PedigreeEditorParameters.attributes.personHandleLength, "Click to create a new child node or drag to an existing parentless node (valid choices will be highlighted in green)");
				this.generateHandle('partnerR', x, y, x + PedigreeEditorParameters.attributes.personHandleLength, y, "Click to create a new partner node or drag to an existing node (valid choices will be highlighted in green)");
				this.generateHandle('partnerL', x, y, x - PedigreeEditorParameters.attributes.personHandleLength, y, "Click to create a new partner node or drag to an existing node (valid choices will be highlighted in green)");
			}
		}

		this._currentHandles.push(editor.getPaper().setFinish());

		//timer.printSinceLast("Generate handles ");
	},

	/**
	 * Creates the buttons used in this hoverbox
	 *
	 * @method generateButtons
	 */
	generateButtons: function ($super) {
		if (this._currentButtons !== null) return;
		$super();

		this.generateMenuBtn();

		// proband can't be removed
		if (!this.getNode().isProband())
			this.generateDeleteBtn();
	},

	/**
	 * Creates a node-shaped show-menu button
	 *
	 * @method generateMenuBtn
	 * @return {Raphael.st} The generated button
	 */
	generateMenuBtn: function () {
		var me = this;
		var action = function () {
			me.toggleMenu(!me.isMenuToggled());
		};
		var genderShapedButton = this.getNode().getGraphics().getGenderShape().clone();
		genderShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOff);
		genderShapedButton.click(action);
		genderShapedButton.hover(function () {
				genderShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOn)
			},
			function () {
				genderShapedButton.attr(PedigreeEditorParameters.attributes.nodeShapeMenuOff)
			});
		genderShapedButton.attr("cursor", "pointer");
		this._currentButtons.push(genderShapedButton);
		this.disable();
		this.getFrontElements().push(genderShapedButton);
		this.enable();
	},

	/**
	 * Returns true if the menu for this node is open
	 *
	 * @method isMenuToggled
	 * @return {Boolean}
	 */
	isMenuToggled: function () {
		return this._isMenuToggled;
	},

	/**
	 * Shows/hides the menu for this node
	 *
	 * @method toggleMenu
	 */
	toggleMenu: function (isMenuToggled) {
		if (this._justClosedMenu) return;
		//console.log("toggle menu: current = " + this._isMenuToggled);
		this._isMenuToggled = isMenuToggled;
		if (isMenuToggled) {
			this.getNode().getGraphics().unmark();
			var optBBox = this.getBoxOnHover().getBBox();
			var x = optBBox.x2;
			var y = optBBox.y;
			var position = editor.getWorkspace().canvasToDiv(x + 5, y);
			editor.getNodeMenu().show(this.getNode(), position.x, position.y);
		}
	},

	/**
	 * Hides the hoverbox with a fade out animation
	 *
	 * @method animateHideHoverZone
	 */
	animateHideHoverZone: function ($super) {
		this._hidden = true;
		if (!this.isMenuToggled()) {
			var parentPartnershipNode = editor.getGraph().getParentRelationship(this.getNode().getID());
			//console.log("Node: " + this.getNode().getID() + ", parentPartnershipNode: " + parentPartnershipNode);
			if (parentPartnershipNode && editor.getNode(parentPartnershipNode))
				editor.getNode(parentPartnershipNode).getGraphics().unmarkPregnancy();
			$super();
		}
	},

	/**
	 * Displays the hoverbox with a fade in animation
	 *
	 * @method animateDrawHoverZone
	 */
	animateDrawHoverZone: function ($super) {
		this._hidden = false;
		if (!this.isMenuToggled()) {
			var parentPartnershipNode = editor.getGraph().getParentRelationship(this.getNode().getID());
			if (parentPartnershipNode && editor.getNode(parentPartnershipNode))
				editor.getNode(parentPartnershipNode).getGraphics().markPregnancy();
			$super();
		}
	},

	/**
	 * Performs the appropriate action for clicking on the handle of type handleType
	 *
	 * @method handleAction
	 * @param {String} handleType "child", "partner" or "parent"
	 * @param {Boolean} isDrag True if this handle is being dragged
	 */
	handleAction: function (handleType, isDrag, curHoveredId) {
		console.log("handleType: " + handleType + ", isDrag: " + isDrag + ", curHovered: " + curHoveredId);

		if (isDrag && curHoveredId !== null) {
			if (handleType == "parent") {
				this.removeHandles();
				this.removeButtons();
				var event = { "personID": this.getNode().getID(), "parentID": curHoveredId };
				document.fire("pedigree:person:drag:newparent", event);
			}
			else if (handleType == "partnerR" || handleType == "partnerL") {
				this.removeHandles();
				var event = { "personID": this.getNode().getID(), "partnerID": curHoveredId };
				document.fire("pedigree:person:drag:newpartner", event);
			}
			else if (handleType == "child") {
				var event = { "personID": curHoveredId, "parentID": this.getNode().getID() };
				document.fire("pedigree:person:drag:newparent", event);
			}
			else if (handleType == "sibling") {
				var event = { "sibling2ID": curHoveredId, "sibling1ID": this.getNode().getID() };
				document.fire("pedigree:person:drag:newsibling", event);
			}
		}
		else if (!isDrag) {
			if (handleType == "partnerR" || handleType == "partnerL") {
				this.removeHandles();
				var preferLeft = (this.getNode().getGender() == 'F') || (handleType == "partnerL");
				var event = { "personID": this.getNode().getID(), "preferLeft": preferLeft };
				document.fire("pedigree:person:newpartnerandchild", event);
			}
			else if (handleType == "child") {
				var position = editor.getWorkspace().canvasToDiv(this.getNodeX(), (this.getNodeY() + PedigreeEditorParameters.attributes.personHandleLength + 15));
				editor.getNodetypeSelectionBubble().show(this.getNode(), position.x, position.y);
				// if user selects anything the bubble will fire an even on its own
			}
			else if (handleType == "sibling") {
				var position = editor.getWorkspace().canvasToDiv(this.getNodeX() + PedigreeEditorParameters.attributes.personSiblingHandleLengthX - 4,
						this.getNodeY() - PedigreeEditorParameters.attributes.personHandleBreakY + PedigreeEditorParameters.attributes.personSiblingHandleLengthY + 15);
				editor.getSiblingSelectionBubble().show(this.getNode(), position.x, position.y);
			}
			else if (handleType == "parent") {
				this.removeHandles();
				this.removeButtons();
				var event = { "personID": this.getNode().getID() };
				document.fire("pedigree:person:newparent", event);
			}
		}
		this.animateHideHoverZone();
	}
});

/**
 * AbstractNode is the general abstract class for nodes on the Pedigree graph. An AbstractNode contains information
 * about its position on the canvas and about relationships with other nodes on the graph.
 *
 * @class AbstractNode
 * @constructor
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 * @param {Number} [id] The id of the node
 */
var AbstractNode = Class.create({

	initialize: function (x, y, id) {
		//console.log("abstract node");
		this._id = id;
		this._comments = "";
		!this._type && (this._type = "AbstractNode");
		this._graphics = this._generateGraphics(x, y);
		//console.log("abstract node end");
	},

	/**
	 * Returns the unique ID of this node
	 *
	 * @method getID
	 * @return {Number} the id of the node
	 */
	getID: function () {
		return this._id;
	},

	/**
	 * Sets the ID of this node
	 * (when nodes get removed all ids above the removed id shift by one down)
	 *
	 * @method setID
	 */
	setID: function (id) {
		if (id == this._id) return;
		//console.log("Updating ID " + this._id + " to " + id);
		this._id = id;
		this._graphics.onSetID(id);
	},

	/**
	 * Generates an instance of AbstractNodeVisuals
	 *
	 * @method _generateGraphics
	 * @param {Number} x The x coordinate of the node
	 * @param {Number} y The y coordinate of the node
	 * @return {AbstractNodeVisuals}
	 * @private
	 */
	_generateGraphics: function (x, y) {
		//console.log("abstract node - generate graphics");
		return new AbstractNodeVisuals(this, x, y);
	},

	/**
	 * Returns the object responsible for managing graphics
	 *
	 * @method getGraphics
	 * @return {AbstractNodeVisuals}
	 */
	getGraphics: function () {
		return this._graphics;
	},

	/**
	 * Returns the X coordinate of the node on the canvas
	 *
	 * @method getX
	 * @return {Number} the x coordinate
	 */
	getX: function () {
		return this.getGraphics().getX();
	},

	/**
	 * Returns the Y coordinate of the node on the canvas
	 *
	 * @method getY
	 * @return {Number} the y coordinate
	 */
	getY: function () {
		return this.getGraphics().getY();
	},

	/**
	 * Changes the position of the node to (x,y)
	 *
	 * @method setPos
	 * @param {Number} x The x coordinate on the canvas
	 * @param {Number} y The y coordinate on the canvas
	 * @param {Boolean} [animate] Set to true if you want to animate the transition
	 * @param {Function} [callback] The function called at the end of the animation
	 */
	setPos: function (x, y, animate, callback) {
		this.getGraphics().setPos(x, y, animate, callback);
	},

	/**
	 * Returns the type of this node
	 *
	 * @method getType
	 * @return {String} The type (eg. "Partnership", "Person", etc)
	 */
	getType: function () {
		return this._type;
	},

	/**
	 * Removes the node and its visuals.
	 *
	 * @method remove
	 * @param [skipConfirmation=false] {Boolean} if true, no confirmation box will pop up
	 */
	remove: function () {
		this.getGraphics().remove();
	},

	/**
	 * Returns any free-form comments associated with the node
	 *
	 * @method getComments
	 * @return {String}
	 */
	getComments: function () {
		return this._comments;
	},

	/**
	 * Replaces free-form comments associated with the node
	 *
	 * @method setComments
	 * @param comment
	 */
	setComments: function (comment) {
		this._comments = comment;
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 */
	getProperties: function () {
		var info = {};
		if (this.getComments() != "")
			info['comments'] = this.getComments();
		return info;
		;
	},

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method assignProperties
	 * @param properties Object
	 * @return {Boolean} True if properties were successfully assigned (i.e. no conflicts/invalid values)
	 */
	assignProperties: function (properties) {
		if (properties.hasOwnProperty("comments") && this.getComments() != properties.comments) {
			this.setComments(properties.comments);
		}
		return true;
	},

	/**
	 * Applies properties that happen to this node when a widget (such as the menu) is closed.
	 *
	 * @method onWidgetHide
	 */
	onWidgetHide: function () {
		this.getGraphics().getHoverBox() && this.getGraphics().getHoverBox().onWidgetHide();
	},

	onWidgetShow: function () {
		this.getGraphics().getHoverBox() && this.getGraphics().getHoverBox().onWidgetShow();
	}
});
/**
 * AbstractNodeVisuals is the general abstract class for the graphic engine used by nodes on the Pedigree graph.
 * Objects of this class have information about the positioning of the graphical elements of the node.
 *
 * @class AbstractNodeVisuals
 * @constructor
 * @param {AbstractNode} node The node for which the graphics are drawn
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 */
var AbstractNodeVisuals = Class.create({

	initialize: function (node, x, y) {
		//console.log("abstract node visuals");
		this._node = node;
		this._absoluteX = x;
		this._absoluteY = y;
		this._hoverBox = null;
		this._isGrown = false;
		this._anonimized = false;
		//console.log("abstract node visuals end");
	},

	/**
	 * Returns the node for which the graphics are being drawn
	 *
	 * @method getNode
	 * @return {AbstractNode}
	 */
	getNode: function () {
		return this._node;
	},

	/**
	 * Returns the current X coordinate of this node on the canvas, taking into consideration transformation data.
	 *
	 * @method getX
	 * @return {Number} the x coordinate
	 */
	getX: function () {
		return this._absoluteX;
	},

	/**
	 * Updates whatever needs to change when node id changes (e.g. id label)
	 *
	 * @method onSetID
	 */
	onSetID: function (id) {
	},

	/**
	 * Removes all PII labels
	 */
	setAnonimizedStatus: function (status) {
		this._anonimized = status;
	},

	/**
	 * Returns the current Y coordinate of this node on the canvas, taking into consideration transformation data.
	 *
	 * @method getY
	 * @return {Number} The y coordinate
	 */
	getY: function () {
		return this._absoluteY;
	},

	/**
	 * Returns the Y coordinate of the lowest part of this node's graphic on the canvas
	 *
	 * @method getY
	 * @return {Number} The y coordinate
	 */
	getBottomY: function () {
		return this._absoluteY;
	},

	/**
	 * Changes the position of the node to (X,Y)
	 *
	 * @method setPos
	 * @param {Number} x The x coordinate
	 * @param {Number} y The y coordinate
	 * @param {Boolean} animate Set to true if you want to animate the transition
	 * @param {Function} callback The function called at the end of the animation
	 */
	setPos: function (x, y, animate, callback) {
		//console.log("Node " + this.getNode().getID() + ", xy: " + x + "/" + y);
		this._absoluteX = x;
		this._absoluteY = y;
		callback && callback();
	},

	/**
	 * Expands the node graphics a bit
	 *
	 * @method grow
	 */
	grow: function () {
		this._isGrown = true;
	},

	/**
	 * Shrinks node graphics to the original size
	 *
	 * @method shrink
	 */
	shrink: function () {
		this._isGrown = false;
	},

	/**
	 * Returns current growth status of the node (true if grown, false if not)
	 *
	 * @method isGrown
	 */
	isGrown: function () {
		return this._isGrown;
	},

	/**
	 * Returns true if this node's graphic representation covers coordinates (x,y)
	 *
	 * @method containsXY
	 */
	containsXY: function (x, y) {
		return false;
	},

	/**
	 * Returns true if this node is selected. A selected node is a node with visible Hoverbox.
	 *
	 * @method isSelected
	 * @return {Boolean}
	 */
	isSelected: function () {
		return this._isSelected;
	},

	/**
	 * Sets this node's selected property to isSelected. A selected node is a node with visible Hoverbox.
	 *
	 * @method setSelected
	 * @param {Boolean} isSelected True if the node is selected
	 */
	setSelected: function (isSelected) {
		this._isSelected = isSelected;
	},

	/**
	 * Returns a Raphael set of all the graphics and labels associated with this node.
	 *
	 * @method getAllGraphics
	 * @return {Raphael.st}
	 */
	getAllGraphics: function () {
		return editor.getPaper().set(this.getShapes());
	},

	/**
	 * Returns a Raphael set of graphic elements of which the icon of the node consists. Does not
	 * include hoverbox elements or labels.
	 *
	 * @method getShapes
	 * @return {Raphael.st}
	 */
	getShapes: function () {
		return editor.getPaper().set()
	},

	/**
	 * Removes all the graphical elements of this node from the canvas
	 *
	 * @method remove
	 */
	remove: function () {
		this.getHoverBox() && this.getHoverBox().remove();
		this.getAllGraphics().remove();
	},

	/**
	 * Returns the hoverbox object for this node
	 *
	 * @method getHoverBox
	 * @return {AbstractHoverbox}
	 */
	getHoverBox: function () {
		return this._hoverBox;
	}
});

/**
 * A general superclass for Person nodes on the Pedigree graph. Contains information about related nodes
 * and some properties specific for people. Creates an instance of AbstractPersonVisuals on initialization
 *
 * @class AbstractPerson
 * @extends AbstractNode
 * @constructor
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 * @param {String} gender Can be "M", "F", "O" or "U"
 * @param {Number} [id] The id of the node
 */
var AbstractPerson = Class.create(AbstractNode, {

	initialize: function ($super, x, y, gender, id) {
		//console.log("abstract person");
		this._gender = this.parseGender(gender);
		this._adoptedStatus = "";
		!this._type && (this._type = "AbstractPerson");
		$super(x, y, id);
		//console.log("abstract person end");
	},

	/**
	 * Initializes the object responsible for creating graphics for this node
	 *
	 * @method _generateGraphics
	 * @param {Number} x The x coordinate on the canvas at which the node is centered
	 * @param {Number} y The y coordinate on the canvas at which the node is centered
	 * @return {AbstractPersonVisuals}
	 * @private
	 */
	_generateGraphics: function (x, y) {
		return new AbstractPersonVisuals(this, x, y);
	},

	/**
	 * Reads a string of input and converts it into the standard gender format of "M","F","O" or "U".
	 * Defaults to "U" if string is not recognized
	 *
	 * @method parseGender
	 * @param {String} gender The string to be parsed
	 * @return {String} the gender in the standard form ("M", "F", "O" or "U")
	 */
	parseGender: function (gender) {
		var genderUpperCase = gender.toUpperCase();
		return (genderUpperCase == 'M'
			|| genderUpperCase == 'F'
			|| genderUpperCase == 'O') ? genderUpperCase : 'U';
	},

	/**
	 * Returns "U", "F", "O" or "M" depending on the gender of this node
	 *
	 * @method getGender
	 * @return {String}
	 */
	getGender: function () {
		return this._gender;
	},

	/**
	 * @method isPersonGroup
	 */
	isPersonGroup: function () {
		return (this._type == "PersonGroup");
	},

	/**
	 * Updates the gender of this node
	 *
	 * @method setGender
	 * @param {String} gender Should be "U", "F", "O" or "M" depending on the gender
	 */
	setGender: function (gender) {
		var gender = this.parseGender(gender);
		if (this._gender != gender) {
			this._gender = gender;
			this.getGraphics().setGenderGraphics();
			this.getGraphics().getHoverBox().regenerateHandles();
			this.getGraphics().getHoverBox().regenerateButtons();
		}
	},

	setSex: function (sex) {
		this.setGender(sex);
	},

	/**
	 * Changes the adoption status of this Person to adoptedStatus. Updates the graphics.
	 *
	 * @method setAdopted
	 * @param {Boolean} adoptedStatus one of "", "adoptedIn" and "adoptedOut"
	 */
	setAdopted: function (adoptedStatus) {
		if (adoptedStatus != "" && adoptedStatus != "adoptedIn" && adoptedStatus != "adoptedOut") {
			adoptedStatus = "";
		}
		this._adoptedStatus = adoptedStatus;
		this.getGraphics().drawAdoptedShape();
		this.getGraphics().getHoverBox().regenerateHandles();
	},

	/**
	 * Returns true if this Person is marked adopted
	 *
	 * @method getAdopted
	 * @return {String} one of "", "adoptedIn" and "adoptedOut"
	 */
	getAdopted: function () {
		return this._adoptedStatus;
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 {
	   sex: "gender of the node"
	 }
	 */
	getProperties: function ($super) {
		var info = $super();
		info['gender'] = this.getGender();
		return info;
	},

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method assignProperties
	 * @param properties Object
	 * @return {Boolean} True if info was successfully assigned
	 */
	assignProperties: function ($super, properties) {
		if (!$super(properties))
			return false;
		if (!properties.gender)
			return false;

		if (this.getGender() != this.parseGender(properties.gender))
			this.setGender(properties.gender);
		return true;
	}
});

/**
 * Created by soheil on 02/08/2016.
 */

Settings = Class.create({

	initialize: function (baseURL) {
		this._settings = config; //'config' is a global variable load it from config.js
		this._settings.version = version;
	},

	getSetting: function (key) {
		if (this._settings == undefined)
			alert("Settings are not loaded yet");
		return this._settings[key];
	}
});

/**
 * UndoRedoManager is responsible for keeping track of user actions and providing an undo/redo functionality
 *
 * @class UndoRedoManager
 * @constructor
 */

var UndoRedoManager = Class.create({
	initialize: function () {
		this._currentState = 0;
		this._stack = [];
		this._MAXUNDOSIZE = 100;
		this._savedState = "";
	},

	hasUnsavedChanges: function () {
		var state = this._getCurrentState();
		if (state == null) {
			return true;
		}
		if (this._savedState == state.serializedState) {
			return false;
		}
		return true;
	},

	hasRedo: function () {
		if (this._getNextState()) return true;
		return false;
	},

	hasUndo: function () {
		if (this._getPreviousState()) return true;
		return false;
	},

	addSaveEvent: function () {
		var state = this._getCurrentState();
		if (state == null) {
			return;
		}
		this._savedState = state.serializedState;
	},
	/**
	 * Moves one state forward in the action stack
	 *
	 * @method redo
	 */
	redo: function () {
		var nextState = this._getNextState();
		//console.log("Next state: " + Helpers.stringifyObject(nextState));
		if (!nextState) return;

		this._currentState++;
		if (nextState.eventToGetToThisState) {
			var memo = nextState.eventToGetToThisState.memo;
			memo["noUndoRedo"] = true;  // so that this event is not added to the undo/redo stack again
			document.fire(nextState.eventToGetToThisState.eventName, memo);
		} else {
			editor.getSaveLoadEngine().createGraphFromSerializedData(nextState.serializedState, true /* do not re-add to undo/redo stack */);
		}
		document.fire("pedigree:historychange", null);
	},

	/**
	 * Moves one state backwards in the action stack
	 *
	 * @method undo
	 */
	undo: function () {
		var prevState = this._getPreviousState();
		if (!prevState) return;

		// it may be more efficient to undo the current state instead of full prev state restore
		var currentState = this._getCurrentState();
		//console.log("Current state: " + Helpers.stringifyObject(currentState));

		this._currentState--;
		if (currentState.eventToUndo) {
			var memo = currentState.eventToUndo.memo;
			memo["noUndoRedo"] = true; // so that this event is not added to the undo/redo stack again
			document.fire(currentState.eventToUndo.eventName, memo);
		} else {
			// no easy way - have to recreate the graph from serialization
			editor.getSaveLoadEngine().createGraphFromSerializedData(prevState.serializedState, true /* do not re-add to undo/redo stack */);
		}
		document.fire("pedigree:historychange", null);
	},

	/**
	 * Pushes a new state to the end of the action stack
	 *
	 *   eventToGetToThisState - optional. Event which should bring the graph from the previous state to this tsate
	 *   eventToGoBack         - optional. Event which should bring the graph back to the previous state
	 *   serializedState       - optional. Serialized state of the graph as accepted by the load() funciton.
	 *                           may only be used when one of the events is not provided. Will be generated
	 *                           automatically when needed if not provided.
	 *
	 * If one of the events is not provided a complete serializatiomn of the graph will be used to transition
	 * in that direction, which is less efficient (slower/requires more memory for state storage).
	 *
	 * @method addState
	 */
	addState: function (eventToGetToThisState, eventToUndo, serializedState) {
		//this._debug_print_states();

		// 1. remove all states after current state (i.e. all "redo" states) -
		//    they are replaced by the current chain of states starting with this state
		if (this._currentState < this._size())
			this._stack.splice(this._currentState, this._stack.length - this._currentState);

		if (!serializedState) {
			serializedState = editor.getSaveLoadEngine().serialize();
		}
		//console.log("Serialized state: " + Helpers.stringifyObject(serializedState));

		//if (!eventToGetToThisState && !serializedState)
		//    serializedState = editor.getSaveLoadEngine().serialize();
		//
		//if (!eventToUndo && this._currentState > 0) {
		//    // no event procided to undo this action AND have a current state:
		//    // => current state needs to have a serialization
		//    .. TODO
		//}

		var state = new State(serializedState, eventToGetToThisState, eventToUndo);

		// 2. push this new state to the array and increment the current index

		// spcial case: consequtive name property changes are combined into one property change
		var currentState = this._getCurrentState();
		if (eventToGetToThisState &&
			currentState && currentState.eventToGetToThisState &&
			currentState.eventToGetToThisState.eventName == "pedigree:node:setproperty" &&
			this._combinableEvents(currentState.eventToGetToThisState, eventToGetToThisState)) {
			//console.log("[UNDOREDO] combining state changes");
			currentState.eventToGetToThisState = eventToGetToThisState;
			currentState.serializedState = serializedState;
			//this._debug_print_states();
			return;
		}

		this._addNewest(state);

		if (this._size() > this._MAXUNDOSIZE)
			this._removeOldest();

		document.fire("pedigree:historychange", null);
		//this._debug_print_states();
	},

	/**
	 * Returns true iff undo/redo should combine event1 and event2,
	 * e.g. name change from "some_old_value" to "Abc" and then to "Abcd" will be combined into
	 *      one name chnage from "some_old_value" to "Abcd"
	 *
	 * @method _size
	 * @return {Number}
	 */
	_combinableEvents: function (event1, event2) {
		if (!event1.memo.hasOwnProperty("nodeID") || !event2.memo.hasOwnProperty("nodeID") || event1.memo.nodeID != event2.memo.nodeID)
			return false;
		if (event1.memo.properties.hasOwnProperty("setFirstName") &&
			event2.memo.properties.hasOwnProperty("setFirstName"))
			return true;
		if (event1.memo.properties.hasOwnProperty("setLastName") &&
			event2.memo.properties.hasOwnProperty("setLastName"))
			return true;
		if (event1.memo.properties.hasOwnProperty("setLastNameAtBirth") &&
			event2.memo.properties.hasOwnProperty("setLastNameAtBirth"))
			return true;
		if (event1.memo.properties.hasOwnProperty("setComments") &&
			event2.memo.properties.hasOwnProperty("setComments"))
			return true;
		if (event1.memo.properties.hasOwnProperty("setChildlessReason") &&
			event2.memo.properties.hasOwnProperty("setChildlessReason"))
			return true;
		return false;
	},

	/**
	 * Returns the number of elements in the stack
	 *
	 * @method _size
	 * @return {Number}
	 */
	_size: function () {
		return this._stack.length;
	},

	/**
	 * Adds the given state as the latest state in the sequence
	 *
	 * @method _addNewest
	 */
	_addNewest: function (state) {
		this._stack.push(state);
		this._currentState++;
	},

	/**
	 * Removes the front element of the stack (i.e. the oldest stored state)
	 *
	 * @method _removeOldest
	 */
	_removeOldest: function () {
		this._stack.splice(0, 1);
		this._currentState--;
	},

	/**
	 * Returns the current state
	 *
	 * @method _getCurrentState
	 * @return {null|Object}
	 */
	_getCurrentState: function () {
		return (this._size() == 0 || this._currentState == 0) ? null : this._stack[this._currentState - 1];
	},

	/**
	 * Returns the next state
	 *
	 * @method _getNextState
	 * @return {null|Object}
	 */
	_getNextState: function () {
		return (this._size() <= 1 || this._currentState >= this._size()) ? null : this._stack[this._currentState];
	},

	/**
	 * Returns the previous state
	 *
	 * @method _getPreviousState
	 * @return {null|Object}
	 */
	_getPreviousState: function () {
		return (this._size() == 1 || this._currentState <= 1) ? null : this._stack[this._currentState - 2];
	},

	_debug_print_states: function () {
		console.log("------------");
		for (var i = 0; i < this._stack.length; i++) {
			console.log("[" + i + "] EventToState: " + Helpers.stringifyObject(this._stack[i].eventToGetToThisState) + "\n" +
				"    EventUndo: " + Helpers.stringifyObject(this._stack[i].eventToUndo) + "\n" +
				"    EventSerial: " + Helpers.stringifyObject(this._stack[i].serializedState));
		}
		console.log("------------");
	}
});

/**
 * State is used by @class UndoRedoManager to enable undo redo actions.
 *
 * @class State
 * @constructor
 */
var State = Class.create({
	initialize: function (serializedState, eventToGetToThisState, eventToUndo) {
		this.serializedState = serializedState;
		this.eventToGetToThisState = eventToGetToThisState;
		this.eventToUndo = eventToUndo;
	}
});
/**
 * ...
 *
 * @class Controller
 * @constructor
 */

// TODO: undo/redo in all handlers

var Controller = Class.create({
	initialize: function () {
		/* this is where the update for the clinicalIndicationName would go likely */
		document.observe("pedigree:update:topMenu", this.handleTopMenuUpdate);
        document.observe("pedigree:update:clinicalIndicationName", this.handleClinicalIndicationNameUpdate);
        document.observe("pedigree:autolayout", this.handleAutoLayout);
		document.observe("pedigree:graph:clear", this.handleClearGraph);
		document.observe("pedigree:undo", this.handleUndo);
		document.observe("pedigree:redo", this.handleRedo);
		document.observe("pedigree:renumber", this.handleRenumber);
		document.observe("pedigree:historychange", this.handleUndoHistoryChange);
		document.observe("pedigree:node:remove", this.handleRemove);
		document.observe("pedigree:node:setproperty", this.handleSetProperty);
		document.observe("pedigree:node:modify", this.handleModification);
		document.observe("pedigree:person:drag:newparent", this.handlePersonDragToNewParent);
		document.observe("pedigree:person:drag:newpartner", this.handlePersonDragToNewPartner);
		document.observe("pedigree:person:drag:newsibling", this.handlePersonDragToNewSibling);
		document.observe("pedigree:person:newparent", this.handlePersonNewParents);
		document.observe("pedigree:person:newsibling", this.handlePersonNewSibling);
		document.observe("pedigree:person:newpartnerandchild", this.handlePersonNewPartnerAndChild);
		document.observe("pedigree:partnership:newchild", this.handleRelationshipNewChild);
	},

	handleUndo: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		editor.getUndoRedoManager().undo();
	},

	handleRedo: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		editor.getUndoRedoManager().redo();
	},

	handleRenumber: function (event) {
		// Assigns user-visible node labels for all person nodes, based on generation and order
		// ("I-1","I-2","I-3", "II-1", "II-2", etc.)

		//console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var check = event.memo.hasOwnProperty("check");
		var clear = false;
		var needRedraw = false;

		do {
			var secondPass = false;

			for (var nodeID in editor.getView().getNodeMap()) {
				if (editor.getView().getNodeMap().hasOwnProperty(nodeID)) {
					if (editor.getGraph().isPerson(nodeID) && !editor.getGraph().isPlaceholder(nodeID)) {
						var node = editor.getView().getNode(nodeID);
						var currentPedNumber = node.getPedNumber();

						if (clear) {
							var pedNumber = "";
						} else {
							var generation = editor.getGraph().getGeneration(nodeID);
							var order = editor.getGraph().getOrderWithinGeneration(nodeID);
							var pedNumber = Helpers.romanize(generation) + "-" + order;

							if (check) {
								if (pedNumber != currentPedNumber) {
									// one of the nodes PED number is not correct
									clear = true;
									secondPass = true;
									break;
								}
							}
						}

						if (currentPedNumber != pedNumber) {
							needRedraw = true;
							node.setPedNumber(pedNumber);
							var allProperties = node.getProperties();
							editor.getGraph().setProperties(nodeID, allProperties);
						}
					}
				}
			}
		} while (secondPass);

		var renumberButton = $('action-number');
		try	{
		    if (clear) {
                renumberButton.removeClassName("disabled-menu-item");
                renumberButton.addClassName("menu-item");
            } else {
                renumberButton.removeClassName("menu-item");
                renumberButton.addClassName("disabled-menu-item");
            }
		}
		catch (err){
		    console.log(err);
		}


		if (!event.memo.noUndoRedo && needRedraw) {
			editor.getView().unmarkAll();
			editor.getUndoRedoManager().addState(event);
		}
	},

	handleUndoHistoryChange: function () {
		var redoButton = $('action-redo');
		if (editor.getUndoRedoManager().hasRedo()) {
			redoButton.removeClassName("disabled-menu-item");
			redoButton.addClassName("menu-item");
		} else {
			redoButton.removeClassName("menu-item");
			redoButton.addClassName("disabled-menu-item");
		}
		var undoButton = $('action-undo');
		if (editor.getUndoRedoManager().hasUndo()) {
			undoButton.removeClassName("disabled-menu-item");
			undoButton.addClassName("menu-item");
		} else {
			undoButton.removeClassName("menu-item");
			undoButton.addClassName("disabled-menu-item");
		}
	},

	handleAutoLayout: function (event) {
		try {
			console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
			var changeSet = editor.getGraph().redrawAll();
			editor.getView().applyChanges(changeSet, true);

			if (!event.memo.noUndoRedo)
				editor.getUndoRedoManager().addState(event);
		} catch (err) {
			console.log("Autolayout error: " + err);
		}
	},

	handleClearGraph: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		var changeSet = editor.getGraph().clearAll();
		editor.getView().applyChanges(changeSet, true);

		editor.getWorkspace().centerAroundNode(0, false);

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);
	},


	/**
	 * Added for GEL(GenomicsEngland)
	 * This event handler will update the text in top menu and displays values like
	 * particpnatId and familyId when they are changed
	 * @param event
	 */
	handleTopMenuUpdate: function (event){
		//var familyId 	  = event.memo.familyId;
		var testRequestId = event.memo.testRequestId;
		editor.getWorkspace().setMenuText(testRequestId, "");
	},
    handleClinicalIndicationNameUpdate: function (event){
        var clinicalIndicationName = event.memo.clinicalIndicationName;
        editor.getWorkspace().setClinicalIndicationNameText(clinicalIndicationName);

    },

	handleRemove: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		var nodeID = event.memo.nodeID;

		// get the list of affected nodes
		var disconnectedList = editor.getGraph().getDisconnectedSetIfNodeRemoved(nodeID);

		var onlyChild = false;
		// special case of removing the last child: need to convert to placeholder
		if (editor.getGraph().isPerson(nodeID) && editor.getGraph().isOnlyChild(nodeID)) {
			var producingRelationship = editor.getGraph().getParentRelationship(nodeID);
			if (!Helpers.arrayContains(disconnectedList, producingRelationship)) {
				onlyChild = true;
			}
		}


		if (onlyChild){
            var closeFunction = function () {
            					if (this.dialog){
            					    this.dialog.show();
            					}

            				};

		    editor.getOkCancelDialogue().showCustomized('You cannot remove an only child (still attached to a parent).' + '<br>'+' Please remove one of the parents to trigger the removal of the only child.',
            					"Genomics England",
            					"Close", closeFunction,
            					null, null,
            					null, null, true);

            return;
		}

		//Added for GEL(GenomicsEngland)
		//Prevent deleting registered nodes and any hierarchy that has a registered node

		for(var i = 0;i < disconnectedList.length; i++){
			var nodeIndex = disconnectedList[i];
			var node = null;

			try
			{
			    var node = editor.getView().getNode(nodeIndex);
			}catch (exp){
			    console.log(exp);
			}
			if (!node){
			    continue;
			}
			//var node = editor.getView().getNode(nodeIndex);
			if(node.isRegistered && node.isRegistered()){
				var closeFunction = function () {
					if (this.dialog){
					    this.dialog.show();
					}

				};
				editor.getOkCancelDialogue().showCustomized('You can not delete registered participants or any hierarchy that contains a registered participant(s) .',
					"Genomics England",
					"Close", closeFunction,
					null, null,
					null, null, true);
				return;
			}
		}
		//................................................................................

		var removeSelected = function () {
			try {
				if (onlyChild) {
					// instea dof removing convert child to a placeholder.
					//
					// note: need to set properties before actual remove while we know the
					//       ID which may change as part of remove process

					Helpers.removeFirstOccurrenceByValue(disconnectedList, nodeID);

					editor.getGraph().setProperties(nodeID, {"gender": "U", "placeholder": true});
					if (!editor.getGraph().isChildless(producingRelationship)) {
						var partnership = editor.getView().getNode(producingRelationship);
						partnership.setChildlessStatus('Childless');
						var newProperties = partnership.getProperties();
						editor.getGraph().setProperties(producingRelationship, newProperties);
					}
				}

				var changeSet = editor.getGraph().removeNodes(disconnectedList);

				if (onlyChild) {
					// mark that this needs to be recreated
					changeSet.removed.push(nodeID);
					var newNodeID = changeSet.changedIDSet.hasOwnProperty(nodeID) ? changeSet.changedIDSet[nodeID] : nodeID;
					//changeSet["new"] = [];
					changeSet["new"] = [ newNodeID ];
				}

				editor.getView().applyChanges(changeSet, true);

				var changeSet = editor.getGraph().improvePosition();
				editor.getView().applyChanges(changeSet, true);

				if (!event.memo.noUndoRedo)
					editor.getUndoRedoManager().addState(event);
			} catch (err) {
				console.log("[DEBUG] Remove error: " + err);
			}
		};

		// if there is only one node or this removal is done as part of an undo/redo action
		// => just remove without asking any questions or highlighting any nodes
		if (disconnectedList.length <= 1 || event.memo.hasOwnProperty("noUndoRedo")) {
			removeSelected();
			return;
		}

		// otherwise remove current highlighting and highlight all nodes which will be removed
		editor.getView().unmarkAll();
		for (var i = 0; i < disconnectedList.length; i++) {
			var nextHighlight = disconnectedList[i];
			if (editor.getView().checkNodeExists(nextHighlight)){
			    editor.getView().getNode(nextHighlight).getGraphics().markPermanently();
			}

		}

		var unhighlightSelected = function () {
			for (var i = 0; i < disconnectedList.length; i++) {
				var nextHighlight = disconnectedList[i];
				if (editor.getView().checkNodeExists(nextHighlight)){
				    editor.getView().getNode(nextHighlight).getGraphics().unmark();
				}

			}
		}

		// ...and display a OK/Cancel dialogue, calling "removeSelected()" on OK and "unhighlightSelected" on Cancel
		editor.getOkCancelDialogue().show('All highlighted nodes will be removed. Do you want to proceed?',
			'Delete nodes?', removeSelected, unhighlightSelected);
	},

	handleSetProperty: function (event) {
		//console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		var nodeID = event.memo.nodeID;
		var properties = event.memo.properties;
		var undoEvent = {"eventName": event.eventName, "memo": {"nodeID": nodeID, "properties": Helpers.cloneObject(event.memo.properties)}};

		var node = editor.getView().getNode(nodeID);
		var changed = false;

		var twinUpdate = undefined;
		var needUpdateAncestors = false;
		var needUpdateRelationship = false;
		var needUpdateAllRelationships = false;
		var needUpdateYPositions = false;  // true iff: setting this property (e.g. extra long comments)
		//           may force stuff to move around in Y direction

		var changedValue = false;

		for (var propertySetFunction in properties) {
			if (properties.hasOwnProperty(propertySetFunction)) {
				var propValue = properties[propertySetFunction];

				//console.log("attmepting to set property " + propertySetFunction + " to " + propValue);
				if (!Controller._validatePropertyValue(nodeID, propertySetFunction, propValue)) continue;

				//console.log("validated");
				// prepare undo event
				var propertyGetFunction = propertySetFunction.replace("set", "get");

				//bugfix when propertyGetFunction is not a function
				var oldValue =null;

				if (node[propertyGetFunction] && typeof(node[propertyGetFunction]) === 'function'){
				    oldValue = node[propertyGetFunction]();
				}

				// var oldValue = node[propertyGetFunction]();
				if (oldValue == propValue) continue;
				if (oldValue && typeof(oldValue) === 'object' && typeof(propValue) === 'object' &&
					(propertySetFunction == "setDeathDate" || propertySetFunction == "setBirthDate")) {
					// compare Date objects
					try {
						if (oldValue.decade == propValue.decade &&
							oldValue.year == propValue.year &&
							oldValue.month == propValue.month &&
							oldValue.day == propValue.day)
							continue;
					} catch (err) {
						// fine, one of the objects is in some other format, maybe date picker has changed
						// and this code was not updated
					}
				}
				if (Object.prototype.toString.call(oldValue) === '[object Array]') {
					oldValue = oldValue.slice(0);
				} else if (typeof(oldValue) == 'object') {
					oldValue = Helpers.cloneObject(oldValue);
				}

				undoEvent.memo.properties[propertySetFunction] = oldValue;

				// sometimes UNDO includes more then the property itself: e.g. changing life status
				// from "dead" to "alive" also clears the death date. Need to add it to the "undo" event
				if (propertySetFunction == "setLifeStatus") {
					undoEvent.memo.properties["setDeathDate"] = node.getDeathDate();
					undoEvent.memo.properties["setGestationAgeWeeks"] = node.getGestationAgeWeeks();
					undoEvent.memo.properties["setGestationAgeDays"] = node.getGestationAgeDays();
					undoEvent.memo.properties["setBirthDate"] = node.getBirthDate();
					undoEvent.memo.properties["setAdopted"] = node.getAdopted();
				}
				if (propertySetFunction == "setDeathDate") {
					undoEvent.memo.properties["setLifeStatus"] = node.getLifeStatus();
				}
				if (propertySetFunction == "setChildlessStatus") {
					undoEvent.memo.properties["setChildlessReason"] = node.getChildlessReason();
				}
				if (propertySetFunction == "setDisorders") {
					undoEvent.memo.properties["setCarrierStatus"] = node.getCarrierStatus();
				}
				if (propertySetFunction == "setCarrierStatus") {
					undoEvent.memo.properties["setDisorders"] = node.getDisorders().slice(0);
				}

				if (node[propertySetFunction] && typeof(node[propertySetFunction]) === 'function' ){
				    node[propertySetFunction](propValue);
				}



				if (propertySetFunction == "setDisorders") {
					var newDisorders = node[propertyGetFunction]();
					if (JSON.stringify(oldValue) == JSON.stringify(newDisorders)) continue;
				}

				changedValue = true;

				if (propertySetFunction == "setLastName") {
					if (editor.getPreferencesManager().getConfigurationOption("propagateFatherLastName")) {
						if (node.getGender(nodeID) == 'M') {
							// propagate last name as "last name at birth" to all descendants (by the male line)
							Controller._propagateLastNameAtBirth(nodeID, propValue, oldValue);
							undoEvent = null; // there is no easy undo other than just remember the previous graph state
						}
					}
				}

				if (propertySetFunction == "setGender") {
					if (node.getMonozygotic()) {
						if (!twinUpdate) twinUpdate = {};
						twinUpdate[propertySetFunction] = propValue;
					}
					if (oldValue == 'U' && propValue == 'M' &&
						node.getLastName() == '' && node.getLastNameAtBirth() != '' &&
						editor.getGraph().getAllChildren(nodeID).length == 0) {
						node.setLastName(node.getLastNameAtBirth());
						node.setLastNameAtBirth("");
						undoEvent = null; // there is no easy undo other than just remember the previous graph state
					}
				}
				if (propertySetFunction == "setBirthDate") {
					if (!twinUpdate) twinUpdate = {};
					twinUpdate[propertySetFunction] = propValue;
				}

				if (propertySetFunction == "setAdopted") {
					needUpdateAncestors = true;
					if (propValue == "adoptedIn") {
						// if one twin is adopted in the other must be as well
						if (!twinUpdate) twinUpdate = {};
						twinUpdate[propertySetFunction] = propValue;
					}
					if (oldValue == "adoptedIn") {
						// if one twin was marked as adopted in the other must have been as well - but not
						// necesserily adopted out as this one
						if (!twinUpdate) twinUpdate = {};
						twinUpdate[propertySetFunction] = "";
					}
				}

				if (propertySetFunction == "setComments" || propertySetFunction == "setExternalID" ||
					propertySetFunction == "setFirstName" || propertySetFunction == "setLastName") {
					// all the methods which may result in addition ort deletion of person labels
					// (which may cause a shift up or down)
					if (Helpers.numTextLines(oldValue) != Helpers.numTextLines(propValue)) {
						needUpdateYPositions = true;
					}
				}
				if (propertySetFunction == "setBirthDate" || propertySetFunction == "setDeathDate") {
					// the number of lines may vary depending on age etc., it is easier to just recompute it
					needUpdateYPositions = true;
				}
				if (propertySetFunction == "setCancers") {
					needUpdateYPositions = true;
				}

				if (propertySetFunction == "setMonozygotic") {
					needUpdateRelationship = true;
					if (!twinUpdate) twinUpdate = {};
					twinUpdate[propertySetFunction] = propValue;
				}

				if (propertySetFunction == "setConsanguinity" || propertySetFunction == "setBrokenStatus") {
					// this updates the relationship lines, as well as any lines
					// crossed by the relationship llines to maintain correct crossing graphics
					needUpdateRelationship = true;
				}

				if (propertySetFunction == "setLostContact") {
					// it is hard to say which of the incoming/outgoing lines needs to be redraws/updated,
					// so it is easier to just redraw all
					needUpdateAllRelationships = true;
				}
			}
		}

		// some properties should be the same for all the twins. If one of those
		// was changed, need to update all the twins
		if (twinUpdate) {
			var allTwins = editor.getGraph().getAllTwinsSortedByOrder(nodeID);
			for (var propertySetFunction in twinUpdate) {
				if (twinUpdate.hasOwnProperty(propertySetFunction)) {
					var propValue = twinUpdate[propertySetFunction];

					for (var i = 0; i < allTwins.length; i++) {
						var twin = allTwins[i];
						if (twin == nodeID) continue;
						var twinNode = editor.getView().getNode(twin);
						twinNode[propertySetFunction](propValue);
						var twinProperties = twinNode.getProperties();
						console.log("Setting twin properties: " + Helpers.stringifyObject(twinProperties));
						editor.getGraph().setProperties(twin, twinProperties);
					}
				}
			}
		}

		var allProperties = node.getProperties();
		editor.getGraph().setProperties(nodeID, allProperties);

		if (needUpdateAncestors) {
			var changeSet = editor.getGraph().updateAncestors();
			editor.getView().applyChanges(changeSet, true);
		}

		if (needUpdateAllRelationships) {
			var rels = editor.getGraph().getAllRelatedRelationships(nodeID);
			var changeSet = {"moved": rels};
			editor.getView().applyChanges(changeSet, true);
		}

		if (needUpdateRelationship) {
			var relID = editor.getGraph().isRelationship(nodeID) ? nodeID : editor.getGraph().getParentRelationship(nodeID);
			var changeSet = {"moved": [relID]};
			editor.getView().applyChanges(changeSet, true);
		}

		if (needUpdateYPositions) {
			var changeSet = editor.getGraph().updateYPositioning();
			editor.getView().applyChanges(changeSet, true);
		}

		editor.getNodeMenu().update();  // for example, user selected a wrong gender in the nodeMenu, which
		// gets reverted back - need to select the correct one in the nodeMenu as well

		//console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
		//console.log("Undo event: " + Helpers.stringifyObject(undoEvent));
		if (!event.memo.noUndoRedo && changedValue)
			editor.getUndoRedoManager().addState(event, undoEvent);
	},

	handleModification: function (event) {
		try {
			console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));
			var nodeID = event.memo.nodeID;
			var modifications = event.memo.modifications;

			var node = editor.getView().getNode(nodeID);

			//var allProperties = node.getProperties();

			for (modificationType in modifications)
				if (modifications.hasOwnProperty(modificationType)) {
					var modValue = modifications[modificationType];

					if (modificationType == "addTwin") {
						var numNewTwins = modValue - 1; // current node is one of the twins, so need to create one less
						for (var i = 0; i < numNewTwins; i++) {
							var twinProperty = { "gender": node.getGender() };
							if (node.getAdopted() == "adoptedIn") {
								twinProperty["adoptedStatus"] = node.getAdopted();
							}
							var changeSet = editor.getGraph().addTwin(nodeID, twinProperty);
							editor.getView().applyChanges(changeSet, true);
						}
						node.assignProperties(editor.getGraph().getProperties(nodeID));
					}

					if (modificationType == "makePlaceholder") {
						// TODO
					}
				}

			if (!event.memo.noUndoRedo)
				editor.getUndoRedoManager().addState(event);

		} catch (err) {
			console.log("err: " + err);
		}
	},

	handlePersonDragToNewParent: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var personID = event.memo.personID;
		var parentID = event.memo.parentID;
		if (!editor.getGraph().isPerson(personID) || !editor.getGraph().isValidID(parentID)) return;

		if (editor.getGraph().isRelationship(parentID) && editor.getGraph().isChildlessByChoice(parentID)) {
			var partnership = editor.getView().getNode(parentID);
			partnership.setChildlessStatus(null);
			var newProperties = partnership.getProperties();
			editor.getGraph().setProperties(parentID, newProperties);
		}

		if (editor.getGraph().isChildless(parentID)) {
			editor.getController().handleSetProperty({ "memo": { "nodeID": personID, "properties": { "setAdopted": "adoptedIn" }, "noUndoRedo": true } });
		}

		try {
			var changeSet = editor.getGraph().assignParent(parentID, personID);
			editor.getView().applyChanges(changeSet, true);

			if (changeSet.moved.indexOf(personID) != -1)
				editor.getWorkspace().centerAroundNode(personID, true);

			if (!event.memo.noUndoRedo)
				editor.getUndoRedoManager().addState(event);

		} catch (err) {
			console.log("err: " + err);
		}
	},

	handlePersonNewParents: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var personID = event.memo.personID;
		if (!editor.getGraph().isPerson(personID)) return;

		var changeSet = editor.getGraph().addNewParents(personID);
		editor.getView().applyChanges(changeSet, true);

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);

		return changeSet["new"][0]; // new relationship
	},

	handlePersonNewSibling: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		// { "personID": id, "childParams": data.params.parameters, "preferLeft": false };
		var personID = event.memo.personID;
		var childParams = event.memo.childParams ? Helpers.cloneObject(event.memo.childParams) : {};
		var numTwins = event.memo.twins ? event.memo.twins : 1;
		var numPersons = event.memo.groupSize ? event.memo.groupSize : 0;

		var parentRelationship = editor.getGraph().getParentRelationship(personID);

		if (parentRelationship === null) {
			// need to add new parents
			parentRelationship = editor.getController().handlePersonNewParents({ "memo": { "personID": personID, "noUndoRedo": true } });
		}

		if (event.memo.twins) {
			var nextEvent = { "nodeID": personID, "modifications": { "addTwin": event.memo.twins }, "noUndoRedo": true };
			editor.getController().handleModification({ "memo": nextEvent });
		}
		else {
			var nextEvent = { "partnershipID": parentRelationship, "childParams": childParams, "noUndoRedo": true };
			if (event.memo.groupSize)
				nextEvent["groupSize"] = event.memo.groupSize;

			editor.getController().handleRelationshipNewChild({ "memo": nextEvent });
		}

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);
	},

	handlePersonDragToNewSibling: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var sibling1 = event.memo.sibling1ID;
		var sibling2 = event.memo.sibling2ID;

		var parentRelationship = editor.getGraph().getParentRelationship(sibling1);
		if (parentRelationship == null)
			parentRelationship = editor.getGraph().getParentRelationship(sibling2);

		if (parentRelationship === null) {
			// need to add new parents
			parentRelationship = editor.getController().handlePersonNewParents({ "memo": { "personID": sibling1, "noUndoRedo": true } });
		}

		if (editor.getGraph().getParentRelationship(sibling2) != parentRelationship) {
			// assign sibling 2 to this relationship: covers the case when none have parents or sibling1 has parents
			editor.getController().handlePersonDragToNewParent({ "memo": { "personID": sibling2, "parentID": parentRelationship, "noUndoRedo": true } });
		} else {
			// assign sibling 1 to this relationship
			editor.getController().handlePersonDragToNewParent({ "memo": { "personID": sibling1, "parentID": parentRelationship, "noUndoRedo": true } });
		}

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);
	},

	handlePersonNewPartnerAndChild: function (event) {
		var timer = new Helpers.Timer();

		try {
			console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

			var personID = event.memo.personID;
			if (!editor.getGraph().isPerson(personID)) return;
			var preferLeft = event.memo.preferLeft;
			var childParams = event.memo.childParams ? Helpers.cloneObject(event.memo.childParams) : {};
			var numTwins = event.memo.twins ? event.memo.twins : 1;
			var numPersons = event.memo.groupSize ? event.memo.groupSize : 0;

			if (editor.getGraph().isChildless(personID)) {
				childParams["adoptedStatus"] = "adoptedIn";
			}

			if (numPersons > 0) {
				childParams["numPersons"] = numPersons;
			}

			if (editor.getPreferencesManager().getConfigurationOption("propagateFatherLastName")) {
				var lastName = null;
				if (editor.getGraph().getGender(personID) == "M") {
					lastName = editor.getGraph().getLastName(personID);
				}
				if (lastName && lastName != "") {
					if (childParams.hasOwnProperty("gender") && childParams.gender == 'M') {
						childParams["lName"] = lastName;
					} else {
						childParams["lNameAtB"] = lastName;
					}
				}
			}

			var changeSet = editor.getGraph().addNewRelationship(personID, childParams, preferLeft, numTwins);
			editor.getView().applyChanges(changeSet, true);

			if (!event.memo.noUndoRedo)
				editor.getUndoRedoManager().addState(event);

		} catch (err) {
			console.log("err: " + err);
		}

		timer.printSinceLast("=== Total new partner+child runtime: ");
	},

	handlePersonDragToNewPartner: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var personID = event.memo.personID;
		var partnerID = event.memo.partnerID;
		if (!editor.getGraph().isPerson(personID) || !editor.getGraph().isPerson(partnerID)) return;

		var childProperties = {};
		if (editor.getGraph().isChildless(personID) || editor.getGraph().isChildless(partnerID)) {
			childProperties["adoptedStatus"] = "adoptedIn";
		}

		// when partnering up a node with unknown gender with a node of known gender
		// change the unknown gender to the opposite of known
		var node1 = editor.getView().getNode(personID);
		var node2 = editor.getView().getNode(partnerID);

		if (node1.getGender() == "U" && node2.getGender() != "U") {
			var gender1 = editor.getGraph().getOppositeGender(partnerID);
			node1.setGender(gender1);
			editor.getGraph().setProperties(personID, node1.getProperties());
		}
		else if (node1.getGender() != "U" && node2.getGender() == "U") {
			var gender2 = editor.getGraph().getOppositeGender(personID);
			node2.setGender(gender2);
			editor.getGraph().setProperties(partnerID, node2.getProperties());
		}

		if (editor.getPreferencesManager().getConfigurationOption("propagateFatherLastName")) {
			var lastName = null;
			if (node1.getGender() == "M") {
				lastName = editor.getGraph().getLastName(personID);
			} else if (node2.getGender() == "M") {
				lastName = editor.getGraph().getLastName(partnerID);
			}
			if (lastName && lastName != "") {
				childProperties["lNameAtB"] = lastName;
			}
		}

		// TODO: propagate change of gender down the partnership chain

		var changeSet = editor.getGraph().assignPartner(personID, partnerID, childProperties);
		editor.getView().applyChanges(changeSet, true);

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);
	},

	handleRelationshipNewChild: function (event) {
		console.log("event: " + event.eventName + ", memo: " + Helpers.stringifyObject(event.memo));

		var partnershipID = event.memo.partnershipID;
		if (!editor.getGraph().isRelationship(partnershipID)) return;

		var numTwins = event.memo.twins ? event.memo.twins : 1;

		var childParams = Helpers.cloneObject(event.memo.childParams);
		if (editor.getGraph().isInfertile(partnershipID)) {
			childParams["adoptedStatus"] = "adoptedIn";
		}

		var numPersons = event.memo.groupSize ? event.memo.groupSize : 0;
		if (numPersons > 0) {
			childParams["numPersons"] = numPersons;
		}

		if (editor.getPreferencesManager().getConfigurationOption("propagateFatherLastName")) {
			var lastName = editor.getGraph().getRelationshipChildLastName(partnershipID);
			if (lastName) {
				if (childParams.gender == "M") {
					childParams["lName"] = lastName;
				} else {
					childParams["lNameAtB"] = lastName;
				}
			}
		}

		// check if there is a placeholder child which has to be replaced by the selected child type
		var children = editor.getGraph().getRelationshipChildrenSortedByOrder(partnershipID);
		if (children.length == 1 && editor.getGraph().isPlaceholder(children[0])) {
			var changeSet = editor.getGraph().convertPlaceholderTo(children[0], childParams);

			if (editor.getGraph().isChildlessByChoice(partnershipID)) {
				var partnership = editor.getView().getNode(partnershipID);
				partnership.setChildlessStatus(null);
				var newProperties = partnership.getProperties();
				editor.getGraph().setProperties(partnershipID, newProperties);
			}
		}
		else {
			var changeSet = editor.getGraph().addNewChild(partnershipID, childParams, numTwins);
		}

		editor.getView().applyChanges(changeSet, true);

		if (!event.memo.noUndoRedo)
			editor.getUndoRedoManager().addState(event);
	}
});

Controller._validatePropertyValue = function (nodeID, propertySetFunction, propValue) {
	if (propertySetFunction == "setGender") {
		var possibleGenders = editor.getGraph().getPossibleGenders(nodeID);
		//console.log("valid genders: " + Helpers.stringifyObject(possibleGenders));
		return possibleGenders[propValue];
	}
	return true;
}

Controller._propagateLastNameAtBirth = function (parentID, parentLastName, changeIfEqualTo) {
	var children = editor.getGraph().getAllChildren(parentID);

	for (var i = 0; i < children.length; i++) {
		var childID = children[i];
		var childNode = editor.getView().getNode(childID);

		if (childNode.getLastNameAtBirth() == changeIfEqualTo ||
			(childNode.getLastNameAtBirth() == "" &&
				(childNode.getLastName() == "" || (childNode.getGender() == 'M' && childNode.getLastName() == changeIfEqualTo))
				)) {
			if (childNode.getGender() == 'M' && childNode.getLastNameAtBirth() != changeIfEqualTo) {
				childNode.setLastName(parentLastName);
			} else {
				childNode.setLastNameAtBirth(parentLastName);
			}
			var allProperties = childNode.getProperties();
			editor.getGraph().setProperties(childID, allProperties);
			if (childNode.getGender() == 'M') {
				Controller._propagateLastNameAtBirth(childID, parentLastName, changeIfEqualTo);
			}
		}
	}
}

var PreferencesManager = Class.create({
	initialize: function (templatePreferences) {
		this.preferences = templatePreferences;
	},

	load: function (callWhenReady) {
		// TODO: get URL from endpoints.js after merger with family-studies
		var preferencesJsonURL = new XWiki.Document('PedigreeInterface', 'PhenoTips').getURL('get', 'action=getPreferences');
		preferencesJsonURL += "&rand=" + Math.random();


		//added by Soheil 31.0.2016
		//These lines will load the default hardcoded configuration, instead of calling
		//the backend service which is used in Phenotips

		var defaultResponse = {};
		defaultResponse.responseJSON = {
			"user": {
				"firstName": "",
				"lastName": "",
				"hideDraggingHint": false
			},
			"global": {
				"disabledFields": [],
				"dateDisplayFormat": "MDY",
				"dateEditFormat": "YMD",
				"nonStandardAdoptedOutGraphic": false,
				"propagateFatherLastName": false,
				"lineStyle": "regular"
			}
		};
		this.onPreferencesAvailable(defaultResponse);
		callWhenReady();
		//commented by Soheil ..........................................
		//new Ajax.Request(preferencesJsonURL, {
		//    method: "GET",
		//    onSuccess: this.onPreferencesAvailable.bind(this),
		//    onComplete: callWhenReady ? callWhenReady : {}
		//});
		//...............................................................
	},

	onPreferencesAvailable: function (response) {
		if (response.responseJSON) {
			// only set preferences which are given in the template
			Helpers.setByTemplate(this.preferences, response.responseJSON);
			console.log("Loaded preferences: " + stringifyObject(response.responseJSON));
		} else {
			console.log("Failed to loaded properties, no JSON");
		}
	},

	/**
	 * Returns value of the given config option. Pedigree-specific settings overwrite user settings,
	 * user settings overwrite global installation settings
	 * @method getConfigurationOption
	 * @param {String} Config option name
	 * @return null if not defined, option value otherwise
	 */
	getConfigurationOption: function (optionName) {
		if (this.preferences.pedigree.hasOwnProperty(optionName)) {
			return this.preferences.pedigree[optionName];
		}
		if (this.preferences.user.hasOwnProperty(optionName)) {
			return this.preferences.user[optionName];
		}
		if (this.preferences.global.hasOwnProperty(optionName)) {
			return this.preferences.global[optionName];
		}
		return null;
	},

	setConfigurationOption: function (domain, optionName, value) {
		if (domain == "user") {
			this.preferences.user[optionName] = value;
			// TODO: save to user profile
		} else if (domain == "pedigree") {
			this.preferences.pedigree[optionName] = value;
			// no save: will be saved when the rest of pedigree is saved
		} else {
			throw "Unsupported options domain: " + domain;
		}
	}
});


/**
 * ProbandDataLoader is responsible for retrieving data on the proband.
 *
 * @class ProbandDataLoader
 * @constructor
 */

var ProbandDataLoader = Class.create({
	initialize: function () {
		this.probandData = {};
	},

	load: function (callWhenReady) {
		var probandID = XWiki.currentDocument.page;
		var patientJsonURL = new XWiki.Document('ExportPatient', 'PhenoTips').getURL('get', 'id=' + probandID);
		// IE caches AJAX requests, use a random URL to break that cache (TODO: investigate)
		patientJsonURL += "&rand=" + Math.random();
		new Ajax.Request(patientJsonURL, {
			method: "GET",
			onSuccess: this.onProbandDataReady.bind(this),
			onComplete: callWhenReady ? callWhenReady : {}
		});
	},

	onProbandDataReady: function (response) {
		if (response.responseJSON) {
			this.probandData = response.responseJSON;
		} else {
			console.log("[!] Error parsing patient JSON");
		}
		console.log("Proband data: " + Helpers.stringifyObject(this.probandData));
	},
});
/**
 * SaveLoadEngine is responsible for automatic and manual save and load operations.
 *
 * @class SaveLoadEngine
 * @constructor
 */
var SaveLoadEngine = Class.create({

    initialize: function () {
        this._saveInProgress = false;
    },

    /**
     * Saves the state of the pedigree (including any user preferences and current color scheme)
     *
     * @return Serialization data for the entire graph
     */
    serialize: function () {
        var jsonObject = editor.getGraph().toJSONObject();

        jsonObject["settings"] = editor.getView().getSettings();

        return JSON.stringify(jsonObject);
    },

    createGraphFromSerializedData: function (JSONString, noUndo, centerAround0) {
        console.log("---- load: parsing data ----");
        document.fire("pedigree:load:start");
		
        try {
            var jsonObject = JSON.parse(JSONString);

            // load the graph model of the pedigree & node data
            var changeSet = editor.getGraph().fromJSONObject(jsonObject);

            //The following is added for GEL(GenomicsEngland) by Soheil ................................................
            //This will make remove all unRenderedNode from unRenderedNodeLegend and adds the new one if any exists
            editor._unRenderedLegend.removeAllNodes();
            var unRenderedNodes = changeSet.unRendered;
            editor._unRenderedLegend.addAllNodes(unRenderedNodes);
            editor.getWorkspace().clearMenuText();
            //..........................................................................................................

            // load/process metadata such as pedigree options and color choices
            if (jsonObject.hasOwnProperty("settings")) {
                editor.getView().loadSettings(jsonObject.settings);
            }
        }
        catch (err) {
            console.log("ERROR loading the graph: " + err);
            alert("Error loading the graph");
            document.fire("pedigree:graph:clear");
            document.fire("pedigree:load:finish");
            return;
        }

        if (!noUndo) {
            var probandJSONObject = editor.getProbandDataFromPhenotips();
            var genderOk = editor.getGraph().setProbandData(probandJSONObject);
            if (!genderOk)
                alert("Proband gender defined in Phenotips is incompatible with this pedigree. Setting proband gender to 'Unknown'");
            JSONString = this.serialize();
        }

        if (editor.getView().applyChanges(changeSet, false)) {
            editor.getWorkspace().adjustSizeToScreen();
        }

        if (centerAround0) {
            editor.getWorkspace().centerAroundNode(0);
        }

        if (!noUndo && !editor.isReadOnlyMode()) {
            editor.getUndoRedoManager().addState(null, null, JSONString);
        }
		
		// deal with issue with node not being centered when. This appears to be a timing issue. 
		//setTimeout(function(){ editor.getWorkspace().centerAroundNode(0); }, 1000);
		
        document.fire("pedigree:load:finish");
    },

    createGraphFromImportData: function (importString, importType, importOptions, noUndo, centerAround0) {
        console.log("---- import: parsing data ----");
        document.fire("pedigree:load:start");
		
        try {
            var changeSet = editor.getGraph().fromImport(importString, importType, importOptions);

            //The following is added for GEL(GenomicsEngland) by Soheil ................................................
            //This will make remove all unRenderedNode from unRenderedNodeLegend and adds the new one if any exists
            editor._unRenderedLegend.removeAllNodes();
            var unRenderedNodes = changeSet.unRendered;
            // Swap ngisRegisteredPatientUid with ngisRegisteredPatientSimpleId as is being done in import.
            // This is currently missing for unrendered nodes
            this.swapNgisPatientIdPropertyforUnrenderedNodes(unRenderedNodes);
            editor._unRenderedLegend.addAllNodes(unRenderedNodes);
            editor.getWorkspace().clearMenuText();
            //..........................................................................................................

            if (changeSet == null) throw "Unable to create a pedigree from imported data";
        }
        catch (err) {
            console.error(err);
            alert("Error importing pedigree: " + err);
            document.fire("pedigree:load:finish");
            return;
        }

        if (!noUndo) {
            var probandJSONObject = editor.getProbandDataFromPhenotips();
            var genderOk = editor.getGraph().setProbandData(probandJSONObject);
            if (!genderOk)
                alert("Proband gender defined in Phenotips is incompatible with the imported pedigree. Setting proband gender to 'Unknown'");
            JSONString = this.serialize();
        }

        if (editor.getView().applyChanges(changeSet, false)) {
            editor.getWorkspace().adjustSizeToScreen();
        }

        if (centerAround0) {
            editor.getWorkspace().centerAroundNode(0);
        }

        if (!noUndo && !editor.isReadOnlyMode()) {
            editor.getUndoRedoManager().addState(null, null, JSONString);
        }
		
		// deal with issue with node not being centered when. This appears to be a timing issue. 
		setTimeout(function(){ editor.getWorkspace().centerAroundNode(0); }, 1000);
		
		
        document.fire("pedigree:load:finish");
    },
    reset: function (callback) {
        //this.load();
       /* //The method is commented by Nigel for GEL(GenomicEngland)
        var webservice = new WebService();
        var href = webservice.saveDiagramEndpointPath();
        new Ajax.Request(href, {
            method: 'DELETE',
            postBody: '',
            onCreate: function () {
                document.fire("pedigree:load:start");
            },
            onSuccess: function (response) {
                document.fire("pedigree:load:finish");
                //alert('0');
                //_this._saveInProgress = false;
                //editor.getUndoRedoManager().addSaveEvent();
                //alert('1');
                //savingNotification.replace(new XWiki.widgets.Notification("Successfully reset"));
                //alert('2');

                //Added by Soheil for GEL(GenomicsEngland)
                //If the backend is OpenClinica and it is in adminEdit mode
                //Show the following message after each save ................................................
                //alert('before debugger;');
                //debugger;
                //alert(callback);
                //alert(editor._probandData);
                //window.setTimeout(this.load(editor._probandData), 10);
                window.setTimeout(callback, 10);
            },
            onComplete: function (response) {
            },
            on401: function (response) {
                document.fire("pedigree:load:finish");
                _this.handleSaveFail(_this, savingNotification);

                var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                _this.showUnauthorisedSaveError(message);
            },
            on0: function (response) {
                document.fire("pedigree:load:finish");
                _this.handleSaveFail(_this, savingNotification);

                var message = "-- Connection Error --";
                message += "<br><br><pre>" + response.request.url.replace(/\?.+/, "");
                message += "</pre><br>Please report this to the ";
                message += _this.constructHelpdeskDetails() + "<br>--------<br>";
                _this.showSaveError(message);
            },
            onFailure: function (response) {
                document.fire("pedigree:load:finish");
                _this.handleSaveFail(_this, savingNotification);

                var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                _this.showSaveError(message);
            }
        });*/
    },


    //First callback function is UI related
    //Second callback function is for host related save commands. Did not want a global function in class
    save: function (callback, callback2) {
        if (this._saveInProgress) {
            return;   // Don't send parallel save requests
        }

        editor.getView().unmarkAll();

        //Added by Soheil for GEL(GenomicsEngland)
        //the following line will export the diagram as JSON and pass the param as all
        var privacySetting = "all";
        var exportString = PedigreeExport.exportAsSimpleJSON(editor.getGraph().DG, privacySetting);
        var _this = this;

        var jsonData = this.serialize();

        console.log("[SAVE] data: " + Helpers.stringifyObject(jsonData));

        var svg = editor.getWorkspace().getSVGCopy(false);
        var svgText = svg.getSVGText();

        var savingNotification = new XWiki.widgets.Notification("Saving", "inprogress");
        //The line is commented by Soheil for GEL(GenomicEngland)
        //instead of using XWiki rest end point for saving the value into XML
        //we pass it the backend Webservice URL
        //new Ajax.Request(XWiki.currentDocument.getRestURL('objects/PhenoTips.PedigreeClass/0.xml', 'method=PUT').substring(1), {
        var webservice = new WebService();

        //var href = webservice.saveDiagramEndpointPath();
        var testRequestId = "";
        var userToken = "";
        var urlParams = new URLSearchParams(window.location.search);
        testRequestId = $ESAPI.encoder().encodeForHTML(urlParams.get('testRequestId'));
        userToken = urlParams.get('userToken');


        var postBodyObject = {};
        postBodyObject.pedigree = JSON.parse(exportString);

        //console.log(postBodyObject.pedigree);
        postBodyObject.pedigree.forEach(function(elem){
            if(elem.hpoTermsFullDetails != undefined){
                elem.hpoTermsFullDetails.forEach(function(hpoFullDetail){
                    if(hpoFullDetail.valueAll != undefined && hpoFullDetail.valueAll.hpoModifiers != undefined && hpoFullDetail.valueAll.hpoModifiers.size() > 0){
                        hpoFullDetail.hpoModifiers = hpoFullDetail.valueAll.hpoModifiers;
                    }
                });
            }


        });
        postBodyObject.svgDiagram = svgText;
        postBodyObject.testRequestId = $ESAPI.encoder().encodeForHTML(PedigreeEditorTool.testRequestId);
        postBodyObject.clinicalIndicationName = document.getElementById("canvas-clinical-indication-name").innerHTML.split("Clinical Indication Name: ")[1];

        new Ajax.Request(CONSTANTS.PEDIGREE_SERVICE_URL + "/api/v1.0/pedigree-tool", {
            method: 'POST',
            headers: {
                "Authorization": PedigreeEditorTool.accessToken,

            },
            requestHeaders: {
                Accept: "*",
                Authorization:PedigreeEditorTool.accessToken,

            },
            contentType: "application/json",
            postBody: JSON.stringify(postBodyObject),//'{"jsonDiagram":' + exportString + ',"svgDiagram":' + JSON.stringify(svgText) + '}',
            onCreate: function () {
                _this._saveInProgress = true;
                // Disable save and close buttons during a save
                var closeButton = $('action-close');
                var saveButton = $('action-save');
                var saveAndExitButton = $('action-saveAndExit');

                Element.addClassName(saveButton, "disabled-menu-item");
                Element.removeClassName(saveButton, "menu-item");
                Element.addClassName(saveButton, "no-mouse-interaction");
                Element.addClassName(closeButton, "disabled-menu-item");
                Element.removeClassName(closeButton, "menu-item");
                Element.addClassName(closeButton, "no-mouse-interaction");


                Element.addClassName(saveAndExitButton, "disabled-menu-item");
                Element.removeClassName(saveAndExitButton, "menu-item");
                Element.addClassName(saveAndExitButton, "no-mouse-interaction");


                // IE9 & IE10 do not support "no-mouse-interaction", so add JS to handle this
                if (closeButton != null && closeButton != undefined) {
                    Helpers.disableMouseclicks(closeButton);
                }
                if (saveButton != null && saveButton != undefined) {
                    Helpers.disableMouseclicks(saveButton);
                }
                if (saveAndExitButton != null && saveAndExitButton != undefined) {
                    Helpers.disableMouseclicks(saveAndExitButton);
                }

            },
            onComplete: function (response) {
                _this._saveInProgress = false;
                var actionAfterSave = editor.getAfterSaveAction();
                actionAfterSave && actionAfterSave();
                // Enable save and close buttons after a save
                var closeButton = $('action-close');
                var saveButton = $('action-save');
                var saveAndExitButton = $('action-saveAndExit');

                Element.addClassName(saveButton, "menu-item");
                Element.removeClassName(saveButton, "disabled-menu-item");
                Element.removeClassName(saveButton, "no-mouse-interaction");

                Element.addClassName(closeButton, "menu-item");
                Element.removeClassName(closeButton, "disabled-menu-item");
                Element.removeClassName(closeButton, "no-mouse-interaction");

                Element.addClassName(saveAndExitButton, "menu-item");
                Element.removeClassName(saveAndExitButton, "disabled-menu-item");
                Element.removeClassName(saveAndExitButton, "no-mouse-interaction");


                // remove IE9/IE10 specific handlers
                if (closeButton != null && closeButton != undefined) {
                    Helpers.enableMouseclicks(closeButton);
                }
                if (saveButton != null && saveButton != undefined) {
                    Helpers.enableMouseclicks(saveButton);
                }
                if (saveAndExitButton != null && saveAndExitButton != undefined) {
                    Helpers.enableMouseclicks(saveAndExitButton);
                }
            },
            on401: function (response) {
                PedigreeEditorTool.accessRefreshFunction();
                //_this.handleSaveFail(_this, savingNotification);

                //var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                //_this.showUnauthorisedSaveError(message);
            },
            on0: function (response) {
                _this.handleSaveFail(_this, savingNotification);

                var message = "-- Connection Error --";
                message += "<br><br><pre>" + response.request.url.replace(/\?.+/, "");
                message += "</pre><br>Please report this to the ";
                message += _this.constructHelpdeskDetails() + "<br>--------<br>";
                _this.showSaveError(message);

                if (callback2){
                    callback2(false);
                }
            },
            onFailure: function (response) {
                _this.handleSaveFail(_this, savingNotification);

                var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                _this.showSaveError(message);
                if (callback2){
                    callback2(false);
                }
            },
            onSuccess: function (response) {
                _this._saveInProgress = false;
                editor.getUndoRedoManager().addSaveEvent();
                savingNotification.replace(new XWiki.widgets.Notification("Successfully saved"));

                window.pedigreeStatus.reset();

                //Added by Soheil for GEL(GenomicsEngland)
                //If the backend is OpenClinica and it is in adminEdit mode
                //Show the following message after each save ................................................
                var settings = new Settings();
                var config = settings.getSetting('diagramEndpoint');
                if (config.service === "openclinica") {
                    var webService = new WebService();
                    var isAdminEdit = webService.getUrlParameter("adminEdit", true);
                    if (isAdminEdit && isAdminEdit != undefined && isAdminEdit == "true") {
                        var closeFunction = function () {
                            this.dialog.show();
                            if (callback) {
                                callback();
                            }
                        };
                        editor.getOkCancelDialogue().showCustomized('Your data will be saved for later but not resubmitted to Genomics England. ' +
                            '<br>When you are ready, please resubmit the Pedigree CRF.',
                            "Genomics England",
                            "Close", closeFunction,
                            null, null,
                            null, null, true);
                    } else {
                        if (callback) {
                            callback();
                        }
                    }
                } else {
                    debugger;
                    if (callback) {
                        callback();
                    }
                }
                if (callback2){
                    callback2(true);
                }
            }
        });
    },

    //probandDataObj passed to set  the probandData from the result content returned by the webservice
    load: function (probandDataObj) {
        console.log("initiating load process");
		
        //This line is commented by Soheil for GEL(GenomicsEngland)
        //we load the pedigree diagram JSON from backend webservice instead of xWiki XML
        //new Ajax.Request(XWiki.currentDocument.getRestURL('objects/PhenoTips.PedigreeClass/0.xml').substring(1), {
        var webservice = new WebService();
        //var path = webservice.getDiagramEndpointPath();
        var testRequestId = "";
        var userToken = "";
        var authCode = "";
        var accessToken = "";
        var state = "";

        var _this = this;
        var urlParams = new URLSearchParams(window.location.search);
        var redirectParams = new URLSearchParams(window.location.hash);
        userToken = urlParams.get('userToken');
        accessToken = redirectParams.get('#id_token');
        state = redirectParams.get('state');
        // For calls to tool that already are authenticated, the URL Param 'testRequestID' may contain testRequestId.
        // For calls to tool that are redirected from auth server, the URL Param 'state' will contain testRequestId if 'NoTestRequestId' isn't set.
        testRequestId = urlParams.get('testRequestId') !== null ? $ESAPI.encoder().encodeForHTML(urlParams.get('testRequestId')) : state !== 'NoTestRequestId' ? state : null;
        // If no userToken exists, check if this is a redirect call from OAuth2 where token should exist
        if (userToken === null && accessToken !== null) {
            userToken = accessToken;
        }

        if (userToken === null && CONSTANTS.AUTH_ENABLED === "true") {
            // No security authentication information exists but yet it's expected.
            // Make call out to get authentication code.  This will require user to login if they are not already connected.
            var existingTestRequestId = testRequestId !== null ? $ESAPI.encoder().encodeForHTML(testRequestId) : 'NoTestRequestId'
            var authPath = CONSTANTS.AUTHORIZE_URL + 'client_id=' + encodeURI(CONSTANTS.CLIENT_ID) + '&redirect_uri=' + encodeURI(CONSTANTS.REDIRECT_URL) + '&scope=openid&response_type=id_token&response_mode=fragment&nonce=424242&state=' + existingTestRequestId;
            console.log("GET AUTHORIZE Endpoint: " + authPath);
            // If a state exists, that means we came from redirect but no token was supplied.
            // This is fail-safe check so that we don't get into recursive loop with authentication server.
            if (state === null) {
                // Redirect if no authentication is turned on, no user token exists, and we haven't already called
                // authentication server (no state value).
                window.location = authPath;
             } else {
                // A call was made to authentication server but no token was received.
                // TODO - display message to user
                console.log("ERROR - No token received from authentication server.")
            }
        } else if (PedigreeEditorTool.testRequestId === null) {
            var message = "No Test Request ID specified";
            _this.showLoadError(message);
        } else {

            console.log("we back");

            // ie still aggressively caching get requests, we can uncomment this to add a cache buster to request
            var ieCachBuster = new Date().getTime().toString();
            var path = CONSTANTS.PEDIGREE_SERVICE_URL + '/api/v1.0/pedigree-tool/' + PedigreeEditorTool.testRequestId + "?cb="+ieCachBuster;

            // var path = CONSTANTS.PEDIGREE_SERVICE_URL + '/api/v1.0/pedigree-tool/' + PedigreeEditorTool.testRequestId;
         
			// a bug in either Prototype.js means that the onsuccess event is being fired twice for same ajax call. leading to tool redrawing itself
			// using this as a flag to stop the second redraw
			window.CONSTANTS.pedigreeLoading = true;
			
            new Ajax.Request(path, {
                method: 'GET',
                headers: {
                    "Authorization": PedigreeEditorTool.accessToken
                },
                requestHeaders: {
                    Accept: "*",
                    Authorization: PedigreeEditorTool.accessToken
                },
                contentType: "application/x-www-form-urlencoded",
                onCreate: function (response) {
                    document.fire("pedigree:load:start");
					window.CONSTANTS.pedigreeLoading = true;
                    //Added for GEL(GenomicsEngland).............
                    //We need to stop sending Pre-flight OPTIONS request
                    //http://stackoverflow.com/questions/13814739/prototype-ajax-request-being-sent-as-options-rather-than-get-results-in-501-err
                    /*var SEND_OPTION_REQUEST = false;
                    if (!SEND_OPTION_REQUEST) {
                        var t = response.transport;
                        t.setRequestHeader = t.setRequestHeader.wrap(function (original, k, v) {
                            if (/^(accept|accept-language|content-language)$/i.test(k))
                                return original(k, v);
                            if (/^content-type$/i.test(k) &&
                                /^(application\/x-www-form-urlencoded|multipart\/form-data|text\/plain)(;.+)?$/i.test(v))
                                return original(k, v);
                        });
                    }*/
                },
                on401: function (response) {
                    window.CONSTANTS.pedigreeLoading = false;
					var message = "Invalid User Token"
                    _this.showLoadError(message);
                    PedigreeEditorTool.accessRefreshFunction();
                    //var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                    //_this.showUnauthorisedLoadError(message);
                },
                on0: function (response) {
					window.CONSTANTS.pedigreeLoading = false;
					var message = "-- Connection Error --";
                    message += "<br><br><pre>" + response.request.url.replace(/\?.+/, "");
                    message += "</pre><br>Please report this to the ";
                    message += _this.constructHelpdeskDetails() + "<br>--------<br>";
                    _this.showLoadError(message);
                },
                onFailure: function (response) {
                    window.CONSTANTS.pedigreeLoading = false;
					var message = _this.constructErrorMessage(response.responseJSON, response.statusText);
                    _this.showLoadError("No information for Test Request ID: " + PedigreeEditorTool.testRequestId);

                },
                onSuccess: function (response) {
                    
					//issue with single ajax call, multiple onSuccess calls
					if (!window.CONSTANTS.pedigreeLoading){
						return;
					}
					
					window.CONSTANTS.pedigreeLoading = false;
					
					
					var pedigreeJSONWrapper = response;
                    //console.log("START");
                   // console.log(response);
                    //console.log(response.responseText)
                    probandDataObj.probandData = {};
                    //var pedigreeJSON =  JSON.parse((response.responseJSON).pedigree);
                    var pedigreeJSON = response.responseJSON.pedigree;
                    /*work around to fix comments */
                    for (i = 0; i < pedigreeJSON.length; i++) {
                        if (pedigreeJSON[i].comments == null) {
                            pedigreeJSON[i].comments = " ";
                        }
                    }
                    /*
                                    response.responseJSON.pedigree.forEach(function(elem){
                                        console.log("processing", elem);
                                        console.log(elem.id,elem.father);
                                        console.log(typeof(elem.father));
                                        console.log(typeof(elem.father) == "undefined");
                                        console.log(elem.father == "null");
                                        console.log(elem.father == null)
                                        if(elem.id != "1") {

                                            console.log(elem.id,elem.father, typeof(elem.father), typeof(elem.father) == "undefined")

                                            if (elem.father == null) {
                                                console.log("herea")
                                                delete elem.father;
                                            }
                                            else{
                                                elem.father = parseInt(elem.father);
                                            }
                                            if (elem.mother == null) {
                                                console.log("hereb")
                                                elem.mother = parseInt(elem.mother);

                                                delete elem.mother;

                                            }
                                            console.log("after", elem);
                                        }else{
                                            console.log("!!!");
                                        }
                                    });
                                    console.log("ZZZ",pedigreeJSON);*/
                    //var pedigreeJSON = pedigreeJSONWrapper.svg;
                    //var settings = new Settings();
                    /*var config = settings.getSetting('diagramEndpoint');
                    if (config.service == "openclinica") {
                        pedigreeJSON = response.responseJSON.pedigreeJSON;
                    }*/

                    var jsonContentString = JSON.stringify(pedigreeJSON);
                    var importType = "simpleJSON";
                    var importOptions = {
                        "acceptUnknownPhenotypes": true,
                        "externalIdMark": true,
                        "markEvaluated": false
                    };
                    var noUndo = false;
                    var centerAround0 = true;

                    var event = {
                        "clinicalIndicationName": response.responseJSON.clinicalIndicationName,
                        'clinicalIndicationCode': response.responseJSON.clinicalIndicationCode
                    };
                    document.fire("pedigree:update:clinicalIndicationName", event);

					var testRequestId = response.responseJSON.testRequestId;
					var clinicalIndicationName = response.responseJSON.clinicalIndicationName;
					//console.log("before",testRequestId,clinicalIndicationName);
					document.getElementById("canvas-test-request-simple-id").innerHTML = "Test Request ID: " + $ESAPI.encoder().encodeForHTML(testRequestId);
					document.getElementById("canvas-clinical-indication-name").innerHTML = "Clinical Indication Name: " + $ESAPI.encoder().encodeForHTML(clinicalIndicationName);
					//console.log("aft",testRequestId);
					//console.log(clinicalIndicationName);
                    //response.responseJSON.clinicalIndicationName
                    //response.responseJSON.clinicalIndicationCode
					this.createGraphFromImportData(jsonContentString, importType, importOptions, noUndo, centerAround0);
					window.pedigreeStatus.reset();
					setTimeout(function () {
                        if (response.responseJSON.testRequestSimpleId) {

                            document.fire("pedigree:update:topMenu", {"testRequestId": response.responseJSON.testRequestSimpleId});
                        } else {
                            document.fire("pedigree:update:topMenu", {"testRequestId": testRequestId});
                        }
					}, 200);
				
                }.bind(this)
            });
        }
    },
    handleSaveFail: function (_this, savingNotification) {
        _this._saveInProgress = false;
        editor.getUndoRedoManager().addSaveEvent();
        savingNotification.replace(new XWiki.widgets.Notification("Save unsuccessful"));
    },
    showLoadError: function (reason) {
        this.showLoadErrorWithReason("", reason);
    },
    showUnauthorisedLoadError: function (reason) {
        this.showLoadErrorWithReason("!! User is not allowed to load pedigree model !!", reason);
    },
    showLoadErrorWithReason: function (message, reason) {
        var fullMessage = message + "<br><br>" + reason;
        editor.getOkCancelDialogue().showCustomized(fullMessage, "Pedigree Editor", null, null, null ,null ,null, null, true);
        /*editor.getOkCancelDialogue().showCustomized(fullMessage, "Error Loading Model", "Choose Template",
            function () {
                new TemplateSelector(false);
            }, null, null, null, null, true);*/
    },
    showSaveError: function (reason) {
        this.showSaveErrorWithReason("!! Failed to save pedigree model !!", reason);
    },
    showUnauthorisedSaveError: function (reason) {
        this.showSaveErrorWithReason("!! User is not allowed to save pedigree model !!", reason);
    },
    showSaveErrorWithReason: function (message, reason) {
        var fullMessage = message + "<br><br>" + reason;
        editor.getOkCancelDialogue().showCustomized(fullMessage, "Error", "Close",
            function () {
            }, null, null, null, null, true);
    },
    constructErrorMessage: function (json, status) {
        var message = "-- " + status;

        if (json) {
            // All messages from Mercury contain an errorcode or a type
            if (json.errorCode || json.type) {
                message = this.constructMercuryErrorMessage(json, message);
            }
            else if (json.message) {
                message += " :: " + json.message + " --";
            }
        } else {
            message += " :: Unknown cause --";
        }
        return message + "<br>--------<br>";
    },
    constructMercuryErrorMessage: function (json, message) {
        var renderJson = {};
        if (json.message) {
            message += ' --<br><br>:: ';

            // Add the error code to the message if its missing
            // This happens for errors which aren't exceptions
            if (json.errorCode && !json.message.startsWith(json.errorCode)) {
                message += json.errorCode + " - ";
            }

            message += json.message + " ::<br>";

            if (json.exception) {
                message += this.constructExceptionSection(json.exception);
            } else if (json.type) {
                message += this.constructExceptionSection(json);
            }

            if (json.validationErrors) {
                message += this.constructJsonRenderSection(json.validationErrors, 'Please find the validation errors below');
            }
        }

        // Situation of exception response when rendering, no standard exception JSON
        else if (json.type) {
            message += " :: " + json.type;
            message += this.constructExceptionSection(json);
        }
        // Just a general catch all for unknown situation
        else {
            message += " :: Unknown Reason --";
        }

        return message;
    },
    constructExceptionSection: function (exception) {
        renderJson = {
            exception: {
                type: exception.type,
                message: exception.message
            }
        };

        if (exception.stacktrace) {
            renderJson.exception.stacktrace = exception.stacktrace;
        }

        return this.constructJsonRenderSection(renderJson, 'Please copy the below and provide to the ' + this.constructHelpdeskDetails());
    },
    constructJsonRenderSection: function (renderJson, title) {
        var message = '<br>--------<br>' + title + '<br><br>';
        message += '<pre style="text-align: left;">';
        message += JSON.stringify(renderJson, null, 2);
        message += "</pre>";
        return message;
    },
    constructHelpdeskDetails: function () {
        var contact = 'Help Desk';

        var settings = new Settings();
        var config = settings.getSetting('helpdesk');

        if (config) {
            contact = config.name;
            contact += '<br>';
            contact += config.contact.phone + " :: " + config.contact.email;
        }
        return contact;
    },
    swapNgisPatientIdPropertyforUnrenderedNodes : function(nodes){

        if (nodes == null || nodes == undefined){
            return;
        }
        for (var i = 0; i < nodes.length; i++){

            var currentNode = nodes[i];

            var currentNgisRegisteredPatientUid = currentNode.ngisRegisteredPatientUid;
            var currentNgisRegisteredPatientSimpleId = currentNode.ngisRegisteredPatientSimpleId;

            currentNode.ngisRegisteredPatientUid = currentNgisRegisteredPatientSimpleId;
            currentNode.ngisRegisteredPatientSimpleId = currentNgisRegisteredPatientUid;

        }

    }
});

/*
 * VersionUpdater is responsible for updating pedigree JSON represenatation to the current version.
 */
VersionUpdater = Class.create({
	initialize: function () {
		this.availableUpdates = [
			{ "comment": "group node comment representation",
				"introduced": "May2014",
				"func": "updateGroupNodeComments"},
			{ "comment": "adopted status",
				"introduced": "Nov2014",
				"func": "updateAdoptedStatus"},
			{ "comment": "id desanitation",
				"introduced": "Mar2015",
				"func": "updateId"}
		];
	},

	updateToCurrentVersion: function (pedigreeJSON) {
		for (var i = 0; i < this.availableUpdates.length; i++) {
			var update = this.availableUpdates[i];

			var updateResult = this[update.func](pedigreeJSON);

			if (updateResult !== null) {
				console.log("[update #" + i + "] [updating to " + update.introduced + " version] - performing " + update.comment + " update");
				pedigreeJSON = updateResult;
			}
		}

		return pedigreeJSON;
	},

	/* - assumes input is in the pre-May-2014 format
	 * - returns null if there were no changes; returns new JSON if there was a change
	 */
	updateGroupNodeComments: function (pedigreeJSON) {
		var change = false;
		var data = JSON.parse(pedigreeJSON);
		for (var i = 0; i < data.GG.length; i++) {
			var node = data.GG[i];

			if (node.hasOwnProperty("prop")) {
				if (node.prop.hasOwnProperty("numPersons") && !node.prop.hasOwnProperty("comments") && node.prop.hasOwnProperty("fName") && node.prop.hasOwnProperty("fName") != "") {
					node.prop["comments"] = node.prop.fName;
					delete node.prop.fName;
					change = true;
				}
			}
		}

		if (!change) {
			return null;
		}

		return JSON.stringify(data);
	},

	/* - assumes input is in the pre-Nov-2014 format
	 * - returns null if there were no changes; returns new JSON if there was a change
	 */
	updateAdoptedStatus: function (pedigreeJSON) {
		var change = false;
		var data = JSON.parse(pedigreeJSON);
		for (var i = 0; i < data.GG.length; i++) {
			var node = data.GG[i];

			if (node.hasOwnProperty("prop")) {
				if (node.prop.hasOwnProperty("isAdopted")) {
					if (node.prop.isAdopted) {
						node.prop["adoptedStatus"] = "adoptedIn";
					}
					delete node.prop.isAdopted;
					change = true;
				}
			}
		}

		if (!change) {
			return null;
		}

		return JSON.stringify(data);
	},
	/* - assumes input is in the pre-Mar-2015 format
	 * - returns null if there were no changes; returns new JSON if there was a change
	 */
	updateId: function (pedigreeJSON) {
		var change = false;
		var data = JSON.parse(pedigreeJSON);
		for (var i = 0; i < data.GG.length; i++) {
			var node = data.GG[i];

			if (node.hasOwnProperty("prop")) {
				if (node.prop.hasOwnProperty("disorders")) {
					for (var j = 0; j < node.prop.disorders.length; j++) {
						node.prop.disorders[j] = desanitizeId(node.prop.disorders[j]);
						change = true;
					}
				}
				if (node.prop.hasOwnProperty("hpoTerms")) {
					for (var j = 0; j < node.prop.hpoTerms.length; j++) {
						node.prop.hpoTerms[j] = desanitizeId(node.prop.hpoTerms[j]);
						change = true;
					}
				}
				if (node.prop.hasOwnProperty("candidateGenes")) {
					for (var j = 0; j < node.prop.candidateGenes.length; j++) {
						node.prop.candidateGenes[j] = desanitizeId(node.prop.candidateGenes[j]);
						change = true;
					}
				}
			}
		}

		if (!change) {
			return null;
		}

		return JSON.stringify(data);

		function desanitizeId(id) {
			var temp = id.replace(/__/g, " ");
			temp = temp.replace(/_C_/g, ":");
			temp = temp.replace(/_L_/g, "(");
			return temp.replace(/_J_/g, ")");
		}
	}
});

/**
 * LineSet is used to track existing lines in the graph and simplify line-crossing-line tracking
 *
 * @class LineSet
 * @constructor
 */
var LineSet = Class.create({
	initialize: function () {
		this._lineCrossings = {};  // { owner: {set of owners of lines crossing its lines} }
		this._lines = [];  // array of sets {owner, x1, y1, x2, y2}
	},

	replaceIDs: function (changedIdsSet) {
		var newLineCrossings = {};
		for (var oldOwnerID in this._lineCrossings)
			if (this._lineCrossings.hasOwnProperty(oldOwnerID)) {
				var crosses = this._lineCrossings[oldOwnerID];
				var newCrosses = {};

				for (var oldID in crosses)
					if (crosses.hasOwnProperty(oldID)) {
						var newID = changedIdsSet.hasOwnProperty(oldID) ? changedIdsSet[oldID] : oldID;
						newCrosses[newID] = true;
					}

				var newOwnerID = changedIdsSet.hasOwnProperty(oldOwnerID) ? changedIdsSet[oldOwnerID] : oldOwnerID;
				newLineCrossings[newOwnerID] = newCrosses;
			}
		this._lineCrossings = newLineCrossings;

		for (var i = 0; i < this._lines.length; i++) {
			var oldID = this._lines[i].owner;
			var newID = changedIdsSet.hasOwnProperty(oldID) ? changedIdsSet[oldID] : oldID;
			this._lines[i].owner = newID;
		}
	},

	addLine: function (owner, x1, y1, x2, y2) {
		// returns: list of crossings [ {x,y} ... {x, y} ]

		// TODO: improve performance by ordering by y or x coordinate -> not critical for now

		if (!this._lineCrossings.hasOwnProperty(owner))
			this._lineCrossings[owner] = {};

		var bendPoints = [];

		var thisLine = { "owner": owner, "x1": x1, "y1": y1, "x2": x2, "y2": y2 };

		// scan through all vertical lines
		for (var i = 0; i < this._lines.length; i++) {
			var line = this._lines[i];
			if (line.owner == owner) continue;

			var crossingPoint = this._getLineCrossing(thisLine, line);
			if (crossingPoint) {
				this._lineCrossings[line.owner][owner] = true;  // that line affects this one
				bendPoints.push(crossingPoint);
			}
		}

		this._lines.push(thisLine);

		return bendPoints;
	},

	removeAllLinesByOwner: function (owner) {
		//console.log("removing all lines by " + owner);

		if (!this._lineCrossings.hasOwnProperty(owner)) return {};

		for (var i = this._lines.length - 1; i >= 0; i--) {
			var line = this._lines[i];
			if (line.owner == owner)
				this._lines.splice(i, 1);
		}

		var affectedOwners = this._lineCrossings[owner];
		delete this._lineCrossings[owner];

		for (var ownerID in this._lineCrossings)
			if (this._lineCrossings.hasOwnProperty(ownerID)) {
				var crosses = this._lineCrossings[ownerID];
				if (crosses.hasOwnProperty(owner)) {
					delete crosses[owner];
				}
			}

		//console.log("Removing " + owner + ", affected: " + Helpers.stringifyObject(affectedOwners));
		return affectedOwners;
	},

	removeAllLinesAffectedByOwnerMovement: function (owner) {
		var returnNewAffected = [];

		var processed = {};
		processed[owner] = true;

		var affected = [ owner ];

		while (affected.length > 0) {
			var next = affected.pop();

			var newAffected = this.removeAllLinesByOwner(next);

			for (var o in newAffected) {
				if (newAffected.hasOwnProperty(o)) {
					if (!processed.hasOwnProperty(o)) {
						affected.push(parseInt(o));
						returnNewAffected.push(parseInt(o));
						processed[o] = true;
					}
				}
			}
		}

		//console.log("affected: " + Helpers.stringifyObject(returnNewAffected));
		//console.log("this: " + Helpers.stringifyObject(this));
		return returnNewAffected;
	},

	_getLineCrossing: function (line1, line2) {
		// Return the coordinates of a point of intersection of the given two line segments.
		// Return null if the line segments are parallel 9even if they cross) or do not intersect
		// (note: ignores intersection at segment ends)
		//
		// The two linesin parametric form:
		//   l1(t) = (x1, y1) + (x2-x1, y2-y1)*t
		//   l2(s) = (u1, v1) + (u2-u1, v2-v1)*s
		//
		//   Intersection, i.e. l1(t) = l2(s) implies two scalar equations:
		//
		//      x1 + (x2-x1)*t = u1 + (u2-u1)*s
		//      y1 + (y2-y1)*t = v1 + (v2-v1)*s
		//
		//      (x2-x1)*t - (u2-u1)*s = u1-x1
		//      (y2-y1)*t - (v2-v1)*s = v1-y1
		//
		//  | a b | | t |  =  | e |
		//  | c d | | s |     | f |

		var a = line1.x2 - line1.x1;
		var b = line2.x1 - line2.x2;
		var c = line1.y2 - line1.y1;
		var d = line2.y1 - line2.y2;
		var e = line2.x1 - line1.x1;
		var f = line2.y1 - line1.y1;

		var denom = a * d - b * c;

		if (Math.abs(denom) <= 0.001) return null; // determinant is ~0, parallel

		var t = (e * d - b * f) / denom;
		var s = (a * f - e * c) / denom;

		if (t <= 0 || t >= 1 || s <= 0 || s >= 1)   // lines intersect but line segments do not, parameters outside of [0,1]
			return 0;                               // (or intersection is at the edge, when t == 0 or t == 1 or s == 0 or s == 1

		var px = line1.x1 + t * (line1.x2 - line1.x1);
		var py = line1.y1 + t * (line1.y2 - line1.y1);

		return { "x": px, "y": py };
	}
});
var ChildlessBehavior = {
	/**
	 * Returns the Childless status of this node
	 *
	 * @method getChildlessStatus
	 * @return {Null|String} null, Childless or Infertile
	 */
	getChildlessStatus: function () {
		return this._childlessStatus;
	},

	/**
	 * Returns true if the status is either 'Infertile' or 'Childless'
	 *
	 * @method isValidChildlessStatus
	 * @return {Boolean}
	 */
	isValidChildlessStatus: function (status) {
		return ((status == 'Infertile' || status == 'Childless'));
	},

	/**
	 * Returns the reason for this node's status of 'Infertile' or 'Childless'
	 *
	 * @method getChildlessReason
	 * @return {String}
	 */
	getChildlessReason: function () {
		return this._childlessReason;
	},

	/**
	 * Changes the reason for this node's 'Childless' or 'Infertile' status
	 *
	 * @method setChildlessReason
	 * @param {String} reason Explanation for the condition (eg. "By Choice", "Vasectomy" etc)
	 */
	setChildlessReason: function (reason) {
		if (this.getChildlessStatus() == null)
			reson = "";
		this._childlessReason = reason;
		this.getGraphics().updateChildlessStatusLabel();
	}
};
var ChildlessBehaviorVisuals = {

	/**
	 * Returns the Childless status shape for this Person
	 *
	 * @method getChildlessShape
	 * @return {Raphael.el}
	 */
	getChildlessShape: function () {
		return this._childlessShape;
	},

	/**
	 * Returns the Raphaël element for this Person's Childless status reason label
	 *
	 * @method getChildlessStatusLabel
	 * @return {Raphael.el}
	 */
	getChildlessStatusLabel: function () {
		return this._childlessStatusLabel;
	},

	/**
	 * Updates the Childless status icon for this Node based on the Childless/infertility status.
	 *
	 * @method updateChildlessShapes
	 */
	updateChildlessShapes: function () {
		var status = this.getNode().getChildlessStatus();
		this._childlessShape && this._childlessShape.remove();

		if (status) {
			var x = this.getX();
			var y = this.getY();
			var r = PedigreeEditorParameters.attributes.infertileMarkerWidth;
			var lowY = this.getBottomY() + PedigreeEditorParameters.attributes.infertileMarkerHeight;

			var childlessPath = [
				["M", x, y],
				["L", x, lowY],
				["M", x - r, lowY],
				["l", 2 * r, 0]
			];
			if (status == 'Infertile')
				childlessPath.push(["M", x - r, lowY + 5], ["l", 2 * r, 0]);

			this._childlessShape = editor.getPaper().path(childlessPath);
			if (status == 'Childless' && this.getChildlessShapeAttr) {
				this._childlessShape.attr(this.getChildlessShapeAttr());
			} else {
				this._childlessShape.attr(PedigreeEditorParameters.attributes.childlessShapeAttr);
			}
			this._childlessShape.toBack();
		}
	},

	/**
	 * Updates the Childless status reason label for this Person
	 *
	 * @method updateChildlessStatusLabel
	 */
	updateChildlessStatusLabel: function () {
		this._childlessStatusLabel && this._childlessStatusLabel.remove();
		this._childlessStatusLabel = null;

		var text = "";
		this.getNode().getChildlessReason() && (text += this.getNode().getChildlessReason());

		if (text.strip() != '') {
			this._childlessStatusLabel = editor.getPaper().text(this.getX(), this.getBottomY() + 18, "(" + text.slice(0, 15) + ")");
			this._childlessStatusLabel.attr({'font-size': 18, 'font-family': 'Cambria'});
			this._childlessStatusLabel.toBack();
		}

		this.drawLabels();
	}
};
/**
 * Class for visualizing partnerships and organizing the graphical elements.
 *
 * @class PartnershipVisuals
 * @extends AbstractNodeVisuals
 * @constructor
 * @param {Partnership} node The node for which the graphics are handled
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 */
var PartnershipVisuals = Class.create(AbstractNodeVisuals, {

	initialize: function ($super, partnership, x, y) {
		//console.log("partnership visuals");
		$super(partnership, x, y);
		this._childlessShape = null;
		this._childlessStatusLabel = null;
		this._junctionShape = editor.getPaper().circle(x, y, PedigreeEditorParameters.attributes.partnershipRadius).attr(PedigreeEditorParameters.attributes.partnershipNode);
		this._junctionShape.node.setAttribute("class", "pedigree-partnership-circle");

		if (editor.isReadOnlyMode()) {
			this._hoverBox = new ReadOnlyHoverbox(partnership, x, y, this.getShapes());
		} else {
			this._hoverBox = new PartnershipHoverbox(partnership, x, y, this.getShapes());
		}
		this.updateIDLabel();

		this._childhubConnection = null;
		this._partnerConnections = null;

		this.updatePartnerConnections();
		this.updateChildhubConnection();
		//console.log("partnership visuals end");
	},

	updateIDLabel: function () {
		if (!editor.DEBUG_MODE) return;
		var x = this.getX();
		var y = this.getY();
		this._idLabel && this._idLabel.remove();
		this._idLabel = editor.getPaper().text(x, y - 20, this.getNode().getID()).attr(PedigreeEditorParameters.attributes.dragMeLabel).insertAfter(this._junctionShape.flatten());
	},

	/**
	 * Updates whatever needs to change when node id changes (e.g. id label)
	 *
	 * @method onSetID
	 */
	onSetID: function ($super, id) {
		$super(id);
		this.updateIDLabel();
	},

	/**
	 * Expands the partnership circle
	 *
	 * @method grow
	 */
	grow: function () {
		if (this.area) return;
		this.area = this.getJunctionShape().clone().flatten().insertBefore(this.getJunctionShape().flatten());
		this.area.attr({'fill': 'green', stroke: 'none'});
		this.area.ot = this.area.transform();
		this.area.attr({transform: "...S2"});
	},

	/**
	 * Shrinks node graphics to the original size
	 *
	 * @method shrink
	 */
	shrink: function () {
		this.area && this.area.remove();
		delete this.area;
	},

	/**
	 * Marks the node in a way different from glow
	 *
	 * @method grow
	 */
	markPregnancy: function () {
		// TODO: maybe mark pregnancy bubble?
		if (this.mark) return;
		this.mark = this.getJunctionShape().glow({width: 10, fill: true, opacity: 0.3, color: "blue"}).insertBefore(this.getJunctionShape().flatten());
	},

	/**
	 * Unmarks the node
	 *
	 * @method unmark
	 */
	unmarkPregnancy: function () {
		this.mark && this.mark.remove();
		delete this.mark;
	},

	markPermanently: function () {
		if (this.mark2) return;
		this.mark2 = this.getJunctionShape().glow({width: 18, fill: true, opacity: 0.4, color: "#ee8d00"}).insertBefore(this.getJunctionShape().flatten());
	},
	unmark: function () {
		this.mark2 && this.mark2.remove();
		delete this.mark2;
	},

	/**
	 * Returns the circle that joins connections
	 *
	 * @method getJunctionShape
	 * @return {Raphael.st}
	 */
	getJunctionShape: function () {
		return this._junctionShape;
	},

	/**
	 * Returns the Y coordinate of the lowest part of this node's graphic on the canvas
	 *
	 * @method getY
	 * @return {Number} The y coordinate
	 */
	getBottomY: function () {
		return this._absoluteY + PedigreeEditorParameters.attributes.partnershipRadius + PedigreeEditorParameters.attributes.parnershipChildlessLength;
	},

	_isDisplayedAsConsanguinous: function () {
		var consangr = editor.getGraph().isConsangrRelationship(this.getNode().getID());
		var nodeConsangrPreference = this.getNode().getConsanguinity();
		if (nodeConsangrPreference == "N")
			consangr = false;
		if (nodeConsangrPreference == "Y")
			consangr = true;
		return consangr;
	},

	/**
	 * Updates the path of all connections to all partners
	 *
	 * @method updatePartnerConnections
	 */
	updatePartnerConnections: function () {
		this._partnerConnections && this._partnerConnections.remove();

		editor.getPaper().setStart();

		var id = this.getNode().getID();

		var consangr = this._isDisplayedAsConsanguinous();

		var lineAttr = consangr ? PedigreeEditorParameters.attributes.consangrPartnershipLines : PedigreeEditorParameters.attributes.partnershipLines;
		var lineAttrNoContact = consangr ? PedigreeEditorParameters.attributes.noContactLinesConsangr : PedigreeEditorParameters.attributes.noContactLines;

		var partnerPaths = editor.getGraph().getPathToParents(id);  // partnerPaths = [ [virtual_node_11, ..., virtual_node_1n, parent1], [virtual_node_21, ..., virtual_node_2n, parent21] ]

		// TODO: a better curve algo for the entire curve at once?
		var smoothCorners = true;
		var cornerRadius = PedigreeEditorParameters.attributes.curvedLinesCornerRadius;

		for (var p = 0; p < partnerPaths.length; p++) {
			var path = partnerPaths[p];

			// for the last piece which attaches to the person:
			// need to consider which attachment point to use, and may have to do a bended curve from current Y to the attachment point Y
			var person = path[path.length - 1];
			var finalSegmentInfo = editor.getGraph().getRelationshipLineInfo(id, person);

			var nodePos = editor.getGraph().getPosition(person);
			var finalPosition = editor.convertGraphCoordToCanvasCoord(nodePos.x, nodePos.y);
			var finalYTo = editor.convertGraphCoordToCanvasCoord(0, finalSegmentInfo.attachY).y;
			var yTop = editor.convertGraphCoordToCanvasCoord(0, finalSegmentInfo.verticalY).y;
			var lastBend = ((finalYTo == yTop) && (yTop < this.getY()) && finalSegmentInfo.attachmentPort == 1) ?
				Infinity :
				( finalSegmentInfo.numAttachPorts > 1 ?
					PedigreeEditorParameters.attributes.radius * (1.8 + finalSegmentInfo.numAttachPorts * 0.1 - finalSegmentInfo.attachmentPort * 0.35) :
					PedigreeEditorParameters.attributes.radius * 1.6
					);
			//console.log("Rel: " + id + ", Y: " + this.getY() + ", Attach/FinalY: " +finalYTo + ", yTOP: " + yTop + ", lastbend: " + lastBend + ", finalPos: " + Helpers.stringifyObject(finalPosition));

			var goesLeft = false;                        // indicates if the current step fo the path is right-to-left or left-to-right
			var xFrom = this.getX();                  // always the X of the end of the previous segment of the curve
			var yFrom = this.getY();                  // always the Y of the end of the previous segment of the curve
			var xTo = xFrom;
			var yTo = yFrom;
			var prevY = yFrom;                        // y-coordinate of the previous node: used to determine vertical vs horizontal segments
			var prevX = xFrom;
			var vertical = false;                        // direction of the previous segment
			var wasAngle = false;
			var firstDraw = true;

			//console.log("Path: " + Helpers.stringifyObject(path));

			for (var i = 0; i < path.length; i++) {
				var nextNodeOnPath = path[i];

				var nodePos = editor.getGraph().getPosition(nextNodeOnPath);
				var position = editor.convertGraphCoordToCanvasCoord(nodePos.x, nodePos.y);

				if (editor.DEBUG_MODE) {
					var _idLabel = editor.getPaper().text(position.x, position.y, nextNodeOnPath).attr(PedigreeEditorParameters.attributes.dragMeLabel).toFront();
					_idLabel.node.setAttribute("class", "no-mouse-interaction");
				}
				//console.log("NextNode: " + nextNodeOnPath + ", nodePos: " + Helpers.stringifyObject(nodePos) + ", position: " + Helpers.stringifyObject(position) );

				if (position.x < xFrom)   // depending on curve direction upper/lower curves of  adouble-line are shifted in different directions
					goesLeft = true;
				else if (position.x > xFrom)
					goesLeft = false;

				var newVertical = (prevY != position.y);

				var angled = (prevX != position.x && prevY != position.y);

				var changesDirection = ((vertical && !newVertical) || (!vertical && newVertical)) || angled;

				if (i == path.length - 1 && prevY == yTop) {
					angled = false;
					changesDirection = (xFrom != xTo || yFrom != yTo);
					newVertical = false;
				}

				// if necessary, mark first segment on the left as broken
				if (i == 0 && goesLeft && this.getNode().getBrokenStatus()) {
					editor.getView().drawLineWithCrossings(id, xFrom, yFrom, xFrom - 16, yFrom, lineAttr, consangr, goesLeft, false, firstDraw);
					editor.getPaper().path("M " + (xFrom - 29) + " " + (yFrom + 9) + " L " + (xFrom - 15) + " " + (yFrom - 9)).attr(lineAttr).toBack();
					editor.getPaper().path("M " + (xFrom - 24) + " " + (yFrom + 9) + " L " + (xFrom - 10) + " " + (yFrom - 9)).attr(lineAttr).toBack();
					xFrom -= 23;
					firstDraw = false;
				}

				//console.log("angled: " + angled + ", changes: " + changesDirection);

				if (changesDirection) {  // finish drawing the current segment
					editor.getView().drawLineWithCrossings(id, xFrom, yFrom, xTo, yTo, lineAttr, consangr, goesLeft, false, firstDraw);
					xFrom = xTo;
					yFrom = yTo;
					firstDraw = false;
				}

				xTo = position.x;
				yTo = (i >= path.length - 2) ? yTop : position.y;
				prevY = position.y;
				prevX = position.x;

				//------------------
				// note: assume that we always draw bottom to top, as relationship nodes are always at or below partner level

				if (smoothCorners && ( (!wasAngle && !angled) || (i >= path.length - 2 && path.length > 1))) {
					//console.log("corner from " + xFrom + "," + yFrom + ", newVert: " + newVertical );
					if (newVertical && !vertical) {
						// was horizontal, now vertical - draw the smooth corner Horiz->Vert (curve bends down)
						if (xTo < xFrom) {
							GraphicHelpers.drawCornerCurve(xFrom, yFrom, xFrom - cornerRadius, yFrom - cornerRadius, true, lineAttr, consangr, +2.5, -2.5, -2.5, +2.5);
							xFrom -= cornerRadius;
							yFrom -= cornerRadius;
						}
						else {
							GraphicHelpers.drawCornerCurve(xFrom, yFrom, xFrom + cornerRadius, yFrom - cornerRadius, true, lineAttr, consangr, +2.5, 2.5, -2.5, -2.5);
							xFrom += cornerRadius;
							yFrom -= cornerRadius;
						}
					} else if (!newVertical && vertical) {
						// was vertical, now vertical - draw the smooth corner Vert->Horiz (curve bends up)
						if (xTo < xFrom) {
							GraphicHelpers.drawCornerCurve(xFrom, yFrom, xFrom - cornerRadius, yFrom - cornerRadius, false, lineAttr, consangr, -2.5, 2.5, 2.5, -2.5);
							xFrom -= cornerRadius;
							yFrom -= cornerRadius;
						}
						else {
							GraphicHelpers.drawCornerCurve(xFrom, yFrom, xFrom + cornerRadius, yFrom - cornerRadius, false, lineAttr, consangr, 2.5, 2.5, -2.5, -2.5);
							xFrom += cornerRadius;
							yFrom -= cornerRadius;
						}
					} else if (!newVertical) {
						// horizontal: stop the line a bit earlier so that we can draw a smooth corner
						if (i != path.length - 1) {
							if (position.x > xFrom)
								xTo -= cornerRadius;             // going right: stop a bit to the right
							else
								xTo += cornerRadius;             // going left: stop a bit to the left
						}
					} else {
						// vertical: stop the line a bit earlier so that we can draw a smooth corner
						yTo += cornerRadius;                     // always going up, so stop a bit below
					}
				}
				//------------------

				vertical = newVertical;
				wasAngle = angled;
			}

			var lostContact = !editor.getView().getNode(person).isProband() &&
				editor.getView().getNode(person).getLostContact() &&
				editor.getGraph().isPartnershipRelatedToProband(id);

			var thisLineAttr = lostContact ? lineAttrNoContact : lineAttr;

			if (yFrom >= finalPosition.y + cornerRadius * 2) {
				editor.getView().drawLineWithCrossings(id, xFrom, yFrom, xTo, finalYTo, thisLineAttr, consangr, false, firstDraw);
			}
			else {
				// draw a line/curve from (xFrom, yFrom) trough (..., yTop) to (xTo, yTo).
				// It may be a line if all y are the same, a line with one bend or a line with two bends
				editor.getView().drawCurvedLineWithCrossings(id, xFrom, yFrom, yTop, xTo, finalYTo, lastBend, thisLineAttr, consangr, goesLeft, firstDraw);
			}
		}

		this._partnerConnections = editor.getPaper().setFinish().toBack();
		if (this.getNode().getGraphics()) {
			this.getHoverBox().regenerateHandles();
			this.getHoverBox().regenerateButtons();
		}
	},

	/**
	 * Updates the path of the connection for the given pregnancy or creates a new
	 * connection if it doesn't exist.
	 *
	 * @method updateChildhubConnection
	 */
	updateChildhubConnection: function () {
		this._childhubConnection && this._childhubConnection.remove();

		var twinCommonVerticalPieceLength = PedigreeEditorParameters.attributes.twinCommonVerticalLength;

		var positionedGraph = editor.getGraph();

		var id = this.getNode().getID();

		var childlinePos = positionedGraph.getRelationshipChildhubPosition(id);
		var childlineY = editor.convertGraphCoordToCanvasCoord(childlinePos.x, childlinePos.y).y;

		// draw child edges from childhub
		var children = positionedGraph.getRelationshipChildrenSortedByOrder(id);

		if (children.length == 1 && editor.getGraph().isPlaceholder(children[0])) {
			editor.getPaper().setStart();
			//editor.getView().drawLineWithCrossings( id, this.getX(), this.getY(), this.getX(), this.getY() + PedigreeEditorParameters.attributes.partnershipHandleBreakY, P
			this._childhubConnection = editor.getPaper().setFinish();
			return;
		}
		editor.getPaper().setStart();


		var leftmostX = this.getX();
		var rightmostX = this.getX();

		var currentTwinGroup = null;
		var currentTwinGroupCenterX = null;
		var currentIsMonozygothic = false;

		var numPregnancies = 0;

		var allChildrenLostContact = true;

		for (var j = 0; j < children.length; j++) {
			var child = children[j];

			if (!editor.getView().checkNodeExists(child)){
                continue;
            }


			var twinGroupId = positionedGraph.getTwinGroupId(child);

			if (twinGroupId != currentTwinGroup) {
				numPregnancies++;

				currentTwinGroup = twinGroupId;

				var allTwins = positionedGraph.getAllTwinsSortedByOrder(child);
				var positionL = editor.getView().getNode(allTwins[0]).getX();
				var positionR = editor.getView().getNode(allTwins[allTwins.length - 1]).getX();
				var positionY = editor.getView().getNode(allTwins[0]).getY();
				currentTwinGroupCenterX = (positionL + positionR) / 2;
				if (allTwins.length == 3)
					currentTwinGroupCenterX = editor.getView().getNode(allTwins[1]).getX();
				editor.getView().drawLineWithCrossings(id, currentTwinGroupCenterX, childlineY, currentTwinGroupCenterX, childlineY + twinCommonVerticalPieceLength, PedigreeEditorParameters.attributes.partnershipLines);

				currentIsMonozygothic = editor.getView().getNode(allTwins[0]).getMonozygotic();

				// draw the monozygothinc line, if necessary
				if (currentIsMonozygothic) {
					var twinlineY = childlineY + PedigreeEditorParameters.attributes.twinMonozygothicLineShiftY;
					var xIntercept1 = GraphicHelpers.findXInterceptGivenLineAndY(twinlineY, currentTwinGroupCenterX, childlineY + twinCommonVerticalPieceLength, positionL, positionY);
					var xIntercept2 = GraphicHelpers.findXInterceptGivenLineAndY(twinlineY, currentTwinGroupCenterX, childlineY + twinCommonVerticalPieceLength, positionR, positionY);
					editor.getView().drawLineWithCrossings(id, xIntercept1, twinlineY, xIntercept2, twinlineY, PedigreeEditorParameters.attributes.partnershipLines);
				}
			}
			else if (twinGroupId == null) {
				numPregnancies++;
				currentIsMonozygothic = false;
			}

			var childX = editor.getView().getNode(child).getX();
			var childY = editor.getView().getNode(child).getY();

			var topLineX = (currentTwinGroup === null) ? childX : currentTwinGroupCenterX;
			var topLineY = (currentTwinGroup === null) ? childlineY : childlineY + twinCommonVerticalPieceLength;

			if (topLineX > rightmostX)
				rightmostX = topLineX;
			if (topLineX < leftmostX)
				leftmostX = topLineX;

			var lostContact = (editor.getGraph().isChildOfProband(child) || editor.getGraph().isSiblingOfProband(child))
				&& editor.getView().getNode(child).getLostContact();

			if (!lostContact) {
				allChildrenLostContact = false;
			}

			var lineAttr = lostContact ? PedigreeEditorParameters.attributes.noContactLines : PedigreeEditorParameters.attributes.partnershipLines;
			if (editor.getGraph().isAdoptedIn(child)) {
				lineAttr = lostContact ? PedigreeEditorParameters.attributes.noContactAdoptedIn : PedigreeEditorParameters.attributes.partnershipLinesAdoptedIn;
			}

			// draw regular child line - for all nodes which are not monozygothic twins and for the
			// rightmost and leftmost monozygothic twin
			if (!currentIsMonozygothic || childX == positionL || childX == positionR) {
				editor.getView().drawLineWithCrossings(id, topLineX, topLineY, childX, childY, lineAttr);
			}
			else {
				var xIntercept = GraphicHelpers.findXInterceptGivenLineAndY(twinlineY, currentTwinGroupCenterX, childlineY + twinCommonVerticalPieceLength, childX, childY);
				editor.getView().drawLineWithCrossings(id, xIntercept, twinlineY, childX, childY, lineAttr);
			}
		}

		var lineAttr = allChildrenLostContact ? PedigreeEditorParameters.attributes.noContactLines : PedigreeEditorParameters.attributes.partnershipLines;

		editor.getView().drawLineWithCrossings(id, leftmostX, childlineY, rightmostX, childlineY, lineAttr);

		var fromY = this._isDisplayedAsConsanguinous() ? this.getY() + 2 : this.getY();
		editor.getView().drawLineWithCrossings(id, this.getX(), fromY, this.getX(), childlineY, lineAttr);

		if (editor.DEBUG_MODE) {
			var childhubID = positionedGraph.DG.GG.getOutEdges(id)[0];
			var _idLabel = editor.getPaper().text(this.getX(), childlineY, childhubID).attr(PedigreeEditorParameters.attributes.dragMeLabel).toFront();
			_idLabel.node.setAttribute("class", "no-mouse-interaction");
		}

		//draw small non-functional childhub junction orb
		if (numPregnancies > 1)
			editor.getPaper().circle(this.getX(), childlineY, PedigreeEditorParameters.attributes.partnershipRadius / 2).attr({fill: '#666666', stroke: '#888888', 'stroke-width': 1, 'opacity': 1});

		this._childhubConnection = editor.getPaper().setFinish();
	},

	/**
	 * Changes the position of the junction to the coordinate (x,y) and updates all surrounding connections.
	 *
	 * @method setPos
	 * @param {Number} x X coordinate relative to the Raphael canvas
	 * @param {Number} y Y coordinate relative to the Raphael canvas
	 * @param {Boolean} animate Set to True to animate the transition
	 * @param {Function} callback Executed at the end of the animation
	 */
	setPos: function ($super, x, y, animate, callback) {

		this.getHoverBox().removeHandles();
		this.getHoverBox().removeButtons();

		if (animate) {
			throw "Can't animate a partnership node";
		}

		this.mark && this.mark.remove();
		this.mark2 && this.mark2.remove();

		this.getAllGraphics().transform("t " + (x - this.getX()) + "," + (y - this.getY()) + "...");
		$super(x, y, animate, callback);

		this.updatePartnerConnections();
		this.updateChildhubConnection();
		this.updateChildlessStatusLabel();
	},

	/**
	 * Removes all the graphical elements of this partnership from the canvas
	 *
	 * @method remove
	 */
	remove: function () {
		this.getJunctionShape().remove();
		this.getHoverBox().remove();
		this._idLabel && this._idLabel.remove();
		this.getChildlessShape() && this.getChildlessShape().remove();
		this.getChildlessStatusLabel() && this.getChildlessStatusLabel().remove();
		this._childhubConnection && this._childhubConnection.remove();
		this._partnerConnections && this._partnerConnections.remove();
		this.area && this.area.remove();
		this.mark && this.mark.remove();
		this.mark2 && this.mark2.remove();
	},

	/**
	 * Returns a Raphael set of graphic elements of which the icon of the Partnership consists. Does not
	 * include hoverbox elements and labels.
	 *
	 * @method getShapes
	 * @return {Raphael.st}
	 */
	getShapes: function ($super) {
		return $super().push(this.getJunctionShape());
	},

	/**
	 * Returns a Raphael set of all the graphics and labels associated with this Partnership. Includes the hoverbox
	 * elements and labels
	 *
	 * @method getAllGraphics
	 * @return {Raphael.st}
	 */
	getAllGraphics: function ($super) {
		return editor.getPaper().set(this.getHoverBox().getBackElements(), this._idLabel, this._childlessShape).concat($super()).push(this.getHoverBox().getFrontElements());
	},

	/**
	 * Displays all the appropriate labels for this Partnership in the correct layering order
	 *
	 * @method drawLabels
	 */
	drawLabels: function () {
		// if need to add some - see PersonVisuals.drawLabels()
	},

	getChildlessShapeAttr: function () {
		return PedigreeEditorParameters.attributes.partnershipChildlessShapeAttr;
	}
});

//ATTACH CHILDLESS BEHAVIOR METHODS TO PARTNERSHIP
PartnershipVisuals.addMethods(ChildlessBehaviorVisuals);


/**
 * Partnership is a class that represents the relationship between two AbstractNodes
 * and their children.
 *
 * @class Partnership
 * @constructor
 * @extends AbstractNode
 * @param x the x coordinate at which the partnership junction will be placed
 * @param y the y coordinate at which the partnership junction will be placed
 * @param partner1 an AbstractPerson who's one of the partners in the relationship.
 * @param partner2 an AbstractPerson who's the other partner in the relationship. The order of partners is irrelevant.
 * @id the unique ID number of this node
 */
var Partnership = Class.create(AbstractNode, {

	initialize: function ($super, x, y, id, properties) {
		//console.log("partnership");
		this._childlessStatus = null;
		this._childlessReason = "";
		this._type = 'Partnership';

		this._broken = false;
		this._consangrMode = "N";    //  Can be either "A" (autodetect), "Y" (always consider consangr.) or "N" (never)
		// "Autodetect": derived from the current pedigree

		// assign some properties before drawing so that relationship lines are drawn properly
		this.setBrokenStatus(properties["broken"]);
		this.setConsanguinity(properties["consangr"]);

		$super(x, y, id);

		this.assignProperties(properties);
		//console.log("partnership end");
	},

	/**
	 * Generates and returns an instance of PartnershipVisuals
	 *
	 * @method _generateGraphics
	 * @param {Number} x X coordinate of this partnership
	 * @param {Number} y Y coordinate of this partnership
	 * @return {PartnershipVisuals}
	 * @private
	 */
	_generateGraphics: function (x, y) {
		return new PartnershipVisuals(this, x, y);
	},

	/**
	 * Changes the status of this partnership. Nullifies the status if the given status is not
	 * "Childless" or "Infertile".
	 *
	 * @method setChildlessStatus
	 * @param {String} status Can be "Childless", "Infertile" or null
	 */
	setChildlessStatus: function (status) {
		if (!this.isValidChildlessStatus(status))
			status = null;

		if (status != this.getChildlessStatus()) {
			this._childlessStatus = status;
			this.setChildlessReason(null);
			this.getGraphics().updateChildlessShapes();
			this.getGraphics().updateChildhubConnection();
			this.getGraphics().getHoverBox().regenerateHandles();
		}

		return this.getChildlessStatus();
	},

	/**
	 * Sets the consanguinity setting of this relationship. Valid inputs are "A" (automatic"), "Y" (yes) and "N" (no)
	 *
	 * @method setConsanguinity
	 */
	setConsanguinity: function (value) {
		if (value != "A" && value != "N" && value != "Y" && value != "P" && value != "U")
			value = "A";
		if (this._consangrMode != value) {
			this._consangrMode = value;
		}
		this.getGraphics() && this.getGraphics().getHoverBox().regenerateButtons();
	},

	/**
	 * Returns the consanguinity setting of this relationship: "A" (automatic"), "Y" (yes) or "N" (no)
	 *
	 * @method getConsanguinity
	 */
	getConsanguinity: function () {
		return this._consangrMode;
	},

	/**
	 * Sets relationship as either broken or not
	 *
	 * @method getBrokenStatus
	 */
	setBrokenStatus: function (value) {
		if (value === undefined)
			value = false;
		if (this._broken != value) {
			this._broken = value;
		}
	},

	/**
	 * Returns the status of this relationship (broken or not)
	 *
	 * @method getBrokenStatus
	 */
	getBrokenStatus: function () {
		return this._broken;
	},

	/**
	 * Returns an object (to be accepted by the menu) with information about this Partnership
	 *
	 * @method getSummary
	 * @return {Object}
	 */
	getSummary: function () {
		var childlessTextInactive = false;
		var childlessInactive = [];
		if (editor.getGraph().hasNonPlaceholderNonAdoptedChildren(this.getID())) {
			childlessInactive = true;
			childlessTextInactive = true;
		} else {
			if (editor.getGraph().hasNoNonPlaceholderChildren(this.getID())) {
				childlessInactive = ['none'];
			}
		}
		return {
			identifier: {value: this.getID()},
			childlessSelect: {value: this.getChildlessStatus() ? this.getChildlessStatus() : 'None', inactive: childlessInactive},
			childlessText: {value: this.getChildlessReason() ? this.getChildlessReason() : 'None', inactive: childlessTextInactive},
			consangr: {value: this._consangrMode, inactive: false},
			broken: {value: this.getBrokenStatus(), inactive: false}
		};
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 */
	getProperties: function ($super) {
		var info = $super();
		if (this.getChildlessStatus() != null) {
			info['childlessStatus'] = this.getChildlessStatus();
			info['childlessReason'] = this.getChildlessReason();
		}
		if (this.getConsanguinity() != "A") {
			info['consangr'] = this.getConsanguinity();
		}
		if (this.getBrokenStatus()) {
			info['broken'] = this.getBrokenStatus();
		}
		return info;
	},

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method assignProperties
	 * @param properties Object
	 * @return {Boolean} True if info was successfully assigned
	 */
	assignProperties: function ($super, info) {
		if ($super(info)) {
			if (info.childlessStatus && info.childlessStatus != this.getChildlessStatus()) {
				this.setChildlessStatus(info.childlessStatus);
			}
			if (info.childlessReason && info.childlessReason != this.getChildlessReason()) {
				this.setChildlessReason(info.childlessReason);
			}
			if (info.consangr && info.consangr != this.getConsanguinity()) {
				this.setConsanguinity(info.consangr);
			}
			if (info.broken && info.broken != this.getBrokenStatus()) {
				this.setBrokenStatus(info.broken);
			}
			return true;
		}
		return false;
	}
});

//ATTACH CHILDLESS BEHAVIOR METHODS TO PARTNERSHIP OBJECTS
Partnership.addMethods(ChildlessBehavior);
/**
 * An abstract superclass for the a graphic engine used by nodes on the Pedigree graph. Can display
 * a shape representing the gender of the attached node.
 *
 * @class AbstractPersonVisuals
 * @extends AbstractNodeVisuals
 * @constructor
 * @param {AbstractPerson} node The node for which this graphics are handled
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y the y coordinate on the canvas
 */
var AbstractPersonVisuals = Class.create(AbstractNodeVisuals, {

	initialize: function ($super, node, x, y) {
		$super(node, x, y);

		this._radius = PedigreeEditorParameters.attributes.radius;
		this._width = PedigreeEditorParameters.attributes.radius * 4;

		this._highlightBox = null;
		this._adoptedShape = null;
		this._genderShape = null;
		this._genderGraphics = null;  // == set(_genderShape, shadow)
		this._numberLabel = null;

		this.setGenderGraphics();

		this.setHighlightBox();

		this.updateIDLabel();

		this._hoverBox = this.generateHoverbox(x, y);
	},

	updateIDLabel: function () {
		if (!editor.DEBUG_MODE) return;

		var x = this.getX();
		var y = this.getY();
		this._idLabel && this._idLabel.remove();
		this._idLabel = editor.getPaper().text(x, y, this.getNode().getID()).attr(PedigreeEditorParameters.attributes.dragMeLabel).toFront();
		this._idLabel.node.setAttribute("class", "no-mouse-interaction");
	},

	updateNumberLabel: function () {
		this._numberLabel && this._numberLabel.remove();
		if (this.getNode().getPedNumber() != "") {
			var x = this.getX();
			var y = this.getY();
			this._numberLabel = editor.getPaper().text(x, y, this.getNode().getPedNumber()).attr(PedigreeEditorParameters.attributes.pedNumberLabel).toFront();
			this._numberLabel.node.setAttribute("class", "no-mouse-interaction");
		}
	},

	generateHoverbox: function (x, y) {
		return null;
	},

	/**
	 * Updates whatever needs to change when node id changes (e.g. id label)
	 *
	 * @method onSetID
	 */
	onSetID: function ($super, id) {
		$super(id);
		this.updateIDLabel();
	},

	/**
	 * Changes the position of the node to (X,Y)
	 *
	 * @method setPos
	 * @param {Number} x The x coordinate
	 * @param {Number} y The y coordinate
	 * @param {Boolean} animate Set to true if you want to animate the transition
	 * @param {Function} callback The function called at the end of the animation
	 */
	setPos: function ($super, x, y, animate, callback) {

		this.getHoverBox().removeHandles();
		this.getHoverBox().removeButtons();

		var moveX = x - this.getX();
		var moveY = y - this.getY();

		if (moveX == 0 && moveY == 0) return;

		// need to set X and Y before animation finishes or other
		// stuff will be drawn incorrectly
		$super(x, y, animate);

		if (animate) {
			var me = this;
			this._callback = function () {
				if (me._toMark) {
					me.markPermanently();
					delete me._toMark;
				}
				delete me._callback;
				callback && callback();
			}

			this.getAllGraphics().animate({'transform': "t " + moveX + "," + moveY + "..."},
				900, "linear", me._callback); //easeInOut

			//this.getAllGraphics().transform("t " + moveX + "," + moveY + "...");
			//callback && callback();
		}
		else {
			this.getAllGraphics().transform("t " + moveX + "," + moveY + "...");
			callback && callback();
		}
	},

	/**
	 * Expands the partnership circle
	 *
	 * @method grow
	 */
	grow: function ($super) {
		$super();
		if (this._callback)
			throw "Assertion failed: grow() during animation";
		if (this.glow) return;
		this.glow = this._genderShape.glow({width: 11, fill: true, opacity: 0.4, color: "green"});
		if (this.marked) this.marked.hide();
	},

	/**
	 * Shrinks node graphics to the original size
	 *
	 * @method shrink
	 */
	shrink: function ($super) {
		this.glow && this.glow.remove();
		delete this.glow;
		if (this.marked) this.marked.show();
		$super();
	},

	/**
	 * Marks the node in  away different from glow
	 *
	 * @method grow
	 */
	markPermanently: function () {
		//console.log("marking " + this.getNode().getID());
		if (this._callback && !this._toMark) {
			// trying to mark during animation - need ot wait until animation finishes to mark @ the final location
			this._toMark = true;
			return;
		}
		if (this.marked) return;
		this.marked = this._genderShape.glow({width: 11, fill: true, opacity: 0.6, color: "#ee8d00"});
	},

	/**
	 * Unmarks the node
	 *
	 * @method shrink
	 */
	unmark: function () {
		this.marked && this.marked.remove();
		delete this.marked;
	},

	/**
	 * Returns true if this node's graphic representation covers coordinates (x,y)
	 *
	 * @method containsXY
	 */
	containsXY: function (x, y) {
		if (Math.abs(x - this.getX()) <= PedigreeEditorParameters.attributes.personHoverBoxRadius &&
			Math.abs(y - this.getY()) <= PedigreeEditorParameters.attributes.personHoverBoxRadius)
			return true;
		return false;
	},

	/**
	 * Returns the Y coordinate of the lowest part of this node's graphic on the canvas
	 *
	 * @method getY
	 * @return {Number} The y coordinate
	 */
	getBottomY: function () {
		return this._absoluteY + this._radius + PedigreeEditorParameters.attributes.childlessLength;
	},

	/**
	 * Draws brackets around the node icon to show that this node is adopted
	 *
	 * @method drawAdoptedShape
	 */
	drawAdoptedShape: function () {
		this._adoptedShape && this._adoptedShape.remove();
		if (this.getNode().getAdopted() != "") {
			var r = PedigreeEditorParameters.attributes.radius;
			var y = this.getY() - ((1.3) * r) + 2;
			if (this.getNode().getAdopted() == "adoptedOut" &&
				editor.getPreferencesManager().getConfigurationOption("nonStandardAdoptedOutGraphic")) {
				var x1 = this.getX() - ((1.7) * r);
				var x2 = this.getX() + ((1.7) * r);
				var coeff = 2.5;
			} else {
				var x1 = this.getX() - ((0.9) * r);
				var x2 = this.getX() + ((0.9) * r);
				var coeff = -2.5;
			}
			brackets = "M" + x1 + " " + y + "l" + r / (coeff) +
				" " + 0 + "l0 " + (2.6 * r - 4) + "l" + r / (-coeff) + " 0M" + x2 +
				" " + y + "l" + r / (-coeff) + " 0" + "l0 " + (2.6 * r - 4) + "l" +
				(r) / (coeff) + " 0";
			this._adoptedShape = editor.getPaper().path(brackets).attr("stroke-width", 2.5);
			this._adoptedShape.toBack();
		}
	},

	/**
	 * Returns the raphael element or set containing the adoption shape
	 *
	 * @method getAdoptedShape
	 * @return {Raphael.el} Raphael Element
	 */
	getAdoptedShape: function () {
		return this._adoptedShape;
	},


	/**
	 * Returns a Raphael set or element that contains the graphics associated with this node, excluding the labels.
	 *
	 * @method getShapes
	 */
	getShapes: function ($super) {
		var shapes = $super().push(this.getGenderGraphics());
		this.getAdoptedShape() && shapes.push(this.getAdoptedShape());
		return shapes;
	},

	/**
	 * Returns a Raphael set that contains all the graphics and labels associated with this node.
	 *
	 * @method getAllGraphics
	 * @return {Raphael.st}
	 */
	getAllGraphics: function ($super) {
		return editor.getPaper().set(this.getHighlightBox(), this._idLabel, this._numberLabel).concat($super());
	},

	/**
	 * Returns the Raphael element representing the gender of the node.
	 *
	 * @method getGenderGraphics
	 * @return {Raphael.st|Raphael.el} Raphael set or Raphael element
	 */
	getGenderGraphics: function () {
		return this._genderGraphics;
	},

	/**
	 * Returns only the shape element from the genderGraphics (i.e. no shadow)
	 *
	 * @method getGenderShape
	 * @return {Raphael.st|Raphael.el}
	 */
	getGenderShape: function () {
		return this._genderShape;
	},

	/**
	 * Sets/replaces the gender graphics with graphics appropriate for the gender
	 *
	 * @method setGenderGraphics
	 */
	setGenderGraphics: function () {
		this.unmark();
		this._genderGraphics && this._genderGraphics.remove();

		var gender = this.getNode().getGender();
		this._shapeRadius = (gender == 'U' || gender == 'O') ?
			PedigreeEditorParameters.attributes.radius * 1.1 / Math.sqrt(2) :
			PedigreeEditorParameters.attributes.radius;
		if (this.getNode().isPersonGroup())
			this._shapeRadius *= PedigreeEditorParameters.attributes.groupNodesScale;

		var shape;
		var x = this.getX(),
			y = this.getY(),
			radius = this._shapeRadius;

		if (gender == 'F') {
			shape = editor.getPaper().circle(x, y, radius);
		}
		else {
			//console.log("x: " + x + ", y: " + y + ", rad: " + radius + ", shape: " + this._genderShape);
			shape = editor.getPaper().rect(x - radius, y - radius, radius * 2, radius * 2);
		}

		if (gender == 'U') {
			shape.attr(PedigreeEditorParameters.attributes.nodeShapeDiag);
			shape.attr({transform: "...R45"});
		} else if (gender == 'O') {
			shape.attr(PedigreeEditorParameters.attributes.nodeShapeOther);
			shape.attr({transform: "...R45"});
		} else if (gender == 'M') {
			shape.attr(PedigreeEditorParameters.attributes.nodeShapeMale);
			//shape.node.setAttribute("shape-rendering","crispEdges");
		} else if (gender == 'F') {
			shape.attr(PedigreeEditorParameters.attributes.nodeShapeFemale);
		}

		this._genderShape = shape;

		if (!editor.isUnsupportedBrowser() && editor.getPreferencesManager().getConfigurationOption("drawNodeShadows")) {
			var shadow = this.makeNodeShadow(shape);
			this._genderGraphics = editor.getPaper().set(shadow, shape);
		} else {
			this._genderGraphics = editor.getPaper().set(shape);
		}
	},

	makeNodeShadow: function (shape) {
		//var shadow = shape.glow({width: 5, fill: true, opacity: 0.1}).translate(3,3);
		var shadow = shape.clone().attr({stroke: 'none', fill: 'gray', opacity: .3});
		shadow.translate(3, 3);
		shadow.insertBefore(shape);
		shadow.node.setAttribute("class", "pedigree-node-shadow");
		return shadow;
	},

	/**
	 * Sets/replaces the current highlight box
	 *
	 * @method setGenderGraphics
	 */
	setHighlightBox: function () {
		this._highlightBox && this._highlightBox.remove();

		var radius = PedigreeEditorParameters.attributes.personHoverBoxRadius;
		this._highlightBox = editor.getPaper().rect(this.getX() - radius, this.getY() - radius,
				radius * 2, radius * 2, 5).attr(PedigreeEditorParameters.attributes.boxOnHover);
		this._highlightBox.attr({fill: 'black', opacity: 0, 'fill-opacity': 0});
		this._highlightBox.insertBefore(this.getGenderGraphics().flatten());
	},

	/**
	 * Returns the box around the element that appears when the node is highlighted
	 *
	 * @method getHighlightBox
	 * @return {Raphael.rect} Raphael rectangle element
	 */
	getHighlightBox: function () {
		return this._highlightBox;
	},

	/**
	 * Displays the highlightBox around the node
	 *
	 * @method highlight
	 */
	highlight: function () {
		this.getHighlightBox() && this.getHighlightBox().attr({"opacity": .5, 'fill-opacity': .5});
	},

	/**
	 * Hides the highlightBox around the node
	 *
	 * @method unHighlight
	 */
	unHighlight: function () {
		this.getHighlightBox().attr({"opacity": 0, 'fill-opacity': 0});
	},

	remove: function ($super) {
		this.marked && this.marked.remove();
		$super();
	}
});
/**
 * Class for organizing graphics for Person nodes.
 *
 * @class PersonVisuals
 * @extends AbstractPersonVisuals
 * @constructor
 * @param {Person} node The node for which the graphics are handled
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 */
var PersonVisuals = Class.create(AbstractPersonVisuals, {

    initialize: function ($super, node, x, y) {
        //var timer = new Helpers.Timer();
        $super(node, x, y);
        this._nameLabel = null;
        this._stillBirthLabel = null;
        this._ageLabel = null;
        this._externalIDLabel = null;
        this._participatingInTestLabel = null;
        this._commentsLabel = null;
        this._cancerAgeOfOnsetLabels = {};
        this._childlessStatusLabel = null;
        this._disorderShapes = null;
        this._deadShape = null;
        this._unbornShape = null;
        this._childlessShape = null;
        this._isSelected = false;
        this._carrierGraphic = null;
        this._evalLabel = null;
        //timer.printSinceLast("Person visuals time");
    },

    generateHoverbox: function (x, y) {
        if (editor.isReadOnlyMode()) {
            return new ReadOnlyHoverbox(this.getNode(), x, y, this.getGenderGraphics());
        } else {
            return new PersonHoverbox(this.getNode(), x, y, this.getGenderGraphics());
        }
    },


    /**
     * Added for GEL(GenomicsEngland)
     * updateAgeLabelForGELDirectly will update the age label underneath the node directly form the text parameter
     * @method text
     */
    updateAgeLabelForGELDirectly: function (text) {
        this.getAgeLabel() && this.getAgeLabel().remove();
        this._ageLabel = text ? editor.getPaper().text(this.getX(), this.getY(), text).attr(PedigreeEditorParameters.attributes.label) : null;
        if (this._ageLabel) {
            this._ageLabel.node.setAttribute("class", "field-no-user-select");
            if (text && text.indexOf("\n") > 0) {
                this._ageLabel.alignTop = true;
            }
        }
        this.drawLabels();
    },

    /**
     * Draws the icon for this Person depending on the gender, life status and whether this Person is the proband.
     * Updates the disorder shapes.
     *
     * @method setGenderGraphics
     */
    setGenderGraphics: function ($super) {
        //console.log("set gender graphics");
        if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
            this._genderGraphics && this._genderGraphics.remove();

            var radius = PedigreeEditorParameters.attributes.radius;
            if (this.getNode().isPersonGroup())
                radius *= PedigreeEditorParameters.attributes.groupNodesScale;
            this._shapeRadius = radius;

            var side = radius * Math.sqrt(3.5),
                height = side / Math.sqrt(2),
                x = this.getX() - height,
                y = this.getY();
            var shape = editor.getPaper().path(["M", x, y, 'l', height, -height, 'l', height, height, "z"]);
            shape.attr(PedigreeEditorParameters.attributes.nodeShapeAborted);
            this._genderShape = shape;
            if (editor.getPreferencesManager().getConfigurationOption("drawNodeShadows")) {
                var shadow = this.makeNodeShadow(shape);
                shape = editor.getPaper().set(shadow, shape);
            } else {
                shape = editor.getPaper().set(shape);
            }

            if (this.getNode().isProband()) {
                shape.transform(["...s", 1.07]);
                shape.attr("stroke-width", 5);
            }

            var gender = this.getNode().getGender();
            if (gender == 'U' || gender == 'O') {
                this._genderGraphics = shape;
            }
            else {
                x = this.getX();
                y = this.getY() + radius / 1.4;
                var text = (gender == 'M') ? "Male" : "Female";
                var genderLabel = editor.getPaper().text(x, y, text).attr(PedigreeEditorParameters.attributes.label);
                this._genderGraphics = editor.getPaper().set(shape, genderLabel);
            }
        }
        else {
            $super();
        }

        if (this.getNode().isProband()) {
            this._genderGraphics.push(this.generateProbandArrow());
            //this._genderGraphics.push(this.generateIsParticipatingInTestArrow());
            this.getGenderShape().transform(["...s", 1.08]);
            this.getGenderShape().attr("stroke-width", 5.5);
        }
        if (!editor.isUnsupportedBrowser() && this.getHoverBox()) {
            this._genderGraphics.flatten().insertBefore(this.getFrontElements().flatten());
        }
        this.updateDisorderShapes();
        this.updateCarrierGraphic();
        this.updateEvaluationLabel();
        this.updateParticipatingInTestLabel();

        if (this.getNode().getLifeStatus() == "Unborn") {
            this.updateLifeStatusShapes("Unborn");
        }
    },

    generateProbandArrow: function () {
        var icon = editor.getPaper().path(editor.getView().__probandArrowPath).attr({fill: "#595959", stroke: "none", opacity: 1});
        var x = this.getX() - this._shapeRadius - 26;
        var y = this.getY() + this._shapeRadius - 12;
        if (this.getNode().getGender() == 'F') {
            x += 5;
            y -= 5;
        }
        icon.transform(["t", x, y]);
        return icon;
    },

    generateIsParticipatingInTestArrow: function () {
        var icon = editor.getPaper().path(editor.getView().__participatingInTest).attr({fill: "#595959", stroke: "none", opacity: 1});
        var x = this.getX() - this._shapeRadius - 20;
        var y = this.getY() + this._shapeRadius - 12;
        if (this.getNode().getGender() == 'F') {
            x += 12;
            y -= 12;
        }
        icon.transform(["t", x, y]);
        return icon;
    },

    /**
     * Returns all graphical elements that are behind the gender graphics
     *
     * @method getBackElements
     * @return {Raphael.st}
     */
    getBackElements: function () {
        return this.getHoverBox().getBackElements().concat(editor.getPaper().set(this.getChildlessStatusLabel(), this.getChildlessShape()));
    },

    /**
     * Returns all graphical elements that should receive mouse focus/clicks
     *
     * @method getFrontElements
     * @return {Raphael.st}
     */
    getFrontElements: function () {
        return this.getHoverBox().getFrontElements();
    },

    /**
     * Updates the external ID label for this Person
     *
     * @method updateParticipatingInTestIDLabel
     */
    updateParticipatingInTestLabel: function () {
        this._participatingInTestLabel && this._participatingInTestLabel.remove();
        if (this.getNode().getParticipatingInTest()) {
            var text = "T";
            this._participatingInTestLabel = editor.getPaper().text(this.getX() - PedigreeEditorParameters.attributes.radius - 13, this.getY(), text).attr(PedigreeEditorParameters.attributes.participatingInTestAttr);
        } else {
            this._participatingInTestLabel = null;
        }
        this.drawLabels();
    },

    getParticipatingInTestLabel: function () {
        return this._participatingInTestLabel;
    },

    updateExternalIDLabel: function () {
        this._externalIDLabel && this._externalIDLabel.remove();

        if (true){//this.getNode().getParticipantId()) {
            var number = this.getNode().getNHSNumber();
            var type = 'nhs';
            /*if (!number || number === undefined) {
                number = this.getNode().getCHINumber();
                type = 'chi';
            }*/

            //var text = '{' + this.getNode().getParticipantId() + "}";
            var text = "\r\n ";
            if (number) {
                text += "[" + type + ":" + number + "] \r\n";
            }
            if (this.getNode().getNgisRegisteredPatientUid()) {
                text += "NGIS Patient ID : " +  this.getNode().getNgisRegisteredPatientUid() + "\r\n";
            }else if(this.getNode().getNonNgisPatientStableUid()){
                text += "Non NGIS Patient ID : " +  this.getNode().getNonNgisPatientStableUid()+ "\r\n";
            }

            //text += "{ Participanting in Test : " +  this.getNode().getParticipatingInTest() + "}";

            this._externalIDLabel = editor.getPaper().text(this.getX(), this.getY() + PedigreeEditorParameters.attributes.radius, text).attr(PedigreeEditorParameters.attributes.externalIDLabels);
        } else {
            this._externalIDLabel = null;
        }
        this.drawLabels();
    },

    /**
     * Returns the Person's external ID label
     *
     * @method getExternalIDLabel
     * @return {Raphael.el}
     */
    getExternalIDLabel: function () {
        return this._externalIDLabel;
    },

    /**
     * Updates the name label for this Person
     *
     * @method updateNameLabel
     */
    updateNameLabel: function () {
        this._nameLabel && this._nameLabel.remove();
        var disabledFields = editor.getPreferencesManager().getConfigurationOption("disabledFields");
        var text = "";

        if (this.getNode().getFirstName() && !Helpers.arrayContains(disabledFields, 'first_name')) {
            text = this.getNode().getFirstName();
        }

        var lastNameAtBirth = (this.getNode().getLastNameAtBirth() && !Helpers.arrayContains(disabledFields, 'last_name_birth')) ?
            this.getNode().getLastNameAtBirth() : "";

        if (this.getNode().getLastName() && !Helpers.arrayContains(disabledFields, 'last_name')) {
            text += ' ' + this.getNode().getLastName();
            if (lastNameAtBirth == this.getNode().getLastName() || lastNameAtBirth === "") {
                lastNameAtBirth = "";
            } else {
                lastNameAtBirth = "(" + lastNameAtBirth + ")";
            }
        }

        text += " " + lastNameAtBirth;
        text = Helpers.toTitleCase(text);
        var wrapLength = 20;
        text = Helpers.wrapString(text, wrapLength);
        // after breaking by space, it is still possible for some to be more than
        // the wrapLength. In this case, just break
        text = Helpers.wrapStringNonBreak(text, wrapLength);

        this._nameLabel && this._nameLabel.remove();
        if (text.strip() != '') {
            this._nameLabel = editor.getPaper().text(this.getX(), this.getY() + PedigreeEditorParameters.attributes.radius, text).attr(PedigreeEditorParameters.attributes.nameLabels);
            this._nameLabel.node.setAttribute("class", "field-no-user-select");
        }
        else {
            this._nameLabel = null;
        }
        this.drawLabels();
    },

    /**
     * Returns the Person's name label
     *
     * @method getNameLabel
     * @return {Raphael.el}
     */
    getNameLabel: function () {
        return this._nameLabel;
    },

    /**
     * Returns colored blocks representing disorders
     *
     * @method getDisorderShapes
     * @return {Raphael.st} Set of disorder shapes
     */
    getDisorderShapes: function () {
        return this._disorderShapes;
    },

    /**
     * Displays the disorders currently registered for this node.
     *
     * @method updateDisorderShapes
     */
    updateDisorderShapes: function () {
        this._disorderShapes && this._disorderShapes.remove();
        var colors = this.getNode().getAllNodeColors();
        var status = this.getNode().getCarrierStatus();
        if (colors.length == 0) return;

        var gradient = function (color, angle) {
            var hsb = Raphael.rgb2hsb(color),
                darker = Raphael.hsb2rgb(hsb['h'], hsb['s'], hsb['b'] - .25)['hex'];
            return angle + "-" + darker + ":0-" + color + ":100";
        };
        var disorderShapes = editor.getPaper().set();
        var delta, color;

        if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
            var radius = PedigreeEditorParameters.attributes.radius;
            if (this.getNode().isPersonGroup())
                radius *= PedigreeEditorParameters.attributes.groupNodesScale;

            var side = radius * Math.sqrt(3.5),
                height = side / Math.sqrt(2),
                x1 = this.getX() - height,
                y1 = this.getY();
            delta = (height * 2) / (colors.length);

            for (var k = 0; k < colors.length; k++) {
                var corner = [];
                var x2 = x1 + delta;
                var y2 = this.getY() - (height - Math.abs(x2 - this.getX()));
                if (x1 < this.getX() && x2 >= this.getX()) {
                    corner = ["L", this.getX(), this.getY() - height];
                }
                var slice = editor.getPaper().path(["M", x1, y1, corner, "L", x2, y2, 'L', this.getX(), this.getY(), 'z']);
                color = colors[k];
                disorderShapes.push(slice.attr({fill: color, 'stroke-width': .5, stroke: 'none'}));
                x1 = x2;
                y1 = y2;
            }
            if (this.getNode().isProband()) {
                disorderShapes.transform(["...s", 1.04, 1.04, this.getX(), this.getY() - this._shapeRadius]);
            }
        }
        else {
            var disorderAngle = (360 / colors.length);
            delta = (360 / (colors.length)) / 2;
            if (colors.length == 1 && (this.getNode().getGender() == 'U' || this.getNode().getGender() == 'O'))
                delta -= 45; // since this will be rotated by shape transform later

            var radius = (this._shapeRadius - 0.6);    // -0.6 to avoid disorder fills to overlap with shape borders (due to aliasing/Raphael pixel layout)
            if (this.getNode().getGender() == 'U' || this.getNode().getGender() == 'O')
                radius *= 1.155;                     // TODO: magic number hack: due to a Raphael transform bug (?) just using correct this._shapeRadius does not work

                for (var i = 0; i < colors.length; i++) {
                color = colors[i];
                disorderShapes.push(GraphicHelpers.sector(editor.getPaper(), this.getX(), this.getY(), radius,
                    this.getNode().getGender(), i * disorderAngle, (i + 1) * disorderAngle, color));
            }

            (disorderShapes.length < 2) ? disorderShapes.attr('stroke', 'none') : disorderShapes.attr({stroke: '#595959', 'stroke-width': .03});
            if (this.getNode().isProband()) {
                disorderShapes.transform(["...s", 1.04, 1.04, this.getX(), this.getY()]);
            }
        }
        this._disorderShapes = disorderShapes;
        this._disorderShapes.flatten().insertAfter(this.getGenderGraphics().flatten());
    },

    /**
     * Draws a line across the Person to display that he is dead (or aborted).
     *
     * @method drawDeadShape
     */
    drawDeadShape: function () {
        var strokeWidth = editor.getWorkspace().getSizeNormalizedToDefaultZoom(2.5);
        var x, y;
        if (this.getNode().getLifeStatus() == 'Aborted') {
            var side = PedigreeEditorParameters.attributes.radius * Math.sqrt(3.5);
            var height = side / Math.sqrt(2);
            if (this.getNode().isPersonGroup())
                height *= PedigreeEditorParameters.attributes.groupNodesScale;

            var x = this.getX() - height / 1.5;
            if (this.getNode().isPersonGroup())
                x -= PedigreeEditorParameters.attributes.radius / 4;

            var y = this.getY() + height / 3;
            this._deadShape = editor.getPaper().path(["M", x, y, 'l', height + height / 3, -(height + height / 3), "z"]);
            this._deadShape.attr("stroke-width", strokeWidth);
        }
        else {
            x = this.getX();
            y = this.getY();
            var coeff = 10.0 / 8.0 * (this.getNode().isPersonGroup() ? PedigreeEditorParameters.attributes.groupNodesScale : 1.0);
            var x1 = x - coeff * PedigreeEditorParameters.attributes.radius,
                y1 = y + coeff * PedigreeEditorParameters.attributes.radius,
                x2 = x + coeff * PedigreeEditorParameters.attributes.radius,
                y2 = y - coeff * PedigreeEditorParameters.attributes.radius;
            this._deadShape = editor.getPaper().path(["M", x1, y1, "L", x2, y2]).attr("stroke-width", strokeWidth);
        }
        if (!editor.isUnsupportedBrowser()) {
            this._deadShape.toFront();
            this._deadShape.node.setAttribute("class", "no-mouse-interaction");
        }
    },

    /**
     * Returns the line drawn across a dead Person's icon
     *
     * @method getDeadShape
     * @return {Raphael.st}
     */
    getDeadShape: function () {
        return this._deadShape;
    },

    /**
     * Returns this Person's age label
     *
     * @method getAgeLabel
     * @return {Raphael.el}
     */
    getAgeLabel: function () {
        return this._ageLabel;
    },

    /**
     * Updates the age label for this Person
     *
     * @method updateAgeLabel
     */
    updateAgeLabel: function () {
        var text,
            person = this.getNode();
        if (person.isFetus()) {
            var date = person.getGestationAgeDays() +(person.getGestationAgeWeeks()*7);
            //text = (date) ? date + " weeks" : null;
        }
        else {
            var birthDate = person.getBirthDate();
            var deathDate = person.getDeathDate();

            var dateFormat = editor.getPreferencesManager().getConfigurationOption("dateDisplayFormat");
            if (dateFormat == "DMY" || dateFormat == "MY") {
                if (person.getLifeStatus() == 'Alive') {
                    if (birthDate && birthDate.isComplete()) {
                        text = "b. " + person.getBirthDate().getBestPrecisionStringDDMMYYY(dateFormat);
                        if (person.getBirthDate().getYear() !== null) {
                            var age = AgeCalc.getAge(person.getBirthDate());
                            //text += " (" + age + ")";
                        }
                    }
                }
                else {
                    if (deathDate && birthDate && deathDate.isComplete() && birthDate.isComplete()) {
                        text = person.getBirthDate().getBestPrecisionStringDDMMYYY(dateFormat) + " - " + person.getDeathDate().getBestPrecisionStringDDMMYYY(dateFormat);
                        if (person.getBirthDate().getYear() !== null && person.getDeathDate().getYear() !== null) {
                            var age = AgeCalc.getAge(person.getBirthDate(), person.getDeathDate());
                            //text += "\n" + age;
                        }
                    }
                    else if (deathDate && deathDate.isComplete()) {
                        //text = "d. " + person.getDeathDate().getBestPrecisionStringDDMMYYY(dateFormat);
                    }
                    else if (birthDate && birthDate.isComplete()) {
                        //text = person.getBirthDate().getBestPrecisionStringDDMMYYY(dateFormat) + " - ?";
                    }
                }
            } else {
                if (person.getLifeStatus() == 'Alive') {
                    if (birthDate) {
                        if (birthDate.onlyDecadeAvailable()) {
                            //text = "b. " + birthDate.getDecade();
                        } else {
                            var age = AgeCalc.getAge(birthDate, null);
                            if (birthDate.getMonth() == null) {
                                //text = "b. " + birthDate.getYear();                          // b. 1972
                            } else {
                                if (birthDate.getDay() == null || dateFormat == "MMY") {
                                    //text = "b. " + birthDate.getMonthName() + " " +
                                        birthDate.getYear();                                     // b. Jan 1972
                                } else {
                                    //text = "b. " + birthDate.getMonthName() + " " +
                                    //    birthDate.getDay() + ", " +
                                    //    birthDate.getYear();                                     // b. Jan 13, 1972
                                    if (age.indexOf("day") != -1 || age.indexOf("wk") != -1) {
                                     //   text += " (" + age + ")";                            // b. Jan 13, 1972 (5 days)
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    if (deathDate && birthDate) {
                        var age = AgeCalc.getAge(birthDate, deathDate);
                        if (deathDate.getYear() != null && deathDate.getMonth() != null &&
                            (age.indexOf("day") != -1 || age.indexOf("wk") != -1 || age.indexOf("mo") != -1)) {
                            //text = "d. " + deathDate.getYear(true) + " (" + age + ")";
                        } else {
                            text = birthDate.getBestPrecisionStringYear() + " - " + deathDate.getBestPrecisionStringYear();
                            if (age !== "") {
                                //text += "\n" + age;
                            }
                        }
                    }
                    else if (deathDate) {
                        //text = "d. " + deathDate.getBestPrecisionStringYear();
                    }
                    else if (birthDate) {
                        //text = birthDate.getBestPrecisionStringYear() + " - ?";
                    }
                }
            }
        }
        this.getAgeLabel() && this.getAgeLabel().remove();
        this._ageLabel = text ? editor.getPaper().text(this.getX(), this.getY(), text).attr(PedigreeEditorParameters.attributes.label) : null;
        if (this._ageLabel) {
            this._ageLabel.node.setAttribute("class", "field-no-user-select");
            if (text && text.indexOf("\n") > 0) {
                this._ageLabel.alignTop = true;
            }
        }
        this.drawLabels();
    },

    /**
     * Returns the shape marking a Person's 'unborn' life-status
     *
     * @method getUnbornShape
     * @return {Raphael.el}
     */
    getUnbornShape: function () {
        return this._unbornShape;
    },

    /**
     * Draws a "P" on top of the node to display this Person's 'unborn' life-status
     *
     * @method drawUnbornShape
     */
    drawUnbornShape: function () {
        this._unbornShape && this._unbornShape.remove();
        if (this.getNode().getLifeStatus() == 'Unborn') {
            this._unbornShape = editor.getPaper().text(this.getX(), this.getY(), "P").attr(PedigreeEditorParameters.attributes.unbornShape);
            if (!editor.isUnsupportedBrowser())
                this._unbornShape.insertBefore(this.getHoverBox().getFrontElements());
        } else {
            this._unbornShape = null;
        }
    },

    /**
     * Draws the evaluation status symbol for this Person
     *
     * @method updateEvaluationLabel
     */
    updateEvaluationLabel: function () {
        this._evalLabel && this._evalLabel.remove();
        if (this.getNode().getEvaluated()) {
            if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
                var x = this.getX() + this._shapeRadius * 1.6;
                var y = this.getY() + this._shapeRadius * 0.6;
            }
            else {
                var mult = 1.1;
                if (this.getNode().getGender() == 'U') mult = 1.3;
                else if (this.getNode().getGender() == 'M') mult = 1.4;
                if (this.getNode().isProband) mult *= 1.1;
                var x = this.getX() + this._shapeRadius * mult - 5;
                var y = this.getY() + this._shapeRadius * mult;
            }
            this._evalLabel = editor.getPaper().text(x, y, "*").attr(PedigreeEditorParameters.attributes.evaluationShape).toBack();
        } else {
            this._evalLabel = null;
        }
    },

    /**
     * Returns this Person's evaluation label
     *
     * @method getEvaluationGraphics
     * @return {Raphael.el}
     */
    getEvaluationGraphics: function () {
        return this._evalLabel;
    },

    /**
     * Draws various distorder carrier graphics such as a dot (for carriers) or
     * a vertical line (for pre-symptomatic)
     *
     * @method updateCarrierGraphic
     */
    updateCarrierGraphic: function () {
        this._carrierGraphic && this._carrierGraphic.remove();
        var status = this.getNode().getCarrierStatus();

        if (status != '' && status != 'Unaffected' && status != 'Affected') {
            if (status == 'Carrier') {
                if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
                    var x = this.getX();
                    var y = this.getY() - this._radius / 2;
                } else {
                    var x = this.getX();
                    var y = this.getY();
                }
                this._carrierGraphic = editor.getPaper().circle(x, y, PedigreeEditorParameters.attributes.carrierDotRadius).attr(PedigreeEditorParameters.attributes.carrierShape);
            } else if (status == 'Uncertain' || status == 'Unknown') {
                if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
                    var x = this.getX();
                    var y = this.getY() - this._radius / 2;
                    var fontAttr = PedigreeEditorParameters.attributes.uncertainSmallShape;
                } else {
                    var x = this.getX();
                    var y = this.getY();
                    var fontAttr = PedigreeEditorParameters.attributes.uncertainShape;
                }
                this._carrierGraphic = editor.getPaper().text(x, y, "?").attr(fontAttr);
            } else if (status == 'Presymptomatic') {
                if (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') {
                    this._carrierGraphic = null;
                    return;
                }
                editor.getPaper().setStart();
                var startX = (this.getX() - PedigreeEditorParameters.attributes.presymptomaticShapeWidth / 2);
                var startY = this.getY() - this._radius;
                editor.getPaper().rect(startX, startY, PedigreeEditorParameters.attributes.presymptomaticShapeWidth, this._radius * 2).attr(PedigreeEditorParameters.attributes.presymptomaticShape);
                if (this.getNode().getGender() == 'U') {
                    editor.getPaper().path("M " + startX + " " + startY +
                        "L " + (this.getX()) + " " + (this.getY() - this._radius * 1.1) +
                        "L " + (startX + PedigreeEditorParameters.attributes.presymptomaticShapeWidth) + " " + (startY) + "Z").attr(PedigreeEditorParameters.attributes.presymptomaticShape);
                    var endY = this.getY() + this._radius;
                    editor.getPaper().path("M " + startX + " " + endY +
                        "L " + (this.getX()) + " " + (this.getY() + this._radius * 1.1) +
                        "L " + (startX + PedigreeEditorParameters.attributes.presymptomaticShapeWidth) + " " + endY + "Z").attr(PedigreeEditorParameters.attributes.presymptomaticShape);
                }
                this._carrierGraphic = editor.getPaper().setFinish();
            }
            if (editor.isReadOnlyMode())
                this._carrierGraphic.toFront();
            else
                this._carrierGraphic.insertBefore(this.getHoverBox().getFrontElements());
        } else {
            this._carrierGraphic = null;
        }
        this.updateDisorderShapes();
    },

    /**
     * Returns this Person's disorder carrier graphics
     *
     * @method getCarrierGraphics
     * @return {Raphael.el}
     */
    getCarrierGraphics: function () {
        return this._carrierGraphic;
    },

    /**
     * Returns this Person's stillbirth label
     *
     * @method getSBLabel
     * @return {Raphael.el}
     */
    getSBLabel: function () {
        return this._stillBirthLabel;
    },

    /**
     * Updates the stillbirth label for this Person
     *
     * @method updateSBLabel
     */
    updateSBLabel: function () {
        this.getSBLabel() && this.getSBLabel().remove();
        if (this.getNode().getLifeStatus() == 'Stillborn') {
            this._stillBirthLabel = editor.getPaper().text(this.getX(), this.getY(), "SB").attr(PedigreeEditorParameters.attributes.label);
        } else {
            this._stillBirthLabel = null;
        }
        this.drawLabels();
    },

    /**
     * Returns this Person's comments label
     *
     * @method getCommentsLabel
     * @return {Raphael.el}
     */
    getCommentsLabel: function () {
        return this._commentsLabel;
    },

    /**
     * Updates the comments label for this Person
     *
     * @method updateCommentsLabel
     */
    updateCommentsLabel: function () {
        this.getCommentsLabel() && this.getCommentsLabel().remove();
        if (this.getNode().getComments() != "") {
            // note: raphael positions text which starts with a new line in a strange way
            //       also, blank lines are ignored unless replaced with a space
            var text = this.getNode().getComments().replace(/^\s+|\s+$/g, '').replace(/\n\n/gi, '\n \n');
            this._commentsLabel = editor.getPaper().text(this.getX(), this.getY(), text).attr(PedigreeEditorParameters.attributes.commentLabel);
            this._commentsLabel.node.setAttribute("class", "field-no-user-select");
            this._commentsLabel.alignTop = true;
            this._commentsLabel.addGap = true;
        } else {
            this._commentsLabel = null;
        }
        this.drawLabels();
    },


    /**
     * Returns this Person's cancer age of onset labels
     *
     * @method getCancerAgeOfOnsetLabels
     * @return {Raphael.el}
     */
    getCancerAgeOfOnsetLabels: function () {
        return this._cancerAgeOfOnsetLabels;
    },


    /**
     * Updates the cancer age of onset labels for this Person
     *
     * @method updateCancerAgeOfOnsetLabels
     */
    updateCancerAgeOfOnsetLabels: function () {
        var cancerLabels = this.getCancerAgeOfOnsetLabels();
        if (!Helpers.isObjectEmpty(cancerLabels)) {
            for (var cancerName in cancerLabels) {
                cancerLabels[cancerName].remove();
            }
        }
        var cancerData = this.getNode().getCancers();
        if (!Helpers.isObjectEmpty(cancerData)
            && editor.getPreferencesManager().getConfigurationOption("displayCancerLabels")) {
            for (var cancerName in cancerData) {
                if (cancerData.hasOwnProperty(cancerName) && cancerData[cancerName].affected) {
                    var text = cancerName.toString() + " ca.";
                    if (cancerData[cancerName].hasOwnProperty("ageAtDiagnosis") && (cancerData[cancerName].ageAtDiagnosis.length > 0)) {
                        var age = cancerData[cancerName].ageAtDiagnosis;
                        if (isNaN(parseInt(age))) {
                            if (age == "before_1") {
                                text += " dx <1";
                            } else if (age == "before_10") {
                                text += " dx <10";
                            } else {
                                text += (age.indexOf('before_') > -1) ? " dx " + (parseInt(age.substring(7)) - 10) + "\'s" : " dx >100";
                            }
                        } else {
                            text += " dx " + cancerData[cancerName].ageAtDiagnosis;
                        }
                    } else {
                        text += " dx ?";
                    }
                    this.getCancerAgeOfOnsetLabels()[cancerName] && this.getCancerAgeOfOnsetLabels()[cancerName].remove();
                    this._cancerAgeOfOnsetLabels[cancerName] = editor.getPaper().text(this.getX(), this.getY(), text).attr(PedigreeEditorParameters.attributes.cancerAgeOfOnsetLabels);
                    this._cancerAgeOfOnsetLabels[cancerName].node.setAttribute("class", "field-no-user-select");
                    this._cancerAgeOfOnsetLabels[cancerName].alignTop = true;
                    this._cancerAgeOfOnsetLabels[cancerName].addGap = true;
                }
            }

        } else {
            this._cancerAgeOfOnsetLabels = {};
        }
        this.drawLabels();
    },

    /**
     * Displays the correct graphics to represent the current life status for this Person.
     *
     * @method updateLifeStatusShapes
     */
    updateLifeStatusShapes: function (oldStatus) {
        var status = this.getNode().getLifeStatus();

        this.getDeadShape() && this.getDeadShape().remove();
        this.getUnbornShape() && this.getUnbornShape().remove();
        this.getSBLabel() && this.getSBLabel().remove();

        // save some redraws if possible
        var oldShapeType = (oldStatus == 'Aborted' || oldStatus == 'Miscarriage');
        var newShapeType = (status == 'Aborted' || status == 'Miscarriage');
        if (oldShapeType != newShapeType)
            this.setGenderGraphics();

        if (status == 'Deceased' || status == 'Aborted') {  // but not "miscarriage"
            this.drawDeadShape();
        }
        else if (status == 'Stillborn') {
            this.drawDeadShape();
            this.updateSBLabel();
        }
        else if (status == 'Unborn') {
            this.drawUnbornShape();
        }
        this.updateAgeLabel();
    },

    /**
     * Marks this node as hovered, and moves the labels out of the way
     *
     * @method setSelected
     */
    setSelected: function ($super, isSelected) {
        $super(isSelected);
        if (isSelected) {
            this.shiftLabels();
        }
        else {
            this.unshiftLabels();
        }
    },

    /**
     * Moves the labels down to make space for the hoverbox
     *
     * @method shiftLabels
     */
    shiftLabels: function () {
        var shift = this._labelSelectionOffset();
        var labels = this.getLabels();
        for (var i = 0; i < labels.length; i++) {
            labels[i].stop().animate({"y": labels[i].oy + shift}, 200, ">");
        }
    },

    /**
     * Animates the labels of this node to their original position under the node
     *
     * @method unshiftLabels
     */
    unshiftLabels: function () {
        var labels = this.getLabels();
        var firstLabel = this._childlessStatusLabel ? 1 : 0;
        for (var i = 0; i < labels.length; i++) {
            labels[i].stop().animate({"y": labels[i].oy}, 200, ">");
        }
    },

    /**
     * Returns set of labels for this Person
     *
     * @method getLabels
     * @return {Raphael.st}
     */
    getLabels: function () {
        var labels = editor.getPaper().set();
        this.getSBLabel() && labels.push(this.getSBLabel());
        if (!this._anonimized) {
            if (this.getNameLabel()) {
                this.getNameLabel().show();
                labels.push(this.getNameLabel());
            }
            if (this.getAgeLabel()) {
                this.getAgeLabel().show();
                labels.push(this.getAgeLabel());
            }
        } else {
            this.getNameLabel() && this.getNameLabel().hide();
            this.getAgeLabel() && this.getAgeLabel().hide();
        }
        this.getExternalIDLabel() && labels.push(this.getExternalIDLabel());
        this.getCommentsLabel() && labels.push(this.getCommentsLabel());
        var cancerLabels = this.getCancerAgeOfOnsetLabels();
        if (!Helpers.isObjectEmpty(cancerLabels)) {
            for (var cancerName in cancerLabels) {
                labels.push(cancerLabels[cancerName]);
            }
        }
        return labels;
    },

    /**
     * Removes all PII labels
     */
    setAnonimizedStatus: function ($super, status) {
        $super(status);
        this.drawLabels();
    },

    /**
     * Displays all the appropriate labels for this Person in the correct layering order
     *
     * @method drawLabels
     */
    drawLabels: function () {
        var labels = this.getLabels();
        var selectionOffset = this._labelSelectionOffset();
        var childlessOffset = this.getChildlessStatusLabel() ? PedigreeEditorParameters.attributes.label['font-size'] : 0;
        childlessOffset += ((this.getNode().getChildlessStatus() !== null) ? (PedigreeEditorParameters.attributes.infertileMarkerHeight + 2) : 0);

        var lowerBound = PedigreeEditorParameters.attributes.radius * (this.getNode().isPersonGroup() ? PedigreeEditorParameters.attributes.groupNodesScale : 1.0);

        var startY = this.getY() + lowerBound * 1.8 + selectionOffset + childlessOffset;
        for (var i = 0; i < labels.length; i++) {
            var shift = (labels[i].addGap && i != 0) ? 4 : 8;   // make a small gap between comments and other fields
            var offset = (labels[i].alignTop) ? (GraphicHelpers.getElementHalfHeight(labels[i]) - shift) : 0;
            labels[i].transform(""); // clear all transofrms, using new real x
            labels[i].attr("x", this.getX());
            labels[i].attr("y", startY + offset);
            labels[i].oy = (labels[i].attr("y") - selectionOffset);
            labels[i].toBack();
            if (i != labels.length - 1) {   // dont do getBBox() computation if dont need to, it is slow in IE9
                startY = labels[i].getBBox().y2 + 11;
            }
        }
        //if(!editor.isUnsupportedBrowser())
        //    labels.flatten().insertBefore(this.getHoverBox().getFrontElements().flatten());
    },

    _labelSelectionOffset: function () {
        var selectionOffset = this.isSelected() ? PedigreeEditorParameters.attributes.radius / 1.4 : 0;

        if (this.isSelected() && this.getNode().isPersonGroup())
            selectionOffset += PedigreeEditorParameters.attributes.radius * (1 - PedigreeEditorParameters.attributes.groupNodesScale) + 5;

        if (this.getChildlessStatusLabel())
            selectionOffset = selectionOffset / 2;
        return selectionOffset;
    },

    /**
     * Returns set with the gender icon, disorder shapes and life status shapes.
     *
     * @method getShapes
     * @return {Raphael.st}
     */
    getShapes: function ($super) {
        var lifeStatusShapes = editor.getPaper().set();
        this.getUnbornShape() && lifeStatusShapes.push(this.getUnbornShape());
        this.getChildlessShape() && lifeStatusShapes.push(this.getChildlessShape());
        this.getChildlessStatusLabel() && lifeStatusShapes.push(this.getChildlessStatusLabel());
        this.getDeadShape() && lifeStatusShapes.push(this.getDeadShape());
        return $super().concat(editor.getPaper().set(this.getDisorderShapes(), lifeStatusShapes));
    },

    /**
     * Returns all the graphics and labels associated with this Person.
     *
     * @method getAllGraphics
     * @return {Raphael.st}
     */
    getAllGraphics: function ($super) {
        //console.log("Node " + this.getNode().getID() + " getAllGraphics");
        return $super().push(this.getHoverBox().getBackElements(), this.getLabels(), this.getCarrierGraphics(), this.getEvaluationGraphics(), this.getParticipatingInTestLabel(), this.getHoverBox().getFrontElements());
    },

    /**
     * Changes the position of the node to (x,y)
     *
     * @method setPos
     * @param [$super]
     * @param {Number} x the x coordinate on the canvas
     * @param {Number} y the y coordinate on the canvas
     * @param {Boolean} animate set to true if you want to animate the transition
     * @param {Function} callback a function that will be called at the end of the animation
     */
    setPos: function ($super, x, y, animate, callback) {
        var funct = callback;
        if (animate) {
            var me = this;
            this.getHoverBox().disable();
            funct = function () {
                me.getHoverBox().enable();
                callback && callback();
            };
        }
        $super(x, y, animate, funct);
    },


});

//ATTACHES CHILDLESS BEHAVIOR METHODS
PersonVisuals.addMethods(ChildlessBehaviorVisuals);


/**
 * Person is a class representing any AbstractPerson that has sufficient information to be
 * displayed on the final pedigree graph (printed or exported). Person objects
 * contain information about disorders, age and other relevant properties, as well
 * as graphical data to visualize this information.
 *
 * @class Person
 * @constructor
 * @extends AbstractPerson
 * @param {Number} x X coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {Number} y Y coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {String} gender 'M', 'F' or 'U' depending on the gender
 * @param {Number} id Unique ID number
 * @param {Boolean} isProband True if this person is the proband
 */
var Person = Class.create(AbstractPerson, {

	initialize: function ($super, x, y, id, properties) {
		//var timer = new Helpers.Timer();
		this._isProband = (id == 0);
		!this._type && (this._type = "Person");
		this._setDefault();
		var gender = properties.hasOwnProperty("gender") ? properties['gender'] : "U";
		$super(x, y, gender, id);

		// need to assign after super() and explicitly pass gender to super()
		// because changing properties requires a redraw, which relies on gender
		// shapes being there already
		//timer.printSinceLast("=== new person runtime: ");
		if (! properties.carrierStatus) {
			properties.carrierStatus =  "Unknown";
		}
		this.assignProperties(properties);
	},

	_setDefault: function () {
		this._phenotipsId = "";

		Person.setMethods["sex"] = "setGender";
		Person.setMethods["gender"] = "setGender";

		this._firstName = "";
		Person.setMethods["firstName"] = "setFirstName";
		this._lastName = "";
		Person.setMethods["lastName"] = "setLastName";
		this._NHSNumber = ""; // added for GEL
		Person.setMethods["NHSNumber"] = "setNHSNumber";

		this._gelSuperFamilyId = "";// added for GEL
		Person.setMethods["gelSuperFamilyId"] = "setGelSuperFamilyId";


		this._familyId = "";// added for GEL
		Person.setMethods["familyId"] = "setFamilyId";

    this._nonNgisPatientStableUid = ""; // added for GEL
    Person.setMethods["nonNgisPatientStableUid"] = "setNonNgisPatientStableUid";

    this._ngisRegisteredPatientUid = ""; // added for GEL
    Person.setMethods["ngisRegisteredPatientUid"] = "setNgisRegisteredPatientUid";

    this._consanguineousPopulation = "";// added for GEL
		Person.setMethods["consanguineousPopulation"] = "setConsanguineousPopulation";
		this._karyotypicSex = "Unknown";// added for GEL
		Person.setMethods["karyotypicSex"] = "setKaryotypicSex";
		this._ancestries = "";//added for GEL
		Person.setMethods["ancestries"] = "setAncestries";
		this._participantId = "";
		Person.setMethods["participantId"] = "setParticipantId";


		this._registered = "";
		Person.setMethods["registered"] = "setRegistered";


		this._lastNameAtBirth = "";
		Person.setMethods["lastNameAtBirth"] = "setLastNameAtBirth";
		this._birthDate = null;
		Person.setMethods["birthDate"] = "setBirthDate";
		this._deathDate = null;
		Person.setMethods["deathDate"] = "setDeathDate";

		this._ageOfDeath = "";
		Person.setMethods["ageOfDeath"] = "setAgeOfDeath";
		this._ageOfDeathFormat = "y"; // added for GEL
		Person.setMethods["ageOfDeathFormat"] = "setAgeOfDeathFormat";

		this._conceptionDate = "";

		//this._gestationAge = "";
		//Person.setMethods["gestationAge"] = "setGestationAge";
		this._adoptedStatus = "";
		Person.setMethods["adoptedStatus"] = "setAdoptedStatus";
		this._externalID = "";
		Person.setMethods["externalID"] = "setExternalID";
		this._lifeStatus = 'Alive';
		Person.setMethods["lifeStatus"] = "setLifeStatus";
		this._childlessStatus = null;
		Person.setMethods["childlessStatus"] = "setChildlessStatus";
		this._childlessReason = "";
		Person.setMethods["childlessReason"] = "setChildlessReason";
		this._carrierStatus = "";
		Person.setMethods["carrierStatus"] = "setCarrierStatus";
		this._disorders = [];
		Person.setMethods["disorders"] = "setDisorders";
		//comment added by Soheil 04.08.2016 for GEL(GenomicsEngland)
		//_disordersFullDetails: this field will hold all disorders with full details that returned from OCService
		//it will help to find out disorderName,disorderType ie. OMIM, ICD10,....
		this._disordersFullDetails = [];
		Person.setMethods["disordersFullDetails"] = "setDisordersFullDetails";
		//comment added by Soheil 04.08.2016 for GEL(GenomicsEngland)
		//_disorderType: this field is used to monitor the value of the selected disorderType in the UI
		//we do not export it into the JSON
		this._disorderType = "";
		this._ageOfOnset = ""; //This field is used internally for assigning ageOfOnset to disorder rows
		this._hpoPresent = ""; //This field is used internally for assigning hpoPresent status to hpo rows
		this._familyId = "";

		//this._cancers = {};
    this._cancers = [];
    Person.setMethods["cancers"] = "setCancers";
		this._hpo = [];
		Person.setMethods["hpoTerms"] = "setHPO";
		this._hpoFullDetails = [];
		Person.setMethods["hpoTermsFullDetails"] = "setHPOFullDetails";
		this._ethnicities = [];
		Person.setMethods["ethnicities"] = "setEthnicities";
		this._candidateGenes = [];
		Person.setMethods["candidateGenes"] = "setGenes";
		this._twinGroup = null;
		Person.setMethods["twinGroup"] = "setTwinGroup";
		this._monozygotic = false;
		Person.setMethods["monozygotic"] = "setMonozygotic";
		this._evaluated = false;
		Person.setMethods["evaluated"] = "setEvaluated";
		this._pedNumber = "";
		Person.setMethods["nodeNumber"] = "setPedNumber";
		this._lostContact = false;
    Person.setMethods["lostContact"] = "setLostContact";

    this._ngisRegisteredPatientId = false;
    Person.setMethods["ngisRegisteredPatientId"] = "setNgisRegisteredPatientId";

    this._nonNgisStableId = false;
    Person.setMethods["nonNgisStableId"] = "setNonNgisStableId";

    this._otherIdentifier = "";
		Person.setMethods["otherIdentifier"] = "setOtherIdentifier";
		
		this._chiNumber = "";
		Person.setMethods["chiNumber"] = "setChiNumber";
		
		this._localIdentifier = "";
		Person.setMethods["localIdentifier"] = "setLocalIdentifier";
		
		this._organDonorId = "";
    Person.setMethods["organDonorId"] = "setOrganDonorId";

    this._otherIdentifierType = "CHINumber";
    Person.setMethods["otherIdentifierType"] = "setOtherIdentifierType";

    this._participatingInTest = false;
    Person.setMethods["participatingInTest"] = "setParticipatingInTest";

    this._gestationAgeDays = "";
    Person.setMethods["gestationAgeDays"] = "setGestationAgeDays";

    this._gestationAgeWeeks = "";
    Person.setMethods["gestationAgeWeeks"] = "setGestationAgeWeeks";

    this._estimatedDateOfDelivery = false;
    Person.setMethods["estimatedDateOfDelivery"] = "setEstimatedDateOfDelivery";

    this._comments = "";
    Person.setMethods["comments"] = "setComments";

    this._clinicalIndicationName = "";
    Person.setMethods["clinicalIndicationName"] = "setClinicalIndicationName";

    this._clinicalIndicationCode= "";
    Person.setMethods["clinicalIndicationCode"] = "setClinicalIndicationCode";

   /* this._clinicalIndicationAgeOfOnset= "";
    Person.setMethods["clinicalIndicationAgeOfOnset"] = "setClinicalIndicationAgeOfOnset";
*/

	this._clinicalIndicationAgeOfOnsetYears= 0;
	Person.setMethods["clinicalIndicationAgeOfOnsetYears"] = "setClinicalIndicationAgeOfOnsetYears";


	this._clinicalIndicationAgeOfOnsetMonths= 0;
	Person.setMethods["clinicalIndicationAgeOfOnsetMonths"] = "setClinicalIndicationAgeOfOnsetMonths";



	this._numberOfColorectalPolypsTotal = "";
	Person.setMethods["numberOfColorectalPolypsTotal"] = "setNumberOfColorectalPolypsTotal";

    this._numberOfColorectalPolypsAdenomas = "";
    Person.setMethods["numberOfColorectalPolypsAdenomas"] = "setNumberOfColorectalPolypsAdenomas";

    this._diagnosisCertainty = "Suspected";
    Person.setMethods["diagnosisCertainty"] = "setDiagnosisCertainty";


    this._lastMenstralPeriod = "";
    Person.setMethods["lastMenstralPeriod"] = "setLastMenstralPeriod";


    },

	/**
	 * Initializes the object responsible for creating graphics for this Person
	 *
	 * @method _generateGraphics
	 * @param {Number} x X coordinate on the Raphael canvas at which the node drawing will be centered
	 * @param {Number} y Y coordinate on the Raphael canvas at which the node drawing will be centered
	 * @return {PersonVisuals}
	 * @private
	 */
	_generateGraphics: function (x, y) {
		return new PersonVisuals(this, x, y);
	},

	/**
	 * Returns True if this node is the proband (i.e. the main patient)
	 *
	 * @method isProband
	 * @return {Boolean}
	 */
	isProband: function () {
		return this._isProband;
	},


	/**
	 * Returns the id of the PhenoTips patient represented by this node.
	 * Returns an empty string for nodes not assosiated with any PhenoTips patients.
	 *
	 * @method getPhenotipsPatientId
	 * @return {String}
	 */
	getPhenotipsPatientId: function () {
		return this._phenotipsId;
	},

	/**
	 * Replaces (or sets) the id of the PhenoTips patient represented by this node
	 * with the given id, and updates the label.
	 *
	 * No error checking for the validity of this id is done.
	 *
	 * @method setPhenotipsPatientId
	 * @param firstName
	 */
	setPhenotipsPatientId: function (phenotipsId) {
		this._phenotipsId = phenotipsId;
	},

  setNgisRegisteredPatientId: function(ngisRegisteredPatientId) {
      this._ngisRegisteredPatientId = ngisRegisteredPatientId;
  },
  getNgisRegisteredPatientId: function () {
      return this._ngisRegisteredPatientId;
  },

  setNonNgisStableId: function(nonNgisStableId) {
      this._nonNgisStableId = nonNgisStableId;
  },
  getNonNgisStableId: function () {
      return this._nonNgisStableId;
  },
  setOtherIdentifier: function(otherIdentifier) {
      this._otherIdentifier = otherIdentifier;
  },
  getOtherIdentifier: function () {
      return this._otherIdentifier;
  },

  setOtherIdentifierType: function(otherIdentifierType) {
      this._otherIdentifierType = otherIdentifierType;
  },
  getOtherIdentifierType: function () {
      return this._otherIdentifierType;
  },

  setParticipatingInTest: function (participatingInTest) {
    //if (participatingInTest == this._participatingInTest) return;
    this._participatingInTest = participatingInTest;
    this.getGraphics().updateParticipatingInTestLabel();

  },
  getParticipatingInTest: function () {
      return this._participatingInTest;
  },

  setGestationAgeWeeks: function(gestationAgeWeeks) {
      this._gestationAgeWeeks = gestationAgeWeeks;
  },
  getGestationAgeWeeks: function () {
      return this._gestationAgeWeeks;
  },
  setGestationAgeDays: function(gestationAgeDays) {
      this._gestationAgeDays = gestationAgeDays;
  },
  getGestationAgeDays: function () {
      return this._gestationAgeDays;
  },

  setEstimatedDateOfDelivery: function(estimatedDateOfDelivery) {
      this._estimatedDateOfDelivery = estimatedDateOfDelivery;
  },
  getEstimatedDateOfDelivery: function () {
      return this._estimatedDateOfDelivery;
  },

  setComments: function(comments) {
      this._comments = comments;
  },
  getComments: function () {
      return this._comments;
  },

  setClinicalIndicationName: function(clinicalIndicationName) {
      this._clinicalIndicationName = clinicalIndicationName;
  },
  getClinicalIndicationName: function () {
      return this._clinicalIndicationName;
  },

 /* setClinicalIndicationAgeOfOnset: function(clinicalIndicationAgeOfOnset) {

      this._clinicalIndicationAgeOfOnset = clinicalIndicationAgeOfOnset;
  },
  getClinicalIndicationAgeOfOnset: function () {
      return this._clinicalIndicationAgeOfOnset;
  },*/

    setClinicalIndicationAgeOfOnsetYears: function(clinicalIndicationAgeOfOnsetYears) {
        if( this._clinicalIndicationAgeOfOnsetMonths < 0 && clinicalIndicationAgeOfOnsetYears > 0){
            this._clinicalIndicationAgeOfOnsetMonths = 0
        }
        this._clinicalIndicationAgeOfOnsetYears = clinicalIndicationAgeOfOnsetYears;
    },
    getClinicalIndicationAgeOfOnsetYears: function () {
        return this._clinicalIndicationAgeOfOnsetYears;
    },

    setClinicalIndicationAgeOfOnsetMonths: function(clinicalIndicationAgeOfOnsetMonths) {
		if(clinicalIndicationAgeOfOnsetMonths < 0 && this._clinicalIndicationAgeOfOnsetYears > 0){
            this._clinicalIndicationAgeOfOnsetYears = 0
		}
        this._clinicalIndicationAgeOfOnsetMonths = clinicalIndicationAgeOfOnsetMonths;
    },
    getClinicalIndicationAgeOfOnsetMonths: function () {
        return this._clinicalIndicationAgeOfOnsetMonths;
    },

  setClinicalIndicationCode: function(clinicalIndicaitonCode) {
      if(this.isProband()) {
          var event = { "clinicalIndicationCode": this._clinicalIndicationCode};
          document.fire("pedigree:update:clinicalIndicationName", event);
      }
      this._clinicalIndicationName = clinicalIndicaitonCode;
  },
  getClinicalIndicationCode: function () {
      return this._clinicalIndicationCode;
  },


	/**
	 * Returns the first name of this Person
	 *
	 * @method getFirstName
	 * @return {String}
	 */
	getFirstName: function () {
		return this._firstName;
	},

	// added for GEL
	getNHSNumber: function() {
		return this._NHSNumber;
	},

  getNgisRegisteredPatientUid: function() {
      return this._ngisRegisteredPatientUid;
  },

  setNgisRegisteredPatientUid: function(ngisRegisteredPatientUid) {
      this._ngisRegisteredPatientUid = ngisRegisteredPatientUid;
      this.getGraphics().updateExternalIDLabel();
  },

  getNonNgisPatientStableUid: function() {
      return this._nonNgisPatientStableUid;
  },

  setNonNgisPatientStableUid: function(nonNgisPatientStableUid) {
      this._nonNgisPatientStableUid = nonNgisPatientStableUid;
      this.getGraphics().updateExternalIDLabel();
  },


    // added for GEL
	getRegistered: function() {
		return this._registered;
	},

	isRegistered: function () {
		if(this._registered && this._registered == true){
			return true;
		}
		return false;
	},

	// added for GEL
	getGelSuperFamilyId: function() {
		return this._gelSuperFamilyId
	},

	// added for GEL
	getFamilyId: function() {
		return this._familyId
	},


	//added for GEL
	getConsanguineousPopulation: function(){
		return this._consanguineousPopulation;
	},

	getKaryotypicSex: function(){
		return this._karyotypicSex;
	},

	getAncestries: function(){
		return this._ancestries;
	},

	// added for GEL
	getChiNumber: function() {
		return this._chiNumber;
	},
	// added for GEL
	getLocalIdentifier: function() {
		return this._localIdentifier;
	},
	// added for GEL
	getOrganDonorId: function() {
		return this._organDonorId;
	},


	getParticipantId: function(){
		return this._participantId;
	},


	/**
	 * Replaces the first name of this Person with firstName, and displays the label
	 *
	 * @method setFirstName
	 * @param firstName
	 */
	setFirstName: function (firstName) {
		firstName && (firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1));
		this._firstName = firstName;
		this.getGraphics().updateNameLabel();
	},

	// added for GEL
	setNHSNumber: function(NHSNumber) {
		this._NHSNumber = NHSNumber;
		this.getGraphics().updateExternalIDLabel();
	},

	// added for GEL
	setRegistered: function(registered) {
		this._registered = registered;
	},


	// added for GEL
	setGelSuperFamilyId: function(gelSuperFamilyId) {
		this._gelSuperFamilyId = gelSuperFamilyId;
	},

	// added for GEL
	setFamilyId: function(familyId) {
		this._familyId = familyId;
		//if it is a proband, then fire "pedigree:update:topMenu" to update the text in top-menu
		if(this.isProband()) {
			//var event = {"testRequestID": this._testRequestId. "familyId": this._familyId, "participantId": this._participantId };
			//document.fire("pedigree:update:topMenu", event);
		}
	},

	//added for GEL
	setConsanguineousPopulation: function(consanguineousPopulation){
		this._consanguineousPopulation = consanguineousPopulation;
	},

	// added for GEL
	setKaryotypicSex: function(karyotypicSex) {
		this._karyotypicSex = karyotypicSex;
	},

	// added for GEL
	setAncestries: function(ancestries) {
		this._ancestries = ancestries;
	},


	// added for GEL
	setChiNumber: function(CHINumber) {
		this._chiNumber = CHINumber;
		//this.getGraphics().updateExternalIDLabel();
	},
	// added for GEL
	setLocalIdentifier: function(localIdentifier) {
		this._localIdentifier = localIdentifier;
		//this.getGraphics().updateExternalIDLabel();
	},
	// added for GEL
	setOrganDonorId: function(id) {
		this._organDonorId = id;
		//this.getGraphics().updateExternalIDLabel();
	},

	setParticipantId: function(participantId) {
		this._participantId = "";//participantId;
		//if it is a proband, then fire "pedigree:update:topMenu" to update the text in top-menu
		if(this.isProband()) {
			//var event = { "familyId": this._familyId, "participantId": this._participantId };
			//document.fire("pedigree:update:topMenu", event);
		}
        this.getGraphics().updateExternalIDLabel();
	},


	/**
	 * Returns the last name of this Person
	 *
	 * @method getLastName
	 * @return {String}
	 */
	getLastName: function () {
		return this._lastName;
	},

	/**
	 * Replaces the last name of this Person with lastName, and displays the label
	 *
	 * @method setLastName
	 * @param lastName
	 */
	setLastName: function (lastName) {
		lastName && (lastName = lastName.charAt(0).toUpperCase() + lastName.slice(1));
		this._lastName = lastName;
		this.getGraphics().updateNameLabel();
		return lastName;
	},

	/**
	 * Returns the externalID of this Person
	 *
	 * @method getExternalID
	 * @return {String}
	 */
	getExternalID: function () {
		return this._externalID;
	},

	/**
	 * Sets the user-visible node ID for this person
	 * ("I-1","I-2","I-3", "II-1", "II-2", etc.)
	 *
	 * @method setPedNumber
	 */
	setPedNumber: function (pedNumberString) {
		this._pedNumber = pedNumberString;
		this.getGraphics().updateNumberLabel();
	},

	/**
	 * Returns the user-visible node ID for this person, e.g. "I", "II", "III", "IV", etc.
	 *
	 * @method getPedNumber
	 * @return {String}
	 */
	getPedNumber: function () {
		return this._pedNumber;
	},

	/**
	 * Replaces the external ID of this Person with the given ID, and displays the label
	 *
	 * @method setExternalID
	 * @param externalID
	 */
	setExternalID: function (externalID) {
		this._externalID = externalID;
		//this.getGraphics().updateExternalIDLabel();
	},

	/**
	 * Returns the last name at birth of this Person
	 *
	 * @method getLastNameAtBirth
	 * @return {String}
	 */
	getLastNameAtBirth: function () {
		return this._lastNameAtBirth;
	},

	/**
	 * Replaces the last name at birth of this Person with the given name, and updates the label
	 *
	 * @method setLastNameAtBirth
	 * @param lastNameAtBirth
	 */
	setLastNameAtBirth: function (lastNameAtBirth) {
		lastNameAtBirth && (lastNameAtBirth = lastNameAtBirth.charAt(0).toUpperCase() + lastNameAtBirth.slice(1));
		this._lastNameAtBirth = lastNameAtBirth;
		this.getGraphics().updateNameLabel();
		return lastNameAtBirth;
	},

	/**
	 * Replaces free-form comments associated with the node and redraws the label
	 *
	 * @method setComments
	 * @param comment
	 */

	/**
	 * Sets the type of twin
	 *
	 * @method setMonozygotic
	 */
	setMonozygotic: function (monozygotic) {
		if (monozygotic == this._monozygotic) return;
		this._monozygotic = monozygotic;
	},

	/**
	 * Returns the documented evaluation status
	 *
	 * @method getEvaluated
	 * @return {Boolean}
	 */
	getEvaluated: function () {
		return this._evaluated;
	},

	/**
	 * Sets the documented evaluation status
	 *
	 * @method setEvaluated
	 */
	setEvaluated: function (evaluationStatus) {
		if (evaluationStatus == this._evaluated) return;
		this._evaluated = evaluationStatus;
		this.getGraphics().updateEvaluationLabel();
	},

    getNumberOfColorectalPolypsTotal: function () {
        return this._numberOfColorectalPolypsTotal;
    },

    setNumberOfColorectalPolypsTotal: function (numberOfColorectalPolypsTotal) {
        this._numberOfColorectalPolypsTotal = numberOfColorectalPolypsTotal;
    },

    getNumberOfColorectalPolypsAdenomas: function () {
        return this._numberOfColorectalPolypsAdenomas;
    },

    setNumberOfColorectalPolypsAdenomas: function (numberOfColorectalPolypsAdenomas) {
        this._numberOfColorectalPolypsAdenomas = numberOfColorectalPolypsAdenomas;
    },

    getDiagnosisCertainty: function () {
        return this._diagnosisCertainty;
    },

    setDiagnosisCertainty: function (diagnosisCertainty) {
        this._diagnosisCertainty = diagnosisCertainty;
    },

	/**
	 * Returns the "in contact" status of this node.
	 * "False" means proband has lost contaxt with this individual
	 *
	 * @method getLostContact
	 * @return {Boolean}
	 */
	getLostContact: function () {
		return this._lostContact;
	},


	setAgeOfOnset: function(ageOfOnset){
		this._ageOfOnset = ageOfOnset;
	},
	getAgeOfOnset: function(ageOfOnset){
		return this._ageOfOnset;
	},
	/**
	 * Sets the "in contact" status of this node
	 *
	 * @method setLostContact
	 */
	setLostContact: function (lostContact) {
		if (lostContact == this._lostContact) return;
		this._lostContact = lostContact;
	},

	/**
	 * Returns the type of twin: monozygotic or not
	 * (always false for non-twins)
	 *
	 * @method getMonozygotic
	 * @return {Boolean}
	 */
	getMonozygotic: function () {
		return this._monozygotic;
	},

	/**
	 * Assigns this node to the given twin group
	 * (a twin group is all the twins from a given pregnancy)
	 *
	 * @method setTwinGroup
	 */
	setTwinGroup: function (groupId) {
		this._twinGroup = groupId;
	},

	/**
	 * Returns the status of this Person
	 *
	 * @method getLifeStatus
	 * @return {String} "alive", "deceased", "stillborn", "unborn", "aborted" or "miscarriage"
	 */
	getLifeStatus: function () {
		return this._lifeStatus;
	},

	/**
	 * Returns True if this node's status is not 'alive' or 'deceased'.
	 *
	 * @method isFetus
	 * @return {Boolean}
	 */
	isFetus: function () {
		return (this.getLifeStatus() != 'Alive' && this.getLifeStatus() != 'Deceased');
	},

	/**
	 * Returns True is status is 'unborn', 'stillborn', 'aborted', 'miscarriage', 'alive' or 'deceased'
	 *
	 * @method _isValidLifeStatus
	 * @param {String} status
	 * @returns {boolean}
	 * @private
	 */
	_isValidLifeStatus: function (status) {
		return (status == 'Unborn' || status == 'Stillborn'
			|| status == 'Aborted' || status == 'Miscarriage'
			|| status == 'Alive' || status == 'Deceased')
	},

	/**
	 * Changes the life status of this Person to newStatus
	 *
	 * @method setLifeStatus
	 * @param {String} newStatus "alive", "deceased", "stillborn", "unborn", "aborted" or "miscarriage"
	 */
	setLifeStatus: function (newStatus) {
		if (this._isValidLifeStatus(newStatus)) {
			var oldStatus = this._lifeStatus;

			this._lifeStatus = newStatus;

			(newStatus != 'Deceased') && this.setDeathDate("");
			(newStatus == 'Alive') && this.setGestationAgeDays() && this.setGestationAgeWeeks();
			this.getGraphics().updateSBLabel();

			if (this.isFetus()) {
				this.setBirthDate("");
				this.setAdopted("");
				this.setChildlessStatus(null);
			}

			//Added for GEL
			//if status is set to alive, then make ageOfDeath and ageOfDeathFormat blank
			if(newStatus == "Alive"){
				this.setAgeOfDeath("");
				this.setAgeOfDeathFormat("y");
			}
			this.getGraphics().updateLifeStatusShapes(oldStatus);
			this.getGraphics().getHoverBox().regenerateHandles();
			this.getGraphics().getHoverBox().regenerateButtons();
		}
	},

	/**
	 * Returns the date of the conception date of this Person
	 *
	 * @method getConceptionDate
	 * @return {Date}
	 */
	getConceptionDate: function () {
		return this._conceptionDate;
	},

	/**
	 * Replaces the conception date with newDate
	 *
	 * @method setConceptionDate
	 * @param {Date} newDate Date of conception
	 */
	setConceptionDate: function (newDate) {
		this._conceptionDate = newDate ? (new Date(newDate)) : '';
		this.getGraphics().updateAgeLabel();
	},

	/**
	 * Returns the number of weeks since conception
	 *
	 * @method getGestationAgeWeeks
	 * @return {Number}
	 */

	/**
	 * Updates the conception age of the Person given the number of weeks passed since conception
	 *
	 * @method setGestationAgeWeeks
	 * @param {Number} numWeeks Greater than or equal to 0
	 */

	/**
	 * Returns the the birth date of this Person
	 *
	 * @method getBirthDate
	 * @return {Date}
	 */
	getBirthDate: function () {
		return this._birthDate;
	},

	/**
	 * Replaces the birth date with newDate
	 *
	 * @method setBirthDate
	 * @param newDate Either a string or an object with "year" (mandatory), "month" (optional) and "day" (optional) fields.
	 *                Must be earlier date than deathDate and a later than conception date
	 */
	setBirthDate: function (newDate) {
		newDate = new PedigreeDate(newDate);  // parse input
		if (!newDate.isSet()) {
			newDate = null;
		}

		//if birthDate has value, then set both ageOfDeath and ageOfDeathFormat to null,
		//we either have ageOfDeath and ageOfDeathFormat OR date-of-birth and date-of-death
		if(newDate != null){
			this.setAgeOfDeath("");
			this.setAgeOfDeathFormat("y");
		}

		if (!newDate || !this.getDeathDate() || this.getDeathDate().canBeAfterDate(newDate)) {
			this._birthDate = newDate;
			this.getGraphics().updateAgeLabel();
		}
	},

	/**
	 * Returns the death date of this Person
	 *
	 * @method getDeathDate
	 * @return {Date}
	 */
	getDeathDate: function () {
		return this._deathDate;
	},


	getAgeOfDeath: function () {
		return this._ageOfDeath;
	},


	getAgeOfDeathFormat: function () {
		return this._ageOfDeathFormat;
	},

	/**
	 * Replaces the death date with deathDate
	 *
	 *
	 * @method setDeathDate
	 * @param {Date} deathDate Must be a later date than birthDate
	 */
	setDeathDate: function (deathDate) {
		deathDate = new PedigreeDate(deathDate);  // parse input
		if (!deathDate.isSet()) {
			deathDate = null;
		}
		//if deathDate has value, then set empty for ageOfDeath and ageOfDeathFormat
		//we either have ageOfDeath and ageOfDeathFormat OR date-of-birth and date-of-death
		if(deathDate != null){
			this.setAgeOfDeath("");
			this.setAgeOfDeathFormat("y");
		}

		// only set death date if it happens ot be after the birth date, or there is no birth or death date
		if (!deathDate || !this.getBirthDate() || deathDate.canBeAfterDate(this.getBirthDate())) {
			this._deathDate = deathDate;
			this._deathDate && (this.getLifeStatus() == 'Alive') && this.setLifeStatus('Deceased');
		}
		this.getGraphics().updateAgeLabel();
		return this.getDeathDate();
	},

	setAgeOfDeath: function(ageOfDeath){
		var wasSet = this._ageOfDeath || this._ageOfDeath.length;
		this._ageOfDeath = ageOfDeath + "";

		//if ageOfDeath has value, then set deathDate and birthDate to null and make life status 'deceased'
		//we either have ageOfDeath and ageOfDeathFormat OR date-of-birth and date-of-death
		if(this._ageOfDeath && this._ageOfDeath.length){
			this.setLifeStatus('Deceased');
			this.setDeathDate(null);
			this.setBirthDate(null);

			//if ageOfDeath and ageOfDeathFormat both have value then create the text to display in the UI
			var text = 	ageOfDeath + " " + this._ageOfDeathFormat;
			this.getGraphics().updateAgeLabelForGELDirectly(text);
		}else if(wasSet){
            // if was set but now is empty, then make sure we wipe out the text
            this.getGraphics().updateAgeLabelForGELDirectly("");
		}
	},


	setAgeOfDeathFormat: function(ageOfDeathFormat){
		this._ageOfDeathFormat = ageOfDeathFormat;

		//if ageOfDeath and ageOfDeathFormat both have value then create the text to display in the UI
		if(this._ageOfDeathFormat && this._ageOfDeathFormat.length > 0 && this._ageOfDeath && this._ageOfDeath.length > 0){
			var text = 	this._ageOfDeath + " " + this._ageOfDeathFormat;
			this.getGraphics().updateAgeLabelForGELDirectly(text);
		}
	},


	_isValidCarrierStatus: function (status) {
		return (status == 'Unaffected' || status == 'Carrier' || status == 'Uncertain' || status == 'Unknown'
			|| status == 'Affected' || status == 'Presymptomatic');
	},

	/**
	 * Sets the global disorder carrier status for this Person
	 *
	 * @method setCarrier
	 * @param status One of {'', 'carrier', 'affected', 'presymptomatic', 'uncertain'}
	 */
	setCarrierStatus: function (status) {

		//Commented for GEL(GenomicsEngland)
		//var numDisorders = this.getDisorders().length;
		//Added for GEL(GenomicsEngland)
		//We set the status as affected, only if there is any GEL disorder, so we count just GEL disorders
		var numDisorders = 0;
		for(var i = 0;i < this._disordersFullDetails.length; i++){
			//if(this._disordersFullDetails[i].valueAll.disorderType /*&& this._disordersFullDetails[i].valueAll.disorderType == "GEL"*/){
				numDisorders = numDisorders + 1;
			//}
		}

		//this condition happens when we assign a disorder and then call 'setCarrierStatus'
		//to update the status (if GEL disorder is assigned then make it affected, otherwise do not change it)
		if (status === undefined || status === null) {
			if (numDisorders > 0) {
				status = "Affected";
				this.getGraphics().updateDisorderShapes();
				this._carrierStatus = status;
				this.getGraphics().updateCarrierGraphic();
				return;
			}
		}

		//if the user select 'affected' manually and we find that No GEL disorders added,
		//then ignore it and do not change the status to affected
		/*if(status == "Affected" && numDisorders == 0) {
			editor.getOkCancelDialogue().showCustomized("At least one Disorder should be added to make the node status 'Affected'.",
				"Genomics England", "Ok", function () {this.dialog.show();},
				null, null,
				null, null, true);
			return;
		}*/

		//if the user select 'uncertain' or 'unaffected' manually and we find that there are GEL disorders in the list,
		//then change the status to affected
		// TODO VALIDATE
		/*if(status != "Affected" && numDisorders > 0 ){
			status = "Affected";
			this.getGraphics().updateDisorderShapes();
		}*/ 


		if (!this._isValidCarrierStatus(status)) return;


		if (status != this._carrierStatus) {
			this._carrierStatus = status;
			this.getGraphics().updateCarrierGraphic();
		}
	},

	/**
	 * Returns the global disorder carrier status for this person.
	 *
	 * @method getCarrier
	 * @return {String} Dissorder carrier status
	 */
	getCarrierStatus: function () {
		return this._carrierStatus;
	},

	/**
	 * Returns the list of all colors associated with the node
	 * (e.g. all colors of all disorders and all colors of all the genes)
	 * @method getAllNodeColors
	 * @return {Array of Strings}
	 */
	getAllNodeColors: function () {
		var result = [];
		for (var i = 0; i < this.getDisorders().length; i++) {
			//commented by Soheil for GEL(GenomicsEngland) 01.10.2016
			//result.push(editor.getDisorderLegend().getObjectColor(this.getDisorders()[i]));
			//and added the following lines
			//We need to show color for just GEL disorders,
			//for other disorders types such as OMIM, IDC10 and SnomedCT we just use WHITE color .......................
			if(this._disordersFullDetails != undefined && this._disordersFullDetails[i].valueAll != undefined){
				//if(this._disordersFullDetails[i].valueAll.disorderType == "GEL") {
					result.push(editor.getDisorderLegend().getObjectColor(this.getDisorders()[i]));
				//}
			}
			//..........................................................................................................
		}
		for (var i = 0; i < this.getGenes().length; i++) {
			result.push(editor.getGeneLegend().getObjectColor(this.getGenes()[i]));
		}
		//for (var cancer in this.getCancers()) {
		//placeholder to set cancer to affected until its fixed
        for (var i = 0; i < this.getCancers().length; i++) {
            //placeholder to set cancer to affected until its fixed
            this.getCancers()[i].affected = true;
			if (this.getCancers()[i].hasOwnProperty("Affected") && this.getCancers()[i].affected) {
			    result.push(editor.getCancerLegend().getObjectColor(this.getCancers()[i]));
			}
		}
		if (this.getCarrierStatus() == 'Affected') {
			result.push("#81a270");
		}
		return result;
	},

	/**
	 * Returns a list of disorders of this person.
	 *
	 * @method getDisorders
	 * @return {Array} List of disorder IDs.
	 */
	getDisorders: function () {
		//console.log("Get disorders: " + Helpers.stringifyObject(this._disorders));
		return this._disorders;
	},

	//added for GEL.......
	getDisorderType: function() {
		return this._disorderType;
	},

	/**
	 * Returns a list of disorders of this person, with non-scrambled IDs
	 *
	 * @method getDisordersForExport
	 * @return {Array} List of human-readable versions of disorder IDs
	 */
	getDisordersForExport: function () {
		var exportDisorders = this._disorders.slice(0);
		return exportDisorders;
	},

	/**
	 * Adds disorder to the list of this node's disorders and updates the Legend.
	 *
	 * @method addDisorder
	 * @param {Disorder} disorder Disorder object or a free-text name string
	 */
	addDisorder: function (disorder) {
		if (typeof disorder != 'object') {
			disorder = editor.getDisorderLegend().getDisorder(disorder);
		}
		//if (!this.hasDisorder(disorder.getDisorderId())) {
			//disorder.valueAll passed for GEL
			editor.getDisorderLegend().addCase(disorder.getDisorderId(), disorder.getName(), disorder.getValueAll(), this.getID());
			this.getDisorders().push(disorder.getDisorderId());
			//this is added for GEL ...........................................................................
			//var alreadyExists = false;
			//for(var i = 0; i < this._disordersFullDetails.length;i++){
			//	if(this._disordersFullDetails[i].disorderId == disorder.getDisorderId()){
			//		alreadyExists = true;
			//	}
			//}
			//if(!alreadyExists) {
				this._disordersFullDetails.push(disorder);
			//}
			//.................................................................................................
		//}
		//else {
			//alert("This person already has the specified disorder");
		//}

		// if any "real" disorder has been added
		// the virtual "affected" disorder should be automatically removed
		if (this.getDisorders().length > 1) {
			this.removeDisorder("Affected");
		}
	},

	/**
	 * Removes disorder from the list of this node's disorders and updates the Legend.
	 *
	 * @method removeDisorder
	 * @param {Number} disorderId id of the disorder to be removed
	 */
	removeDisorder: function (disorderId) {
		if (this.hasDisorder(disorderId)) {
			editor.getDisorderLegend().removeCase(disorderId, this.getID());
			this._disorders = this.getDisorders().without(disorderId);
			//added for GEL ................................................

			//...............................................................
		}

		for(var i = this._disordersFullDetails.length -1 ;i>=0; i--){
			if(this._disordersFullDetails[i].disorderId == disorderId){
				this._disordersFullDetails.splice(i, 1);

				//break;
			}
		}
		//else {
		//	if (disorderId != "affected") {
		//		alert("This person doesn't have the specified disorder");
		//	}
		//}
	},

	/**
	 * Sets the list of disorders of this person to the given list
	 *
	 * @method setDisorders
	 * @param {Array} disorders List of Disorder objects
	 */
	setDisorders: function (disorders) {
		//console.log("Set disorders: " + Helpers.stringifyObject(disorders));
		for (var i = this.getDisorders().length - 1; i >= 0; i--) {
			this.removeDisorder(this.getDisorders()[i]);
		}
		for (var i = 0; i < disorders.length; i++) {
			this.addDisorder(disorders[i]);
		}
		this.getGraphics().updateDisorderShapes();
		if (this.getCarrierStatus() == "Affected")
			this.setCarrierStatus(); // update carrier status
	},
	//added for GEL................................................................................
	setDisorderType: function(disorderType) {
		this._disorderType = disorderType;
	},
	//.............................................................................................


	//added for GEL................................................................................
	setDisordersFullDetails: function(disordersFullDetails){
		this._disordersFullDetails = disordersFullDetails;
	},

	/**
	 * Returns a list of all HPO terms associated with the patient
	 *
	 * @method getHPO
	 * @return {Array} List of HPO IDs.
	 */
	getHPO: function () {
		return this._hpo;
	},

	/**
	 * Returns a list of phenotypes of this person, with non-scrambled IDs
	 *
	 * @method getHPOForExport
	 * @return {Array} List of human-readable versions of HPO IDs
	 */
	getHPOForExport: function () {
		var exportHPOs = this._hpo.slice(0);
		return exportHPOs;
	},

	/**
	 * Adds HPO term to the list of this node's phenotypes and updates the Legend.
	 *
	 * @method addHPO
	 * @param {HPOTerm} hpo HPOTerm object or a free-text name string
	 */
	addHPO: function (hpo) {
		if (typeof hpo != 'object') {
			hpo = editor.getHPOLegend().getTerm(hpo);
		}
		if (!this.hasHPO(hpo.getID())) {
			//hpo.valueAll passed for GEL
			editor.getHPOLegend().addCase(hpo.getID(), hpo.getName(), hpo.getValueAll(), this.getID());
			this.getHPO().push(hpo.getID());
			//this is added for GEL .......................................................................
			var alreadyExists = false;
			for(var i = 0; i < this._hpoFullDetails.length;i++){
				if(this._hpoFullDetails[i].hpoId == hpo){
					alreadyExists = true;
				}
			}
			if(!alreadyExists) {
				this._hpoFullDetails.push(hpo);
			}
			//.............................................................................................
		}
		else {
			alert("This person already has the specified phenotype");
		}
	},

	/**
	 * Removes HPO term from the list of this node's terms and updates the Legend.
	 *
	 * @method removeHPO
	 * @param {Number} hpoId id of the term to be removed
	 */
	removeHPO: function (hpoId){
        if (this.hasHPO(hpoId)) {
            editor.getHPOLegend().removeCase(hpoId, this.getID());
            this._hpo = this.getHPO().without(hpoId);

            //added for GEL ................................................
            for(var i = 0;i < this._hpoFullDetails.length; i++){
                if(this._hpoFullDetails[i].hpoId == hpoId){
                    this._hpoFullDetails.splice(i, 1);
                    break;
                }
            }
            //...............................................................
        }
		else {
			alert("This person doesn't have the specified HPO term");
		}
	},

	/**
	 * Sets the list of HPO temrs of this person to the given list
	 *
	 * @method setHPO
	 * @param {Array} hpos List of HPOTerm objects
	 */
	setHPO: function (hpos) {
		//console.log("set hpo", hpos)
		for (var i = this.getHPO().length - 1; i >= 0; i--) {
			this.removeHPO(this.getHPO()[i]);
		}
        //console.log("hppp",hpos)

        hpos = this.sortHPOs(hpos);

        for (var i = 0; i < hpos.length; i++) {
			this.addHPO(hpos[i]);
		}

    },
	sortHPOs: function(hpos){
		var resultHPOs = [];
		hpos.forEach(function(hpo){
            if(hpo.hpoPresent && hpo.hpoPresent == 'Present'){
                resultHPOs.push(hpo);
            }
		})
        hpos.forEach(function(hpo){
            if(!hpo.hpoPresent || hpo.hpoPresent == 'Unknown'){
                resultHPOs.push(hpo);
            }
        })
        hpos.forEach(function(hpo){
            if(hpo.hpoPresent == 'Absent'){
                resultHPOs.push(hpo);
            }
        })
		return resultHPOs;

	},
	//added for GEL................................................................................
	setHPOFullDetails: function(hpoFullDetails) {
		this._hpoFullDetails = hpoFullDetails;
	},

	/**
	 * @method hasHPO
	 * @param {Number} id Term ID, taken from the HPO database
	 */
	hasHPO: function (id) {
		return (this.getHPO().indexOf(id) != -1);
	},

	/**
	 * Sets the list of ethnicities of this person to the given list
	 *
	 * @method setEthnicities
	 * @param {Array} ethnicities List of ethnicity names (as strings)
	 */
	setEthnicities: function (ethnicities) {
		this._ethnicities = ethnicities;
	},

	/**
	 * Returns a list of ethnicities of this person.
	 *
	 * @method getEthnicities
	 * @return {Array} List of ethnicity names.
	 */
	getEthnicities: function () {
        var elements = document.getElementsByName("ethnicity")[0].options;
		if(document.getElementsByName("ethnicity") && document.getElementsByName("ethnicity")[0]){
            for(var i = 0; i < elements.length; i++){
                elements[i].selected = false;
            }
		}

        return this._ethnicities;
	},

	/**
	 * Adds gene to the list of this node's candidate genes
	 *
	 * @method addGenes
	 */
	addGene: function (gene) {
		if (this.getGenes().indexOf(gene) == -1) {
			editor.getGeneLegend().addCase(gene, gene, this.getID());
			this.getGenes().push(gene);
		}
	},

	/**
	 * Removes gene from the list of this node's candidate genes
	 *
	 * @method removeGene
	 */
	removeGene: function (gene) {
		if (this.getGenes().indexOf(gene) !== -1) {
			editor.getGeneLegend().removeCase(gene, this.getID());
			this._candidateGenes = this.getGenes().without(gene);
		}
	},

	/**
	 * Sets the list of candidate genes of this person to the given list
	 *
	 * @method setGenes
	 * @param {Array} genes List of gene names (as strings)
	 */
	setGenes: function (genes) {
		for (var i = this.getGenes().length - 1; i >= 0; i--) {
			this.removeGene(this.getGenes()[i]);
		}
		for (var i = 0; i < genes.length; i++) {
			this.addGene(genes[i]);
		}
		this.getGraphics().updateDisorderShapes();
	},

	/**
	 * Returns a list of candidate genes for this person.
	 *
	 * @method getGenes
	 * @return {Array} List of gene names.
	 */
	getGenes: function () {
		return this._candidateGenes;
	},

	/**
	 * Adds cancer to the list of this node's common cancers
	 *
	 * @param cancerName String
	 * @param cancerDetails Object {affected: Boolean, numericAgeAtDiagnosis: Number, ageAtDiagnosis: String, comments: String}
	 * @method addCancer
	 */
	addCancer: function (cancer) {
		console.log("CCCancer",cancer)
        /*if (typeof cancer != 'object') {
            cancer = editor.getCancerLegend().getCancer(cancer);
        }*/
		//console.log("cancerName", cancerName, "details", cancerDetails)
		//if (!this.getCancers().hasOwnProperty(cancerName)) {
			//TODO://Temp making this require less so that it will proc easier
            //if (cancerDetails.hasOwnProperty("affected") && cancerDetails.affected) {
			if (true) {
                //editor.getCancerLegend().addCase(cancerName, cancerName,cancerDetails, this.getID());
                editor.getCancerLegend().addCase(cancer.tumourUid, cancer.tumourCodeMorphText, cancer, this.getID());
				this.getCancers().push(cancer.tumourUid);

                //editor.getCancerLegend().addCase(cancerName, cancerName, this.getID());
			}
			//this.getCancers()[cancerName] = cancerDetails;
		//}
	},

	/**
	 * Removes cancer from the list of this node's common cancers
	 *
	 * @method removeCancer
	 */
	removeCancer: function (cancerName) {
		if (this.getCancers().hasOwnProperty(cancerName)) {
			editor.getCancerLegend().removeCase(cancerName, this.getID());
			delete this._cancers[cancerName];
		}
	},

    addUnmappedPerson: function (cancerName, cancerDetails) {
		console.log("addunmappedperson")
        console.log("cancerName", cancerName, "details", cancerDetails)
        if (!this.getCancers().hasOwnProperty(cancerName)) {
            //TODO://Temp making this require less so that it will proc easier
            //if (cancerDetails.hasOwnProperty("affected") && cancerDetails.affected) {
            if (true) {
                editor.getUnmappedPersonLegend().addCase(cancerDetails.tumourUid, cancerDetails.tumourCodeMorphText, this.getID());
                //editor.getCancerLegend().addCase(cancerName, cancerName, this.getID());
            }
            this.getCancers()[cancerName] = cancerDetails;
        }
    },

    /**
     * Removes cancer from the list of this node's common cancers
     *
     * @method removeCancer
     */
    removeUnmappedPerson: function (cancerName) {
        if (this.getCancers().hasOwnProperty(cancerName)) {
            editor.getCancerLegend().removeCase(cancerName, this.getID());
            delete this._cancers[cancerName];
        }
    },

	/**
	 * Sets the set of common cancers affecting this person to the given set
	 *
	 * @method setCancers
	 * @param {Object} { Name: {affected: Boolean, numericAgeAtDiagnosis: Number, ageAtDiagnosis: String, comments: String} }
	 */
	setCancers: function (cancers) {
		console.log("TTT")
		console.log(this.getCancers());
		console.log(cancers)
		/*for (var cancerName in this.getCancers()) {
			console.log("cn", cancerName)
			if (this.getCancers().hasOwnProperty(cancerName)) {
				this.removeCancer(cancerName);
			}
		}*/
		/* temp commenting this out to try replacement
		for (var cancerName in cancers) {
			if (cancers.hasOwnProperty(cancerName)) {
				this.addCancer(cancer);
			}
		}*/

     /*   for (var cancerName in this.getCancers()) {
            console.log("cn", cancerName)
            if (this.getCancers().hasOwnProperty(cancerName)) {
                this.removeCancer(cancerName);
            }
        }*/

     //*also need to fix the remove cancer basedon cancer id this.remove cancer...
       /* for (var i = 0; i < this.getCancers().length; i++) {
            this.removeCancer(cancer);
        }*/

        for (var i = 0; i < cancers.length; i++) {
            this.addCancer(cancers[i]);
        }


		this.getGraphics().updateDisorderShapes();
		this.getGraphics().updateCancerAgeOfOnsetLabels();
	},

    getLastMenstralPeriod: function () {
		return this._lastMenstralPeriod;
    },
    setLastMenstralPeriod: function (lastMenstralPeriod) {
		this._lastMenstralPeriod = lastMenstralPeriod;
    },

	/**
	 * Returns a list of common cancers affecting this person.
	 *
	 * @method getCancers
	 * @return {Object}  { Name: {affected: Boolean, numericAgeAtDiagnosis: Number, ageAtDiagnosis: String, comments: String} }
	 */
	getCancers: function () {
		return this._cancers;
	},

	/**
	 * Removes the node and its visuals.
	 *
	 * @method remove
	 * @param [skipConfirmation=false] {Boolean} if true, no confirmation box will pop up
	 */
	remove: function ($super) {
		this.setDisorders([]);  // remove disorders form the legend
		this.setHPO([]);
		this.setGenes([]);
		this.setCancers([]);
		$super();
	},

	/**
	 * Returns disorder with given id if this person has it. Returns null otherwise.
	 *
	 * @method getDisorderByID
	 * @param {Number} id Disorder ID, taken from the OMIM database
	 * @return {Disorder}
	 */
	hasDisorder: function (id) {
		return (this.getDisorders().indexOf(id) != -1);
	},

	/**
	 * Changes the Childless status of this Person. Nullifies the status if the given status is not
	 * "Childless" or "Infertile". Modifies the status of the partnerships as well.
	 *
	 * @method setChildlessStatus
	 * @param {String} status Can be "Childless", "Infertile" or null
	 * @param {Boolean} ignoreOthers If True, changing the status will not modify partnerships's statuses or
	 * detach any children
	 */
	setChildlessStatus: function (status) {
		if (!this.isValidChildlessStatus(status))
			status = null;
		if (status != this.getChildlessStatus()) {
			this._childlessStatus = status;
			this.setChildlessReason(null);
			this.getGraphics().updateChildlessShapes();
			this.getGraphics().getHoverBox().regenerateHandles();
		}
		return this.getChildlessStatus();
	},

	/**
	 * Returns an object (to be accepted by node menu) with information about this Person
	 *
	 * @method getSummary
	 * @return {Object} Summary object for the menu
	 */
	getSummary: function () {
		var onceAlive = editor.getGraph().hasRelationships(this.getID());
		var inactiveStates = onceAlive ? ['Unborn', 'Aborted', 'Miscarriage', 'Stillborn'] : false;
		var disabledStates = false;

		if (this.isProband() || this.isRegistered()) {
			disabledStates = ['Alive', 'Deceased', 'Unborn', 'Aborted', 'Miscarriage', 'Stillborn']; // all possible
			Helpers.removeFirstOccurrenceByValue(disabledStates, this.getLifeStatus())
		}

		var disabledGenders = (this.isProband() || this.isRegistered()) ? [] : false;
		var inactiveGenders = false;
		var genderSet = editor.getGraph().getPossibleGenders(this.getID());
		for (gender in genderSet) {
			if (genderSet.hasOwnProperty(gender))
				if (!genderSet[gender]) {
					if (!inactiveGenders)
						inactiveGenders = [];
					inactiveGenders.push(gender);
				}
			if (this.isProband() && gender != this.getGender()) {
				disabledGenders.push(gender);
			}
		}

		var childlessInactive = this.isFetus();  // TODO: can a person which already has children become Childless?
		// maybe: use editor.getGraph().hasNonPlaceholderNonAdoptedChildren() ?
		var disorders = [];
		this._disordersFullDetails.forEach(function (disorder) {
			//var disorderName = editor.getDisorderLegend().getDisorder(disorder).getName();
			//added for GEL, get disorderObject and push valueAll into the array ........................
			//var disorderObj  = editor.getDisorderLegend().getDisorder(disorder);
			disorders.push({id: disorder.disorderId, value: disorder.name, valueAll:disorder.valueAll});
			//............................................................................................
		});
		var hpoTerms = [];
		this.getHPO().forEach(function (hpo) {
			var termName = editor.getHPOLegend().getTerm(hpo).getName();
			//Added for GEL(GenomicsEngland) ................................................................
			var hpoObj  = editor.getHPOLegend().getTerm(hpo);
			hpoTerms.push({id: hpo, value: termName, valueAll:hpoObj.valueAll});
			//...............................................................................................
		});

		var cantChangeAdopted = this.isFetus() || editor.getGraph().hasToBeAdopted(this.getID());
		// a person which has relationships can't be adopted out - we wouldn't know details in that case
		if (!cantChangeAdopted && onceAlive) {
			cantChangeAdopted = ["adoptedOut", "disableViaOpacity"];
		}

		var inactiveMonozygothic = true;
		var disableMonozygothic = true;
		if (this._twinGroup !== null) {
			var twins = editor.getGraph().getAllTwinsSortedByOrder(this.getID());
			if (twins.length > 1) {
				// check that there are twins and that all twins
				// have the same gender, otherwise can't be monozygothic
				inactiveMonozygothic = false;
				disableMonozygothic = false;
				for (var i = 0; i < twins.length; i++) {
					if (editor.getGraph().getGender(twins[i]) != this.getGender()) {
						disableMonozygothic = true;
						break;
					}
				}
			}
		}

		var inactiveCarriers = [];
		//Commented for GEL(GenomicsEngland)
		//We don't need to inactivate any 'Disease Affection' radio button items in th UI
		//if (disorders.length > 0) {
		//	if (disorders.length != 1 || disorders[0].id != "affected") {
		//		inactiveCarriers = [''];
		//	}
		//}
		if (this.getLifeStatus() == "Aborted" || this.getLifeStatus() == "Miscarriage") {
			inactiveCarriers.push('presymptomatic');
		}
		//If it has participantId, then disable all options
		if(this.isRegistered()){
			inactiveCarriers = ['','Carrier','Uncertain','Affected','Unknown','Unaffected','Presymptomatic'];
		}


		var inactiveLostContact = this.isProband() || !editor.getGraph().isRelatedToProband(this.getID()) || this.isRegistered();

		// TODO: only suggest posible birth dates which are after the latest
		//       birth date of any ancestors; only suggest death dates which are after birth date

		return {
			identifier: {value: this.getID()},
			nhs_number:    {value : this.getNHSNumber(), disabled: true},
			chiNumber:    {value : this.getChiNumber(), disabled: true},
			organDonorId:    {value : this.getOrganDonorId(), disabled: true},
			localIdentifier:    {value : this.getLocalIdentifier(), disabled: true},

			gel_super_family_id: {value : this.getGelSuperFamilyId()},
			family_id: {value : this.getFamilyId()},
			consanguineous_population: {value : this.getConsanguineousPopulation()},
			karyotypic_sex: {value : this.getKaryotypicSex(), disabled: this.isRegistered()},
			ancestries: {value : this.getAncestries()},
			participant_id:{value : this.getParticipantId(), disabled: true},
			registered:{value : this.getRegistered()},

			first_name: {value: this.getFirstName(), disabled: true},
			last_name: {value: this.getLastName(), disabled: true},
			last_name_birth: {value: this.getLastNameAtBirth(), disabled: this.isRegistered()}, //, inactive: (this.getGender() != 'F')},
			external_id: {value: this.getExternalID(), disabled: this.isRegistered()},

      //ngisRegisteredPatientId: {value: this.getNgisRegisteredPatientId(), disabled: false},
      //nonNgisStableId: {value: this.getNonNgisStableId(), disabled: false},
      //otherIdentifier: {value: this.getOtherIdentifier(), disabled: true},
      //otherIdentifierType: {value: this.getOtherIdentifierType(), disabled: true},
			chiNumber: {value: this.getChiNumber(), disabled: true},
			organDonorId: {value: this.getOrganDonorId(), disabled: true},
			localIdentifier: {value: this.getLocalIdentifier(), disabled: true},

			participatingInTest: {value: this.getParticipatingInTest(), disabled: true},
      gestationAgeWeeks: {value: this.getGestationAgeWeeks(), disabled: this.isRegistered()},
      gestationAgeDays: {value: this.getGestationAgeDays(), disabled: this.isRegistered()},
      estimatedDateOfDelivery: {value: this.getEstimatedDateOfDelivery(), disabled: this.isRegistered()},
      comments: {value: this.getComments(), disabled: this.isRegistered()},

      gender: {value: this.getGender(), inactive: inactiveGenders, disabled: this.isRegistered()},
			date_of_birth: {value: this.getBirthDate(), inactive: this.isFetus(), disabled: this.isRegistered()},
			carrierStatus: {value: this.getCarrierStatus(), disabled: this.isRegistered()},//inactiveCarriers},
			disorders: {value: disorders, disabled: this.isRegistered()},
			disordersFullDetails:     {value : this._disordersFullDetails, disabled: this.isRegistered()},
			disorderType:  {value : this.getDisorderType(), disabled: this.isRegistered()},
			ethnicity: {value: this.getEthnicities(), disabled: this.isRegistered() },
			candidate_genes: {value: this.getGenes(), disabled: this.isRegistered()},
			adopted: {value: this.getAdopted(), inactive: cantChangeAdopted, disabled: this.isRegistered()},
			state: {value: this.getLifeStatus(), inactive: inactiveStates, disabled: disabledStates },
			date_of_death: {value: this.getDeathDate(), inactive: this.isFetus(), disabled: this.isRegistered()},

			age_of_death: {value: this.getAgeOfDeath(), inactive: this.isFetus(), disabled: this.isRegistered() || (this.getBirthDate() != null && this.getDeathDate()!=null)},
			age_of_death_format: {value: this.getAgeOfDeathFormat(), inactive: this.isFetus(), disabled: this.isRegistered() || (this.getBirthDate() != null && this.getDeathDate()!=null) },

			commentsClinical: {value: this.getComments(), inactive: false, disabled: this.isRegistered()},
			commentsPersonal: {value: this.getComments(), inactive: false, disabled: this.isRegistered()},  // so far the same set of comments is displayed on all tabs
			commentsCancers: {value: this.getComments(), inactive: false, disabled: this.isRegistered()},
			gestation_age_weeks: {value: this.getGestationAgeWeeks(), inactive: !this.isFetus(), disabled: this.isRegistered()},
			gestation_age_days: {value: this.getGestationAgeDays(), inactive: !this.isFetus(), disabled: this.isRegistered()},
			childlessSelect: {value: this.getChildlessStatus() ? this.getChildlessStatus() : 'None', inactive: childlessInactive, disabled: this.isRegistered()},
			childlessText: {value: this.getChildlessReason() ? this.getChildlessReason() : undefined, inactive: childlessInactive, disabled: !this.getChildlessStatus() || this.isRegistered()},
			placeholder: {value: false, inactive: true },
			monozygotic: {value: this.getMonozygotic(), inactive: inactiveMonozygothic, disabled: disableMonozygothic || this.isRegistered()},
			evaluated: {value: this.getEvaluated(), disabled: false },
			hpo_positive: {value: hpoTerms , disabled: this.isRegistered()},
			hpo_positiveFullDetails: {value : this._hpoFullDetails}, //Added for GEL(GenomicsEngland)..........
			nocontact: {value: this.getLostContact(), inactive: inactiveLostContact },
			cancers: {value: this.getCancers() , disabled: this.isRegistered()},
			phenotipsid: {value: this.getPhenotipsPatientId() , disabled: this.isRegistered()},

			//These two fields are used internally for creating rows in disorder and hpo, we do not export them
			ageOfOnset: {value: this.getAgeOfOnset() , disabled: this.isRegistered()},
			hpoPresent: {value: "" , disabled: this.isRegistered()},
			//"age_of_death_guide" this is a label field (added in pedigree.js as a label in Personal tab)
			//which is a guidance for ageOfDeath and should be hidden when node is not Alive or not Death
			//This is just for display purpose
			age_of_death_guide:{value:"", inactive: this.isFetus()},
      numberOfColorectalPolypsAdenomas: {value: this.getNumberOfColorectalPolypsAdenomas(), disabled: this.isRegistered()},
      numberOfColorectalPolypsTotal: {value: this.getNumberOfColorectalPolypsTotal(), disabled: this.isRegistered()},
      clinicalIndicationName: {value: this.getClinicalIndicationName(), disabled: true},
/*
      clinicalIndicationAgeOfOnset: {value: this.getClinicalIndicationAgeOfOnset(), disabled: this.isRegistered()},
*/
	  clinicalIndicationAgeOfOnsetYears: {value: this.getClinicalIndicationAgeOfOnsetYears(), disabled: this.isRegistered()},
	  clinicalIndicationAgeOfOnsetMonths: {value: this.getClinicalIndicationAgeOfOnsetMonths(), disabled: this.isRegistered()},
      diagnosisCertainty: {value: this.getDiagnosisCertainty(), disabled: this.isRegistered()},
      lastMenstralPeriod: {value: this.getLastMenstralPeriod(), disabled: this.isRegistered()},
      nonNgisPatientStableUid: {value: this.getNonNgisPatientStableUid(), disabled: true},
      ngisRegisteredPatientUid: {value: this.getNgisRegisteredPatientUid(), disabled: true},

      }
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 {
	   property: value
	 }
	 */
	getProperties: function ($super) {
		// note: properties equivalent to default are not set
		var info = $super();
		if (this.getPhenotipsPatientId() != "")
			info['phenotipsId'] = this.getPhenotipsPatientId();
		if (this.getFirstName() != "")
			info['fName'] = this.getFirstName();
		if (this.getLastName() != "")
			info['lName'] = this.getLastName();
		if (this.getNHSNumber() != "")
			info['NHSNumber'] = this.getNHSNumber();
		if (this.getGelSuperFamilyId() != "")
			info['gelSuperFamilyId'] = this.getGelSuperFamilyId();

		if (this.getFamilyId() != "")
			info['familyId'] = this.getFamilyId();

		if (this.getKaryotypicSex() != "")
			info['karyotypicSex'] = this.getKaryotypicSex();
		if (this.getConsanguineousPopulation() != "")
			info['consanguineousPopulation'] = this.getConsanguineousPopulation();
		if (this.getAncestries() != "")
			info['ancestries'] = this.getAncestries();
		if (this.getChiNumber() != "")
			info['chiNumber'] = this.getChiNumber();
		if (this.getOrganDonorId() != "")
			info['organDonorId'] = this.getOrganDonorId();
		if (this.getLocalIdentifier() != "")
			info['localIdentifier'] = this.getLocalIdentifier();

		if (this.getParticipantId() != "")
			info['participantId'] = this.getParticipantId();


		if (this.getRegistered() != "")
			info['registered'] = this.getRegistered();


		if (this.getLastNameAtBirth() != "")
			info['lNameAtB'] = this.getLastNameAtBirth();
		if (this.getExternalID() != "")
			info['externalID'] = this.getExternalID();
		if (this.getBirthDate() != null)
			info['dob'] = this.getBirthDate().getSimpleObject();
		if (this.getAdopted() != "")
			info['adoptedStatus'] = this.getAdopted();
		if (this.getLifeStatus() != 'Alive')
			info['lifeStatus'] = this.getLifeStatus();
		if (this.getDeathDate() != null)
			info['dod'] = this.getDeathDate().getSimpleObject();


		if (this.getAgeOfDeath() != "")
			info['ageOfDeath'] = this.getAgeOfDeath();

		if (this.getAgeOfDeathFormat() != "")
			info['ageOfDeathFormat'] = this.getAgeOfDeathFormat();


		if (this.getGestationAgeWeeks() != null) {
			info['gestationAgeWeeks'] = this.getGestationAgeWeeks();
		}
		if (this.getGestationAgeDays() != null) {
			info['gestationAgeDays'] = this.getGestationAgeDays();
		}

		if (this.getChildlessStatus() != null) {
			info['childlessStatus'] = this.getChildlessStatus();
			info['childlessReason'] = this.getChildlessReason();
		}
		if (this.getDisorders().length > 0)
			info['disorders'] = this.getDisordersForExport();

		if (this._disordersFullDetails.length > 0)
			info['disordersFullDetails'] = this._disordersFullDetails;


		if (!Helpers.isObjectEmpty(this.getCancers()))
			info['cancers'] = this.getCancers();
		if (this.getHPO().length > 0)
			info['hpoTerms'] = this.getHPOForExport();
		//Added for GEL(GenomicsEngland) ............................................................
		if (this._hpoFullDetails.length > 0)
			info['hpoTermsFullDetails'] = this._hpoFullDetails;
		//...........................................................................................

		if (this.getEthnicities() && this.getEthnicities().length > 0)
			info['ethnicities'] = this.getEthnicities();
		if (this.getGenes() && this.getGenes().length > 0)
			info['candidateGenes'] = this.getGenes();
		if (this._twinGroup !== null)
			info['twinGroup'] = this._twinGroup;
		if (this._monozygotic)
			info['monozygotic'] = this._monozygotic;
		if (this._evaluated)
			info['evaluated'] = this._evaluated;
		if (this._carrierStatus)
			info['carrierStatus'] = this._carrierStatus;
		if (this.getLostContact())
			info['lostContact'] = this.getLostContact();
		if (this.getPedNumber() != "")
			info['nodeNumber'] = this.getPedNumber();


    if (this._participatingInTest)
      info['participatingInTest'] = this._participatingInTest;

    if (this.getNonNgisPatientStableUid() != "")
      info['nonNgisPatientStableUid'] = this.getNonNgisPatientStableUid();

    if (this.getNgisRegisteredPatientUid() != "")
      info['ngisRegisteredPatientUid'] = this.getNgisRegisteredPatientUid();

    if (this.getOtherIdentifier() != "")
      info['otherIdentifier'] = this.getOtherIdentifier();

    if (this.getOtherIdentifierType() != "")
      info['otherIdentifierType'] = this.getOtherIdentifierType();

    if (this.getGestationAgeWeeks() != "")
      info['gestationAgeWeeks'] = this.getGestationAgeWeeks();
		if (this.getGestationAgeDays() != "")
			info['gestationAgeDays'] = this.getGestationAgeDays();

    if (this.getEstimatedDateOfDelivery() != "")
      info['estimatedDateOfDelivery'] = this.getEstimatedDateOfDelivery();

    if (this.getComments() != "")
      info['comments'] = this.getComments();

    if (this.getLastMenstralPeriod() != "")
      info['lastMenstralPeriod'] = this.getLastMenstralPeriod();

   /* if (this.getClinicalIndicationAgeOfOnset() != "")
      info['clinicalIndicationAgeOfOnset'] = this.getClinicalIndicationAgeOfOnset();
*/
    if (this.getNumberOfColorectalPolypsTotal() != "")
      info['numberOfColorectalPolypsTotal'] = this.getNumberOfColorectalPolypsTotal();

    if (this.getNumberOfColorectalPolypsAdenomas() != "")
      info['numberOfColorectalPolypsAdenomas'] = this.getNumberOfColorectalPolypsAdenomas();

	if (this.getClinicalIndicationAgeOfOnsetMonths() != "")
		info['clinicalIndicationAgeOfOnsetMonths'] = this.getClinicalIndicationAgeOfOnsetMonths();

	if (this.getClinicalIndicationAgeOfOnsetYears() != "")
		info['clinicalIndicationAgeOfOnsetYears'] = this.getClinicalIndicationAgeOfOnsetYears();

        return info;
	}




	,

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method assignProperties
	 * @param properties Object
	 * @return {Boolean} True if info was successfully assigned
	 */
	assignProperties: function ($super, info) {
		this._setDefault();

		if ($super(info)) {
		
			if (info.phenotipsId && this.getPhenotipsPatientId() != info.phenotipsId) {
				this.setPhenotipsPatientId(info.phenotipsId);
			}
			if (info.fName && this.getFirstName() != info.fName) {
				this.setFirstName(info.fName);
			}
			if (info.lName && this.getLastName() != info.lName) {
				this.setLastName(info.lName);
			}
			if (info.participantId && this.getParticipantId() != info.participantId) {
				this.setParticipantId(info.participantId);
			}
			if (info.registered && this.getRegistered() != info.registered) {
				this.setRegistered(info.registered);
			}
			if(info.NHSNumber && this.getNHSNumber() != info.NHSNumber) {
				this.setNHSNumber(info.NHSNumber);
			}
			if(info.gelSuperFamilyId && this.getGelSuperFamilyId() != info.gelSuperFamilyId) {
				this.setGelSuperFamilyId(info.gelSuperFamilyId);
			}
			if(info.familyId && this.getFamilyId() != info.familyId) {
				this.setFamilyId(info.familyId);
			}
			if(info.karyotypicSex && this.getKaryotypicSex() != info.karyotypicSex) {
				this.setKaryotypicSex(info.karyotypicSex);
			}
			if(info.consanguineousPopulation && this.getConsanguineousPopulation() != info.consanguineousPopulation) {
				this.setConsanguineousPopulation(info.consanguineousPopulation);
			}
			if(info.ancestries && this.getAncestries() != info.ancestries) {
				this.setAncestries(info.ancestries);
			}
			if(info.chiNumber && this.getChiNumber() != info.chiNumber) {
				this.setChiNumber(info.chiNumber);
			}
			if(info.organDonorId && this.getOrganDonorId() != info.organDonorId) {
				this.setOrganDonorId(info.organDonorId);
			}
			if(info.localIdentifier && this.getLocalIdentifier() != info.localIdentifier) {
				this.setLocalIdentifier(info.localIdentifier);
			}
			if (info.lNameAtB && this.getLastNameAtBirth() != info.lNameAtB) {
				this.setLastNameAtBirth(info.lNameAtB);
			}
			if (info.externalID && this.getExternalID() != info.externalID) {
				this.setExternalID(info.externalID);
			}
			if (info.dob && this.getBirthDate() != info.dob) {
				this.setBirthDate(info.dob);
			}
      
      if (info.ngisRegisteredPatientUid && this.getNgisRegisteredPatientUid() != info.ngisRegisteredPatientUid) {
        this.setNgisRegisteredPatientUid(info.ngisRegisteredPatientUid);
      }

      if (info.nonNgisPatientStableUid && this.getNonNgisPatientStableUid() != info.nonNgisPatientStableUid) {
        this.setNonNgisPatientStableUid(info.nonNgisPatientStableUid);
      }
      /* Generate nonNgisId if there is no NGIS ID or NHS number */
      if (! this.getNonNgisPatientStableUid() && ! this.getNgisRegisteredPatientId() && ! this.getNHSNumber()) {
        var nonNgisId = Math.random().toString(36).substr(2, 5);
        this.setNonNgisPatientStableUid(nonNgisId);
        info.nonNgisPatientStableUid = nonNgisId;
      }

      if (info.otherIdentifier && this.getOtherIdentifier() != info.otherIdentifier) {
        this.setOtherIdentifier(info.otherIdentifier);
      }
      if (info.otherIdentifierType && this.getOtherIdentifierType() != info.otherIdentifierType) {
        this.setOtherIdentifierType(info.otherIdentifierType);
      }
      if (info.hasOwnProperty("participatingInTest") && this._participatingInTest != info.participatingInTest) {
        this.setParticipatingInTest(info.participatingInTest);
      }
      if (info.participatingInTest && this.getParticipatingInTest() != info.participatingInTest) {
        this.setParticipatingInTest(info.participatingInTest);
			}
      if (info.gestationAgeWeeks && this.getGestationAgeWeeks() != info.gestationAgeWeeks) {
        this.setGestationAgeWeeks(info.gestationAgeWeeks);
			}
			if (info.gestationAgeDays && this.getGestationAgeDays() != info.gestationAgeDays) {
        this.setGestationAgeDays(info.gestationAgeDays);
      }
      if (info.estimatedDateOfDelivery && this.getEstimatedDateOfDelivery() != info.estimatedDateOfDelivery) {
        this.setEstimatedDateOfDelivery(info.estimatedDateOfDelivery);
      }
      if (info.comments && this.getComments() != info.comments) {
        this.setComments(info.comments);
      }
			/* info will be missing these two because it is set at higher level */
			var clinicalIndicationName = document.getElementById("clinical-indication-name").innerHTML.split("<span")[0];
			if(clinicalIndicationName && this.getClinicalIndicationName() != clinicalIndicationName) {
        this.setClinicalIndicationName(clinicalIndicationName);
      }
      if(info.clinicalIndicationCode && this.getClinicalIndicationCode() != info.clinicalIndicationCode) {
        this.setClinicalIndicationCode(info.clinicalIndicationCode);
      }

      if(info.numberOfColorectalPolypsAdenomas && this.getNumberOfColorectalPolypsAdenomas() != info.numberOfColorectalPolypsAdenomas) {
        this.setNumberOfColorectalPolypsAdenomas(info.numberOfColorectalPolypsAdenomas);
      }
      if(info.numberOfColorectalPolypsTotal && this.getNumberOfColorectalPolypsTotal() != info.numberOfColorectalPolypsTotal) {
        this.setNumberOfColorectalPolypsTotal(info.numberOfColorectalPolypsTotal);
      }

      if(info.diagnosisCertainty && this.getDiagnosisCertainty() != info.diagnosisCertainty) {
        this.setDiagnosisCertainty(info.diagnosisCertainty);
      }
      if(info.lastMenstralPeriod && this.getLastMenstralPeriod() != info.lastMenstralPeriod) {
        this.setLastMenstralPeriod(info.lastMenstralPeriod);
      }

      if(info.carrierStatus && this.getCarrierStatus() != info.carrierStatus) {
        this.setCarrierStatus(info.carrierStatus);
      }

      if(info.clinicalIndicationAgeOfOnsetYears && this.getClinicalIndicationAgeOfOnsetYears() != info.clinicalIndicationAgeOfOnsetYears) {
        this.setClinicalIndicationAgeOfOnsetYears(info.clinicalIndicationAgeOfOnsetYears);
      }

	if(info.clinicalIndicationAgeOfOnsetMonths && this.getClinicalIndicationAgeOfOnsetMonths() != info.clinicalIndicationAgeOfOnsetMonths) {
		this.setClinicalIndicationAgeOfOnsetMonths(info.clinicalIndicationAgeOfOnsetMonths);
	}


/*
	if(info.clinicalIndicationAgeOfOnset && this.getClinicalIndicationAgeOfOnset() != info.clinicalIndicationAgeOfOnset) {
		this.setClinicalIndicationAgeOfOnset(info.clinicalIndicationAgeOfOnset);
	}
*/



            //then load disorders
			if (info.disorders) {
				var disorders = [];
				//if we have disordersFullDetails, then complete the disorders objects based on that
				if (info.disordersFullDetails != undefined && info.disordersFullDetails.length > 0) {
					for (var i = 0; i < info.disordersFullDetails.length; i++) {
						//console.log("TTTTT",info.disordersFullDetails[i])
						var disorder = new Disorder(info.disordersFullDetails[i].disorderId,info.disordersFullDetails[i].name,info.disordersFullDetails[i].ageOfOnset, info.disordersFullDetails[i].diagnosisCertainty, info.disordersFullDetails[i].codeSystemUri,  info.disordersFullDetails[i].versionNumber, info.disordersFullDetails[i].disorderType,info.disordersFullDetails[i].valueAll);
						disorders.push(disorder);
					}
					this.setDisorders(disorders);
				}else{
					this.setDisorders(info.disorders);
				}
			}

			if (info.cancers) {
				console.log("cancers")
				this.setCancers(info.cancers);
			}

			if (info.hpoTermsFullDetails) {
				this._hpoTermsFullDetails = info.hpoTermsFullDetails.slice();

				for(var i = 0;i<this._hpoTermsFullDetails.length;i++){
					if(!this._hpoTermsFullDetails[i].valueAll){
						this._hpoTermsFullDetails[i].valueAll = {};
					}
				}
			//}
			// TODO FIX THIS
			//if (info.hpoTerms) {

				var terms = [];
				//if we have hpoTermsFullDetails, then complete the hpoTerms objects based on that
				if (this._hpoTermsFullDetails != undefined && this._hpoTermsFullDetails.length > 0) {
					for (var i = 0; i < this._hpoTermsFullDetails.length; i++) {
                        var term = new HPOTerm(this._hpoTermsFullDetails[i].hpoId,this._hpoTermsFullDetails[i].name,this._hpoTermsFullDetails[i].hpoPresent, this._hpoTermsFullDetails[i].hpoModifiers,this._hpoTermsFullDetails[i].valueAll);
						terms.push(term);
					}
					this.setHPO(terms);
				}else{
					this.setHPO(info.hpoTerms);
				}
			}
			if (info.ethnicities) {
				this.setEthnicities(info.ethnicities);
			}
			if (info.candidateGenes) {
				this.setGenes(info.candidateGenes);
			}
			if (info.hasOwnProperty("adoptedStatus") && this.getAdopted() != info.adoptedStatus) {
				this.setAdopted(info.adoptedStatus);
			}
			if (info.hasOwnProperty("lifeStatus") && this.getLifeStatus() != info.lifeStatus) {
				this.setLifeStatus(info.lifeStatus);
			}
			if (info.dod && this.getDeathDate() != info.dod) {
				this.setDeathDate(info.dod);
			}

			if (info.ageOfDeath && this.getAgeOfDeath() != info.ageOfDeath) {
				this.setAgeOfDeath(info.ageOfDeath);
			}

			if (info.ageOfDeathFormat && this.getAgeOfDeathFormat() != info.ageOfDeathFormat) {
				this.setAgeOfDeathFormat(info.ageOfDeathFormat);
			}

			if (info.gestationAgeWeeks && this.getGestationAgeWeeks() != info.gestationAgeWeeks) {
				this.setGestationAgeWeeks(info.gestationAgeWeeks);
			}
			if (info.gestationAgeDays && this.getGestationAgeDays() != info.gestationAgeDays) {
				this.setGestationAgeDays(info.gestationAgeDays);
			}
			if (info.childlessStatus && this.getChildlessStatus() != info.childlessStatus) {
				this.setChildlessStatus(info.childlessStatus);
			}
			if (info.childlessReason && this.getChildlessReason() != info.childlessReason) {
				this.setChildlessReason(info.childlessReason);
			}
			if (info.hasOwnProperty("twinGroup") && this._twinGroup != info.twinGroup) {
				this.setTwinGroup(info.twinGroup);
			}
			if (info.hasOwnProperty("monozygotic") && this._monozygotic != info.monozygotic) {
				this.setMonozygotic(info.monozygotic);
			}
			if (info.hasOwnProperty("evaluated") && this._evaluated != info.evaluated) {
				this.setEvaluated(info.evaluated);
			}
			if (info.hasOwnProperty("carrierStatus") && this._carrierStatus != info.carrierStatus) {
				this.setCarrierStatus(info.carrierStatus);
			}
			if (info.hasOwnProperty("nodeNumber") && this.getPedNumber() != info.nodeNumber) {
				this.setPedNumber(info.nodeNumber);
			}
			if (info.hasOwnProperty("lostContact") && this.getLostContact() != info.lostContact) {
				this.setLostContact(info.lostContact);
			}
      if (info.hasOwnProperty("ngisRegisteredPatientUid") && this.getNgisRegisteredPatientUid() != info.ngisRegisteredPatientUid) {
        this.setNgisRegisteredPatientUid(info.ngisRegisteredPatientUid);
      }

      if (info.hasOwnProperty("lostContact") && this.getLostContact() != info.lostContact) {
        this.setLostContact(info.lostContact);
      }
			return true;
		}
		return false;
	}
});

//ATTACHES CHILDLESS BEHAVIOR METHODS TO THIS CLASS
Person.addMethods(ChildlessBehavior);

//Added for GEL(GenomicsEngland)
//we hold name of set methods for each property in this map, this will be used in "Person.assignValues" for assigning values into each property dynamically
Person.setMethods = {};

//Added for GEL(GenomicsEngland)
//This will be used to assign values into a node and dynamically update the UI. Mainly used for drag/drop and copying an unRendered node into a node in the UI
Person.copyUnassignedNode = function(person, unRenderedValueAll){

	var yesFunction = function(){
		var disorderLoaded = false;
		var hpoLoaded = false;

		//Although all unRendered nodes are registered in Mercury and it returns "registered=true" for all
		//of them, but we also set it to True, here
		unRenderedValueAll.registered = true;

		for (var property in unRenderedValueAll) {

			if (Object.prototype.hasOwnProperty.call(unRenderedValueAll, property)) {
				var value = unRenderedValueAll[property];
				var setMethod = Person.setMethods[property];
				if(!setMethod){
					console.log("Set method '"+ setMethod + "' for property '" + property +"' not specified in 'Person.setMethods'");
					continue;
				}

				//if property is Gender, then get it in the right format
				if(property == "sex" || property == "gender"){
					value = Person.FormatGender(value);
				}


				//Do not copy the following values from unAssigned node into the destination node
				var ignoreProperties = [
					"gelsuperfamilyid",
					"ancestries",
					"consanguineouspopulation",
					"comments",
					"childlessstatus",
					"childlessreason",
					"karyotypicsex"
				];
				if(ignoreProperties.indexOf(property.toLocaleLowerCase().trim()) > -1){
					continue;
				}

				//We need to follow a certain order to fill disorder and disorderFullDetails
				if((property == "disordersFullDetails" || property == "disorders")){

					if(disorderLoaded){
						continue;
					}

					if(!unRenderedValueAll.disordersFullDetails){
						//disordersFullDetails must have been included, otherwise we can not load disorders from "disorders" in unRendered Nodes disorders from 'disorders' in unRendered
						console.log("disordersFullDetails must have been included, otherwise we can not load Nodes");
						continue;
					}
					console.log("unrenderedva",unRenderedValueAll);
					console.log("dfd",unRenderedValueAll.disordersFullDetails);
					if(unRenderedValueAll.disordersFullDetails){
						var disorders = unRenderedValueAll.disordersFullDetails;
						var newDisorderArray = [];
						for(var i = 0; i < disorders.length; i++){
                            var disorder = new Disorder(disorders[i].disorderId, disorders[i].name,disorders[i].ageOfOnset, disorders[i].diagnosisCertainty, disorders[i].codeSystemUri, disorders[i].versionNumber,disorders[i].disorderType,disorders[i].valueAll);
							newDisorderArray.push(disorder);
						}
						var properties = {};
						properties["setDisorders"] = newDisorderArray;
						var event = { "nodeID": person.getID(), "properties": properties };
						document.fire("pedigree:node:setproperty", event);
					}

					disorderLoaded = true;
					continue;
				}

				//We need to follow a certain order to fill hpoTerms and hpoTermsFullDetails
				if((property == "hpoTerms" || property == "hpoTermsFullDetails")){

					if(hpoLoaded){
						continue;
					}

					if(!unRenderedValueAll.hpoTermsFullDetails){
						//hpoTermsFullDetails must have been included, otherwise we can not load HPO from "hpoTerms" in unRendered Nodes
						console.log("hpoTermsFullDetails must have been included, otherwise we can not load HPOs from 'hpoTerms' in unRendered Nodes");
						continue;
					}

					if(unRenderedValueAll.hpoTermsFullDetails){
						var HPOs = unRenderedValueAll.hpoTermsFullDetails;
						console.log("hpos",HPOs)
						var newHPOArray = [];
						for(var i = 0; i < HPOs.length; i++){
							var HPO = new HPOTerm(HPOs[i].hpoId, HPOs[i].name,HPOs[i].hpoPresent,HPOs[i].hpoModifiers, HPOs[i].valueAll);
							newHPOArray.push(HPO);
						}
						var properties = {};
						properties["setHPO"] = newHPOArray;
						var event = { "nodeID": person.getID(), "properties": properties };
						document.fire("pedigree:node:setproperty", event);
					}
					hpoLoaded = true;
					continue;
				}

				var properties = {};
				properties[setMethod] = value;
				var event = { "nodeID": person.getID(), "properties": properties };
				document.fire("pedigree:node:setproperty", event);
			}
		}
	};

	var closeFunction = function () {
		this.dialog.show();
	};

	//If target has a gender like "M","F","O" but the source gender is different from the target gender, then ask for confirmation
	var targetNodeGender = Person.FormatGender(person.getGender());
	var sourceNodeGender = Person.FormatGender(unRenderedValueAll.sex);
	var genderMessage = undefined;
	if(targetNodeGender === "M" && (sourceNodeGender === "F" || sourceNodeGender === "O" || sourceNodeGender === "unknown" )){
		genderMessage = "Gender in target node is 'Male' but in unassigned node it is '"+Person.getGenderString(sourceNodeGender)+"',<br> Are you sure you want to assign the values to this node?"
	}else if (targetNodeGender === "F" && (sourceNodeGender === "M" || sourceNodeGender === "O" || sourceNodeGender === "unknown" )){
		genderMessage = "Gender in target node is 'Female' but in unassigned node it is '"+Person.getGenderString(sourceNodeGender)+"',<br> Are you sure you want to assign the values to this node?"
	}else if (targetNodeGender === "O" && (sourceNodeGender === "M" || sourceNodeGender === "F" || sourceNodeGender === "unknown" )){
		genderMessage = "Gender in target node is 'Other' but in unassigned node it is '"+Person.getGenderString(sourceNodeGender)+"',<br> Are you sure you want to assign the values to this node?"
	}


	if(genderMessage){
		//get confirmation
		editor.getOkCancelDialogue().showCustomized(genderMessage,
			"Genomics England",
			"Yes", yesFunction,
			"No", closeFunction,
			null, true);
	}else{
		yesFunction();
	}

};

Person.FormatGender = function(genderString){
	if(genderString == null || genderString == undefined){
		return "unknown";
	}
	var genderString = genderString.toLowerCase();
	if (genderString == "female" || genderString == "f" || genderString == "2")
		return "F";
	if (genderString == "other" || genderString == "o"  || genderString == "9")
		return "O";
	else if (genderString == "male" || genderString == "m" || genderString == "1")
		return "M";
	else
		return "unknown";
};

Person.getGenderString = function(genderString){
	if(genderString == null || genderString == undefined){
		return "unknown";
	}
	var genderString = genderString.toLowerCase();

 	if (genderString == "female" || genderString == "f" || genderString == "2")
		return "Female";
	if (genderString == "other" || genderString == "o"  || genderString == "9")
		return "Other";
	else if (genderString == "male" || genderString == "m" || genderString == "1")
		return "Male";
	else
		return "Unknown";
};

/**
 * PersonGroupHoverbox is a class for all the UI elements and graphics surrounding a PersonGroup node and
 * its labels. This includes the box that appears around the node when it's hovered by a mouse.
 *
 * @class GroupHoverbox
 * @extends AbstractHoverbox
 * @constructor
 * @param {PersonGroup} node The node PersonGroup for which the hoverbox is drawn
 * @param {Number} centerX The x coordinate for the hoverbox
 * @param {Number} centerY The y coordinate for the hoverbox
 * @param {Raphael.st} nodeShapes Raphaël set containing the graphical elements that make up the node
 */
var PersonGroupHoverbox = Class.create(PersonHoverbox, {
	initialize: function ($super, personNode, centerX, centerY, nodeShapes) {
		var radius = PedigreeEditorParameters.attributes.radius * 2;
		$super(personNode, centerX, centerY, nodeShapes);
	},

	/**
	 * Creates the handles used in this hoverbox - overriden to generate no handles
	 *
	 * @method generateHandles
	 * @return {Raphael.st} A set of handles
	 */
	generateHandles: function ($super) {
		if (this._currentHandles !== null) return;

		if (PedigreeEditorParameters.attributes.newHandles) {
			// TODO: singling handle for person groups?
		}
		// else: no handles
	},

	/**
	 * Creates the buttons used in this hoverbox
	 *
	 * @method generateButtons
	 */
	generateButtons: function ($super) {
		if (this._currentButtons !== null) return;
		this._currentButtons = [];

		// note: no call to super as we don't want default person buttons
		this.generateMenuBtn();
		this.generateDeleteBtn();
	},

	/**
	 * Returns true if the menu for this node is open
	 *
	 * @method isMenuToggled
	 * @return {Boolean}
	 */
	isMenuToggled: function () {
		return this._isMenuToggled;
	},

	/**
	 * Shows/hides the menu for this node
	 *
	 * @method toggleMenu
	 */
	toggleMenu: function (isMenuToggled) {
		if (this._justClosedMenu) return;
		this._isMenuToggled = isMenuToggled;
		if (isMenuToggled) {
			this.getNode().getGraphics().unmark();
			var optBBox = this.getBoxOnHover().getBBox();
			var x = optBBox.x2;
			var y = optBBox.y;
			var position = editor.getWorkspace().canvasToDiv(x + 5, y);
			editor.getNodeGroupMenu().show(this.getNode(), position.x, position.y);
		}
	}
});
/**
 * Class for organizing graphics for PersonGroup nodes.
 *
 * @class PersonGroupVisuals
 * @constructor
 * @extends AbstractPersonVisuals
 * @param {PersonGroup} node The node for which this graphics are handled
 * @param {Number} x The x coordinate on the canvas
 * @param {Number} y The y coordinate on the canvas
 */
var PersonGroupVisuals = Class.create(PersonVisuals, {

	initialize: function ($super, node, x, y) {
		$super(node, x, y);
		this.setNumPersons(node.getNumPersons());
	},

	generateHoverbox: function (x, y) {
		if (editor.isReadOnlyMode()) {
			return new ReadOnlyHoverbox(this.getNode(), x, y, this.getGenderGraphics());
		} else {
			return new PersonGroupHoverbox(this.getNode(), x, y, this.getGenderGraphics());
		}
	},

	/**
	 * Returns all the graphics associated with this PersonGroup
	 *
	 * @method getAllGraphics
	 * @param [$super]
	 * @return {Raphael.st} Raphael set containing graphics elements
	 */
	getAllGraphics: function ($super) {
		return $super().push(this._label);
	},

	/**
	 * Changes the label for the number of people in this group
	 *
	 * @method setNumPersons
	 * @param {Number} numPersons The number of people in this group
	 */
	setNumPersons: function (numPersons) {
		this._label && this._label.remove();
		var text = (numPersons && numPersons > 1) ? String(numPersons) : "n";
		var y = (this.getNode().getLifeStatus() == 'Aborted' || this.getNode().getLifeStatus() == 'Miscarriage') ? this.getY() - 12 : this.getY();
		var x = (this.getNode().getLifeStatus() == 'Aborted') ? this.getX() + 8 : this.getX();
		this._label = editor.getPaper().text(x, y, text).attr(PedigreeEditorParameters.attributes.descendantGroupLabel);
		this._label.node.setAttribute("class", "no-mouse-interaction");
	}
});
/**
 * PersonGroup is node that represents a grouping of an unknown number of nodes ("n"). This type of
 * node is usually used to indicate the existence of relatives without providing any other information.
 * Therefore the options for this node are limited.
 *
 * @class PersonGroup
 * @constructor
 * @extends AbstractPerson
 * @param {Number} x The x coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {Number} y The y coordinate on the Raphael canvas at which the node drawing will be centered
 * @param {String} gender Either 'M', 'F' or 'U' depending on the gender
 * @param {Number} id Unique ID number
 */
var PersonGroup = Class.create(Person, {

	initialize: function ($super, x, y, id, properties) {
		this._numPersons = 1;
		this._comment = "";
		this._type = "PersonGroup";
		$super(x, y, id, properties);
		// already done as the last step in super():
		// this.assignProperties(properties);
	},

	/**
	 * Initializes the object responsible for creating graphics for this PersonGroup
	 *
	 * @method _generateGraphics
	 * @param {Number} x The x coordinate of hte PersonGroup Node
	 * @param {Number} y The y coordinate of hte PersonGroup Node
	 * @return {PersonGroupVisuals}
	 */
	_generateGraphics: function (x, y) {
		return new PersonGroupVisuals(this, x, y);
	},

	/**
	 * Always returns False - needed for compatibility with personHowerBox which uses this
	 *
	 * @method isProband
	 */
	isProband: function () {
		return false;
	},

	/**
	 * Changes the number of people who are in this PersonGroup
	 *
	 * @method setNumPersons
	 * @param {Number} numPersons The number of people in this grouping
	 */
	setNumPersons: function (numPersons) {
		this._numPersons = numPersons;
		this.getGraphics().setNumPersons(numPersons);
	},

	/**
	 * Returns the number of people who are in this PersonGroup
	 *
	 * @method getNumPersons
	 * @return {Number}
	 */
	getNumPersons: function () {
		return this._numPersons;
	},

	/**
	 * Changes the life status of this Person to newStatus
	 *
	 * @method setLifeStatus
	 * @param {String} newStatus "alive", "deceased", "stillborn", "unborn", "aborted" or "miscarriage"
	 */
	setLifeStatus: function ($super, newStatus) {
		$super(newStatus);
		this.getGraphics().setNumPersons(this._numPersons); // force-redraw of the "N" symbol on top of the new shape
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 {
	   property: value
	 }
	 */
	getProperties: function ($super) {
		var info = $super();
		info['numPersons'] = this.getNumPersons();
		return info;
	},

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method loadProperties
	 * @param properties Object
	 * @return {Boolean} True if info was successfully assigned
	 */
	assignProperties: function ($super, info) {
		if ($super(info) && info.numPersons) {
			if (this.getNumPersons() != info.numPersons) {
				this.setNumPersons(info.numPersons);
			}
			return true;
		}
		return false;
	},

	/**
	 * Returns an object (to be accepted by the menu) with information about this Person
	 *
	 * @method getSummary
	 * @return {Object} Summary object for the menu
	 */
	getSummary: function () {
		var disorders = [];
		this.getDisorders().forEach(function (disorder) {
			var disorderName = editor.getDisorderLegend().getDisorder(disorder).getName();
			disorders.push({id: disorder, value: disorderName});
		});

		var cantChangeAdopted = this.isFetus() || editor.getGraph().hasToBeAdopted(this.getID());

		return {
			identifier: {value: this.getID()},
			comment: {value: this.getFirstName()},
			gender: {value: this.getGender()},
			external_ids: {value: this.getExternalID()},
			disorders: {value: disorders},
			disordersFullDetails:     {value : this._disordersFullDetails},
			disorderType:  {value : this.getDisorderType()},
			ethnicity: {value: this.getEthnicities()},
			adopted: {value: this.getAdopted(), inactive: cantChangeAdopted},
			comments: {value: this.getComments(), inactive: false},
			state: {value: this.getLifeStatus()},
			numInGroup: {value: this.getNumPersons()},
			evaluatedGrp: {value: this.getEvaluated() }
		};
	}
});
/**
 * Class for organizing graphics for PersonPlaceholder nodes.
 *
 * @class PersonPlaceholderVisuals
 */

var PersonPlaceholderVisuals = Class.create(PersonVisuals, {
	initialize: function ($super, node, x, y) {
		$super(node, x, y);
	},

	generateHoverbox: function (x, y) {
		return new ReadOnlyHoverbox(this.getNode(), x, y, this.getGenderGraphics());
		//if (editor.isReadOnlyMode()) {
		//    return new ReadOnlyHoverbox(this.getNode(), x, y, this.getGenderGraphics());
		//} else {
		//    return new PersonPlaceholderHoverbox(this.getNode(), x, y, this.getGenderGraphics());
		//}
	},

	markPermanently: function () {
	},

	grow: function () {
	},

	setGenderGraphics: function () {
		this._genderGraphics && this._genderGraphics.remove();
		var x = this.getX();
		var y = this.getY();
		var radius = 10;
		var shape = editor.getPaper().rect(x - radius, y - radius, radius * 2, radius * 2).hide();
		this._genderShape = shape;
		this._genderGraphics = editor.getPaper().set(shape);
	},

	/**
	 * Overridden to make sure some runaway label does not appear for a placeholder
	 * (E.g. when father's name is propagated)
	 */
	drawLabels: function () {
		var labels = this.getLabels();
		for (var i = 0; i < labels.length; i++) {
			labels[i].hide();
		}
	}
});
/**
 * Personplaceholder represents a non-existing or unknown person
 *
 * @class PersonPlaceholder
 * @constructor
 * @extends AbstractPerson
 */
var PersonPlaceholder = Class.create(Person, {

	initialize: function ($super, x, y, id, properties) {
		this._comment = "";
		this._type = "PersonPlaceholder";
		$super(x, y, id, {"gender": "U"});
	},

	/**
	 * Initializes the object responsible for creating graphics for this PersonGroup
	 *
	 * @method _generateGraphics
	 * @param {Number} x The x coordinate of hte PersonGroup Node
	 * @param {Number} y The y coordinate of hte PersonGroup Node
	 * @return {PersonGroupVisuals}
	 */
	_generateGraphics: function (x, y) {
		return new PersonPlaceholderVisuals(this, x, y);
	},

	/**
	 * Always returns False - proband is never a placehodler
	 *
	 * @method isProband
	 */
	isProband: function () {
		return false;
	},

	/**
	 * Returns an object containing all the properties of this node
	 * except id, x, y & type
	 *
	 * @method getProperties
	 * @return {Object} in the form
	 *
	 {
	   property: value
	 }
	 */
	getProperties: function ($super) {
		//var info = $super();
		var info = {};
		if (this.getComments() != "")
			info['comments'] = this.getComments();
		info['placeholder'] = true;
		return info;
	},

	/**
	 * Applies the properties found in info to this node.
	 *
	 * @method loadProperties
	 * @param properties Object
	 * @return {Boolean} True if info was successfully assigned
	 */
	assignProperties: function ($super, info) {
		return $super(info)
	},

	/**
	 * Returns an object (to be accepted by the menu) with information about this Node
	 *
	 * @method getSummary
	 * @return {Object} Summary object for the menu
	 */
	getSummary: function () {

		return {
			type: {value: "placeholder"}
		};
	}
});
/**
 * View is responsible for graphical representation of th epedigree as well as user interaction
 *
 * @class View
 * @constructor
 */
var View = Class.create({

	initialize: function () {
		console.log("--- view init ---");

		this.preGenerateGraphics();

		this._nodeMap = {};    // {nodeID} : {AbstractNode}

		this.hoverModeZones = editor.getPaper().set();

		this._currentMarkedNew = [];
		this._currentGrownNodes = [];
		this._currentHoveredNode = null;
		this._currentDraggable = null;

		this._lineSet = new LineSet();   // used to track intersecting lines
	},

	/**
	 * Saves all pedigree-specific settings/user choices/color scheme into an object
	 */
	getSettings: function () {
		// TODO: filter out items which are currently not being displayed on the pedigree
		return {"colors": {"disorders": editor.getDisorderLegend().getAllColors(),
			"genes": editor.getGeneLegend().getAllColors(),
			"cancers": editor.getCancerLegend().getAllColors() },
			"names": {"disorders": editor.getDisorderLegend().getAllNames() } };
	},

	/**
	 * Restores pedigree-specific settings/user choices/color scheme from an object
	 */
	loadSettings: function (settingsObject) {
		if (settingsObject.hasOwnProperty("colors")) {
			if (settingsObject.colors.hasOwnProperty("disorders")) {
				editor.getDisorderLegend().setAllPreferredColors(settingsObject.colors.disorders);
			}
			if (settingsObject.colors.hasOwnProperty("genes")) {
				editor.getGeneLegend().setAllPreferredColors(settingsObject.colors.genes);
			}
		}
	},

	/**
	 * Pre-generates paths and pre-computes bounding boxes for shapes which are commonly used in the graph.
	 * Raphael is slow and re-computing each path/box for every node is noticeably slow
	 *
	 * @method preGenerateGraphics
	 */
	preGenerateGraphics: function () {
		//
		// computing scaled icons:
		//   var iconScale = 0.6;
		//   var path = "...";
		//   console.log("scaled path: " + Raphael.transformPath(path, ["s", iconScale, iconScale, 0, 0]));
		//

		// 1) menu button
		// nonScaledPath = "M2.021,9.748L2.021,9.748V9.746V9.748zM2.022,9.746l5.771,5.773l-5.772,5.771l2.122,2.123l7.894-7.895L4.143,7.623L2.022,9.746zM12.248,23.269h14.419V20.27H12.248V23.269zM16.583,17.019h10.084V14.02H16.583V17.019zM12.248,7.769v3.001h14.419V7.769H12.248z";
		this.__menuButton_svgPath = "M1.213,5.849C1.213,5.849,1.213,5.849,1.213,5.849C1.213,5.849,1.213,5.848,1.213,5.848C1.213,5.848,1.213,5.849,1.213,5.849C1.213,5.849,1.213,5.849,1.213,5.849M1.213,5.848C1.213,5.848,4.676,9.3114,4.676,9.3114C4.676,9.3114,1.2126,12.774,1.2126,12.774C1.2126,12.774,2.486,14.048,2.486,14.048C2.486,14.048,7.222,9.311,7.222,9.311C7.222,9.311,2.486,4.574,2.486,4.574C2.486,4.574,1.213,5.848,1.213,5.8476C1.2131999999999998,5.8476,1.2131999999999998,5.8476,1.2131999999999998,5.8476M7.348799999999999,13.9614C7.348799999999999,13.9614,16.0002,13.9614,16.0002,13.9614C16.0002,13.9614,16.0002,12.161999999999999,16.0002,12.161999999999999C16.0002,12.161999999999999,7.348799999999999,12.161999999999999,7.348799999999999,12.161999999999999C7.348799999999999,12.161999999999999,7.348799999999999,13.9614,7.348799999999999,13.9614C7.348799999999999,13.9614,7.348799999999999,13.9614,7.348799999999999,13.9614M9.949799999999998,10.2114C9.949799999999998,10.2114,16.0002,10.2114,16.0002,10.2114C16.0002,10.2114,16.0002,8.411999999999999,16.0002,8.411999999999999C16.0002,8.411999999999999,9.949799999999998,8.411999999999999,9.949799999999998,8.411999999999999C9.949799999999998,8.411999999999999,9.949799999999998,10.2114,9.949799999999998,10.2114C9.949799999999998,10.2114,9.949799999999998,10.2114,9.949799999999998,10.2114M7.348799999999999,4.6613999999999995C7.348799999999999,4.6613999999999995,7.348799999999999,6.462,7.348799999999999,6.462C7.348799999999999,6.462,16.0002,6.462,16.0002,6.462C16.0002,6.462,16.0002,4.661,16.0,4.6614C16.0,4.6614,7.349,4.6614,7.349,4.6614C7.349,4.6614,7.349,4.6614,7.349,4.6614";
		this.__menuButton_BBox = Raphael.pathBBox(this.__menuButton_svgPath);

		// 2) delete button
		// nonScaledPath = var path = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z";
		this.__deleteButton_svgPath = "M14.867,12.851C14.867,12.851,11.566,9.55,11.566,9.55C11.566,9.55,14.866,6.249,14.866,6.249C14.866,6.249,13.169,4.551,13.169,4.551C13.169,4.551,9.868,7.852,9.868,7.852C9.868,7.852,6.567,4.551,6.567,4.551C6.567,4.551,4.87,6.249,4.87,6.249C4.87,6.249,8.171,9.55,8.171,9.55C8.171,9.55,4.87,12.851,4.870,12.851C4.870,12.851,6.568,14.549,6.568,14.549C6.568,14.549,9.868,11.248,9.868,11.248C9.868,11.248,13.169,14.549,13.169,14.549C13.169,14.549,14.867,12.851,14.867,12.851";
		this.__deleteButton_BBox = Raphael.pathBBox(this.__deleteButton_svgPath);

		// 3) twins button
		//this.__twinsButton_svgPath = "M0,15L8,0L16,15";
		//this.__twinsButton_BBox    = Raphael.pathBBox(this.__twinsButton_svgPath);

		// 4) proband arrow
		//this.__arrow_svgPath = "M7.589,20.935l-6.87,6.869l2.476,2.476l6.869-6.869l1.858,1.857l2.258-8.428l-8.428,2.258L7.589,20.935z";
		this.__arrow_svgPath = "M8.348,23.029C8.348,23.029,0.791,30.584,0.791,30.584C0.791,30.584,3.515,33.308,3.515,33.308C3.515,33.308,11.07,25.752,11.0704,25.752C11.07,25.752,13.114,27.795,13.114,27.795C13.114,27.795,15.598,18.524,15.598,18.524C15.598,18.524,6.327,21.008,6.327,21.008C6.327,21.008,8.348,23.029,8.348,23.0285C8.348,23.029,8.348,23.029,8.348,23.029";
		this.__probandArrowPath = Raphael.transformPath(this.__arrow_svgPath, ["s", 1.1, 1.1, 0, 0]);
	},

	/**
	 * Returns a map of node IDs to nodes
	 *
	 * @method getNodeMap
	 * @return {Object}
	 *
	 {
		{nodeID} : {AbstractNode}
	 }
	 */
	getNodeMap: function () {
		return this._nodeMap;
	},

	/**
	 * Returns a node with the given node ID
	 *
	 * @method getNode
	 * @param {nodeId} id of the node to be returned
	 * @return {AbstractNode}
	 *
	 */
	getNode: function (nodeId) {
		if (!this._nodeMap.hasOwnProperty(nodeId)) {
			console.log("ERROR: requesting non-existent node " + nodeId);
			throw "ERROR";
			return null;
		}
		return this._nodeMap[nodeId];
	},

	checkNodeExists : function(nodeId){
        var exists = this._nodeMap.hasOwnProperty(nodeId);

        return exists;
	},

	/**
	 * Returns the person node containing x and y coordinates, or null if outside all person nodes
	 *
	 * @method getPersonNodeNear
	 * @return {Object} or null
	 */
	getPersonNodeNear: function (x, y) {
		for (var nodeID in this._nodeMap) {
			if (this._nodeMap.hasOwnProperty(nodeID)) {
				var node = this.getNode(nodeID);
				if ((node.getType() == "Person" || node.getType() == "PersonGroup") && node.getGraphics().containsXY(x, y))
					return node;
			}
		}
		return null;
	},

	/**
	 * Redraws the pedigree image in anoimized/non-anonimized way
	 */
	setAnonimizeStatus: function (status) {
		for (var nodeID in this._nodeMap) {
			if (this._nodeMap.hasOwnProperty(nodeID)) {
				var node = this.getNode(nodeID);
				node.getGraphics().setAnonimizedStatus(status);
			}
		}
	},

	/**
	 * Returns the node that is currently selected
	 *
	 * @method getCurrentHoveredNode
	 * @return {AbstractNode}
	 */
	getCurrentHoveredNode: function () {
		return this._currentHoveredNode;
	},

	/**
	 * Returns the currently dragged element
	 *
	 * @method getCurrentDraggable
	 * @return Either a handle from a hoverbox, or a PlaceHolder
	 */
	getCurrentDraggable: function () {
		return this._currentDraggable;
	},

	/**
	 * Returns the Object that is currently being dragged
	 *
	 * @method setCurrentDraggable
	 * @param draggable A handle or a PlaceHolder
	 */
	setCurrentDraggable: function (draggable) {
		this._currentDraggable = draggable;
	},

	/**
	 * Removes given node from node index (Does not delete the node visuals).
	 *
	 * @method removeFromNodeMap
	 * @param {nodeId} id of the node to be removed
	 */
	removeFromNodeMap: function (nodeID) {
		delete this.getNodeMap()[nodeID];
	},

	/**
	 * Creates a new set of raphael objects representing a curve from (xFrom, yFrom) trough (...,yTop) to (xTo, yTo).
	 * The bend from (xTo,yTo) to vertical level yTop will happen "lastBend" pixels from xTo.
	 * In case the flat part intersects any existing known lines a special crossing is drawn and added to the set.
	 *
	 * @method drawCurvedLineWithCrossings
	 */
	drawCurvedLineWithCrossings: function (id, xFrom, yFrom, yTop, xTo, yTo, lastBend, attr, twoLines, secondLineBelow, startSameX) {
		//console.log("yFrom: " + yFrom + ", yTo: " + yTo + ", yTop: " + yTop);

		if (yFrom == yTop && yFrom == yTo) {
			return this.drawLineWithCrossings(id, xFrom, yFrom, xTo, yTo, attr, twoLines, secondLineBelow, false, startSameX);
		}

		var cornerRadius = PedigreeEditorParameters.attributes.curvedLinesCornerRadius * 0.8;
		var goesRight = ( xFrom > xTo );
		if (isFinite(lastBend)) {
			var xFinalBend = goesRight ? xTo + lastBend : xTo - lastBend;
			var xFinalBendVert = goesRight ? xTo + lastBend + cornerRadius : xTo - lastBend - cornerRadius;
			var xBeforeFinalBend = goesRight ? xTo + lastBend + cornerRadius * 2 : xTo - lastBend - cornerRadius * 2;
		} else {
			var xBeforeFinalBend = xTo;
		}
		var xFromAndBit = goesRight ? xFrom - cornerRadius / 2 : xFrom + cornerRadius / 2;
		var xFromAfterCorner = goesRight ? xFromAndBit - cornerRadius : xFromAndBit + cornerRadius;
		var xFromAfter2Corners = goesRight ? xFromAndBit - 2 * cornerRadius : xFromAndBit + 2 * cornerRadius;

		//console.log("XFinalBend: " + xFinalBend + ", xTo : " + xTo);

		if (yFrom <= yTop) {
			this.drawLineWithCrossings(id, xFrom, yFrom, xBeforeFinalBend, yFrom, attr, twoLines, !goesRight, true, startSameX);
		}
		else {
			this.drawLineWithCrossings(id, xFrom, yFrom, xFromAndBit, yFrom, attr, twoLines, !goesRight, true, startSameX);

			if (Math.abs(yFrom - yTop) >= cornerRadius * 2) {
				if (goesRight)
					GraphicHelpers.drawCornerCurve(xFromAndBit, yFrom, xFromAfterCorner, yFrom - cornerRadius, true, attr, twoLines, -2.5, 2.5, 2.5, -2.5);
				else
					GraphicHelpers.drawCornerCurve(xFromAndBit, yFrom, xFromAfterCorner, yFrom - cornerRadius, true, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
				this.drawLineWithCrossings(id, xFromAfterCorner, yFrom - cornerRadius, xFromAfterCorner, yTop + cornerRadius, attr, twoLines, goesRight);
				if (goesRight)
					GraphicHelpers.drawCornerCurve(xFromAfterCorner, yTop + cornerRadius, xFromAfter2Corners, yTop, false, attr, twoLines, -2.5, 2.5, 2.5, -2.5);
				else
					GraphicHelpers.drawCornerCurve(xFromAfterCorner, yTop + cornerRadius, xFromAfter2Corners, yTop, false, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
			} else {
				// draw one continuous curve
				if (goesRight)
					GraphicHelpers.drawLevelChangeCurve(xFromAndBit, yFrom, xFromAfter2Corners, yTop, attr, twoLines, -2.5, 2.5, 2.5, -2.5);
				else
					GraphicHelpers.drawLevelChangeCurve(xFromAndBit, yFrom, xFromAfter2Corners, yTop, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
			}
			this.drawLineWithCrossings(id, xFromAfter2Corners, yTop, xBeforeFinalBend, yTop, attr, twoLines, !goesRight, true);
		}

		if (xBeforeFinalBend != xTo) {
			// curve down to yTo level
			if (Math.abs(yTo - yTop) >= cornerRadius * 2) {
				// draw corner
				if (goesRight)
					GraphicHelpers.drawCornerCurve(xBeforeFinalBend, yTop, xFinalBendVert, yTop + cornerRadius, true, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
				else
					GraphicHelpers.drawCornerCurve(xBeforeFinalBend, yTop, xFinalBendVert, yTop + cornerRadius, true, attr, twoLines, 2.5, -2.5, -2.5, 2.5);
				this.drawLineWithCrossings(id, xFinalBendVert, yTop + cornerRadius, xFinalBendVert, yTo - cornerRadius, attr, twoLines, !goesRight);
				if (goesRight)
					GraphicHelpers.drawCornerCurve(xFinalBendVert, yTo - cornerRadius, xFinalBend, yTo, false, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
				else
					GraphicHelpers.drawCornerCurve(xFinalBendVert, yTo - cornerRadius, xFinalBend, yTo, false, attr, twoLines, 2.5, -2.5, -2.5, 2.5);
			} else {
				// draw one continuous curve
				if (goesRight)
					GraphicHelpers.drawLevelChangeCurve(xBeforeFinalBend, yTop, xFinalBend, yTo, attr, twoLines, 2.5, 2.5, -2.5, -2.5);
				else
					GraphicHelpers.drawLevelChangeCurve(xBeforeFinalBend, yTop, xFinalBend, yTo, attr, twoLines, 2.5, -2.5, -2.5, 2.5);
			}
			this.drawLineWithCrossings(id, xFinalBend, yTo, xTo, yTo, attr, twoLines, !goesRight);
		}
	},

	/**
	 * Creates a new set of raphael objects representing a line segment from (x1,y1) to (x2,y2).
	 * In case this line segment intersects any existing known segments a special crossing is drawn and added to the set.
	 *
	 * @method drawLineWithCrossings
	 */
	drawLineWithCrossings: function (owner, x1, y1, x2, y2, attr, twoLines, secondLineBelow, bothEndsGoDown, sameXStart) {

		// make sure line goes from the left to the right (and if vertical from the top to the bottom):
		// this simplifies drawing the line piece by piece from intersection to intersection
		if (x1 > x2 || ((x1 == x2) && (y1 > y2))) {
			var tx = x1;
			var ty = y1;
			x1 = x2;
			y1 = y2;
			x2 = tx;
			y2 = ty;
		}

		var isHorizontal = (y1 == y2);
		var isVertical = (x1 == x2);

		var intersections = this._lineSet.addLine(owner, x1, y1, x2, y2);

		// sort intersections by distance form the start
		var compareDistanceToStart = function (p1, p2) {
			var dist1 = (x1 - p1.x) * (x1 - p1.x) + (y1 - p1.y) * (y1 - p1.y);
			var dist2 = (x1 - p2.x) * (x1 - p2.x) + (y1 - p2.y) * (y1 - p2.y);
			return dist1 - dist2;
		};
		intersections.sort(compareDistanceToStart);
		//console.log("intersection points: " + Helpers.stringifyObject(intersections));

		for (var lineNum = 0; lineNum < (twoLines ? 2 : 1); lineNum++) {

			// TODO: this is a bit hairy, just a quick hack to make two nice parallel curves
			//       for consang. relationships: simple raphael.transform() does not work well
			//       because then the curves around crossings wont be exactly above the crossing
			if (twoLines) {
				if (!bothEndsGoDown) {
					x1 += (sameXStart && !secondLineBelow) ? 0 : (-2.5 + lineNum * 7.5);
					x2 += (sameXStart && secondLineBelow) ? 0 : (-2.5 + lineNum * 7.5);
				} else {
					x1 -= (sameXStart && secondLineBelow) ? 0 : 2.5;
					x2 += (sameXStart && !secondLineBelow) ? 0 : 2.5;
				}

				if (secondLineBelow) {
					y1 += ( 2.5 - lineNum * 7.5);
					y2 += ( 2.5 - lineNum * 7.5);
				}
				else {
					y1 += (-2.5 + lineNum * 7.5);
					y2 += (-2.5 + lineNum * 7.5);
				}
			}

			var raphaelPath = "M " + x1 + " " + y1;
			for (var i = 0; i < intersections.length; i++) {
				var intersectPoint = intersections[i];

				var distance = function (p1, p2) {
					return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
				};

				var noCrossSymbolProximity = isHorizontal ? 20 * 20 : 9 * 9;

				if (distance(intersectPoint, {"x": x1, "y": y1}) < noCrossSymbolProximity)
					continue;
				if (distance(intersectPoint, {"x": x2, "y": y2}) < noCrossSymbolProximity)
					continue;

				if (isHorizontal) {
					if (twoLines) {
						if (secondLineBelow)
							intersectPoint.y += ( 2.5 - lineNum * 7.5);
						else
							intersectPoint.y += (-2.5 + lineNum * 7.5);
					}
					// a curve above the crossing
					raphaelPath += " L " + (intersectPoint.x - 10) + " " + intersectPoint.y;
					raphaelPath += " C " + (intersectPoint.x - 7) + " " + (intersectPoint.y + 1) +
						" " + (intersectPoint.x - 7) + " " + (intersectPoint.y - 7) +
						" " + (intersectPoint.x) + " " + (intersectPoint.y - 7);
					raphaelPath += " C " + (intersectPoint.x + 7) + " " + (intersectPoint.y - 7) +
						" " + (intersectPoint.x + 7) + " " + (intersectPoint.y + 1) +
						" " + (intersectPoint.x + 10) + " " + (intersectPoint.y);
				} else if (isVertical) {
					if (twoLines) {
						intersectPoint.x += ( -2.5 + lineNum * 7.5);
					}
					// a curve on the right around crossing
					raphaelPath += " L " + intersectPoint.x + " " + (intersectPoint.y - 10);
					raphaelPath += " C " + (intersectPoint.x - 1) + " " + (intersectPoint.y - 7) +
						" " + (intersectPoint.x + 7) + " " + (intersectPoint.y - 7) +
						" " + (intersectPoint.x + 7) + " " + (intersectPoint.y);
					raphaelPath += " C " + (intersectPoint.x + 7) + " " + (intersectPoint.y + 7) +
						" " + (intersectPoint.x - 1) + " " + (intersectPoint.y + 7) +
						" " + (intersectPoint.x) + " " + (intersectPoint.y + 10);
				}
				// else: some diagonal line: presumably there should be none, if there are some
				//       everything will be ok except there will be no special intersection graphic drawn
			}
			raphaelPath += " L " + x2 + " " + y2;
			editor.getPaper().path(raphaelPath).attr(attr).toBack();
		}
	},

	/**
	 * Creates a new node in the graph and returns it. The node type is obtained from
	 * editor.getGraph() and may be on of Person, Partnership or ... TODO. The position
	 * of the node is also obtained form editor.getGraph()
	 *
	 * @method addPerson
	 * @param {Number} [id] The id of the node
	 * @return {Person}
	 */
	addNode: function (id) {
		//console.log("add node");
		var positionedGraph = editor.getGraph();

		if (!positionedGraph.isValidID(id))
			throw "addNode(): Invalid id";

		var node;
		var properties = positionedGraph.getProperties(id);

		var graphPos = positionedGraph.getPosition(id);
		var position = editor.convertGraphCoordToCanvasCoord(graphPos.x, graphPos.y);

		if (positionedGraph.isRelationship(id)) {
			//console.log("-> add partnership");
			node = new Partnership(position.x, position.y, id, properties);
		}
		else if (positionedGraph.isPlaceholder(id)) {
			node = new PersonPlaceholder(position.x, position.y, id, properties);
		}
		else if (positionedGraph.isPersonGroup(id)) {
			//console.log("-> add person group");
			node = new PersonGroup(position.x, position.y, id, properties);
		}
		else if (positionedGraph.isPerson(id)) {
			//console.log("-> add person");
			node = new Person(position.x, position.y, id, properties);
		}
		else {
			throw "addNode(): unsupported node type";
		}

		this.getNodeMap()[id] = node;

		return node;
	},

	moveNode: function (id, animate) {
		var positionedGraph = editor.getGraph();
		var graphPos = positionedGraph.getPosition(id);
		var position = editor.convertGraphCoordToCanvasCoord(graphPos.x, graphPos.y);
		if (this.checkNodeExists(id)){
		    this.getNode(id).setPos(position.x, position.y, animate);
		}

	},

	changeNodeIds: function (changedIdsSet) {
		var newNodeMap = {};

		// change all IDs at once so that have both new and old references at the same time
		for (oldID in this._nodeMap) {
			var node = this.getNode(oldID);

			var newID = changedIdsSet.hasOwnProperty(oldID) ? changedIdsSet[oldID] : oldID;
			node.setID(newID);

			newNodeMap[newID] = node;
		}

		this._nodeMap = newNodeMap;

		this._lineSet.replaceIDs(changedIdsSet);

		editor.getCancerLegend().replaceIDs(changedIdsSet);
		editor.getGeneLegend().replaceIDs(changedIdsSet);
		editor.getHPOLegend().replaceIDs(changedIdsSet);
		editor.getDisorderLegend().replaceIDs(changedIdsSet);
	},

	/**
	 * Enters hover-mode state, which is when a handle or a PlaceHolder is being dragged around the screen
	 *
	 * @method enterHoverMode
	 * @param sourceNode The node whose handle is being dragged, or the placeholder that is being dragged
	 * @param hoverType Enum includes 'parent', 'child', 'partner' or 'sibling'. Only nodes which can be in the correponding
	 *                   relationship with sourceNode will be highlighted
	 * dragged on top of them.
	 */
	enterHoverMode: function (sourceNode, hoverType) {

		//var timer = new Helpers.Timer();

		var me = this;
		var validTargets = this.getValidDragTargets(sourceNode.getID(), hoverType);

		validTargets.each(function (nodeID) {
			me._currentGrownNodes.push(nodeID);

			var node = me.getNode(nodeID);
			node.getGraphics().grow();

			var hoverModeZone = node.getGraphics().getHoverBox().getHoverZoneMask().clone().toFront();
			//var hoverModeZone = node.getGraphics().getHoverBox().getHoverZoneMask().toFront();
			hoverModeZone.hover(
				function () {
					me._currentHoveredNode = nodeID;
					node.getGraphics().getHoverBox().setHighlighted(true);
				},
				function () {
					me._currentHoveredNode = null;
					node.getGraphics().getHoverBox().setHighlighted(false);
				});

			me.hoverModeZones.push(hoverModeZone);
		});

		//timer.printSinceLast("=== Enter hover mode - highlight: ");
	},

	/**
	 * Exits hover-mode state, which is when a handle or a PlaceHolder is being dragged around the screen
	 *
	 * @method exitHoverMode
	 */
	exitHoverMode: function () {
		this._currentHoveredNode = null;

		this.hoverModeZones.remove();

		var me = this;
		this._currentGrownNodes.each(function (nodeID) {
			var node = me.getNode(nodeID)
			node.getGraphics().shrink();
			node.getGraphics().getHoverBox().setHighlighted(false);
		});

		this._currentGrownNodes = [];
	},

	unmarkAll: function () {
		for (var i = 0; i < this._currentMarkedNew.length; i++) {
			var node = this.getNode(this._currentMarkedNew[i]);
			node.getGraphics().unmark();
		}
		this._currentMarkedNew = [];
	},

	getValidDragTargets: function (sourceNodeID, hoverType) {
		var result = [];
		switch (hoverType) {
			case "sibling":
				result = editor.getGraph().getPossibleSiblingsOf(sourceNodeID);
				break;
			case "child":
				// all person nodes which are not ancestors of sourse node and which do not already have parents
				result = editor.getGraph().getPossibleChildrenOf(sourceNodeID);
				break;
			case "parent":
				result = editor.getGraph().getPossibleParentsOf(sourceNodeID);
				break;
			case "partnerR":
			case "partnerL":
				// all person nodes of the other gender or unknown gender (who ar enot already partners)
				result = editor.getGraph().getPossiblePartnersOf(sourceNodeID)
				//console.log("possible partners: " + Helpers.stringifyObject(result));
				break;
			case "PlaceHolder":
				// all nodes which can be this placehodler: e.g. all that can be child of it's parents &&
				// partners of it's partners
				throw "TODO";
			default:
				throw "Incorrect hoverType";
		}
		return result;
	},

	applyChanges: function (changeSet, markNew) {
		// applies change set of the form {"new": {list of nodes}, "moved": {list of nodes} }
		//console.log("Change set: " + Helpers.stringifyObject(changeSet));
		if (Helpers.isObjectEmpty(changeSet)) return;

		var timer = new Helpers.Timer();
		var timer2 = new Helpers.Timer();

		//try {

			this.unmarkAll();

			// to simplify code which deals woith removed nodes making other mnodes to move
			if (!changeSet.hasOwnProperty("moved"))
				changeSet["moved"] = [];
			if (!changeSet.hasOwnProperty("removed"))
				changeSet["removed"] = [];
			if (!changeSet.hasOwnProperty("changedIDSet"))
				changeSet["changedIDSet"] = {};

			if (!changeSet.hasOwnProperty("new"))
                changeSet["new"] = [];

			// 0. remove all removed
			//
			// 1. move all person nodes
			// 2. create all new person nodes
			//
			// 3. move all existing relationships - as all lines are attached to relationships we want to draw
			//                                      them after all person nodes are already in correct position
			// 4. create new relationships

			if (changeSet.hasOwnProperty("removed")) {
				var affectedByLineRemoval = {};

				for (var i = 0; i < changeSet.removed.length; i++) {
					var nextRemoved = changeSet.removed[i];

					this.getNodeMap()[nextRemoved].remove();
					this.removeFromNodeMap(nextRemoved);

					var affected = this._lineSet.removeAllLinesAffectedByOwnerMovement(nextRemoved);

					for (var j = 0; j < affected.length; j++)
						if (!Helpers.arrayContains(changeSet.removed, affected[j])) { // ignore nodes which are removed anyway
							//console.log("adding due to line removal: " + affected[j]);
							affectedByLineRemoval[affected[j]] = true;
						}
				}

				// change all IDs at once so that have both new and old references at the same time
				this.changeNodeIds(changeSet.changedIDSet);

				//console.log("Affected by line removal: " + Helpers.stringifyObject(affectedByLineRemoval));
				//console.log("LineSet: " + Helpers.stringifyObject(this._lineSet));

				for (var node in affectedByLineRemoval) {
					if (affectedByLineRemoval.hasOwnProperty(node)) {
						var newID = changedIDs.hasOwnProperty(node) ? changedIDs[node] : node;
						if (!Helpers.arrayContains(changeSet.moved, newID)) {
							//console.log("moved due to line removal: oldID="+node + ", newID=" + newID);
							changeSet.moved.push(newID);
						}
					}
				}
			}

			timer.printSinceLast("=== Removal runtime: ");


			var movedPersons = [];
			var movedRelationships = [];
			var newPersons = [];
			var newRelationships = [];
			var animate = {};

			/*
			 // TODO: animations disabled because hoverboxes & labels behave strangely
			 if (changeSet.hasOwnProperty("animate")) {
			 for (var i = 0; i < changeSet.animate.length; i++) {
			 animate[changeSet.animate[i]] = true;
			 }
			 }*/

			//console.log("moved: " + Helpers.stringifyObject(changeSet.moved));

			if (changeSet.hasOwnProperty("moved")) {
				// remove all lines so that we start drawing anew
				for (var i = 0; i < changeSet.moved.length; i++) {
					var nextMoved = changeSet.moved[i];
					if (editor.getGraph().isRelationship(nextMoved)) {
						var affected = this._lineSet.removeAllLinesAffectedByOwnerMovement(nextMoved);
						for (var j = 0; j < affected.length; j++) {
							var node = affected[j];
							if (!Helpers.arrayContains(changeSet.moved, node))
								changeSet.moved.push(node);
						}
					}
				}

				// move actual nodes
				for (var i = 0; i < changeSet.moved.length; i++) {
					var nextMoved = changeSet.moved[i];
					if (editor.getGraph().isRelationship(nextMoved))
						movedRelationships.push(nextMoved);
					else
						movedPersons.push(nextMoved);
				}
			}
			console.log("moved: " + Helpers.stringifyObject(changeSet.moved));
			if (changeSet.hasOwnProperty("new")) {
				for (var i = 0; i < changeSet["new"].length; i++) {
					var nextNew = changeSet["new"][i];
					if (editor.getGraph().isRelationship(nextNew))
						newRelationships.push(nextNew);
					else
						newPersons.push(nextNew);
				}
			}

			timer.printSinceLast("=== Bookkeeping/sorting runtime: ");


			for (var i = 0; i < movedPersons.length; i++) {
				this.moveNode(movedPersons[i], animate.hasOwnProperty(movedPersons[i]));
			}

			timer.printSinceLast("=== Move persons runtime: ");

			for (var i = 0; i < newPersons.length; i++) {
				var newPerson = this.addNode(newPersons[i]);
				if (markNew) {
					newPerson.getGraphics().markPermanently();
					this._currentMarkedNew.push(newPersons[i]);
				}
			}

			timer.printSinceLast("=== New persons runtime: ");

			for (var i = 0; i < movedRelationships.length; i++)
				this.moveNode(movedRelationships[i]);

			timer.printSinceLast("=== Move rels runtime: ");

			for (var i = 0; i < newRelationships.length; i++)
				this.addNode(newRelationships[i]);

			timer.printSinceLast("=== New rels runtime: ");

			if (changeSet.hasOwnProperty("highlight")) {
				for (var i = 0; i < changeSet.highlight.length; i++) {
					var nextHighlight = changeSet.highlight[i];
					this.getNode(nextHighlight).getGraphics().markPermanently();
					this._currentMarkedNew.push(nextHighlight);
				}
			}

			//timer.printSinceLast("=== highlight: ");

			if (!editor.isReadOnlyMode()) {
				// re-evaluate which buttons & handles are appropriate for the nodes (e.g. twin button appears/disappears)
				for (var nodeID in this._nodeMap) {
					if (this._nodeMap.hasOwnProperty(nodeID)) {
						if (editor.getGraph().isPerson(nodeID) && !this.getNode(nodeID).getGraphics().getHoverBox().isMenuToggled()) {
							this.getNode(nodeID).getGraphics().getHoverBox().removeButtons();
							this.getNode(nodeID).getGraphics().getHoverBox().removeHandles();
						}
					}
				}

				var checkNumberingEvent = { "memo": { "check": true, "noUndoRedo": true } };
				editor.getController().handleRenumber(checkNumberingEvent);

				// TODO: move the viewport to make changeSet.makevisible nodes visible on screen
				timer.printSinceLast("=== highlight & update handles runtime: ");
			}

			timer2.printSinceLast("=== Total apply changes runtime: ");

		//} catch (err) {
		//	console.log("[view] update error: " + err);
		//}
	}
});

/**
 * SVGWrapper is a wrapper around textual representation of an SVG with methods to manipulate the SVG
 *
 * @class SVGWrapper
 * @constructor
 */


var SVGWrapper = Class.create({

	// needs to get bbox as an input as this needs an external compiutation by the browser
	initialize: function (svgText, boundingBox, scale) {
		this._svgText = svgText;
		this._bbox = {"x": boundingBox.x,
			"y": boundingBox.y,
			"height": boundingBox.height,
			"width": boundingBox.width};
		this._scale = scale ? scale : 1.0;
	},

	/**
	 * Returns the text string representing the SVG
	 *
	 * @method getSVGText
	 * @return {Object} Raphael Paper element
	 */
	getSVGText: function () {
		return this._svgText;
	},

	/**
	 * Returns the bounding box of the wrapped SVG
	 *
	 * @method getBBox
	 * @return {Object} {x,y, width, height}
	 */
	getBBox: function () {
		return Helpers.cloneObject(this._bbox);
	},

	getCopy: function () {
		return new SVGWrapper(this._svgText, this._bbox, this._scale);
	},

	setNoAspectRatioPreservation: function () {
		this._svgText = this._svgText.replace(/preserveAspectRatio="xMinYMin"/, "preserveAspectRatio=\"none\"");
		return this;
	},

	move: function (xShift, yShift) {
		this._bbox.x += xShift;
		this._bbox.y += yShift;
	},

	scale: function (scaleFactor) {
		this._scale = scaleFactor;

		this._bbox.width = Math.ceil(this._bbox.width * scaleFactor);
		this._bbox.height = Math.ceil(this._bbox.height * scaleFactor);

		this._svgText = this._svgText.replace(/(<svg [^<>]+) width=["-]?\d+"? height=["-]?\d+"?/g, "$1 width=\"" +
			(this._bbox.width) + "\" height=\"" + (this._bbox.height) + "\"");
		return this;
	},

	setViewBox: function (xOffset, yOffset, xWidth, yWidth) {
		xWidth = Math.ceil(xWidth);
		yWidth = Math.ceil(yWidth);
		this._svgText = this._svgText.replace(/(<svg[^<>]+) viewBox="[^<>"]*"/g,
				"$1 viewBox=\"" + Math.floor(this._bbox.x + xOffset / this._scale) + " " + Math.floor(this._bbox.y + yOffset / this._scale) + " " + xWidth / this._scale + " " + yWidth / this._scale + "\"");
		this._svgText = this._svgText.replace(/(<svg [^<>]+) width=["-]?\d+"? height=["-]?\d+"?/g, "$1 width=\"" +
			(xWidth) + "\" height=\"" + (yWidth) + "\"");
		return this;
	},

	addCenteringCSS: function () {
		this._svgText = this._svgText.replace(/(<svg [^<>]+) style="/, "$1 style=\"display:block; margin: auto; ");
		return this;
	}
});
/**
 * Workspace contains the Raphael canvas, the zoom/pan controls and the menu bar
 * on the top. The class includes functions for managing the Raphael paper object and coordinate transformation methods
 * for taking pan and zoom levels into account.
 *
 * @class Workspace
 * @constructor
 */

var PedigreeEditorTool = window.PedigreeEditorTool;
window.PedigreeEmbeddedWidth = 800;

function initializeEthnicitiesAndCreateEditor(){
	var webservice = new WebService();
	return new Ajax.Request(webservice.getEthnicityLookupPath(), {
		method: 'GET',
		headers: {
			"Authorization": PedigreeEditorTool.accessToken
		},
		requestHeaders: {
			Accept: "application/json",
			"Access-Control-Allow-Origin": "*",
			Authorization: PedigreeEditorTool.accessToken
		},
		contentType: "application/x-www-form-urlencoded",
		onSuccess: function (response) {
			//console.log("STARTAAA");
			console.log(response);
			//console.log(response.responseJSON);
			PedigreeEditorTool.ethnicityList = response.responseJSON;
			editor = new PedigreeEditor();
			var legendContainer = document.getElementById('legend-container');
			var canvasContainer = document.getElementById('work-area');
			var clinicalIndicationDiv = new Element("div",{'class':'clinical-indication-name', 'id':'clinical-indication-name'});
			clinicalIndicationDiv.innerHTML = "Clinical Indication Name";
			legendContainer.insertBefore(clinicalIndicationDiv, legendContainer.firstElementChild);
			var clinicalIndicationNames = document.getElementsByName("clinicalIndicationName");
			var clinicalIndicationValue = document.getElementById("clinical-indication-name").innerHTML;
			//IE11/Edge Issues : NodeList cannot be iterated upon.  
			if (clinicalIndicationNames && !clinicalIndicationNames.forEach){
				clinicalIndicationNames = [].slice.call(clinicalIndicationNames);
			}
			
			clinicalIndicationNames.forEach(function(clinicalIndicationName){
				clinicalIndicationName.value = clinicalIndicationValue;
			});

			var canvasSideBar = new Element("div",{'class':'canvas-sidebar-container', 'id':'canvas-sidebar-container'});
			canvasSideBar.innerHTML = '<div id="canvas-clinical-indication-name" class="sidebar-item">Clinical Indication Name</div>'
				+ '<div id="canvas-test-request-simple-id" class="sidebar-item"> Test Request Simple Id</div>'
			canvasContainer.insertBefore(canvasSideBar, canvasContainer.firstElementChild);

			document.getElementById(PedigreeEditorTool.divId).className = 'pedigree-tool skin-colibri wiki-xwiki space-data viewbody hidelefthideright panel-left-width-Medium panel-right-width-Medium';

			// Adjust parent node
			var parentNode = document.getElementById(PedigreeEditorTool.divId).parentNode;

			if (parentNode){
				//if (parentNode.className.includes('PedigreeTool') || parentNode.className.includes('pedigree-tool')){
					parentNode.style.maxWidth = '970px';
				//}
			}

			var srcs = ["/pedigree-ui/resources/font-awesome/css/font-awesome.min.css",
				"/pedigree-ui/css/style.min.css",
				"/pedigree-ui/css/colibri-ie-all.min.css"
			];

			console.log("CONSTANTS:",CONSTANTS)
			if(typeof(CONSTANTS) == "object" && CONSTANTS.PEDIGREE_TOOL_URL != "" && typeof(CONSTANTS.PEDIGREE_TOOL_URL) != "undefined") {
				//console.warn("in")
				srcs.forEach(function(src){
					// if (src != "font-awesome/css/font-awesome.min.css") {
						src = CONSTANTS.PEDIGREE_TOOL_URL + src;
					// }
					
					var isCssLinkAdded = Utils.checkIfCssExist(src);
					
					if (!isCssLinkAdded){
						
						console.log("adding stylesheet:" + src)
						if (document.createStyleSheet) {
							document.createStyleSheet(src);
						}
						else {
							var stylesheet = document.createElement('link');
							stylesheet.href = src;
							stylesheet.rel = 'stylesheet';
							stylesheet.type = 'text/css';
							document.getElementsByTagName('head')[0].appendChild(stylesheet);
						}
					}
					
					
				});
			}

		}, onFailure: function (response) {
			console.error("FAILURE", response);
		}
	});
}
function initializeEditor(accessToken, id, divId, referralId,currentPatientId,accessRefreshFunction, standalone, hostSaveFunc){
	var urlParams = new URLSearchParams(window.location.search);
	//var testRequestId = urlParams.get('testRequestId') !== null ? urlParams.get('testRequestId') : "";
	//userToken = urlParams.get('userToken');
	PedigreeEditorTool = {
		accessToken:accessToken,
		id:id,
		divId:divId,
		testRequestId:referralId ? referralId : $ESAPI.encoder().encodeForHTML(urlParams.get('testRequestId')),
		currentPatientId:currentPatientId,
		accessRefreshFunction:accessRefreshFunction,
		standalone:standalone,
		save : hostSaveFunc,
		isDirty : window.pedigreeStatus.isDirty
	}

	initializeEthnicitiesAndCreateEditor();

}

var Workspace = Class.create({

	initialize: function () {
		var me = this;
		this._settings = new Settings();
		this.canvas = new Element('div', {'id': 'canvas'});
		this.workArea = new Element('div', {'id': 'work-area'}).update(this.canvas);
		document.getElementById(PedigreeEditorTool.divId).update(this.workArea);
		var screenDimensions = document.viewport.getDimensions();
		//Added for GEL(GenomicsEngland) to have a reference to topMenu
		//this.generateTopMenu()
		this.topMenu = this.generateTopMenu();
		var offsets = Utils.getOffsetFromHost();
		this.width = PedigreeEditorTool.standalone ? screenDimensions.width : PedigreeEmbeddedWidth; //" screenDimensions.width;
		this.height = screenDimensions.height - this.canvas.cumulativeOffset().top - 4 ; //- offsets.y;

		this._paper = Raphael("canvas", this.width, this.height);
		this.viewBoxX = 0;
		this.viewBoxY = 0;
		this.zoomCoefficient = 1;
		this.disablePan = false;

		this.background = this.getPaper().rect(0, 0, this.width, this.height).attr({fill: 'blue', stroke: 'none', opacity: 0}).toBack();
		this.background.node.setAttribute("class", "panning-background");

		this.adjustSizeToScreen = this.adjustSizeToScreen.bind(this);
		Event.observe(window, 'resize', me.adjustSizeToScreen);
		this.generateViewControls();

		//Initialize pan by dragging
		var start = function () {
			me.background.ox = me.background.attr("x");
			me.background.oy = me.background.attr("y");
			if (editor.isAnyMenuVisible()) {
				me.disablePan = true;
				return;
			}
			//me.background.attr({cursor: 'url(https://mail.google.com/mail/images/2/closedhand.cur)'});
			me.background.attr({cursor: 'move'});
		};
		var move = function (dx, dy) {
			if (editor.isAnyMenuVisible() || me.disablePan) {
				me.disablePan = true;
				return;
			}
			var deltax = me.viewBoxX - dx / me.zoomCoefficient;
			var deltay = me.viewBoxY - dy / me.zoomCoefficient;

			me.getPaper().setViewBox(deltax, deltay, me.width / me.zoomCoefficient, me.height / me.zoomCoefficient);
			me.background.ox = deltax;
			me.background.oy = deltay;
			me.background.attr({x: deltax, y: deltay });
		};
		var end = function () {
			me.viewBoxX = me.background.ox;
			me.viewBoxY = me.background.oy;
			me.background.attr({cursor: 'default'});
			me.disablePan = false;
		};
		me.background.drag(move, start, end);

		if (document.addEventListener) {
			// adapted from from raphaelZPD
			me.handleMouseWheel = function (evt) {
				if (evt.preventDefault)
					evt.preventDefault();
				else
					evt.returnValue = false;

				// disable while menu is active - too easy to scroll and get the active node out of sight, which is confusing
				if (editor.isAnyMenuVisible()) {
					return;
				}

				var delta;
				if (evt.wheelDelta)
					delta = -evt.wheelDelta; // Chrome/Safari
				else
					delta = evt.detail; // Mozilla

				//console.log("Mouse wheel: " + delta);
				if (delta > 0) {
					var x = $$('.zoom-out')[0];
					$$('.zoom-out')[0].click();
				} else {
					$$('.zoom-in')[0].click();
				}
			}

			if (navigator.userAgent.toLowerCase().indexOf('webkit') >= 0) {
				this.canvas.addEventListener('mousewheel', me.handleMouseWheel, false); // Chrome/Safari
			} else {
				this.canvas.addEventListener('DOMMouseScroll', me.handleMouseWheel, false); // Others
			}
		}
	},

	/**
	 * Returns the SVGWrapper object containing a copy of pedigree SVG with all edit-related
	 *				  elements such as handles, invisible interactive layers, etc. removed.
	 *
	 * @method getSVGCopy
	 * @param {Boolean} anonimize - if true, all names and birthdays are removed.
	 * @return {Object} SVGWrapper object.
	 */
	getSVGCopy: function (anonimize) {
		editor.getView().unmarkAll();

		var image = $('canvas');

		var background = image.getElementsByClassName('panning-background')[0];
		background.style.display = "none";

		if (anonimize) {
			editor.getView().setAnonimizeStatus(true);
		}

		var _bbox = image.down().getBBox();
		var bbox = {};
		// Due to a bug (?) in firefox bounding box as reported by the browser may be a few pixels
		// too small and exclude lines at the very edge of the svg - so bbox is manually extended
		// by a few pixels in all directions.
		// Also, need to use _bbox and bbox bcause IE does not allow to modify the bbox obtained by getBBox()
		bbox.x = Math.floor(_bbox.x) - 2;
		bbox.y = Math.floor(_bbox.y) - 2;
		bbox.width = Math.ceil(_bbox.width) + 4;
		bbox.height = Math.ceil(_bbox.height) + 4;
		//console.log("BBOX: x:" + bbox.x + " y:" + bbox.y + " width: " + bbox.width + " height: " + bbox.height + "\n");


		var svgText = image.innerHTML.replace(/xmlns(:xlink)?=".*?"/g, '').replace(/width=".*?"/, '').replace(/height=".*?"/, '')
			.replace(/viewBox=".*?"/, "viewBox=\"" + bbox.x + " " + bbox.y + " " + bbox.width + " " + bbox.height + "\" width=\"" + (bbox.width) + "\" height=\"" + (bbox.height) +
				"\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\"");

		if (anonimize) {
			editor.getView().setAnonimizeStatus(false);
		}

		// set display:block
		svgText = svgText.replace(/(<svg[^<>]+style=")/g, "$1display:block; ");
		// remove invisible elements to slim down svg
		svgText = svgText.replace(/<[^<>]+display: ?none;[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove elements with opacity==0 to slim down svg
		svgText = svgText.replace(/<[^<>]+[" ]opacity: ?0;[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove partnership clickable circles
		svgText = svgText.replace(/<circle [^<>]+pedigree-partnership-circle[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove titles of the handles
		svgText = svgText.replace(/<a [^<>]*xlink:title=[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove hoverboxes
		svgText = svgText.replace(/<[^<>]+pedigree-hoverbox[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove node shadows
		svgText = svgText.replace(/<[^<>]+pedigree-node-shadow[^<>]+([^/]><\/\w+|\/)>/g, "");
		// remove gradient definitions (only used for handles),
		// or they confuse the browser after used and discarded for print preview
		svgText = svgText.replace(/<linearGradient.*<\/linearGradient>/g, "");
		svgText = svgText.replace(/<radialGradient.*?<\/radialGradient>/g, "");
		// remove "created by raphael", some older browsers may be confused
		svgText = svgText.replace(/<desc>[^<>]+<\/desc>/g, "");

		background.style.display = "";

		return new SVGWrapper(svgText, bbox, 1.0);
	},

	/**
	 * Returns the Raphael paper object.
	 *
	 * @method getPaper
	 * @return {Object} Raphael Paper element
	 */
	getPaper: function () {
		return this._paper;
	},

	/**
	 * Returns the div element containing everything except the top menu bar
	 *
	 * @method getWorkArea
	 * @return {HTMLElement}
	 */
	getWorkArea: function () {
		return this.workArea;
	},

	/**
	 * Returns width of the work area
	 *
	 * @method getWidth
	 * @return {Number}
	 */
	getWidth: function () {
		return this.width;
	},

	/**
	 * Returns height of the work area
	 *
	 * @method getHeight
	 * @return {Number}
	 */
	getHeight: function () {
		return this.height;
	},

	/**
	 * Creates the menu on the top
	 *
	 * @method generateTopMenu
	 */
	generateTopMenu: function () {
		var menu = new Element('div', {'class': 'editor-menu'});
		this.getWorkArea().insert({before: menu});

		var secondaryMenu = new Element('div', {'class': 'editor-menu editor-menu-secondary'});
		this.getWorkArea().insert({before: secondaryMenu});
		secondaryMenu.hide();

		var hideShowSubmenu = function (button, icon) {
			if (secondaryMenu.style.display == "none") {
				secondaryMenu.show();
				Element.removeClassName(icon, "fa-caret-down");
				Element.addClassName(icon, "fa-caret-up");
			} else {
				secondaryMenu.hide();
				Element.removeClassName(icon, "fa-caret-up");
				Element.addClassName(icon, "fa-caret-down");
			}
		}

		var menuItems = [];
		if (editor.isUnsupportedBrowser()) {
			menuItems = [
				{
					name: 'input',
					items: [
						{ key: 'readonlymessage', label: 'Unsuported browser mode', icon: 'exclamation-triangle'}
					]
				},
				{
					name: 'output',
					items: [
						{ key: 'export', label: 'Export', icon: 'download'},
						{ key: 'close', label: 'Close', icon: 'sign-out'}
					]
				}
			];
		} else {
			menuItems = [
				/*{
					name: 'input',
					items: [
						{ key: 'templates', label: 'Templates', icon: 'copy'},
						{ key: 'import', label: 'Import', icon: 'upload'}
					]
				},*/
				{
					name: 'edit',
					items: [
						{ key: 'undo', label: 'Undo', icon: 'undo'},
						{ key: 'redo', label: 'Redo', icon: 'repeat'},
						//{ key: 'layout', label: 'Automatic layout', icon: 'sitemap'},
						//{ key : 'number', label : 'Renumber', icon : 'sort-numeric-asc'}
						{ key: 'reset', label: 'Reset', icon: 'unlock'}
					]
				},
				{
					name: 'print',
					items: [
						{ key: 'print', label: 'Print', icon: 'print'},
					]
				},
				{
					name: 'output',
					items: [
						//{ key: 'save', label: 'Save', icon: 'check'},
						{ key: 'saveAndExit', label: 'Save', icon: 'check'}, //Added for GEL(GenomicsEngland)
						{ key: 'export', label: 'Export', icon: 'download'},
						//{ key : 'print',	 label : 'Print', icon : 'print'},
						{ key: 'close', label: 'Close', icon: 'sign-out'}
					]
				},
				{
					name: 'details',
					items: [
						{ key: 'familyId', label: '', isTextOnly:true}
					]
				},
				{
					name: 'version',
					items: [
						{key: 'version', label: "NGIS Editor Based on Version: "+this._settings.getSetting('version'), isTextOnly:true }
					]
				}
			];
		}

		var secondaryMenuItems = [];
		if (!editor.isUnsupportedBrowser()) {
			secondaryMenuItems = [
				/*{
					name: 'edit',
					items: [
						{ key: 'number', label: 'Renumber', icon: 'sort-numeric-asc'}
					]
				},*/
				/*{
					name: 'other',
					items: [
						{ key: 'clear', label: 'Clear', icon: 'times-circle'},
						{ key: 'reset', label: 'Reset', icon: 'unlock'}

					]
				}*/
			];
		}

		var _createSubmenu = function (data) {
			var submenu = new Element('div', {'class': data.name + '-actions action-group'});
			this.insert(submenu);
			data.items.each(function (item) {
				submenu.insert(_createMenuItem(item));
			});
		};
		var _createMenuItem = function (data) {

			//Added for GEL(GenomicsEngland).......
			var settings = new Settings();
			//.....................................

			//Added for GEL(GenomicsEngland) ......................................................................
			//if it is a textOnly subMenu, just display the text
			if(data.isTextOnly){
				var mi = new Element('span', {'id': 'text-' + data.key, 'class': 'menu-item-text-only'}).insert(data.label);
				return mi;
			}else{
				//Added for GEL(GenomicsEngland)............................................
				//If saveAndExit is set to 'true' in config file, then show 'save and exit' button and hide 'save' and 'close'
				var saveAndExit = settings.getSetting("saveAndExit");
				if(saveAndExit === true){
					if(data.key == "save" || data.key == "close"){
						return;
					}
				}else {
					if (data.key == "saveAndExit"){
						return;
					}
				}
				//..........................................................................
				//if it is NOT a textOnly subMenu, work as before
				var buttonIcon = new Element('span', {'class': 'fa fa-' + data.icon});
				var mi = new Element('span', {'id': 'action-' + data.key, 'class': 'field-no-user-select menu-item ' + data.key}).insert(buttonIcon).insert(' ').insert(data.label);
				if (data.callback && typeof(data.callback) == 'function') {
					mi.observe('click', function () {
						data.callback(mi, buttonIcon);
					});
				}
				return mi;
			}
			//commented for GEL(GenomicsEngland) ...................................................
			//var buttonIcon = new Element('span', {'class': 'fa fa-' + data.icon});
			//var mi = new Element('span', {'id': 'action-' + data.key, 'class': 'field-no-user-select menu-item ' + data.key}).insert(buttonIcon).insert(' ').insert(data.label);
			//if (data.callback && typeof(data.callback) == 'function') {
			//	mi.observe('click', function () {
			//		data.callback(mi, buttonIcon);
			//	});
			//}
			//return mi;
			//.......................................................................................
		};

		menuItems.each(_createSubmenu.bind(menu));
		secondaryMenuItems.each(_createSubmenu.bind(secondaryMenu));

		return menu;
	},

	/**
	 * Added for GEL(GenomicsEngland)
	 * This method will set the text on topMenu in "span#text-familyId"
	 * It is used for setting participantId and familyId
	 * @param participantId
	 * @param familyId
	 */
	setMenuText: function(testRequestId, familyId){
		if(this.topMenu) {
			var span = this.topMenu.select("span#text-familyId");
			if (span && span.length > 0) {
				var label = "";
				if(testRequestId.length > 0) {
					label = "Test Request ID: " + testRequestId;
				}
			   /* if (participantId && participantId.length > 0) {
					label = "Proband Id: "+participantId;
				}
				if (familyId && familyId.length > 0) {
					label = label + " Family Id:" + familyId +"";
				}*/
				(span[0]).update(label);
			}
		}
	},
	setClinicalIndicationNameText: function(clinicalIndicationName){
		//document.getElementsByClassName('clinical-indication-name')[0]
		console.log($(".clinicalIndicationName"))
		if(document.getElementsByClassName('clinical-indication-name')[0]) {
			document.getElementsByClassName('clinical-indication-name')[0].innerHTML = $ESAPI.encoder().encodeForHTML(clinicalIndicationName);
			var clinicalIndiciationColor = new Element("span", {'class':'abnormality-color clinical-indication-color'});
			document.getElementsByClassName('clinical-indication-name')[0].appendChild(clinicalIndiciationColor);
		}
	},

	/**
	 * Added for GEL(GenomicsEngland)
	 * This method clears the top-menu text in span#text-familyId
	 */
	clearMenuText : function(){
		if(this.topMenu) {
			var span = this.topMenu.select("span#text-familyId");
			if (span && span.length > 0) {
				span[0].update("");
			}
		}
	},

	/**
	 * Adjusts the canvas viewbox to the given zoom coefficient
	 *
	 * @method zoom
	 * @param {Number} zoomCoefficient The zooming ratio
	 */
	zoom: function (zoomCoefficient) {
		if (zoomCoefficient < 0.15) zoomCoefficient = 0.15;
		if (zoomCoefficient > 0.15 && zoomCoefficient < 0.25) zoomCoefficient = 0.25;
		zoomCoefficient = Math.round(zoomCoefficient / 0.05) / 20;
		var newWidth = this.width / zoomCoefficient;
		var newHeight = this.height / zoomCoefficient;
		var offsets = Utils.getOffsetFromHost();
		
		if (this.viewBoxX == 0){
			this.viewBoxX = -offsets.x;
		}
		
		if (this.viewBoxY == 0){
			this.viewBoxY = -offsets.y;
		}
		
		this.viewBoxX = this.viewBoxX + (this.width / this.zoomCoefficient - newWidth) / 2;
		this.viewBoxY = this.viewBoxY + (this.height / this.zoomCoefficient - newHeight) / 2;
		this.getPaper().setViewBox(this.viewBoxX, this.viewBoxY, newWidth, newHeight);
		this.zoomCoefficient = zoomCoefficient;
		this.background.attr({x: this.viewBoxX, y: this.viewBoxY, width: newWidth, height: newHeight});
	},
	enableReset: function(enabled) {
		var span = document.getElementById("action-reset");
		console.log("spacn=" + span);
		if (span) {
			span.style.display = enabled?'':'none';
		}
	},
	/**
	 * Creates the controls for panning and zooming
	 *
	 * @method generateViewControls
	 */
	generateViewControls: function () {
		var _this = this;
		this.__controls = new Element('div', {'class': 'view-controls'});
		// Pan controls
		this.__pan = new Element('div', {'class': 'view-controls-pan', title: 'Pan'});
		this.__controls.insert(this.__pan);
		['up', 'right', 'down', 'left', 'home'].each(function (direction) {
			var faIconClass = (direction == 'home') ? "fa-user" : "fa-arrow-" + direction;
			_this.__pan[direction] = new Element('span', {'class': 'view-control-pan pan-' + direction + ' fa fa-fw ' + faIconClass, 'title': 'Pan ' + direction});
			_this.__pan.insert(_this.__pan[direction]);
			_this.__pan[direction].observe('click', function (event) {
				if (direction == 'home') {
					_this.centerAroundNode(0);
				}
				else if (direction == 'up') {
					_this.panTo(_this.viewBoxX, _this.viewBoxY - 150);
				}
				else if (direction == 'down') {
					_this.panTo(_this.viewBoxX, _this.viewBoxY + 150);
				}
				else if (direction == 'left') {
					_this.panTo(_this.viewBoxX - 150, _this.viewBoxY);
				}
				else {
					_this.panTo(_this.viewBoxX + 150, _this.viewBoxY);
				}
			})
		});
		// Zoom controls
		var trackLength = 200;
		this.__zoom = new Element('div', {'class': 'view-controls-zoom', title: 'Zoom'});
		this.__controls.insert(this.__zoom);
		this.__zoom.track = new Element('div', {'class': 'zoom-track'});
		this.__zoom.handle = new Element('div', {'class': 'zoom-handle', title: 'Drag to zoom'});
		this.__zoom['in'] = new Element('div', {'class': 'zoom-button zoom-in fa fa-fw fa-search-plus', title: 'Zoom in'});
		this.__zoom['out'] = new Element('div', {'class': 'zoom-button zoom-out fa fa-fw fa-search-minus', title: 'Zoom out'});
		this.__zoom.label = new Element('div', {'class': 'zoom-crt-value'});
		this.__zoom.insert(this.__zoom['in']);
		this.__zoom.insert(this.__zoom.track);
		this.__zoom.track.insert(this.__zoom.handle);
		this.__zoom.track.style.height = trackLength + 'px';
		this.__zoom.insert(this.__zoom.out);
		this.__zoom.insert(this.__zoom.label);
		// Scriptaculous slider
		// see also http://madrobby.github.com/scriptaculous/slider/
		//
		// Here a non-linear scale is used: slider positions form [0 to 0.9] correspond to
		// zoom coefficients from 1.25x to 0.25x, and zoom positions from (0.9 to 1]
		// correspond to single deepest zoom level 0.15x
		this.zoomSlider = new Control.Slider(this.__zoom.handle, this.__zoom.track, {
			axis: 'vertical',
			minimum: 0,
			maximum: trackLength,
			increment: 1,
			alignY: 6,
			onSlide: function (value) {
				// Called whenever the Slider is moved by dragging.
				// The called function gets the slider value (or array if slider has multiple handles) as its parameter.
				//console.log("new val: " + value + " current coeff: " + _this.zoomCoefficient );
				if (value <= 0.9) {
					_this.zoom(-value / 0.9 + 1.25);
				} else {
					_this.zoom(0.15);
				}
			},
			onChange: function (value) {
				// Called whenever the Slider has finished moving or has had its value changed via the setSlider Value function.
				// The called function gets the slider value (or array if slider has multiple handles) as its parameter.
				if (value <= 0.9) {
					_this.zoom(-value / 0.9 + 1.25);
				} else {
					_this.zoom(0.15);
				}
			}
		});
		if (editor.isUnsupportedBrowser()) {
			this.zoomSlider.setValue(0.25 * 0.9); // 0.25 * 0.9 corresponds to zoomCoefficient of 1, i.e. 1:1
			// - for best chance of decent looks on non-SVG browsers like IE8
		} else {
			this.zoomSlider.setValue(0.5 * 0.9);  // 0.5 * 0.9 corresponds to zoomCoefficient of 0.75x
		}
		this.__zoom['in'].observe('click', function (event) {
			if (_this.zoomCoefficient < 0.25)
				_this.zoomSlider.setValue(0.9);   // zoom in from the any value below 0.25x goes to 0.25x (which is 0.9 on the slider)
			else
				_this.zoomSlider.setValue(-(_this.zoomCoefficient - 1) * 0.9);	 // +0.25x
		});
		this.__zoom['out'].observe('click', function (event) {
			if (_this.zoomCoefficient <= 0.25)
				_this.zoomSlider.setValue(1);	 // zoom out from 0.25x goes to the final slider position
			else
				_this.zoomSlider.setValue(-(_this.zoomCoefficient - 1.5) * 0.9);   // -0.25x
		});
		// Insert all controls in the document
		this.getWorkArea().insert(this.__controls);
	},

	/* To work around a bug in Raphael or Raphaelzpd (?) which creates differently sized lines
	 * @ different zoom levels given the same "stroke-width" in pixels this function computes
	 * the pixel size to be used at this zoom level to create a line of the correct size.
	 *
	 * Returns the pixel value to be used in stoke-width
	 */
	getSizeNormalizedToDefaultZoom: function (pixelSizeAtDefaultZoom) {
		return pixelSizeAtDefaultZoom;
	},

	/**
	 * Returns the current zoom level (not normalized to any value, larger numbers mean deeper zoom-in)
	 */
	getCurrentZoomLevel: function (pixelSizeAtDefaultZoom) {
		return this.zoomCoefficient;
	},

	/**
	 * Converts the coordinates relative to the Raphael canvas to coordinates relative to the canvas div
	 * and returns them
	 *
	 * @method canvasToDiv
	 * @param {Number} canvasX The x coordinate relative to the Raphael canvas (ie with pan/zoom transformations)
	 * @param {Number} canvasY The y coordinate relative to the Raphael canvas (ie with pan/zoom transformations)
	 * @return {{x: number, y: number}} Object with coordinates
	 */
	canvasToDiv: function (canvasX, canvasY) {
		return {
			x: this.zoomCoefficient * (canvasX - this.viewBoxX),
			y: this.zoomCoefficient * (canvasY - this.viewBoxY)
		}
	},

	/**
	 * Converts the coordinates relative to the canvas div to coordinates relative to the Raphael canvas
	 * by applying zoom/pan transformations and returns them.
	 *
	 * @method divToCanvas
	 * @param {Number} divX The x coordinate relative to the canvas
	 * @param {Number} divY The y coordinate relative to the canvas
	 * @return {{x: number, y: number}} Object with coordinates
	 */
	divToCanvas: function (divX, divY) {
		return {
			x: divX / this.zoomCoefficient + this.viewBoxX,
			y: divY / this.zoomCoefficient + this.viewBoxY
		}
	},

	/**
	 * Converts the coordinates relative to the browser viewport to coordinates relative to the canvas div,
	 * and returns them.
	 *
	 * @method viewportToDiv
	 * @param {Number} absX The x coordinate relative to the viewport
	 * @param {Number} absY The y coordinate relative to the viewport
	 * @return {{x: number, y: number}} Object with coordinates
	 */
	viewportToDiv: function (absX, absY) {
		return {
			x: +absX - this.canvas.cumulativeOffset().left,
			y: absY - this.canvas.cumulativeOffset().top
		};
	},

	/**
	 * Animates a transformation of the viewbox to the given coordinate
	 *
	 * @method panTo
	 * @param {Number} x The x coordinate relative to the Raphael canvas
	 * @param {Number} y The y coordinate relative to the Raphael canvas
	 */
	panTo: function (x, y, instant) {
		var me = this,
			oX = this.viewBoxX,
			oY = this.viewBoxY,
			xDisplacement = x - oX,
			yDisplacement = y - oY;
		
		if (editor.isUnsupportedBrowser()) {
			instant = true;
		}

		var numSeconds = instant ? 0 : .4;
		var frames = instant ? 1 : 11;

		var xStep = xDisplacement / frames,
			yStep = yDisplacement / frames;
			
		if (xStep == 0 && yStep == 0) return;
		
		var progress = 0;
		
		(function draw() {
			setTimeout(function () {
				if (progress++ < frames) {
					me.viewBoxX += xStep;
					me.viewBoxY += yStep;
					me.getPaper().setViewBox(me.viewBoxX, me.viewBoxY, me.width / me.zoomCoefficient, me.height / me.zoomCoefficient);
					me.background.attr({x: me.viewBoxX, y: me.viewBoxY });
					draw();
				}
			}, 1000 * numSeconds / frames);
		})();
	},

	/**
	 * Animates a transformation of the viewbox by the given delta in the X direction
	 *
	 * @method panTo
	 * @param {Number} deltaX The move size
	 */
	panByX: function (deltaX, instant) {
		this.panTo(this.viewBoxX + Math.floor(deltaX / this.zoomCoefficient), this.viewBoxY, instant);
	},

	/**
	 * Adjusts the canvas size to the current viewport dimensions.
	 *
	 * @method adjustSizeToScreen
	 */
	adjustSizeToScreen: function () {
		var screenDimensions = document.viewport.getDimensions();
		var offsets = Utils.getOffsetFromHost();
		this.width = PedigreeEditorTool.standalone ? screenDimensions.width : PedigreeEmbeddedWidth; // screenDimensions.width-offsets.x;
		this.height = screenDimensions.height - this.canvas.cumulativeOffset().top - 4; // - offsets.y;
		this.getPaper().setSize(this.width, this.height);
		this.getPaper().setViewBox(this.viewBoxX, this.viewBoxY, this.width / this.zoomCoefficient, this.height / this.zoomCoefficient);
		this.background && this.background.attr({"width": this.width, "height": this.height});
		if (editor.getNodeMenu()) {
			editor.getNodeMenu().reposition();
		}
	},

	/**
	 * Pans the canvas to put the node with the given id at the center.
	 *
	 * When (xCenterShift, yCenterShift) are given positions the node with the given shift relative
	 * to the center instead of exact center of the screen
	 *
	 * @method centerAroundNode
	 * @param {Number} nodeID The id of the node
	 */
	centerAroundNode: function (nodeID, instant, xCenterShift, yCenterShift) {
		var node = editor.getNode(nodeID);
		
		if (node) {
			
			var x = node.getX(),
				y = node.getY();
			if (!xCenterShift) xCenterShift = 0;
			if (!yCenterShift) yCenterShift = 0;
			var xOffset = this.getWidth() / this.zoomCoefficient;
			var yOffset = this.getHeight() / this.zoomCoefficient;
			this.panTo(x - xOffset / 2 - xCenterShift, y - yOffset / 2 - yCenterShift, instant);

		}
	}
});





/**
 * Class responsible for keeping track of cancers and their properties.
 * This information is graphically displayed in a 'Legend' box.
 *
 * @class CancerLegend
 * @constructor
 */

var CancerLegend = Class.create(Legend, {

	initialize: function ($super) {
		this._cancerColors = { "Breast": "#e267a3",    // pink e762a4
			"Ovarian": "#9370DB",   // purple
			"Colon": "#945d34",     // brown
			"Uterus": "#c93320",    // red
			"Prostate": "#ecb739",  // yellow
			"Pancreatic": "#4657dc",  // blue
			"Melanoma": "#444444",  // black (#333333 and darker do not work with raphael gradients)
			"Kidney": "#197419",    // green
			"Gastric": "#9aac8c",   // (?) greenish
			"Lung": "#008080",      // teal
			"Brain": "#F5DEB3",     // (?) wheat
			"Oesophagus": "#BC8F8F", // (?) rosybrown
			"Thyroid": "#FFFF00"     // yellow
		};
		this._cancerLabels = { "Breast": "Breast cancer",
			"Ovarian": "Ovarian cancer",
			"Colon": "Colon cancer",
			"Uterus": "Uterus cancer",
			"Prostate": "Prostate cancer",
			"Pancreatic": "Pancreatic cancer",
			"Melanoma": "Melanoma",
			"Kidney": "Kidney cancer",
			"Gastric": "Gastric cancer",
			"Lung": "Lung cancer",
			"Brain": "Brain cancer",
			"Oesophagus": "Oesophagus cancer",
			"Thyroid": "Thyroid cancer"
		};
		$super('Cancers', true);
	},

	_getPrefix: function (id) {
		return "cancers";
	},

	_getAllSupportedCancers: function () {
		var clist = [];
		for (var cancer in this._cancerColors) {
			if (this._cancerColors.hasOwnProperty(cancer)) {
				clist.push(cancer);
			}
		}
		return clist;
	},

	addCase: function ($super, id, name, valueAll, nodeID) {
		//var name = this._cancerLabels.hasOwnProperty(name) ? this._cancerLabels[name] : name;
		//$super(id, name, valueAll, nodeID);
	},

	/**
	 * Generate the element that will display information about the given cancer in the legend
	 *
	 * @method _generateElement
	 * @param {Number} disorderID The id for the disorder, taken from the OMIM database
	 * @param {String} name The human-readable disorder name
	 * @return {HTMLLIElement} List element to be insert in the legend
	 */
	_generateElement: function ($super, cancerID, name) {
		if (!this._objectColors.hasOwnProperty(cancerID)) {
			var color = this._generateColor(cancerID);
			this._objectColors[cancerID] = color;
			document.fire('cancer:color', {'id': cancerID, color: color});
		}
		return $super(cancerID, name);
	},

	/**
	 * Callback for dragging an object from the legend onto nodes
	 *
	 * @method _onDropGeneric
	 * @param {Person} Person node
	 * @param {String} id ID of the cancer being dropped
	 */
	_onDropObject: function (node, cancerID) {
		if (node.isPersonGroup()) {
			return;
		}
		var currentCancers = Helpers.cloneObject(node.getCancers());
		// only if the node does not have this cancer yet (either "not tested" or "unaffected")
		if (!currentCancers.hasOwnProperty(cancerID) || !currentCancers[cancerID].affected) {
			currentCancers[cancerID] = {"affected": true};
			editor.getView().unmarkAll();
			var properties = { "setCancers": currentCancers };
			var event = { "nodeID": node.getID(), "properties": properties };
			document.fire("pedigree:node:setproperty", event);
		} else {
			this._onFailedDrag(node, "This person is already marked as affected by the selected cancer", "Can't drag this cancer to this person");
		}
	},

	/**
	 * Generates a CSS color.
	 * Has preference for some predefined colors that can be distinguished in gray-scale
	 * and are distint from gene colors.
	 *
	 * @method generateColor
	 * @return {String} CSS color
	 */
	_generateColor: function (cancerID) {
		if (this._objectColors.hasOwnProperty(cancerID)) {
			return this._objectColors[cancerID];
		}
		if (this._cancerColors.hasOwnProperty(cancerID)) {
			return this._cancerColors[cancerID];
		}
		var usedColors = Object.values(this._objectColors);
		// red/yellow gamma
		var prefColors = ['#f8ebb7', '#eac080', '#bf6632', '#a47841', '#c95555', '#ae6c57'];
		usedColors.each(function (color) {
			prefColors = prefColors.without(color);
		});
		if (prefColors.length > 0) {
			return prefColors[0];
		}
		else {
			var randomColor = Raphael.getColor();
			while (randomColor == "#ffffff" || usedColors.indexOf(randomColor) != -1) {
				randomColor = "#" + ((1 << 24) * Math.random() | 0).toString(16);
			}
			return randomColor;
		}
	}
});
/**
 * PrintEngine handles splitting of pedigree into pages for printing and generating print previews
 *
 * @class PrintEngine
 */
var PrintEngine = Class.create({

	initialize: function () {
		// TODO: load default paper settings from pedigree preferences in admin section
		this.printPageWidth = 1055;
		this.printPageHeight = 756;
		this.printPageWidthPortrait = 756;
		this.printPageHeightPortrait = 980;
		this.xOverlap = 32;
		this.yOverlap = 32;
	},

	/**
	 * @param {emulateFullPage} When true, makes svg include extra blank space up to the pageWidth/pageHeight size
	 */
	_generatePages: function (scale, moveHorizontallySize, pageWidth, pageHeight, options, emulateFullPage, scaleComparedToPrint) {
		var totalLegendHeight = 0;
		var patientInfoHeight = 0;
		var legendHTML = "";
		var patientInfoHTML = "";
		if (options.includeLegend) {
			// Manually compose legend for print; 3 benefits:
			//   - color samples not using background gcolor (which is not printed by default in some browsers)
			//   - known height (need th eheight to compute required number of pages; no need to pre-render in the browser)
			//   - better handling of disabled/enabled legend items (regular legend has both enabled and disabled items)

			var legendData = editor.getView().getSettings();

			var generateSection = function (colors, names, sectionName) {
				var count = 0;
				var height = 30;
				var html = "<div class='legend-section'><h3 class='section-title'>" + sectionName + "</h3>" +
					"<ul class='abnormality-list'>";
				for (var id in colors) {
					if (colors.hasOwnProperty(id)) {
						count++;
						var color = colors[id];
						var name = (names && names.hasOwnProperty(id)) ? names[id] : id;
						html += "<li class='abnormality'>";
						html += "<span class='abnormality-color'><svg height='13' width='13' style='display: inline-block;'><rect x='0' y='0' rx='6' ry='6' width='13' height='13' fill='" + color + "'></rect></svg></span>";
						html += "<span class='legend-item-name'>" + name + "</span>";
						height += 20;
					}
				}
				html += "</ul></div>";
				if (count > 0) {
					return {"html": html, "heightInPixels": height};
				} else {
					return {"html": "", "heightInPixels": 0};
				}
			}
			var sections = [];
			if (legendData.hasOwnProperty("colors")) {
				legendData["colors"].hasOwnProperty("disorders") && sections.push(generateSection(legendData["colors"]["disorders"], legendData["names"]["disorders"], "Disorders"));
				legendData["colors"].hasOwnProperty("genes") && sections.push(generateSection(legendData["colors"]["genes"], null, "Genes"));
				legendData["colors"].hasOwnProperty("phenotypes") && sections.push(generateSection(legendData["colors"]["phenotypes"], null, "Phenotypes"));
				legendData["colors"].hasOwnProperty("cancers") && sections.push(generateSection(legendData["colors"]["cancers"], null, "Cancers"));
			}

			for (var i = 0; i < sections.length; i++) {
				totalLegendHeight += sections[i].heightInPixels;
				legendHTML += sections[i].html;
			}
		} // if includeLegend
		if (options.includePatientInfo) {
			patientInfoHeight = 30;
			var proband = editor.getNode(0);
			if (options.anonimize || (!proband.getFirstName() && !proband.getLastName())) {
				patientInfoHTML = "Participant " + proband.getParticipantId();
				var familyId = proband.getFamilyId();
				if(familyId && familyId.length > 0 ){
					patientInfoHTML = patientInfoHTML + " (FamilyId: " + familyId + ")" ;
				}
			} else {
				// TODO: update to correct proband/family when fmaly studies are merged in
				var space = (proband.getFirstName() && proband.getLastName()) ? " " : "";
				var probandName = proband.getFirstName() + space + proband.getLastName();
				patientInfoHTML = probandName + ", " + XWiki.currentDocument.page;
			}
			var userFirstName = editor.getPreferencesManager().getConfigurationOption("firstName");
			var userLastName = editor.getPreferencesManager().getConfigurationOption("lastName");
			var date = new PedigreeDate(new Date());
			patientInfoHTML += ". Printed";
			if (userFirstName || userLastName) {
				patientInfoHTML += " by " + userFirstName + " " + userLastName;
			}
			var dateDisplayFormat = editor.getPreferencesManager().getConfigurationOption("dateDisplayFormat");
			if (dateDisplayFormat == "DMY" || dateDisplayFormat == "MY") {
				patientInfoHTML += " on " + date.getBestPrecisionStringDDMMYYY() + ".";
			} else {
				patientInfoHTML += " on " + date.getMonthName() + " " + date.getDay() + ", " + date.getYear() + ".";
			}
		}

		var svg = editor.getWorkspace().getSVGCopy(options.anonimize);

		//console.log("BBOX: " + stringifyObject(svg.getBBox()));

		svg.scale(scale);

		svg.move(moveHorizontallySize, 0);

		var svgText = svg.getSVGText();
		var bbox = svg.getBBox();

		var xOverlap = options.addOverlaps ? Math.floor(this.xOverlap * scale) : 0;
		var yOverlap = options.addOverlaps ? Math.floor(this.yOverlap * scale) : 0;

		var pagesWide = (bbox.width <= pageWidth) ? 1 : Math.ceil(bbox.width / pageWidth);
		var pagesTall = (bbox.height + patientInfoHeight * scaleComparedToPrint <= pageHeight) ? 1 : Math.ceil((bbox.height + patientInfoHeight * scaleComparedToPrint) / pageHeight);
		if (pagesWide > 1 && options.addOverlaps) {
			var realWidthWithOverlaps = bbox.width + (pagesWide - 1) * xOverlap;
			pagesWide = Math.ceil(realWidthWithOverlaps / pageWidth);
		}
		if (pagesTall > 1 && options.addOverlaps) {
			var realHeightWithOverlaps = bbox.height + (pagesTall - 1) * yOverlap;
			pagesTall = Math.ceil(realHeightWithOverlaps / pageHeight);
		}

		// split into pages
		var pages = [];
		var pageStartY = 0;
		var legendOnSeparatePage = false;
		for (var pageNumY = 0; pageNumY < pagesTall; pageNumY++) {
			var rowHeight = Math.min(pageHeight, bbox.height - pageStartY);
			// to account for rounding & avoid priting pages with just 1 pixel of data
			if (!emulateFullPage && rowHeight <= 2) {
				pagesTall = pagesTall - 1;
				legendOnSeparatePage = true;
				continue;
			}
			if (emulateFullPage) {
				var rowHeight = pageHeight;
			}
			var pagesRow = [];
			var pageStartX = 0;
			if (pageNumY == 0 && options.includePatientInfo) {
				if (rowHeight + patientInfoHeight * scaleComparedToPrint > pageHeight) {
					rowHeight = pageHeight - patientInfoHeight * scaleComparedToPrint;
				}
			}
			for (var pageNumX = 0; pageNumX < pagesWide; pageNumX++) {
				var columnWidth = pageWidth; //(emulateFullPage || (pagesWide > 1 && pageNumX == pagesWide-1))? pageWidth : Math.min(pageWidth,  bbox.width - pageStartX);
				var startX = pageStartX;
				if (pagesWide == 1) {
					startX = pageStartX - (pageWidth - bbox.width) / 2;
				}
				var pageSvg = svg.getCopy().setViewBox(startX, pageStartY, columnWidth, rowHeight).getSVGText();
				var page = { "pageName": "page " + pageNumX + ":" + pageNumY,
					"svg": pageSvg, "width": columnWidth };
				pagesRow.push(page);
				pageStartX += (columnWidth - xOverlap);
			}
			pages.push(pagesRow);
			if (pageNumY == (pagesTall - 1) && pageHeight < rowHeight + totalLegendHeight) {
				legendOnSeparatePage = true;
			}
			pageStartY += (rowHeight - yOverlap);
		}

		return { "pages": pages,
			"pagesWide": pagesWide,
			"pagesTall": pagesTall,
			"needLegendOnSeparatePage": legendOnSeparatePage,
			"legendHTML": legendHTML,
			"legendHeight": totalLegendHeight,
			"patientInfoHTML": patientInfoHTML,
			"patientInfoHeight": patientInfoHeight}
	},

	generatePreviewHTML: function (landscape, maxPreviewWidth, maxPreviewHeight, printScale, moveHorizontallySize, options) {
		var previewWidth = maxPreviewWidth - 30;

		var printedWidth = landscape ? this.printPageWidth : this.printPageWidthPortrait;
		var printedHeight = landscape ? this.printPageHeight : this.printPageHeightPortrait;

		// generate pages for print, and based on the number of pages used re-generate preview pages
		var pagesReal = this._generatePages(printScale,
			moveHorizontallySize,
			printedWidth,
			printedHeight,
			options,
			false,
			1);

		var printWidth = 0;
		for (var pageNumX = 0; pageNumX < pagesReal.pagesWide; pageNumX++) {
			printWidth += pagesReal.pages[0][pageNumX].width; // this includes overlaps, if any
		}
		var expectedWidth = pagesReal.pagesWide * printedWidth;

		// need to scale even more than for print, the ratio is the ratio of printWidth to previewWidth
		var scaleComparedToPrint = previewWidth / expectedWidth;
		var useScale = scaleComparedToPrint * printScale;

		var pages = this._generatePages(useScale,
			moveHorizontallySize,
				scaleComparedToPrint * printedWidth,
				scaleComparedToPrint * printedHeight,
			options,
			true,
			scaleComparedToPrint);
		if (pages.pagesTall > pagesReal.pagesTall) {
			pages.pagesTall = pagesReal.pagesTall;  // may hapen due to rounding errors
		}
		var html = "<div class='printPreview' id='printPreview' style='height: " + maxPreviewHeight + "px; width: " + maxPreviewWidth + "px; overflow-y: scroll;'>";
		for (var pageNumY = 0; pageNumY < pages.pagesTall; pageNumY++) {
			for (var pageNumX = 0; pageNumX < pages.pagesWide; pageNumX++) {
				var page = pages.pages[pageNumY][pageNumX];
				html += "<div class='previewPage' style='border: 1px; border-style: dotted; float: left;' id='pedigree-page-x" + pageNumX + "-y" + pageNumY + "'>";
				if (pageNumY == 0 && options.includePatientInfo) {
					var content = (pageNumX == 0) ? pages.patientInfoHTML : "";
					html += "<div style='height: " + pages.patientInfoHeight * scaleComparedToPrint + "px; font-size: " + (11 * scaleComparedToPrint) + "pt; text-align: left'>" + content + "</div>";
				}
				html += page.svg;
				html += "</div>";
			}
			//html += "<br>";
		}
		html += "</div>";
		return html;
	},

	print: function (landscape, printScale, moveHorizontallySize, options, printPageSet) {
		var pages = this._generatePages(printScale,
			moveHorizontallySize,
			landscape ? this.printPageWidth : this.printPageWidthPortrait,
			landscape ? this.printPageHeight : this.printPageHeightPortrait,
			options,
			false,
			1);
		var w = window.open();
		w.document.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
		//w.document.write("<link rel='stylesheet' type='text/css' href='print.css' />");
		if (landscape) {
			w.document.write("<style type='text/css' media='print'>@page { size: landscape; }</style>");
		} else {
			w.document.write("<style type='text/css' media='print'>@page { size: portrait; }</style>");
		}
		w.document.write("<style type='text/css'>" +
			"* {margin: 0;}" +
			"html, body { height: 100%; }" +
			".wrapper { min-height: 100%; height: auto !important; height: 100%; }" +
			".break_here { page-break-before:always; }" +
			".abnormality-list { list-style-type: none; }" +
			".abnormality-color { margin-right: 8px; }" +
			".legend-item-name {font-size: 11pt }" +
			".patient-info {font-size: 11pt }" +
			"</style>");

		for (var pageNumY = 0; pageNumY < pages.pagesTall; pageNumY++) {
			for (var pageNumX = 0; pageNumX < pages.pagesWide; pageNumX++) {
				if (printPageSet && !printPageSet["x" + pageNumX + "y" + pageNumY]) {
					// skip pages marked to be skipped by the user
					continue;
				}
				var patientInfoOnThisPage = (pageNumY == 0 && options.includePatientInfo);
				if (patientInfoOnThisPage) {
					var content = (pageNumX == 0) ? pages.patientInfoHTML : "";
					w.document.write("<div id='patientInfo' class='header patient-info' style='height: " + pages.patientInfoHeight + "px;'>" + content + "</div>");
				}
				var page = pages.pages[pageNumY][pageNumX];
				var bottomLeftPage = (pageNumY == (pages.pagesTall - 1)) && (pageNumX == 0);
				var spaceForLegend = options.includeLegend && (pages.legendHeight > 0) && options.legendAtBottom && bottomLeftPage && !pages.needLegendOnSeparatePage;
				if (spaceForLegend) {
					var skipOnTop = patientInfoOnThisPage ? -pages.patientInfoHeight : 0;
					w.document.write("<div class='wrapper' style='margin: " + skipOnTop + "px auto -" + pages.legendHeight + "px;'>");
					if (patientInfoOnThisPage) {
						w.document.write("<div style='height: " + pages.patientInfoHeight + "px;'></div>");
					}
				}
				if (pages.pagesWide == 1) {
					w.document.write("<center>");
				}
				w.document.write("<div id='pedigree-page-x" + pageNumX + "-" + pageNumY + "'>" + page.svg + "</div>");
				if (pages.pagesWide == 1) {
					w.document.write("</center>");
				}
				if (spaceForLegend) {
					w.document.write("<div style='height: " + pages.legendHeight + "px;'></div></div>");
					w.document.write("<div id='legend' class='footer print-legend' style='height: " + pages.legendHeight + "px;'>" + pages.legendHTML + "</div>");
				} else if (!this._isLastPage(pageNumY, pageNumX, pages, printPageSet)) {  // IE9 is not smart enough to realize there is no page after the very last break
					w.document.write("<div class='break_here'></div>");
				}
			}
		}

		if (options.includeLegend && options.legendAtBottom && pages.needLegendOnSeparatePage) {
			w.document.write("<div class='break_here'></div>");
			w.document.write("<div id='legend' class='print-legend'>" + pages.legendHTML + "</div>");
		}
		w.document.close(); // to prevent infinite "page loading"

		w.print();
		if (options.closeAfterPrint) {
			w.close();
		}
	},

	_isLastPage: function (pageY, pageX, pages, printPageSet) {
		for (var pageNumY = pageY; pageNumY < pages.pagesTall; pageNumY++) {
			var startX = ((pageNumY == pageY) ? pageX + 1 : 0);
			for (var pageNumX = startX; pageNumX < pages.pagesWide; pageNumX++) {
				if (printPageSet && !printPageSet["x" + pageNumX + "y" + pageNumY]) {
					continue;  // skip pages marked to be skipped by the user
				}
				return false;  // yes, there is another page to be printed
			}
		}
		return true;
	}
});
/**
 * The UI Element for selecting pedigree print settings.
 *
 * Should be instantiated after preferences have been loaded as default paper/printer
 * settings may be stored in the preferences.
 *
 * @class PrintDialog
 */
var PrintDialog = Class.create({

	initialize: function () {
		var _this = this;

		this._defaultScale = 0.4;
		this._landscape = true;
		this._zoomLevel = 100;
		this._moveHorizontally = 0;
		this._printPageSet = {};
		this._printEngine = new PrintEngine();

		var mainDiv = new Element('div', {'class': 'import-selector field-no-user-select cursor-normal'});

		var previewHeader = new Element('div', {'class': 'print-preview-header'}).update("Print preview:<br>(each block indicates a separate printed page; click on a page to exclude/include the page from print job)");
		this.previewContainer = new Element("div", {"id": "preview", "class": "preview-container"});
		var previewFooter = new Element('div', {'class': 'print-preview-footer fa fa-exclamation-triangle'});
		previewFooter.update(new Element('span', {'class': "print-preview-footer-text"}).update("Note: in some browsers you need to manually select correct orientation (landscape or portrait)"));
		mainDiv.insert(previewHeader).insert(this.previewContainer).insert(previewFooter);

		var minusButton = new Element('input', {"type": "button", "value": "-", "class": "print-small-button print-left-margin"});
		var plusButton = new Element('input', {"type": "button", "value": "+", "class": "print-small-button"});
		this.zoomValue = new Element('label', {"class": "print-zoom-value no-mouse-interaction"}).update("100%");
		var zoom = new Element('span', {"class": "print-zoom-span"});
		zoom.update("Print scale:").insert(minusButton).insert(this.zoomValue).insert(plusButton);

		var leftButton = new Element('input', {"type": "button", "value": "<", "class": "print-small-button print-small-left-margin"});
		var rightButton = new Element('input', {"type": "button", "value": ">", "class": "print-small-button print-small-left-margin"});
		this._centerButton = new Element('input', {"type": "button", "value": "default", "class": "print-long-button print-small-left-margin"});
		var move = new Element('span', {"class": "print-move-span"});
		move.update("Move on page:").insert(leftButton).insert(this._centerButton).insert(rightButton);

		var landscape = new Element('input', {"type": "button", "value": "landscape", "class": "print-long-button", "id": "landscape-button"});
		var portrait = new Element('input', {"type": "button", "value": "portrait", "class": "print-long-button print-small-left-margin", "id": "portrait-button"});
		var orientation = new Element('span', {"class": "print-orientation-span"});
		orientation.update(landscape).insert(portrait);

		var controlsDiv = new Element('div', {'class': 'pedigree-print-controls-container field-no-user-select'});
		controlsDiv.update(zoom).insert(move).insert(orientation);
		minusButton.observe('click', function (event) {
			if (_this._zoomLevel > 10) {
				_this._zoomLevel -= 10;
				_this._moveHorizontally = 0;
				_this.zoomValue.update(_this._zoomLevel + "%");
				_this._updatePreview();
			}
		});
		plusButton.observe('click', function (event) {
			if (_this._zoomLevel < 250) {
				_this._zoomLevel += 10;
				_this._moveHorizontally = 0;
				_this.zoomValue.update(_this._zoomLevel + "%");
				_this._updatePreview();
			}
		});
		leftButton.observe('click', function (event) {
			_this._moveHorizontally += 40;
			_this._updatePreview();
		});
		rightButton.observe('click', function (event) {
			_this._moveHorizontally -= 40;
			_this._updatePreview();
		});
		this._centerButton.observe('click', function (event) {
			_this._moveHorizontally = 0;
			_this._updatePreview();
		});
		landscape.observe('click', function (event) {
			_this._landscape = true;
			_this._moveHorizontally = 0;
			$('landscape-button').disable();
			$('portrait-button').enable();
			_this._updatePreview();
		});
		portrait.observe('click', function (event) {
			_this._landscape = false;
			_this._moveHorizontally = 0;
			$('landscape-button').enable();
			$('portrait-button').disable();
			_this._updatePreview();
		});

		mainDiv.insert(controlsDiv);

		var configListElement = new Element('table', {id: 'print-settings'});
		var anonimize = new Element('input', {"type": "checkbox", "value": "0", "name": "anonimize"});
		anonimize.checked = false;
		anonimize.observe('click', function () {
			_this._updatePreview();
		});
		configListElement.insert(new Element('label', {'class': 'import-mark-label1'}).insert(anonimize).insert("Remove PII information (anonimize)").wrap('td').wrap('tr'));
		var addLegend = new Element('input', {"type": "checkbox", "value": "1", "name": "add-legend"});
		addLegend.checked = true;
		configListElement.insert(new Element('label', {'class': 'import-mark-label2'}).insert(addLegend).insert("Print legend on the bottom left sheet").wrap('td').wrap('tr'));
		var includeOverlaps = new Element('input', {"type": "checkbox", "value": "1", "name": "add-overlap", "id": "add-overlaps-checkbox"});
		includeOverlaps.checked = false;
		includeOverlaps.observe('click', function () {
			_this._updatePreview();
		});
		configListElement.insert(new Element('label', {'class': 'import-mark-label2'}).insert(includeOverlaps).insert("Make pages slightly overlapped").wrap('td').wrap('tr'));
		var info = new Element('input', {"type": "checkbox", "value": "1", "name": "patient-info"});
		info.checked = true;
		info.observe('click', function () {
			_this._updatePreview();
		});
		configListElement.insert(new Element('label', {'class': 'import-mark-label2'}).insert(info).insert("Include patient information and print date at the top of the first page").wrap('td').wrap('tr'));
		var closeAfterPrint = new Element('input', {"type": "checkbox", "value": "1", "name": "close-print"});
		closeAfterPrint.checked = true;
		configListElement.insert(new Element('label', {'class': 'import-mark-label2'}).insert(closeAfterPrint).insert("Close window with printer-friendly version after printing").wrap('td').wrap('tr'));

		var dataSection3 = new Element('div', {'class': 'print-settings-block'});
		dataSection3.insert(configListElement);
		mainDiv.insert(dataSection3);

		var buttons = new Element('div', {'class': 'buttons import-block-bottom'});
		this._printButton = new Element('input', {type: 'button', name: 'print', 'value': 'Print', 'class': 'button', 'id': 'print_button'});
		buttons.insert(this._printButton.wrap('span', {'class': 'buttonwrapper'}));
		buttons.insert(new Element('input', {type: 'button', name: 'done', 'value': 'Close', 'class': 'button secondary'}).wrap('span', {'class': 'buttonwrapper'}));
		mainDiv.insert(buttons);

		var doneButton = buttons.down('input[name="done"]');
		doneButton.observe('click', function (event) {
			_this.hide();
		});
		this._printButton.observe('click', function (event) {
			_this._onPrint();
		});

		var closeShortcut = ['Esc'];
		this.dialog = new PhenoTips.widgets.ModalPopup(mainDiv, {close: {method: this.hide.bind(this), keys: closeShortcut}}, {extraClassName: "pedigree-print-dialog", title: "Print pedigree", displayCloseButton: true, verticalPosition: "top"});

		Event.observe(window, 'resize', _this._adjustPreviewWindowHeight.bind(_this));
	},

	/**
	 * Prints the pedigree using the scale and option selected.
	 */
	_onPrint: function () {
		var options = this._generateOptions();

		this._printEngine.print(this._landscape,
			this._getSelectedPrintScale(),
			this._moveHorizontally,
			options,
			this._printPageSet);
	},

	/**
	 * Creates an options object based on state of UI input elements
	 */
	_generateOptions: function () {
		var patientInfo = $$('input[type=checkbox][name="patient-info"]')[0].checked;

		var anonimize = $$('input[type=checkbox][name="anonimize"]')[0].checked;

		var closePrintVersion = $$('input[type=checkbox][name="close-print"]')[0].checked;

		var addLegend = $$('input[type=checkbox][name="add-legend"]')[0].checked;

		var addOverlaps = $$('input[type=checkbox][name="add-overlap"]')[0].checked;

		return { "includeLegend": addLegend,
			"legendAtBottom": true,
			"addOverlaps": addOverlaps,
			"closeAfterPrint": closePrintVersion,
			"anonimize": anonimize,
			"includePatientInfo": patientInfo};
	},

	/**
	 * Displays the template selector
	 *
	 * @method show
	 */
	show: function () {
		this.dialog.show();
		this._moveHorizontally = 0;
		this._updatePreview();
	},

	/**
	 * Attempts to make preview window fit on screen by adjusting the preview pane height
	 */
	_adjustPreviewWindowHeight: function () {
		var canvas = editor.getWorkspace().canvas || document.getElementById(PedigreeEditorTool.divId);
		var pedigreeDialogue = $$('.pedigree-print-dialog')[0];
		if (!pedigreeDialogue) {
			return;
		}
		var screenHeight = canvas.getHeight() - 10;
		var dialogueHeight = pedigreeDialogue.getHeight();
		var freeSpace = screenHeight - dialogueHeight;
		var previewPaneHeight = $('printPreview').getHeight();
		if (freeSpace < 0) {
			var newPreviewHeight = Math.max(PedigreeEditorParameters.attributes.minPrintPreviewPaneHeight, previewPaneHeight + freeSpace);
			$('printPreview').style.height = newPreviewHeight + "px";
		}
		if (freeSpace > 0 && previewPaneHeight < PedigreeEditorParameters.attributes.maxPrintPreviewPaneHeight) {
			var newPreviewHeight = Math.min(PedigreeEditorParameters.attributes.maxPrintPreviewPaneHeight, previewPaneHeight + freeSpace);
			$('printPreview').style.height = newPreviewHeight + "px";
		}
	},

	/**
	 * Updates print preview using currently selected zoom level.
	 */
	_updatePreview: function () {
		var options = this._generateOptions();
		var previewHTML = this._printEngine.generatePreviewHTML(this._landscape,
			730, PedigreeEditorParameters.attributes.maxPrintPreviewPaneHeight,
			this._getSelectedPrintScale(),
			this._moveHorizontally,
			options);
		this.previewContainer.update(previewHTML);
		this._adjustPreviewWindowHeight();

		var _this = this;
		this._printPageSet = {};
		var numPrinted = 0;
		// add click-on-page handlers
		$$("div[id^=pedigree-page-]").forEach(function (page) {
			try {
				var pageIDParts = page.id.match(/pedigree-page-x(\d+)-y(\d+)/);
				var pageX = pageIDParts[1];
				var pageY = pageIDParts[2];

				_this._printPageSet["x" + pageX + "y" + pageY] = true;
				numPrinted++;

				page.observe("click", function () {
					if (_this._printPageSet["x" + pageX + "y" + pageY]) {
						_this._printPageSet["x" + pageX + "y" + pageY] = false;
						page.style.backgroundColor = "#111";
						page.style.opacity = 0.1;
						_this._checkPrintbuttonStatus();  // check if there are any pages left
					} else {
						_this._printPageSet["x" + pageX + "y" + pageY] = true;
						page.style.backgroundColor = "";
						page.style.opacity = 1;
						_this._checkPrintbuttonStatus();
					}
				});
			} catch (err) {
				console.log("Preview page ID mismatch");
			}
		});
		this._printButton.enable();

		if (numPrinted < 2) {
			$('add-overlaps-checkbox').disable();
		} else {
			$('add-overlaps-checkbox').enable();
		}

		if (this._landscape) {
			$('landscape-button').disable();
			$('portrait-button').enable();
		} else {
			$('landscape-button').enable();
			$('portrait-button').disable();
		}
		if (_this._moveHorizontally == 0) {
			this._centerButton.disable();
		} else {
			this._centerButton.enable();
		}
	},

	/**
	 * Disabled print button if there are no pages selected; enables otherwise
	 */
	_checkPrintbuttonStatus: function () {
		for (var page in this._printPageSet) {
			if (this._printPageSet.hasOwnProperty(page)) {
				if (this._printPageSet[page]) {
					this._printButton.enable();
					return;
				}
			}
		}
		this._printButton.disable();
	},

	_getSelectedPrintScale: function () {
		return this._defaultScale * this._zoomLevel / 100;
	},

	/**
	 * Removes the the template selector
	 *
	 * @method hide
	 */
	hide: function () {
		this.dialog.closeDialog();
	}
});
/**
 * The main class of the Pedigree Editor, responsible for initializing all the basic elements of the app.
 * Contains wrapper methods for the most commonly used functions.
 * This class should be initialized only once.
 *
 * @class PedigreeEditor
 * @constructor
 */
var PedigreeEditor = Class.create({
	initialize: function () {
		//this.DEBUG_MODE = true;
		window.editor = this;

		// Available options:
		//
		//  nonStandardAdoptedOutGraphic: {true|false}   - use out-brackets for adopted out persons; default "false"
		//  hideDraggingHint:             {true|false}   - do not display the hint on top of the legend; default "false"
		//  propagateFatherLastName:      {true|false}   - auto-propagate father's last name or not; default: "true"
		//  dateDisplayFormat:            {"MDY"|"DMY"|"MY"|"MMY"}  - date display format; default "MDY"; MY = "02-2015", MMY = "Feb 2015"
		//  dateEditFormat:               {"YMD"|"DMY"|"MY"}  - defines order of fields in the date picker; default "YMD"
		//  drawNodeShadows:              {true|false}   - display small shadow under node graphic; default: "true"
		//  disabledFields:               [array]        - list of node-menu fields disabled for this installation
		//  displayCancerLabels:          {true|false}   - display labels for each afecting cancer; default: "true"
		//
		this._defaultPreferences = { global: { nonStandardAdoptedOutGraphic: false,
			propagateFatherLastName: false,
			dateDisplayFormat: "YMD",
			dateEditFormat: "YMD",
			drawNodeShadows: true,
			disabledFields: [],
			displayCancerLabels: true },
			user: { hideDraggingHint: false,
				firstName: "",
				lastName: "" },
			pedigree: {}
		};
		this._preferencesManager = new PreferencesManager(this._defaultPreferences);

		// initialize main data structure which holds the graph structure
		this._graphModel = DynamicPositionedGraph.makeEmpty(PedigreeEditorParameters.attributes.layoutRelativePersonWidth, PedigreeEditorParameters.attributes.layoutRelativeOtherWidth);

		//initialize the elements of the app
		this._workspace = new Workspace();
		this._unRenderedLegend = new unRenderedLegend();
		this._disorderLegend = new DisorderLegend();
		this._geneLegend = new GeneLegend();
		this._hpoLegend = new HPOLegend();
		this._cancerLegend = new CancerLegend();

		this._nodetypeSelectionBubble = new NodetypeSelectionBubble(false);
		this._siblingSelectionBubble = new NodetypeSelectionBubble(true);
		this._okCancelDialogue = new OkCancelDialogue();

		this._view = new View();

		this._actionStack = new UndoRedoManager();
		this._templateSelector = new TemplateSelector();
		this._saveLoadIndicator = new SaveLoadIndicator();
		this._versionUpdater = new VersionUpdater();
		this._saveLoadEngine = new SaveLoadEngine();
		this._probandData = new ProbandDataLoader();

		this._preferencesManager.load(function () {
			Helpers.copyProperties(PedigreeEditorParameters.styles.blackAndWhite, PedigreeEditorParameters.attributes);

			//The line is commented by Soheil for GEL(GenomicsEngland)
			//_saveLoadEngine will set the proband details
			//this._probandData.load( this._saveLoadEngine.load.bind(this._saveLoadEngine) );
			this._saveLoadEngine.load(this._probandData);

			// generate various dialogues after preferences have been loaded
			this._nodeMenu = this.generateNodeMenu();
			this._nodeGroupMenu = this.generateNodeGroupMenu();
			this._partnershipMenu = this.generatePartnershipMenu();
			this._importSelector = new ImportSelector();
			this._exportSelector = new ExportSelector();
			this._printDialog = new PrintDialog();
		}.bind(this));

		this._controller = new Controller();

		//attach actions to buttons on the top bar
		var undoButton = $('action-undo');
		undoButton && undoButton.on("click", function (event) {
			document.fire("pedigree:undo");
		});
		var redoButton = $('action-redo');
		redoButton && redoButton.on("click", function (event) {
			document.fire("pedigree:redo");
		});

		var autolayoutButton = $('action-layout');
		autolayoutButton && autolayoutButton.on("click", function (event) {
			document.fire("pedigree:autolayout");
		});
		var clearButton = $('action-clear');
		clearButton && clearButton.on("click", function (event) {
			document.fire("pedigree:graph:clear");
		});

		var saveButton = $('action-save');
		saveButton && saveButton.on("click", function (event) {
			editor.getSaveLoadEngine().save();
		});


		//Added for GEL(GenomicsEngland) ........................................................................
		//Add eventHandler for saveAndExit button, it should actually call save and also pass a callBack
		//which is a close function. Once the save is done, it will check if callback exists and then calls that
		var saveAndExitButton = $('action-saveAndExit');
		saveAndExitButton && saveAndExitButton.on("click", function (event) {
			editor.getSaveLoadEngine().save(onCloseButtonClickFunc);
		});

        var resetFunction = function() {
            this._probandData = new ProbandDataLoader();
			//editor.getSaveLoadEngine().reset(function () {
			editor.getSaveLoadEngine().load(function () {
                //editor.getSaveLoadEngine().load(editor._probandData);
            });
        }

        var resetButton = $('action-reset');
        resetButton && resetButton.on("click", function (event) {
			/*
			 if (confirm('You are about to delete the Pedigrees for this Proband and all user-added information will be lost and need to be re-input.\n\nDo you want to continue?')) {
			 this._probandData = new ProbandDataLoader();
			 editor.getSaveLoadEngine().reset(function () {
			 editor.getSaveLoadEngine().load(editor._probandData);
			 });
			 }
			 */
            editor.getOkCancelDialogue().showCustomized('You are about to delete the Pedigrees for this Proband and all user-added information will be lost and will need to be re-input.\n\nDo you want to continue?',
                'Are you sure you want to continue?',
                "Yes", resetFunction,
                "No", null);

        });

		//........................................................................................................


		var templatesButton = $('action-templates');
		templatesButton && templatesButton.on("click", function (event) {
			editor.getTemplateSelector().show();
		});
		var importButton = $('action-import');
		importButton && importButton.on("click", function (event) {
			editor.getImportSelector().show();
		});
		var exportButton = $('action-export');
		exportButton && exportButton.on("click", function (event) {
			editor.getExportSelector().show();
		});
		var printButton = $('action-print');
		printButton && printButton.on("click", function (event) {
			editor.getPrintDialog().show();
		});

		var onLeavePageFunc = function () {
			if (!editor.isReadOnlyMode() && editor.getUndoRedoManager().hasUnsavedChanges()) {
				return "All changes will be lost when navigating away from this page.";
			}
		};
		setTimeout(function(){
            window.addEventListener("beforeonload",onLeavePageFunc);
        },200)

		var onCloseButtonClickFunc = function (event) {
			var dontQuitFunc = function () {
				window.onbeforeunload = onLeavePageFunc;
			};
			var quitFunc = function () {

				//Added by Soheil for GEL(GenomicsEngland)
				//If the backend is OpenClinica, by click on Close button, got to "returnURL" which is provided in the URL
				var settings = new Settings();
				var config = settings.getSetting('diagramEndpoint');
				if(config.service == "openclinica" || config.service == "mercury"){
					var webService = new WebService();
					var returnURL = webService.getUrlParameter("returnURL", true);
					var status = webService.getUrlParameter("status", true);
					//In case of OpenClinica, if it is in new mode, the pedigree CRF might not have been saved yet,
					//and as the main CRF page is still open, so just close this
					if(config.service == "openclinica" && status == "new"){
						window.close();
						return;
					}
					//for Mercury and OpenClinica(status=edit), go to the returnURL
					if(returnURL){
						window.location = decodeURIComponent(returnURL);
					}else{
						//do nothing for now
					}
				}
				//........................................................................................
			};
			var saveAndQuitFunc = function () {
				editor._afterSaveFunc = quitFunc;
				editor.getSaveLoadEngine().save();
			}


			
			var settings = new Settings();
			var saveAndExit = settings.getSetting('saveAndExit');
			//Added for GEL(GenomicsEngland)
			//condition "saveAndExit === true" is added for GEL
			//if saveAndExit is True, it means that the save is already called successfully and we are here!
			//so we can then call quitFunc to quit the app
			if (editor.isReadOnlyMode() || saveAndExit === true) {
				quitFunc();
			} else {
				window.onbeforeunload = undefined;

				if (editor.getUndoRedoManager().hasUnsavedChanges()) {
					editor.getOkCancelDialogue().showCustomized('There are unsaved changes, do you want to save the pedigree before closing the pedigree editor?',
						'Save before closing?',
						"Save", saveAndQuitFunc,
						"Don't save", quitFunc,
						"Don't close", dontQuitFunc, true);
				} else {
					quitFunc();
				}
			}
		};
		var closeButton = $('action-close');
		this._afterSaveFunc = null;
		closeButton && (closeButton.onclick = onCloseButtonClickFunc);

		var renumberButton = $('action-number');
		renumberButton && renumberButton.on("click", function (event) {
			document.fire("pedigree:renumber");
		});

		var unsupportedBrowserButton = $('action-readonlymessage');
		unsupportedBrowserButton && unsupportedBrowserButton.on("click", function (event) {
			alert("Your browser does not support all the features required for " +
				"Pedigree Editor, so pedigree is displayed in read-only mode (and may have quirks).\n\n" +
				"Supported browsers include Firefox v3.5+, Internet Explorer v9+, " +
				"Chrome, Safari v4+, Opera v10.5+ and most mobile browsers.");
		});

		//this.startAutoSave(30);
	},

	/**
	 * @method getPreferencesManager
	 * @return {PreferencesManager}
	 */
	getPreferencesManager: function () {
		return this._preferencesManager;
	},

	/**
	 * Returns the graph node with the corresponding nodeID
	 * @method getNode
	 * @param {Number} nodeID The id of the desired node
	 * @return {AbstractNode} the node whose id is nodeID
	 */
	getNode: function (nodeID) {
		return this.getView().getNode(nodeID);
	},

	/**
	 * @method getView
	 * @return {View} (responsible for managing graphical representations of nodes and interactive elements)
	 */
	getView: function () {
		return this._view;
	},

	/**
	 * @method getVersionUpdater
	 * @return {VersionUpdater}
	 */
	getVersionUpdater: function () {
		return this._versionUpdater;
	},

	/**
	 * @method getGraph
	 * @return {DynamicPositionedGraph} (data model: responsible for managing nodes and their positions)
	 */
	getGraph: function () {
		return this._graphModel;
	},

	/**
	 * @method getController
	 * @return {Controller} (responsible for managing user input and corresponding data changes)
	 */
	getController: function () {
		return this._controller;
	},

	/**
	 * @method getUndoRedoManager
	 * @return {UndoRedoManager} (responsible for undoing and redoing actions)
	 */
	getUndoRedoManager: function () {
		return this._actionStack;
	},

	/**
	 * The action which should happen after pedigree is saved
	 * (normally null, close the editor when "save on quit")
	 */
	getAfterSaveAction: function () {
		return this._afterSaveFunc;
	},

	/**
	 * @method getOkCancelDialogue
	 * @return {OkCancelDialogue} (responsible for displaying ok/cancel prompts)
	 */
	getOkCancelDialogue: function () {
		return this._okCancelDialogue;
	},

	/**
	 * @method getNodetypeSelectionBubble
	 * @return {NodetypeSelectionBubble} (floating window with initialization options for new nodes)
	 */
	getNodetypeSelectionBubble: function () {
		return this._nodetypeSelectionBubble;
	},

	/**
	 * @method getSiblingSelectionBubble
	 * @return {NodetypeSelectionBubble} (floating window with initialization options for new sibling nodes)
	 */
	getSiblingSelectionBubble: function () {
		return this._siblingSelectionBubble;
	},

	/**
	 * @method getWorkspace
	 * @return {Workspace}
	 */
	getWorkspace: function () {
		return this._workspace;
	},

	/**
	 * @method getDisorderLegend
	 * @return {Legend} Responsible for managing and displaying the disorder legend
	 */
	getDisorderLegend: function () {
		return this._disorderLegend;
	},

	/**
	 * @method getHPOLegend
	 * @return {Legend} Responsible for managing and displaying the phenotype/HPO legend
	 */
	getHPOLegend: function () {
		return this._hpoLegend;
	},

	/**
	 * @method getGeneLegend
	 * @return {Legend} Responsible for managing and displaying the candidate genes legend
	 */
	getGeneLegend: function () {
		return this._geneLegend;
	},

	/**
	 * @method getCancerLegend
	 * @return {Legend} Responsible for managing and displaying the common cancers legend
	 */
	getCancerLegend: function () {
		return this._cancerLegend;
	},

    getUnmappedPersonLegend: function () {
        return this._unmappedPersonLegend;
    },

	/**
	 * @method getPaper
	 * @return {Workspace.paper} Raphael paper element
	 */
	getPaper: function () {
		return this.getWorkspace().getPaper();
	},

	/**
	 * @method isReadOnlyMode
	 * @return {Boolean} True iff pedigree drawn should be read only with no handles
	 *                   (read-only mode is used for IE8 as well as for template display and
	 *                   print and export versions).
	 */
	isReadOnlyMode: function () {
		if (this.isUnsupportedBrowser()) return true;
		return false;
	},

	isUnsupportedBrowser: function () {
		// http://voormedia.com/blog/2012/10/displaying-and-detecting-support-for-svg-images
		if (!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")) {
			// implies unpredictable behavior when using handles & interactive elements,
			// and most likely extremely slow on any CPU
			return true;
		}
		// http://kangax.github.io/es5-compat-table/
		if (!window.JSON) {
			// no built-in JSON parser - can't proceed in any way; note that this also implies
			// no support for some other functions such as parsing XML.
			//
			// TODO: include free third-party JSON parser and replace XML with JSON when loading data;
			//       (e.g. https://github.com/douglascrockford/JSON-js)
			//
			//       => at that point all browsers which suport SVG but are treated as unsupported
			//          should theoreticaly start working (FF 3.0, Safari 3 & Opera 9/10 - need to test).
			//          IE7 does not support SVG and JSON and is completely out of the running;
			alert("Your browser is not supported and is unable to load and display any pedigrees.\n\n" +
				"Suported browsers include Internet Explorer version 9 and higher, Safari version 4 and higher, " +
				"Firefox version 3.6 and higher, Opera version 10.5 and higher, any version of Chrome and most " +
				"other modern browsers (including mobile). IE8 is able to display pedigrees in read-only mode.");
			window.stop && window.stop();
			return true;
		}
		return false;
	},

	/**
	 * @method getSaveLoadEngine
	 * @return {SaveLoadEngine} Engine responsible for saving and loading operations
	 */
	getSaveLoadEngine: function () {
		return this._saveLoadEngine;
	},

	/**
	 * @method getProbandDataFromPhenotips
	 * @return {firstName: "...", lastName: "..."}
	 */
	getProbandDataFromPhenotips: function () {
		return this._probandData.probandData;
	},

	/**
	 * @method getTemplateSelector
	 * @return {TemplateSelector}
	 */
	getTemplateSelector: function () {
		return this._templateSelector
	},

	/**
	 * @method getImportSelector
	 * @return {ImportSelector}
	 */
	getImportSelector: function () {
		return this._importSelector
	},

	/**
	 * @method getExportSelector
	 * @return {ExportSelector}
	 */
	getExportSelector: function () {
		return this._exportSelector
	},

	/**
	 * @method getPrintDialog
	 * @return {PrintDialog}
	 */
	getPrintDialog: function () {
		return this._printDialog;
	},

	/**
	 * Returns true if any of the node menus are visible
	 * (since some UI interactions should be disabled while menu is active - e.g. mouse wheel zoom)
	 *
	 * @method isAnyMenuVisible
	 */
	isAnyMenuVisible: function () {
		if (this.getNodeMenu().isVisible() || this.getNodeGroupMenu().isVisible() || this.getPartnershipMenu().isVisible()) {
			return;
		}
	},

	/**
	 * Creates the context menu for Person nodes
	 *
	 * @method generateNodeMenu
	 * @return {NodeMenu}
	 */
	generateNodeMenu: function () {
		if (this.isReadOnlyMode()) return null;
		var _this = this;
		var disabledFields = this.getPreferencesManager().getConfigurationOption("disabledFields");

		var fieldList = [
			{
				'name': 'identifier',
				'label': '',
				'type': 'hidden',
				'tab': 'Personal'
			},
			/*{
			 'name' : 'phenotipsid',
			 'label' : 'Phenotips Patient Link',
			 'type' : 'text', //phenotipsid-picker',
			 'tab' : 'Personal',
			 'function' : 'setPhenotipsPatientId'
			 },*/
			{
				'name': 'gender',
				'label': 'Gender',
				'type': 'select',
				'tab': 'Personal',
				'values': [
					{ 'actual': 'M', 'displayed': 'Male' },
					{ 'actual': 'F', 'displayed': 'Female' },
					{ 'actual': 'O', 'displayed': 'Indeterminate' },
					{ 'actual': 'U', 'displayed': 'Unknown' }
				],
				'default': 'U',
				'function': 'setGender'
			},
			{
				'name': 'karyotypic_sex',
				'label': 'Working Karyotypic Sex',
				'values': [
					{'actual': 'Unknown',displayed:'Unknown'},
					{'actual': 'XY',displayed:'XY'},
					{'actual': 'XX',displayed:'XX'},
					{'actual': 'XO',displayed:'XO'},
					{'actual': 'XXY',displayed:'XXY'},
					{'actual': 'XYY',displayed:'XYY'},
					{'actual': 'XXX',displayed:'XXX'},
					{'actual': 'XXYY',displayed:'XXYY'},
					{'actual': 'XXXY',displayed:'XXXY'},
					{'actual': 'XXXX',displayed:'XXXX'},
					{'actual': 'Other',displayed:'Other'}
				],
				'type': 'select',
				'tab': 'Personal',
				'function': 'setKaryotypicSex',
				'isMultipleSelect': false
			},
			{
				'name' : 'participant_id',
				'label': '&nbsp',
				'type' : 'text',
				'tab': 'Personal',
				'function' : 'setParticipantId'
			},
			//{
			//	'name' : 'family_id',
			//	'label': 'Family ID',
			//	'type' : 'text',
			//	'tab': 'Personal',
			//	'function' : 'setFamilyId'
			//},
		/*	{
				'name': 'gel_super_family_id',
				'label': 'GEL Super Family ID',
				'type': 'text',
				'tab': 'Personal',
				'function': 'setGelSuperFamilyId'
			},*/
			{
				'name' : 'nhs_number',
				'label': 'NHS Number',
				'type' : 'text',
				'tab': 'Personal',
 				'function' : 'setNHSNumber'
			},
      {
        'name' : 'ngisRegisteredPatientUid',
        'label': 'NGIS Patient ID',
        'type' : 'text',
        'tab': 'Personal',
        'function' : 'setNgisRegisteredPatientUid'
			},
			{
        'name' : 'ngisRegisteredPatientSimpleId',
        'label': 'NGIS Patient ID',
        'type' : 'hidden',
        'tab': 'Personal',
				'function' : 'setNgisRegisteredPatientUid'
      },
      {
        'name' : 'nonNgisPatientStableUid',
        'label': 'Non NGIS Patient ID',
        'type' : 'text',
        'tab': 'Personal',
        'function' : 'setNonNgisPatientStableUid'
			},
			
			/*
            {
                'name': 'otherIdentifierType',
                'label': 'Other Identifier Type',
                'type': 'select',
                'tab': 'Personal',
                'values': [
                    { 'actual': 'CHINumber', 'displayed': 'CHI Number' },
                    { 'actual': 'OrganDonorID', 'displayed': 'Organ Donor ID' },
                    { 'actual': 'LocalID', 'displayed': 'Local Identifier' },
                ],
                'default': 'CHINumber',
                'function': 'setOtherIdentifierType'
            },
            {
                'name' : 'otherIdentifier',
                'label': 'Other Identifier ',
                'type' : 'text',
                'tab': 'Personal',
                'function' : 'setOtherIdentifier'
			},*/
			{
                'name' : 'chiNumber',
                'label': 'CHI Number',
                'type' : 'text',
                'tab': 'Personal',
                'function' : 'setChiNumber'
			},
			{
                'name' : 'organDonorId',
                'label': 'Organ Donor ID',
                'type' : 'text',
                'tab': 'Personal',
                'function' : 'setOrganDonorId'
			},
			{
                'name' : 'localIdentifier',
                'label': 'Local Identifier',
                'type' : 'text',
                'tab': 'Personal',
                'function' : 'setLocalIdentifier'
			},
            {
                'name': 'last_name',
                'label': 'Last name',
                'type': 'text',
                'tab': 'Personal',
                'function': 'setLastName'
            },
			{
				'name': 'first_name',
				'label': 'First name',
				'type': 'text',
				'tab': 'Personal',
				'function': 'setFirstName'
			},

			//commented for GEL(GenomicsEngland)
			//{
			//	'name': 'last_name_birth',
			//	'label': 'Last name at birth',
			//	'type': 'text',
			//	'tab': 'Personal',
			//	'function': 'setLastNameAtBirth'
			//},
			{
				'name': 'ethnicity',
				'label': 'Ethnicity',
				'values': [
                    {'actual': 'A','displayed':'British, Mixed British'},
                    {'actual': 'B','displayed':'Irish'},
                    {'actual': 'C','displayed':'Any other White background'},
                    {'actual': 'C2','displayed':'Northern Irish'},
                    {'actual': 'C3','displayed':'Other white, white unspecified'},
                    {'actual': 'CA','displayed':'English'},
                    {'actual': 'CB','displayed':'Scottish'},
                    {'actual': 'CC','displayed':'Welsh'},
                    {'actual': 'CD','displayed':'Cornish'},
                    {'actual': 'CE','displayed':'Cypriot (part not stated)'},
                    {'actual': 'CF','displayed':'Greek'},
                    {'actual': 'CG','displayed':'Greek Cypriot'},
                    {'actual': 'CH','displayed':'Turkish'},
                    {'actual': 'CJ','displayed':'Turkish Cypriot'},
                    {'actual': 'CK','displayed':'Italian'},
                    {'actual': 'CL','displayed':'Irish Traveller'},
                    {'actual': 'CM','displayed':'Traveller'},
                    {'actual': 'CN','displayed':'Gypsy/Romany'},
                    {'actual': 'CP','displayed':'Polish'},
                    {'actual': 'CQ','displayed':'All republics which made up the former USSR'},
                    {'actual': 'CR','displayed':'Kosovan'},
                    {'actual': 'CS','displayed':'Albanian'},
                    {'actual': 'CT','displayed':'Bosnian'},
                    {'actual': 'CU','displayed':'Croatian'},
                    {'actual': 'CV','displayed':'Serbian'},
                    {'actual': 'CW','displayed':'Other republics which made up the former Yugoslavia'},
                    {'actual': 'CX','displayed':'Mixed white'},
                    {'actual': 'CY','displayed':'Other white European, European unspecified, European mixed'},
                    {'actual': 'D','displayed':'White and Black Caribbean'},
                    {'actual': 'E','displayed':'White and Black African'},
                    {'actual': 'F','displayed':'White and Asian'},
                    {'actual': 'G','displayed':'Any other mixed background'},
                    {'actual': 'GA','displayed':'Black and Asian'},
                    {'actual': 'GB','displayed':'Black and Chinese'},
                    {'actual': 'GC','displayed':'Black and White'},
                    {'actual': 'GD','displayed':'Chinese and White'},
                    {'actual': 'GE','displayed':'Asian and Chinese'},
                    {'actual': 'GF','displayed':'Other Mixed, Mixed Unspecified'},
                    {'actual': 'H','displayed':'Indian or British Indian'},
                    {'actual': 'J','displayed':'Pakistani or British Pakistani'},
                    {'actual': 'K','displayed':'Bangladeshi or British Bangladeshi'},
                    {'actual': 'L','displayed':'Any other Asian background'},
                    {'actual': 'LA','displayed':'Mixed Asian'},
                    {'actual': 'LB','displayed':'Punjabi'},
                    {'actual': 'LC','displayed':'Kashmiri'},
                    {'actual': 'LD','displayed':'East African Asian'},
                    {'actual': 'LE','displayed':'Sri Lanka'},
                    {'actual': 'LF','displayed':'Tamil'},
                    {'actual': 'LG','displayed':'Sinhalese'},
                    {'actual': 'LH','displayed':'British Asian'},
                    {'actual': 'LJ','displayed':'Caribbean Asian'},
                    {'actual': 'LK','displayed':'Other Asian, Asian unspecified'},
                    {'actual': 'M','displayed':'Caribbean'},
                    {'actual': 'N','displayed':'African'},
                    {'actual': 'P','displayed':'Any other Black background'},
                    {'actual': 'PA','displayed':'Somali'},
                    {'actual': 'PB','displayed':'Mixed Black'},
                    {'actual': 'PC','displayed':'Nigerian'},
                    {'actual': 'PD','displayed':'Black British'},
                    {'actual': 'PE','displayed':'Other Black, Black unspecified'},
                    {'actual': 'R','displayed':'Chinese'},
                    {'actual': 'S','displayed':'Any other ethnic group'},
                    {'actual': 'SA','displayed':'Vietnamese'},
                    {'actual': 'SB','displayed':'Japanese'},
                    {'actual': 'SC','displayed':'Filipino'},
                    {'actual': 'SD','displayed':'Malaysian'},
                    {'actual': 'SE','displayed':'Any Other Group'},
                    {'actual': 'Z','displayed':'Not stated'}

				],
				'type': 'select',//'ethnicity-picker',
				'tab': 'Personal',
				'function': 'setEthnicities',
				'isMultipleSelect': true
			},
            {
                'name': 'clinicalIndicationName',
                'label': 'Clinical Indication Name',
                'type': 'text',
                'tab': 'Clinical',
                'function': 'setClinicalIndicationName'
            },
            {
                'name': 'clinicalIndicationAgeOfOnsetYears',
                'label': 'Age at Onset (Y)',
                'type': 'select',
                'range': {'start': 0, 'end': 100, 'item': ['year', 'years']},
                'tab': 'Clinical',
                'function': 'setClinicalIndicationAgeOfOnsetYears'
            },
            {
                'name': 'clinicalIndicationAgeOfOnsetMonths',
                'label': 'Age at Onset (m)',
                'type':'select',
                'range': {'start': -9, 'end': 11, 'default':'0', 'item': ['month', 'months']},
				'default':'0',
				'tab': 'Clinical',
                'function': 'setClinicalIndicationAgeOfOnsetMonths'
            },
			{
				'name': 'carrierStatus',
				'label': 'Disease status',
				'type': 'radio',
				'tab': 'Clinical',
				'values': [
					{ 'actual': 'Unaffected', 'displayed': 'Unaffected' },
					{ 'actual': 'Affected', 'displayed': 'Affected' },
					{ 'actual': 'Uncertain', 'displayed': 'Uncertain' },
                    { 'actual': 'Unknown', 'displayed': 'Unknown' }

                ],
				'default': 'Unknown',
				'function': 'setCarrierStatus'
			},
			{
				'label' : "<i class='fa fa-info-circle' aria-hidden='true'></i> Please select coding system for disorder search:",
				'name' : 'disorderType',
				'type' : 'select',
				'tab': 'Clinical',
				'values' : [
					{'actual': 'OMIM', displayed: 'OMIM'},
					{'actual': 'Orphanet',  displayed: 'Orphanet'},
				],
				'function' : 'setDisorderType'
			},
            {
                'label': 'Diagnosis Certainty',
                'name' : 'diagnosisCertainty',
                'type': 'select',
                'values' : [
                    {'actual': 'Suspected', displayed: 'Suspected'},
                    {'actual': 'Confirmed', displayed: 'Confirmed'}
                ],
                'tab': 'Clinical',
                'function' : 'setDiagnosisCertainty'
            },
            {
                'name': 'disorders',
                'label': 'Disorder',
                'type': 'disease-picker',
                'tab': 'Clinical',
                'function': 'setDisorders'
            },
			/*{
			 	'name': 'consanguineous_population',
			 	'label': 'Consanguineous Population',
			 	'type': 'text',
			 	'tab': 'Clinical',
			 	'function': 'setConsanguineousPopulation'
			 },
			 {
			 	'name': 'ancestries',
			 	'label': 'Ancestries',
			 	'type': 'textarea',
			 	 'columns':4,
			  	'tab': 'Clinical',
			 	'function': 'setAncestries'
			 },*/

			{
				'name': 'hpo_positive',
				'label': 'Phenotype',
				'type': 'hpo-picker',
				'tab': 'Phenotype',
				'function': 'setHPO'
			},
			{
				'name' : 'hpoPresent',
				'label': 'HPO Present',
				'type': 'select',
				'tab': 'Phenotype',
				'values' : [
					{'actual': 'Present', displayed: 'Present'},
					{'actual': 'Absent', displayed: 'Absent'},
					{'actual': 'Unknown', displayed: 'Unknown'},
				],
				'function' : 'setHPOPresent'
			},
          /*  {
                'name': 'hpoModifier',
                'label': 'Phenotype',
                'type': 'hpo-modifier-picker',
                'tab': 'Phenotype',
                'function': 'setHPOModifier'
            },*/
			//Commented for GEL(GenomicsEngland)
			/*{
				'name': 'candidate_genes',
				'label': 'Genotype information: candidate genes',
				'type': 'gene-picker',
				'tab': 'Clinical',
				'function': 'setGenes'
			},*/
			{
				'name': 'age_of_death_guide',
				'label': "<i class='fa fa-info-circle' aria-hidden='true'></i> Please use either 'Age of death' or 'Date of birth/death'",
				'type': 'label',
				'tab': 'Personal'
			},

			{
				'name': 'age_of_death',
				'label': "Age at death",
				'type': 'text',
				'tab': 'Personal',
				'function': 'setAgeOfDeath'
			},
			{
				'name': 'age_of_death_format',
				'label': "",
				'type': 'select',
				'tab': 'Personal',
				'function': 'setAgeOfDeathFormat',
				'values' : [
					{'actual': 'y', displayed: 'Year'},
					{'actual': 'mo', displayed: 'Month'},
					{'actual': 'wk', displayed: 'Week'},
					{'actual': 'd', displayed: 'Day'}
				]
			},
			{
				'name': 'date_of_birth',
				'label': 'Date of birth',
				'type': 'date-picker',
				'tab': 'Personal',
				'function': 'setBirthDate'
			},
			{
				'name': 'date_of_death',
				'label': 'Date of death',
				'type': 'date-picker',
				'tab': 'Personal',
				'function': 'setDeathDate'
			},

      {
        'name': 'gestationAgeWeeks',
        'label': 'Gestation age',
        'type': 'select',
        'tab': 'Personal',
				'range': {'start': 0, 'end': 50, 'item': ['week', 'weeks']},
        'nullValue': true,
        'function': 'setGestationAgeWeeks'
			},

	{

		'name': 'gestationAgeDays',
		'label': '  ',
        'type': 'select',
        'tab': 'Personal',
        'range': {'start': 0, 'end': 6, 'item': ['day', 'days']},
        'nullValue': true,
        'function': 'setGestationAgeDays'
      },

			{
        'name': 'estimatedDateOfDelivery',
        'label': 'Estimated Date Of Delivery',
        'type': 'date-picker',
        'tab': 'Personal',
        'function': 'setEstimatedDateOfDelivery'
			},

			{
				'name': 'state',
				'label': 'Individual is',
				'type': 'radio',
				'tab': 'Personal',
				'columns': 3,
				'valuesIE9': [
					// different order of options because they are displayed sequentially instead of in 3-column layout
					{ 'actual': 'Alive', 'displayed': 'Alive' },
					{ 'actual': 'Deceased', 'displayed': 'Deceased' },
					{ 'actual': 'Stillborn', 'displayed': 'Stillborn' },
					{ 'actual': 'Unborn', 'displayed': 'Unborn' },
					{ 'actual': 'Miscarriage', 'displayed': 'Miscarried' },
					{ 'actual': 'Aborted', 'displayed': 'Elective abortion' }
				],
				'values': [
					{ 'actual': 'Alive', 'displayed': 'Alive' },
					{ 'actual': 'Stillborn', 'displayed': 'Stillborn' },
					{ 'actual': 'Deceased', 'displayed': 'Deceased', 'columnshiftPX': -2 },
					{ 'actual': 'Miscarriage', 'displayed': 'Miscarried', 'columnshiftPX': -2},
					{ 'actual': 'Unborn', 'displayed': 'Unborn', 'columnshiftPX': 8 },
					{ 'actual': 'Aborted', 'displayed': 'Aborted', 'columnshiftPX': 8 }
				],
				'default': 'Alive',
				'function': 'setLifeStatus'
			},
			{
				'label': 'Heredity options',
				'name': 'childlessSelect',
				'values': [
					{'actual': 'None', displayed: 'None'},
					{'actual': 'Childless', displayed: 'Childless'},
					{'actual': 'Infertile', displayed: 'Infertile'}
				],
				'type': 'select',
				'tab': 'Personal',
				'function': 'setChildlessStatus'
			},
			{
				'name': 'childlessText',
				'type': 'text',
				'dependency': 'childlessSelect != None',
				'dependencyShowInline': true,
				'tip': 'Reason',
				'tab': 'Personal',
				'function': 'setChildlessReason'
			},
            {
                'name' : 'participatingInTest',
                'label': 'Participating In Test',
                'type' : 'checkbox',
                'tab': 'Personal',
                'function' : 'setParticipatingInTest'
            },
			{
				'name': 'adopted',
				'label': 'Adopted status',
				'type': 'radio',
				'tab': 'Personal',
				'columns': 3,
				'values': [
					{ 'actual': '', 'displayed': 'Not adopted' },
					{ 'actual': 'adoptedIn', 'displayed': 'Adopted in' },
					{ 'actual': 'adoptedOut', 'displayed': 'Adopted out' }
				],
				'default': '',
				'function': 'setAdopted'
			},
			{
			 'name': 'comments',
			 'label': 'Comments',
			 'type': 'textarea',
			 'rows': 4,
			 'tab': 'Personal',
			 'function': 'setComments'
			 },
           /* {
                'name': 'comments',
                'label': 'Comments',
                'type': 'text',
                //'rows': 4,
                'tab': 'Personal',
                'function': 'setComments'
            },*/
			{
				'name': 'monozygotic',
				'label': 'Monozygotic twin',
				'type': 'checkbox',
				'tab': 'Personal',
				'function': 'setMonozygotic'
			},
			{
				'name': 'nocontact',
				'label': 'Not in contact with proband',
				'type': 'checkbox',
				'tab': 'Personal',
				'function': 'setLostContact'
			},
			{
				'name': 'placeholder',
				'label': 'Placeholder node',
				'type': 'checkbox',
				'tab': 'Personal',
				'function': 'makePlaceholder'
			},
			// {
			// 	'name': 'commentsClinical',
			// 	'label': 'Comments',
			// 	'type': 'textarea',
			// 	'tab': 'Clinical',
			// 	'function': 'setComments'
			// },
			{
				'name': 'evaluated',
				'label': 'Documented evaluation',
				'type': 'checkbox',
				'tab': 'Clinical',
				'function': 'setEvaluated'
			},
            {
                'name': 'numberOfColorectalPolypsTotal',
                'label': 'Number Of Colorectal Polyps Total',
                'type': 'text',
                'tab': 'Tumours',
                'function': 'setNumberOfColorectalPolypsTotal'
            },
            {
                'name': 'numberOfColorectalPolypsAdenomas',
                'label': 'Number of Colorectal Polyps Adenomas',
                'type': 'text',
                'tab': 'Tumours',
                'function': 'setNumberOfColorectalPolypsAdenomas'
            }
			,
		/*{   'name': 'cancers',
				'label': 'Common Cancers',
				'type': 'cancerlist',
				'tab': 'Tumors',
				'function': 'setCancers'
			},*/
            {   'name': 'lastMenstralPeriod',
                'label': 'last menstral period',
                'type': 'text',
                'tab': 'Personal',
                'function': 'setLastMenstralPeriod'
            },
			/*{
				'name': 'commentsCancers',
				'label': 'Comments',
				'type': 'textarea',
				'tab': 'Tumors',
				'rows': 2,
				'function': 'setComments'
			}*/
		];

		function isDisabled(field) {
			if (Helpers.arrayContains(disabledFields, field.name)) {
				return false;
			}
			return true;
		}

		//'Cancers' tab removed for GEL(GenomicsEngland)
		//return new NodeMenu(fieldList.filter(isDisabled), ["Personal", "Clinical", "Cancers"]);
		return new NodeMenu(fieldList.filter(isDisabled), ["Personal", "Clinical","Phenotype", "Tumours"]);
	},

	/**
	 * @method getNodeMenu
	 * @return {NodeMenu} Context menu for nodes
	 */
	getNodeMenu: function () {
		return this._nodeMenu;
	},

	/**
	 * Creates the context menu for PersonGroup nodes
	 *
	 * @method generateNodeGroupMenu
	 * @return {NodeMenu}
	 */
	generateNodeGroupMenu: function () {
		if (this.isReadOnlyMode()) return null;
		var _this = this;
		return new NodeMenu([
			{
				'name': 'identifier',
				'label': '',
				'type': 'hidden',
				'tab': 'Personal'
			},
			{
				'name': 'gender',
				'label': 'Gender',
				'type': 'select',
				'columns': 3,
				'values': [
					{ 'actual': 'Male', 'displayed': 'Male' },
					{ 'actual': 'Female', 'displayed': 'Female' },
					{ 'actual': 'Indeterminate', 'displayed': 'Indeterminate' },
					{ 'actual': 'Unknown', 'displayed': 'Unknown' }
				],
				'default': 'U',
				'tab': 'Personal',
				'function': 'setGender'
			},
			{
				'name': 'karyotypic_sex',
				'label': 'Working Karyotypic Sex',
				'values': [
					{'actual': 'Unknown',displayed:'Unknown'},
					{'actual': 'XY',displayed:'XY'},
					{'actual': 'XX',displayed:'XX'},
					{'actual': 'XO',displayed:'XO'},
					{'actual': 'XXY',displayed:'XXY'},
					{'actual': 'XYY',displayed:'XYY'},
					{'actual': 'XXX',displayed:'XXX'},
					{'actual': 'XXYY',displayed:'XXYY'},
					{'actual': 'XXXY',displayed:'XXXY'},
					{'actual': 'XXXX',displayed:'XXXX'},
					{'actual': 'Other',displayed:'Other'}
				],
				'type': 'select',
				'tab': 'Personal',
				'function': 'setKaryotypicSex',
				'isMultipleSelect': false
			},
			{
				'name': 'numInGroup',
				'label': 'Number of persons in this group',
				'type': 'select',
				'values': [
					{'actual': 1, displayed: 'N'},
					{'actual': 2, displayed: '2'},
					{'actual': 3, displayed: '3'},
					{'actual': 4, displayed: '4'},
					{'actual': 5, displayed: '5'},
					{'actual': 6, displayed: '6'},
					{'actual': 7, displayed: '7'},
					{'actual': 8, displayed: '8'},
					{'actual': 9, displayed: '9'}
				],
				'tab': 'Personal',
				'function': 'setNumPersons'
			},
			{
				'name': 'external_ids',
				'label': 'External ID(s)',
				'type': 'text',
				'tab': 'Personal',
				'function': 'setExternalID'
			},
			{
				'name': 'ethnicity',
				'label': 'Ethnicities<br>(common to all individuals in the group)',
				'values': [
					{'actual': 'A',displayed:'White: British'},
					{'actual': 'B',displayed:'White: Irish'},
					{'actual': 'C',displayed:'White: Any other White background'},
					{'actual': 'D',displayed:'Mixed: White and Black Caribbean'},
					{'actual': 'E',displayed:'Mixed: White and Black African'},
					{'actual': 'F',displayed:'Mixed: White and Asian'},
					{'actual': 'G',displayed:'Mixed: Any other mixed background'},
					{'actual': 'H',displayed:'Asian or Asian British: Indian'},
					{'actual': 'J',displayed:'Asian or Asian British: Pakistani'},
					{'actual': 'K',displayed:'Asian or Asian British: Bangladeshi'},
					{'actual': 'L',displayed:'Asian or Asian British: Any other Asian background'},
					{'actual': 'M',displayed:'Black or Black British: Caribbean'},
					{'actual': 'N',displayed:'Black or Black British: African'},
					{'actual': 'P',displayed:'Black or Black British: Any other Black background'},
					{'actual': 'R',displayed:'Other Ethnic Groups: Chinese'},
					{'actual': 'S',displayed:'Other Ethnic Groups: Any other ethnic group'},
					{'actual': 'Z',displayed:'Not stated'}
				],
				'type': 'select',
				'tab': 'Personal',
				'function': 'setEthnicities',
				'isMultipleSelect': true
			},
			{
				'label' : "<i class='fa fa-info-circle' aria-hidden='true'></i> Please select coding system for disorder search:",
				'name' : 'disorderType',
				'type' : 'select',
				'tab': 'Clinical',
				'values' : [
					{'actual': 'OMIM',  displayed: 'OMIM'},
					{'actual': 'Orphanet', displayed: 'Orphanet'}
				],
				'function' : 'setDisorderType'
			},
			{
				'name': 'disorders',
				'class': 'disordersNodeGroup',
				'label': 'Known disorders<br>(common to all individuals in the group)',
				'type': 'disease-picker',
				'tab': 'Clinical',
				'function': 'setDisorders'
			},
			{
				'name': 'comments',
				'label': 'Comments',
				'type': 'textarea',
				'rows': 4,
				'tab': 'Clinical',
				'function': 'setComments'
			},
			{
				'name': 'adopted',
				'label': 'Adopted status',
				'type': 'radio',
				'tab': 'Personal',
				'columns': 3,
				'values': [
					{ 'actual': '', 'displayed': 'Not adopted' },
					{ 'actual': 'adoptedIn', 'displayed': 'Adopted in' },
					{ 'actual': 'adoptedOut', 'displayed': 'Adopted out' }
				],
				'default': '',
				'tab': 'Personal',
				'function': 'setAdopted'
			},
			{
				'name': 'state',
				'class': 'stateNodeGroup',
				'label': 'All individuals in the group are',
				'type': 'radio',
				'values': [
					{ 'actual': 'Alive', 'displayed': 'Alive' },
					{ 'actual': 'Aborted', 'displayed': 'Aborted electively' },
					{ 'actual': 'Deceased', 'displayed': 'Deceased' },
					{ 'actual': 'Miscarriage', 'displayed': 'Miscarried' }
				],
				'default': 'Alive',
				'tab': 'Personal',
				'function': 'setLifeStatus'
			},
			{
				'name': 'evaluatedGrp',
				'label': 'Documented evaluation',
				'type': 'checkbox',
				'tab': 'Clinical',
				'function': 'setEvaluated'
			}

		], ["Personal", "Clinical"]);
	},

	/**
	 * @method getNodeGroupMenu
	 * @return {NodeMenu} Context menu for nodes
	 */
	getNodeGroupMenu: function () {
		return this._nodeGroupMenu;
	},

	/**
	 * Creates the context menu for Partnership nodes
	 *
	 * @method generatePartnershipMenu
	 * @return {NodeMenu}
	 */
	generatePartnershipMenu: function () {
		if (this.isReadOnlyMode()) return null;
		var _this = this;
		return new NodeMenu([
			{
				'name': 'consangr',
				'label': 'Consanguinity of this relationship',
				'type': 'radio',
				'values': [
					{ 'actual': 'A', 'displayed': 'Automatic' },
					{ 'actual': 'Y', 'displayed': 'Yes' },
					{ 'actual': 'P', 'displayed': 'Possible' },
					{ 'actual': 'U', 'displayed': 'Unknown' },
					{ 'actual': 'N', 'displayed': 'No' }
				],
				'default': 'A',
				'function': 'setConsanguinity'
			},
			{
				'name': 'broken',
				'label': 'Separated',
				'type': 'checkbox',
				'function': 'setBrokenStatus'
			}
		], [], "relationship-menu");
	},

	/**
	 * @method getPartnershipMenu
	 * @return {NodeMenu} The context menu for Partnership nodes
	 */
	getPartnershipMenu: function () {
		return this._partnershipMenu;
	},

	/**
	 * @method convertGraphCoordToCanvasCoord
	 * @return [x,y] coordinates on the canvas
	 */
	convertGraphCoordToCanvasCoord: function (x, y) {
		var scale = PedigreeEditorParameters.attributes.layoutScale;
		return { x: x * scale.xscale,
			y: y * scale.yscale };
	},

	/**
	 * Starts a timer to save the application state every 30 seconds
	 *
	 * @method initializeSave
	 */
	startAutoSave: function (intervalInSeconds) {
		setInterval(function () {
			editor.getSaveLoadEngine().save()
		}, intervalInSeconds * 1000);
	}
});


var editor;

PedigreeEditor.styles = {
	"blackAndWhite": {
		nodeShapeFemale: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeMale: {fill: "#ffffff", stroke: "#111111"},
		nodeShapeOther: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeDiag: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeAborted: {fill: "#ffffff", stroke: "#222222"}
	}
};

//attributes for graphical elements in the editor
PedigreeEditor.attributes = {
	radius: 40,
	orbRadius: 6,
	touchOrbRadius: 8,
	personHoverBoxRadius: 90,  // 80    for old handles, 90 for new
	newHandles: true,          // false for old handles
	personHandleLength: 75,    // 60    for old handles, 75 for new
	personHandleBreakX: 55,
	personHandleBreakY: 53,
	personSiblingHandleLengthX: 65,
	personSiblingHandleLengthY: 30,
	enableHandleHintImages: true,
	handleStrokeWidth: 5,
	groupNodesScale: 0.85,
	infertileMarkerHeight: 4,
	infertileMarkerWidth: 14,
	twinCommonVerticalLength: 6,
	twinMonozygothicLineShiftY: 24,
	curvedLinesCornerRadius: 25,
	unbornShape: {'font-size': 50, 'font-family': 'Cambria'},
	carrierShape: {fill: '#595959'},
	carrierDotRadius: 8,
	presymptomaticShape: {fill: '#777777', "stroke": "#777777"},
	presymptomaticShapeWidth: 8,
	uncertainShape: {'font-size': '45px', 'font-family': 'Arial', 'fill': '#696969', 'font-weight': 'bold'},
	uncertainSmallShape: {'font-size': '30px', 'font-family': 'Arial', 'fill': '#696969', 'font-weight': 'bold'},
	evaluationShape: {'font-size': 40, 'font-family': 'Arial'},
	nodeShapeFemale: PedigreeEditor.styles.blackAndWhite.nodeShapeFemale,
	nodeShapeMale: PedigreeEditor.styles.blackAndWhite.nodeShapeMale,
	nodeShapeOther: PedigreeEditor.styles.blackAndWhite.nodeShapeOther,
	nodeShapeDiag: PedigreeEditor.styles.blackAndWhite.nodeShapeDiag,
	nodeShapeAborted: PedigreeEditor.styles.blackAndWhite.nodeShapeAborted,
	nodeShapeMenuOn: {fill: "#000", stroke: "none", "fill-opacity": 0.1},
	nodeShapeMenuOff: {fill: "#000", stroke: "none", "fill-opacity": 0},
	nodeShapeMenuOnPartner: {fill: "#000", stroke: "none", "fill-opacity": 0.1},
	nodeShapeMenuOffPartner: {fill: "#000", stroke: "none", "fill-opacity": 0},
	boxOnHover: {fill: "gray", stroke: "none", opacity: 1, "fill-opacity": .35},
	menuBtnIcon: {fill: "#1F1F1F", stroke: "none"},
	deleteBtnIcon: {fill: "#990000", stroke: "none"},
	btnMaskHoverOn: {opacity: .6, stroke: 'none'},
	btnMaskHoverOff: {opacity: 0},
	btnMaskClick: {opacity: 1},
	orbHue: .53,
	phShape: {fill: "white", "fill-opacity": 0, "stroke": 'black', "stroke-dasharray": "- "},
	dragMeLabel: {'font-size': 14, 'font-family': 'Tahoma'},
	pedNumberLabel: {'font-size': 19, 'font-family': 'Serif'},
	descendantGroupLabel: {'font-size': 21, 'font-family': 'Tahoma'},
	label: {'font-size': 20, 'font-family': 'Arial'},
	nameLabels: {'font-size': 20, 'font-family': 'Arial'},
	commentLabel: {'font-size': 19, 'font-family': 'Arial' },
	cancerAgeOfOnsetLabels: {'font-size': 19, 'font-family': 'Arial' },
	externalIDLabels: {'font-size': 18, 'font-family': 'Arial' },
	disorderShapes: {},
	partnershipNode: {fill: '#d79185', stroke: 'black', 'stroke-width': 2},  //#dc7868, #E25740
	partnershipRadius: 7.0,
	partnershipHandleBreakY: 18,
	partnershipHandleLength: 36,
	partnershipLines: {"stroke-width": 1.25, stroke: '#303058'},
	partnershipLinesAdoptedIn: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "--"},
	consangrPartnershipLines: {"stroke-width": 1.25, stroke: '#402058'},
	noContactLines: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "-.-."},
	noContactAdoptedIn: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "-- ."},
	noContactLinesConsangr: {"stroke-width": 1.25, stroke: '#402058', "stroke-dasharray": "-.-."},
	childlessShapeAttr: {"stroke-width": 2.5, stroke: "#3C3C3C"},
	partnershipChildlessShapeAttr: {"stroke-width": 2.0, stroke: "#3C3C3C"},
	childlessLength: 14,
	parnershipChildlessLength: 27,
	graphToCanvasScale: 12,
	layoutRelativePersonWidth: 10,
	layoutRelativeOtherWidth: 2,
	layoutScale: { xscale: 12.0, yscale: 8 },
	maxPrintPreviewPaneHeight: 600,
	minPrintPreviewPaneHeight: 250
};

document.observe("xwiki:dom:loaded", function () {
    // this functionality is also duplicated by workspace.js -> initializeEthnicitiesAndCreateEditor
    // due to it causing issues with duplicate loading, Check if this needs commenting this out as
    // workspace.js will call the same functionality anyway
    //if (!CONSTANTS.STANDALONE){
	//	return;
	//}

	return;
	editor = new PedigreeEditor();
    var legendContainer = document.getElementById('legend-container');
    var canvasContainer = document.getElementById('work-area');
    //console.log("lllc",legendContainer);
    var clinicalIndicationDiv = new Element("div",{'class':'clinical-indication-name', 'id':'clinical-indication-name'});
    clinicalIndicationDiv.innerHTML = "Clinical Indication Name";
    legendContainer.insertBefore(clinicalIndicationDiv, legendContainer.firstElementChild);
    //Sync All of the clinical indication names

    var clinicalIndicationNames = document.getElementsByName("clinicalIndicationName");
    var clinicalIndicationValue = document.getElementById("clinical-indication-name").innerHTML;
	
	//IE11/Edge Issues : NodeList cannot be iterated upon.  
	if (clinicalIndicationNames && !clinicalIndicationNames.forEach){
		clinicalIndicationNames = [].slice.call(clinicalIndicationNames);
	}
	
    clinicalIndicationNames.forEach(function(clinicalIndicationName){
        clinicalIndicationName.value = clinicalIndicationValue;
    });


    var canvasSideBar = new Element("div",{'class':'canvas-sidebar-container', 'id':'canvas-sidebar-container'});
    canvasSideBar.innerHTML = '<div id="canvas-clinical-indication-name" class="sidebar-item">Clinical Indication Name</div>'
		+ '<div id="canvas-test-request-simple-id" class="sidebar-item"> Test Request Simple Id</div>'
    canvasContainer.insertBefore(canvasSideBar, canvasContainer.firstElementChild);
    //Sync All of the clinical indication names
    //var clinicalIndicationNames = document.getElementsByName("clinicalIndicationName");
	document.getElementById(PedigreeEditorTool.divId).className = 'pedigree-tool skin-colibri wiki-xwiki space-data viewbody hidelefthideright panel-left-width-Medium panel-right-width-Medium';

    var srcs = ["/pedigree-ui/resources/font-awesome/css/font-awesome.min.css",
				"/pedigree-ui/css/style.min.css",
				"/pedigree-ui/css/colibri-ie-all.min.css"
	];

    if(typeof(CONSTANTS) == "object" && CONSTANTS.PEDIGREE_TOOL_URL != "" && typeof(CONSTANTS.PEDIGREE_TOOL_URL) != "undefined") {
        srcs.forEach(function(src){
            // if (src != "font-awesome/css/font-awesome.min.css") {
                 src = CONSTANTS.PEDIGREE_TOOL_URL + src;
            // }
			
			var isCssLinkAdded = Utils.checkIfCssExist(src);
					
			if (!isCssLinkAdded){
				
				console.log("adding stylesheet:" + src)
				if (document.createStyleSheet) {
					document.createStyleSheet(src);
				}
				else {
					var stylesheet = document.createElement('link');
					stylesheet.href = src;
					stylesheet.rel = 'stylesheet';
					stylesheet.type = 'text/css';
					document.getElementsByTagName('head')[0].appendChild(stylesheet);
				}
						
			}

            
        });
    }

});

var XWiki = (function (d) {
	var c = d.actionButtons = d.actionButtons || {};
	c.EditActions = Class.create({initialize: function () {
		this.addListeners();
		this.addShortcuts();
		this.addValidators()
	}, addListeners: function () {
		$$("input[name=action_cancel]").each(function (e) {
			e.observe("click", this.onCancel.bindAsEventListener(this))
		}.bind(this));
		$$("input[name=action_preview]").each(function (e) {
			e.observe("click", this.onPreview.bindAsEventListener(this))
		}.bind(this));
		$$("input[name=action_save]").each(function (e) {
			e.observe("click", this.onSaveAndView.bindAsEventListener(this))
		}.bind(this));
		$$("input[name=action_saveandcontinue]").each(function (e) {
			e.observe("click", this.onSaveAndContinue.bindAsEventListener(this))
		}.bind(this))
	}, addShortcuts: function () {
		var e = {action_cancel: "$services.localization.render('core.shortcuts.edit.cancel')", action_preview: "$services.localization.render('core.shortcuts.edit.preview')", action_edit: "$services.localization.render('core.shortcuts.edit.backtoedit')", action_inline: "$services.localization.render('core.shortcuts.edit.backtoedit')", action_save: "$services.localization.render('core.shortcuts.edit.saveandview')", action_propupdate: "$services.localization.render('core.shortcuts.edit.saveandview')", action_saveandcontinue: "$services.localization.render('core.shortcuts.edit.saveandcontinue')"};
		for (var f in e) {
			var g = $$("input[name=" + f + "]");
			if (g.size() > 0) {
				shortcut.add(e[f], function () {
					this.click()
				}.bind(g.first()), {propagate: false})
			}
		}
	}, validators: new Array(), addValidators: function () {
		var e = document.getElementById(PedigreeEditorTool.divId).select("input.required");
		for (var h = 0; h < e.length; h++) {
			var f = e[h];
			var g = new LiveValidation(f, {validMessage: ""});
			g.add(Validate.Presence, {failureMessage: "$services.localization.render('core.validation.required.message')"});
			g.validate();
			this.validators.push(g)
		}
	}, validateForm: function (g) {
		for (var f = 0; f < this.validators.length; f++) {
			if (!this.validators[f].validate()) {
				return false
			}
		}
		var h = g.comment;
		if (h && ($xwiki.isEditCommentSuggested() || $xwiki.isEditCommentMandatory())) {
			while (h.value == "") {
				var e = prompt("$services.localization.render('core.comment.prompt')", "");
				if (e === null) {
					return false
				}
				h.value = e;
				if (!$xwiki.isEditCommentMandatory()) {
					break
				}
			}
		}
		return true
	}, onCancel: function (g) {
		g.stop();
		this.notify(g, "cancel");
		var f = g.element().form.action;
		if (typeof f != "string") {
			f = g.element().form.attributes.getNamedItem("action");
			if (f) {
				f = f.nodeValue
			} else {
				f = window.self.location.href
			}
		}
		var i = f.split("#", 2);
		var k = (i.length == 2) ? i[1] : "";
		f = i[0];
		if (f.indexOf("?") == -1) {
			f += "?"
		}
		var j = "&action_cancel=true";
		var h = g.element().form.elements.xredirect;
		var e = h ? "&xredirect=" + escape(h.value) : "";
		d.EditLock && d.EditLock.setLocked(false);
		window.location = f + j + e + k
	}, onPreview: function (e) {
		if (!this.validateForm(e.element().form)) {
			e.stop()
		} else {
			this.notify(e, "preview")
		}
	}, onSaveAndView: function (e) {
		if (!this.validateForm(e.element().form)) {
			e.stop()
		} else {
			this.notify(e, "save", {"continue": false})
		}
	}, onSaveAndContinue: function (e) {
		if (!this.validateForm(e.element().form)) {
			e.stop()
		} else {
			this.notify(e, "save", {"continue": true})
		}
	}, notify: function (e, f, g) {
		document.fire("xwiki:actions:" + f, Object.extend({originalEvent: e, form: e.element().form}, g || {}));
		if (e.stopped) {
			e.stop()
		}
	}});
	c.AjaxSaveAndContinue = Class.create({initialize: function () {
		this.createMessages();
		this.addListeners()
	}, createMessages: function () {
		this.savingBox = new d.widgets.Notification("$escapetool.javascript($services.localization.render('core.editors.saveandcontinue.notification.inprogress'))", "inprogress", {inactive: true});
		this.savedBox = new d.widgets.Notification("$escapetool.javascript($services.localization.render('core.editors.saveandcontinue.notification.done'))", "done", {inactive: true});
		this.failedBox = new d.widgets.Notification('$escapetool.javascript($services.localization.render("core.editors.saveandcontinue.notification.error", ["<span id=""ajaxRequestFailureReason""/>"]))', "error", {inactive: true})
	}, addListeners: function () {
		document.observe("xwiki:actions:save", this.onSave.bindAsEventListener(this))
	}, onSave: function (e) {
		if (e.stopped) {
			return
		}
		if (e.memo["continue"]) {
			if (typeof(e.memo.originalEvent) != "undefined") {
				e.memo.originalEvent.stop()
			}
			this.form = $(e.memo.form);
			this.savedBox.hide();
			this.failedBox.hide();
			this.savingBox.show();
			var f = new Hash(this.form.serialize({hash: true, submit: "action_saveandcontinue"}));
			f.set("minorEdit", "1");
			if (!Prototype.Browser.Opera) {
				f.set("ajax", "true")
			}
			new Ajax.Request(this.form.action, {method: "post", parameters: f.toQueryString(), onSuccess: this.onSuccess.bindAsEventListener(this), on1223: this.on1223.bindAsEventListener(this), on0: this.on0.bindAsEventListener(this), onFailure: this.onFailure.bind(this)})
		}
	}, on1223: function (e) {
		e.request.options.onSuccess(e)
	}, on0: function (e) {
		e.request.options.onFailure(e)
	}, onSuccess: function (e) {
		if (this.form && this.form.template) {
			this.form.template.disabled = true;
			this.form.template.value = ""
		}
		this.savingBox.replace(this.savedBox);
		document.fire("xwiki:document:saved")
	}, onFailure: function (e) {
		this.savingBox.replace(this.failedBox);
		if (e.statusText == "" || e.status == 12031) {
			$("ajaxRequestFailureReason").update("Server not responding")
		} else {
			if (e.getHeader("Content-Type").match(/^\s*text\/plain/)) {
				$("ajaxRequestFailureReason").update(e.responseText)
			} else {
				$("ajaxRequestFailureReason").update(e.statusText)
			}
		}
		document.fire("xwiki:document:saveFailed", {response: e})
	}});
	function b() {
		new c.EditActions();
		if (!document.getElementById(PedigreeEditorTool.divId).hasClassName("previewbody")) {
			new c.AjaxSaveAndContinue()
		}
		return true
	}

	(d.domIsLoaded && b()) || document.observe("xwiki:dom:loaded", b);
	function a() {
		if (typeof(Wysiwyg) == "undefined") {
			return
		}
		var h = Wysiwyg.getInstances();
		for (var f in h) {
			var g = h[f];
			var e = g.getPlainTextArea();
			if (e && !e.disabled) {
				$(f).value = e.value
			} else {
				g.getCommandManager().execute("submit")
			}
		}
	}

	document.observe("xwiki:actions:save", a);
	document.observe("xwiki:actions:preview", a);
	return d
}(XWiki || {}));
document.observe("xwiki:dom:loaded", function () {
	var b = function (g) {
		var d = g.findElement("a");
		var f = d && d.getAttribute("href");
		var h = f && $(f.substring(1));
		var e = h && (h.up(".collapsible-group") || h.up(".chapter"));
		if (e && e.hasClassName("collapsed")) {
			e.removeClassName("collapsed");
			if (e.down(".expand-tool")) {
				e.down(".expand-tool").update("▼")
			}
			if (e.up(".chapter")) {
				e.up(".chapter").removeClassName("collapsed")
			}
		} else {
		}
	};
	var c = $("table-of-contents");
	var a = $("toc-entry");
	if (!c || !a || !c.down("ul")) {
		a && a.up("li").remove();
		return
	}
	a = a.up("li");
	a.down("ul").replace(c.down("ul"));
	a.down("ul").select("a").invoke("observe", "click", b)
});
document.observe("xwiki:dom:loaded", function () {
	var a = $("prActionDelete");
	if (!a) {
		return false
	}
	a.observe("click", function (b) {
		b.stop();
		var d = b.element();
		d.blur();
		if (d.disabled) {
			return
		} else {
			var c = d.readAttribute("href") + "?confirm=1&form_token=" + $$("meta[name=form_token]")[0].content + (Prototype.Browser.Opera ? "" : "&ajax=1");
			new XWiki.widgets.ConfirmedAjaxRequest(c, {onCreate: function () {
				d.disabled = true
			}, onSuccess: function () {
				window.location = new XWiki.Document("WebHome", XWiki.Document.currentSpace).getURL("view")
			}, onFailure: function () {
				d.disabled = false
			}}, {confirmationText: "Are you sure you wish to move this document to the recycle bin?"})
		}
	})
});
document.observe("xwiki:dom:loaded", function () {
	if (XWiki.contextaction != "edit") {
		return
	}
	var a = $("edit") || $("inline");
	if (!a) {
		return
	}
	var e = a.form_token && a.form_token.value;
	var c = a.serialize();
	var i = ($$("meta[name=version]").length > 0) ? $$("meta[name=version]")[0].content : false;
	var f = function (k) {
		return XWiki.currentDocument.getURL("rollback", "rev=" + k + "&confirm=1&form_token=" + e)
	};
	var h = XWiki.currentDocument.getURL("delete", "confirm=1&form_token=" + e);
	var g = "none";
	if (i) {
		var b = f(i)
	}
	var j = XWiki.currentDocument.getRestURL();
	var d = function (l) {
		var k = l.getElementsByTagName("version");
		if (k.length > 0) {
			return k[0].firstChild.nodeValue
		}
		return false
	};
	new Ajax.Request(j, {method: "get", onSuccess: function (k) {
		if (!i && (i = d(k.responseXML))) {
			b = f(i)
		}
	}, onFailure: function (k) {
		if (k.statusCode == 404) {
			i = g;
			b = h
		}
	}.bind(this)});
	a.select("input[name=action_cancel]").invoke("observe", "click", function (k) {
		if (a._isVersionVerified || !i || !b) {
			return
		}
		Event.stop(k);
		new Ajax.Request(j, {method: "get", onCreate: function () {
			a._isVersionVerified = true
		}, onSuccess: function (m) {
			var l = d(m.responseXML);
			window.onbeforeunload = function () {
			};
			if (l && l != i) {
				window.location = b
			} else {
				k.element().click()
			}
		}.bind(this), onFailure: function (l) {
			window.onbeforeunload = function () {
			};
			k.element().click()
		}.bind(this), on0: function (l) {
			l.request.options.onFailure(l)
		}})
	})
});
(function () {
	var a = function (d) {
		var c = $("mainContentArea");
		var e = $("patient-record-actions");
		if (c && e) {
			var b = new StickyBox(e, c, {offsetTop: 0})
		}
	};
	(XWiki.domIsLoaded && a()) || document.observe("xwiki:dom:loaded", a)
})();
document.observe("xwiki:dom:loaded", function () {
	var a = $$(" .export-link");
	a.invoke("observe", "click", function (b) {
		b.stop();
		if (typeof b.findElement(".editbody") !== "undefined") {
			var d = window.open("", "_blank");
			var c = function () {
				d.location = b.findElement().href;
				document.stopObserving("xwiki:document:saved", c)
			};
			document.observe("xwiki:document:saved", c);
			document.fire("xwiki:actions:save", {"continue": true, form: b.findElement("form")})
		} else {
			window.open(b.findElement().href, "_blank")
		}
	})
});
var PhenoTips = (function (b) {
	var a = b.widgets = b.widgets || {};
	a.PushPatientWidget = Class.create({initialize: function () {
		this._consentsModule = null;
		this._pushManyPatients = false;
		var f = $$("div[id^=push-patient]");
		if (f.length == 0) {
			f = $$("a[id^=pushall-server]");
			if (f.length == 0) {
				return
			}
			this._pushManyPatients = true
		}
		this._serviceURL = new XWiki.Document("PushPatientService", "PhenoTips").getURL("get", "outputSyntax=plain");
		this._patientId = XWiki.currentDocument.page;
		this._initUI();
		var i = this;
		this._observeSave = function () {
			i._launchUI()
		};
		for (var e = 0; e < f.length; e++) {
			var c = f[e];
			var d = this._pushManyPatients ? c : c.down("a");
			if (!d) {
				continue
			}
			var h = c.readAttribute("name");
			var g = function (j) {
				return function (k) {
					k.stop();
					k.findElement().blur();
					i._selectedServer = j;
					if (k.findElement(".editbody")) {
						document.fire("xwiki:actions:save", {"continue": true, form: k.findElement("form")});
						document.observe("xwiki:document:saved", i._observeSave)
					} else {
						i._launchUI()
					}
				}
			};
			d.observe("click", g(h))
		}
	}, _initUI: function () {
		var f = function (j, i, h) {
			return new Element("div", {id: j, "class": "section"}).insert(i && new Element("h2").update(i) || "").insert(h && new Element("p", {"class": "intro xHint"}).update(h) || "").insert(new Element("div", {"class": "section-contents"}))
		};
		var c = this._pushManyPatients ? "Where to send all the patient data to?" : "Where to send this patient profile?";
		var d = this._pushManyPatients ? "Remote PhenoTips server where all the data will be sent." : "Remote PhenoTips server where this patient's data will be sent.";
		this._container = new Element("form", {id: "push-patients-ui", "class": "xform", method: "post", action: this._serviceURL});
		this._container.insert(f("server-selection", c, d)).insert(f("user-selection", "Authentication on remote server", "Please choose the user name to be used to authenticate on the server and send the data; this user will be marked as the reporter on the remote server.")).insert(f("group-selection", "Remote PhenoTips group", "The PhenoTips group you would like to share this patient with on the remote server. If a group is selected, the group would be the owner and the given remote user will be a collaborator. If no group is selected, the remote user will be the only owner."));
		this._container.insert(f("consents-section", "Consents", "Remote servers may accept some patient data only if the patient has consented to collection and/or sharing of such data. The set of required consents depends on the server you want to push data to."));
		this._retryButtonClass = "button secondary push-retry-button";
		this._checkBoxApprove = new Element("input", {type: "checkbox", id: "approve-checkbox", value: "approve"});
		this._approveMessage = new Element("span", {"class": "field-no-user-select"});
		var e = new Element("label", {id: "approve-label"}).update(this._checkBoxApprove).insert(this._approveMessage);
		this._approveElement = new Element("div", {"class": "confirm-push plainmessage"});
		this._approveElement.insert(e);
		this._container.insert(this._approveElement);
		this._serverManager = this._container.down("#server-selection .section-contents");
		this._userManager = this._container.down("#user-selection .section-contents");
		this._groupManager = this._container.down("#group-selection .section-contents");
		this._consentsSection = this._container.down("#consents-section");
		this._consentsManager = this._consentsSection.down(".section-contents");
		this._consentsSection.hide();
		this._consentsManager.insert('<div class="box warningmessage hidden error">Consents that need to be granted before pushing could not be found. This might prevent you from pushing this patient to a remote server</div>');
		this._initServerSelector();
		this._initMainFormActions();
		var g = this._pushManyPatients ? "Pushing patient data to a remote PhenoTips instance..." : "Pushing __patientID__ to a remote database...".replace("__patientID__", this._patientId);
		this._dialog = new b.widgets.ModalPopup(this._container, false, {title: g, verticalPosition: "top", removeOnClose: false})
	}, _updateConsentHint: function (d) {
		var c = $("consents-section").down(".intro");
		if (c) {
			c.update(d)
		}
	}, _generateServerFirstMessage: function () {
		return new Element("div", {"class": "warningmessage"}).update("Please select server first")
	}, _generateServerAndUserFirstMessage: function () {
		return new Element("div", {"class": "warningmessage"}).update("Please login to the remote server first")
	}, _generateNoServerListMessage: function () {
		var c = new Element("input", {type: "button", name: "retry", value: "Retry", "class": this._retryButtonClass}).wrap("span", {"class": "buttonwrapper"});
		var d = this;
		c.observe("click", function (e) {
			d._launchUI()
		});
		return new Element("div", {"class": "errormessage"}).update("Cannot access the list of remote servers. Please contact your administrator for further details.").insert(c)
	}, _generateCantConnectToServerMessage: function (d, g, e) {
		var c = new Element("input", {type: "button", name: "retry", value: "Retry", "class": this._retryButtonClass}).wrap("span", {"class": "buttonwrapper"});
		var f = this;
		c.observe("click", function (h) {
			f._loginAndGetConfig(g, e)
		});
		return new Element("div", {"class": "errormessage"}).update(d + " ").insert(c)
	}, _generateNoPushServerConfiguredMessage: function () {
		return new Element("div", {"class": "errormessage"}).update("Unable to authenticate user: incorrect credentials")
	}, _generateIncorrectCredentialsMessage: function () {
		return new Element("div", {"class": "errormessage"}).update("Unable to authenticate user: incorrect credentials")
	}, _generateFailedToPushPatient: function (e, d, h) {
		var c = new Element("div", {"class": "errormessage"}).update(e);
		if (d) {
			var d = new Element("input", {type: "button", name: "retry", value: "Retry", "class": this._retryButtonClass}).wrap("span", {"class": "buttonwrapper"});
			var g = this;
			d.observe("click", function (i) {
				g._pushPatient()
			});
			c.insert(d)
		}
		if (h) {
			var f = new Element("input", {type: "button", name: "retry", value: "Push as a new patient", "class": this._retryButtonClass}).wrap("span", {"class": "buttonwrapper"});
			var g = this;
			f.observe("click", function (i) {
				g._selectPushNewPatient();
				g._pushPatient()
			});
			c.insert(f)
		}
		return c
	}, _onUnapprovedUser: function () {
		this._patientData = undefined;
		this._groupManager.update(this._generateServerAndUserFirstMessage());
		this._consentsSection.hide();
		this._pushButton.disable();
		this._approveElement.hide();
		this._pushResultSection.update("");
		this._patientFieldList = undefined;
		this._userGroupsList = undefined
	}, _onNoServerSelected: function () {
		this._lastApprovedUser = undefined;
		this._lastSelectedGroup = undefined;
		this._userLoginError = undefined;
		this._serverInfo.hide();
		this._userManager.update(this._generateServerFirstMessage());
		this._onUnapprovedUser()
	}, _disableControl: function (c) {
		c.disable();
		c.__wasDisabledState = true
	}, _disableInputs: function (e) {
		this._container.addClassName("loading-indicator-large");
		var d = this._container.getElementsByTagName("input");
		for (var c = 0; c < d.length; c++) {
			if (d[c].disabled) {
				d[c].__wasDisabledState = true
			} else {
				d[c].disable()
			}
		}
		this._serverSelector.down("select").disable();
		if (!e) {
			this._cancelButton.enable()
		}
	}, _restoreInputs: function () {
		this._container.removeClassName("loading-indicator-large");
		var d = this._container.getElementsByTagName("input");
		for (var c = 0; c < d.length; c++) {
			if (d[c].__wasDisabledState) {
				delete (d[c].__wasDisabledState)
			} else {
				d[c].enable()
			}
		}
		this._serverSelector.down("select").enable()
	}, _launchUI: function () {
		var c = this;
		document.stopObserving("xwiki:document:saved", c._observeSave);
		if (this.__launchUIAjaxInProgress) {
			return
		}
		this._consentsModule = b.widgets.ConsentsModule.createNew();
		this._remoteServers = {};
		this._numAvailableServers = 0;
		this._onNoServerSelected();
		this._serverLoadMessages.update(new Element("div", {"class": "infomessage"}).update("Retrieving server list..."));
		this._serverLoadMessages.show();
		this._serverSelector.hide();
		this._container.addClassName("loading-indicator-large");
		new Ajax.Request(this._serviceURL, {method: c._container.method, parameters: {"do": "getremotes", patientId: c._patientId}, onCreate: function () {
			c.__launchUIAjaxInProgress = true;
			c._dialog.showDialog();
			c._container.up(".msdialog-modal-container").style.zIndex = 3001
		}, onSuccess: function (d) {
			console.log("PUSH: Got response for the getremotes request");
			var e = d.responseJSON;
			if (!e || e.length == 0) {
				c._serverLoadMessages.update(c._generateNoPushServerConfiguredMessage())
			} else {
				c._serverLoadMessages.hide();
				c._populateServerList(e)
			}
		}, onFailure: function (d) {
			c._serverLoadMessages.update(c._generateNoServerListMessage())
		}, on0: function (d) {
			d.request.options.onFailure(d)
		}, onComplete: function () {
			c.__launchUIAjaxInProgress = false;
			c._container.removeClassName("loading-indicator-large");
			console.log("PUSH: getting remotes - complete")
		}})
	}, _queryStoredUserName: function () {
		var c = this;
		this._userManager.update("");
		new Ajax.Request(this._serviceURL, {method: c._container.method, parameters: {"do": "getuser", serverid: this._selectedServer}, onCreate: function () {
			console.log("PUSH: get username - start");
			c._disableInputs()
		}, onSuccess: function (d) {
			if (d.responseJSON.remoteUserName) {
				c._lastApprovedUser = d.responseJSON.remoteUserName
			}
		}, onFailure: function (d) {
			console.log("PUSH: couldn't not get the user last used for this server")
		}, on0: function (d) {
			d.request.options.onFailure(d)
		}, onComplete: function () {
			c._restoreInputs();
			console.log("PUSH: getting username - complete");
			if (c._lastApprovedUser) {
				c._loginAndGetConfig(c._lastApprovedUser, null)
			} else {
				c._updateUserList()
			}
		}})
	}, _loginAndGetConfig: function (f, c) {
		console.log("loginAndGetConfig: probing " + f);
		var e = this;
		var d = {"do": "getremoteconfig", serverid: this._selectedServer, savetoken: true};
		if (c) {
			d.usr = f;
			d.pwd = c
		}
		new Ajax.Request(this._serviceURL, {method: e._container.method, parameters: d, onCreate: function () {
			console.log("PUSH: get remote config - start");
			e._disableInputs()
		}, onSuccess: function (g) {
			if (g.hasOwnProperty("responseJSON") && g.responseJSON) {
				console.log("PUSH: Got response from server: " + stringifyObject(g.responseJSON));
				e._lastLoginResponse = g.responseJSON
			} else {
				console.log("PUSH: No response from local service");
				e._lastLoginResponse = {status: "error", nolocalresponse: true}
			}
		}, onFailure: function (g) {
			console.log("PUSH: unable to get a response from remote server");
			e._lastLoginResponse = {status: "error", serverconnectproblem: true}
		}, on0: function (g) {
			g.request.options.onFailure(g)
		}, onComplete: function () {
			this._restoreInputs();
			console.log("PUSH: get remote config - complete");
			if (this._lastLoginResponse.status == "success") {
				console.log("--> login successful!");
				this._lastApprovedUser = f;
				this._updateUserList();
				this._populateGroupsAndData(this._lastLoginResponse.groups, this._lastLoginResponse.serverfields, this._lastLoginResponse.updatesEnabled);
				this._populateConsentsList(this._lastLoginResponse.consents)
			} else {
				console.log("--> login failed!");
				if (this._lastApprovedUser == f) {
					this._lastApprovedUser = undefined
				}
				this._updateUserList(f, this._lastLoginResponse, f, c)
			}
		}.bind(this)})
	}, _logoutUser: function () {
		var d = this;
		var c = {"do": "removetokens", serverid: this._selectedServer};
		new Ajax.Request(this._serviceURL, {method: d._container.method, parameters: c, onCreate: function () {
			console.log("PUSH: logout user");
			try {
				d._disableInputs()
			} catch (f) {
				console.log("ERROR: " + f)
			}
		}, onSuccess: function (e) {
			d._lastLoginResponse = undefined;
			d._lastApprovedUser = undefined;
			d._updateUserList()
		}, onFailure: function (e) {
			alert("Failed to log out")
		}, on0: function (e) {
			e.request.options.onFailure(e)
		}, onComplete: function () {
			this._restoreInputs();
			console.log("PUSH: logout - complete")
		}.bind(this)})
	}, _updateUserList: function (d, f, c, p) {
		if (f) {
			if (this._lastLoginResponse.nolocalresponse) {
				this._userManager.update(this._generateCantConnectToServerMessage("Can't connect to local service. Make sure you are currently logged in.", c, p));
				return
			}
			if (this._lastLoginResponse.unauthorizedserver) {
				this._userManager.update(this._generateCantConnectToServerMessage("This server is not authorized to push patients to the selected server. Please contact your administrator", c, p));
				return
			}
			if (this._lastLoginResponse.serverconnectproblem) {
				this._userManager.update(this._generateCantConnectToServerMessage("Cannot connect to selected PhenoTips server.", c, p));
				return
			}
			if (this._lastLoginResponse.serverdoesnotsupportclientprotocol) {
				this._userManager.update(this._generateCantConnectToServerMessage("Cannot connect to selected PhenoTips server - the server does not support the (old) version of PhenoTips this instance is running.", c, p));
				return
			}
			if (this._lastLoginResponse.clientdoesnotsupportserverprotocol) {
				this._userManager.update(this._generateCantConnectToServerMessage("Cannot connect to selected PhenoTips server - the server is running an outdated unsupported version of PhenoTips software.", c, p));
				return
			}
		}
		console.log("updateUserList: " + d + ", last approved: " + this._lastApprovedUser);
		var h = this;
		var e = new Element("table", {id: "user-list"});
		var n = function (v, r, u, q, w) {
			var x = new Element("tr");
			var s = new Element("input", {type: "radio", value: u, name: "select-user"});
			if (v) {
				s.checked = true
			}
			var t = new Element("label").insert(s).insert(u);
			x.insert(new Element("span", {"class": "fa fa-" + r}).wrap("td")).insert(t.wrap("td"));
			if (w) {
				x.insert(w.wrap("td", {"class": "controlled-element"}))
			}
			s.observe("change", function (B) {
				var z = B.findElement("input");
				var y = z.up("table").getElementsByTagName("input");
				for (var A = 0; A < y.length; A++) {
					if (y[A].getAttribute("name") != "select-user") {
						y[A].disable()
					}
				}
				var y = z.up("tr").getElementsByTagName("input");
				for (var A = 0; A < y.length; A++) {
					y[A].enable()
				}
				q()
			});
			return x
		};
		var j = false;
		if (this._lastApprovedUser) {
			j = !d || (this._lastApprovedUser == d);
			var m = new Element("input", {type: "button", name: "logout", value: "Log out", "class": "button secondary"}).wrap("span", {"class": "buttonwrapper"});
			m.observe("click", function (q) {
				this._onUnapprovedUser();
				this._logoutUser()
			}.bind(this));
			var k = n(j, "check", "Currently authenticated user: __lastApprovedUser__".replace("__lastApprovedUser__", "<strong>" + this._lastApprovedUser + "</strong> &nbsp;"), function () {
				this._userLoginError.hide();
				this._onUnapprovedUser();
				this._loginAndGetConfig(this._lastApprovedUser)
			}.bind(this), m);
			e.insert(k)
		}
		var i = new Element("span", {"class": "user-password-box"});
		var g = new Element("input", {type: "text", id: "newusername", value: "", placeholder: "user name", size: 12});
		if (d) {
			g.value = d
		}
		var l = new Element("input", {type: "password", id: "password", value: "", placeholder: "password", size: 12});
		var o = new Element("input", {type: "button", id: "authorizenewuser", name: "authorize", value: "Log in", "class": "button secondary"});
		o.observe("click", function (q) {
			if (l.value != "") {
				this._userLoginError.hide();
				this._loginAndGetConfig(g.value, l.value)
			} else {
				this._userLoginError.update("No password provided");
				this._userLoginError.show()
			}
		}.bind(this));
		if (j) {
			g.disable();
			l.disable();
			o.disable()
		}
		i.insert(g.wrap("label", {"class": "fa fa-user"})).insert(" ").insert(l.wrap("label", {"class": "fa fa-key"})).insert(" ").insert(o.wrap("span", {"class": "buttonwrapper"}));
		if (this._lastApprovedUser) {
			e.insert(n(!j, "user", "Another remote user: ", this._onUnapprovedUser.bind(this), i))
		} else {
			e.insert(i.wrap("td", {"class": "controlled-element"}).wrap("tr"))
		}
		this._userLoginError = new Element("div", {"class": "errormessage"});
		this._userLoginError.hide();
		this._userManager.update(e).insert(this._userLoginError);
		if (f) {
			if (this._lastLoginResponse.loginfailed && p != "") {
				this._userLoginError.update("Unable to authorize user: incorrect credentials");
				this._userLoginError.show()
			}
		}
	}, _populateGroupsAndData: function (d, c, e) {
		if (!e) {
			this._remoteServers[this._selectedServer]["noUpdates"] = true
		}
		this._displayGroupPicker(d);
		this._showApproveCheckbox()
	}, _displayGroupPicker: function (c) {
		if (!c) {
			c = this._userGroupsList;
			if (!this._userGroupsList) {
				return
			}
		} else {
			this._userGroupsList = c
		}
		console.log("Groups: " + stringifyObject(c));
		var d = new Element("table", {id: "user-list"});
		var e = function (l, h, k, m) {
			var n = new Element("tr");
			var i = new Element("input", {type: "radio", value: m, name: "select-group"});
			if (l) {
				i.checked = true
			}
			var j = new Element("label").insert(i).insert(k);
			n.insert(new Element("span", {"class": "fa fa-" + h}).wrap("td")).insert(j.wrap("td"));
			return n
		};
		if (!this._updatingExistingPatient()) {
			var f = "<span class ='hint'>None</span>";
			if (c.length == 0) {
				f += " (user __lastApprovedUser__ does not belong to any PhenoTips groups on the selected server)".replace("__lastApprovedUser__", this._lastApprovedUser)
			}
			d.insert(e(true, "user", f, "__self"));
			c.each(function (h) {
				d.insert(e(false, "group", h, h))
			})
		} else {
			var g = "Keep existing group(s)";
			g += " <span class ='hint'>(the group can't be changed when updating an existing patient)</span>";
			d.insert(e(true, "check", g, "__self"))
		}
		this._groupManager.update(d);
		if (this._remoteServers[this._selectedServer]["noUpdates"]) {
			this._disableUpdateOption()
		}
	}, _showApproveCheckbox: function () {
		this._checkBoxApprove.checked = false;
		this._checkBoxApprove.enable();
		this._approveElement.show()
	}, _populateConsentsList: function (c) {
		if (c == null || c.length == 0) {
			this._consentsSection.hide();
			return
		}
		var d = function (f, e) {
			this._pushResultSection.update("")
		}.bind(this);
		this._consentsManager.update("");
		this._updateConsentHint(this._selectedServer + " is configured with the following set of consents. Not all consents are required, but some data might not be uploaded if corresponding consent has not been granted.");
		this._consentsModule.init(this._consentsManager, "edit", c, false, d);
		this._consentsSection.show()
	}, _populateServerList: function (j) {
		this._remoteServers = {};
		var n = [];
		this._numAvailableServers = j.length;
		for (var h = 0; h < j.length; h++) {
			var e = j[h].serverinfo;
			var d = j[h].pushinfo;
			var c = e.serverID;
			n.push(c);
			e.serverURL = this._addHTTP(e.serverURL);
			var f = d ? d.lastPushAgeInHours : -1;
			var g = d ? d.remotePatientID : "";
			var m = d ? d.remotePatientGUID : "";
			var l = d ? (e.serverURL + d.remotePatientURL) : "";
			this._remoteServers[c] = {url: e.serverURL, desc: e.serverDescription, pushAgeHours: f, remoteID: g, remoteGUID: m, remoteURL: l}
		}
		n.sort();
		var k = this;
		this._selectServer(this._selectedServer)
	}, _selectServer: function (d, c) {
		this._selectedServer = d;
		var h = this._remoteServers[d];
		var m = new Element("a", {href: h.url, target: "_blank", "class": "remote-server-name"}).update(this._selectedServer);
		if (this._numAvailableServers == 1) {
			this._serverInfo.update("There is only one configured remote server: ")
		}
		var n = "";
		if (h.pushAgeHours !== undefined && h.pushAgeHours >= 0) {
			n = new Element("dd");
			var o = new Element("p", {id: "server-description"});
			var l = h.pushAgeHours;
			o.insert("This patient was uploaded to " + this._selectedServer);
			if (l < 1) {
				o.insert(" less than an hour ago")
			} else {
				if (l >= 48) {
					o.insert(" " + Math.floor(l / 24) + " days ago")
				} else {
					o.insert(" " + l + " hours ago")
				}
			}
			o.insert(" and was assigned patient ID ").insert(new Element("a", {href: h.remoteURL, target: "_blank"}).update(h.remoteID)).insert(".");
			o.insert("<br/>If data in the record has changed, push to __serverID__ again to update the record there.".replace("__serverID__", this._selectedServer));
			n.insert(o);
			var k = this;
			var e = new Element("p");
			var j = new Element("input", {type: "radio", value: "update", id: "choice-update-patient", name: "new-or-update"});
			j.checked = true;
			j.observe("change", function () {
				k._displayGroupPicker()
			});
			var g = new Element("label", {hidden: true}).insert(new Element("span", {"class": "fa fa-refresh"}).update(" ")).insert(j).insert("Update remote patient");
			var i = new Element("input", {type: "radio", value: "new", id: "choice-new-patient", name: "new-or-update"});
			i.observe("change", function () {
				k._displayGroupPicker()
			});
			var f = new Element("label", {hidden: true}).insert(new Element("span", {"class": "fa fa-plus-square"}).update(" ")).insert(i).insert("Create new remote patient");
			n.insert(g).insert(f)
		}
		this._serverInfo.update(new Element("dl").insert(m.clone(true).wrap("dt")).insert(h.desc && new Element("dd", {"class": "hint"}).update(h.desc) || "").insert(n || ""));
		this._approveMessage.update("I agree to push selected patient data to " + this._selectedServer);
		if (!c) {
			this._serverInfo.show();
			this._queryStoredUserName()
		}
	}, _onServerOptionChange: function () {
		var c = this._serverSelector.down("select");
		var d = c.options[c.selectedIndex].value;
		this._onNoServerSelected();
		if (d != "none") {
			this._selectServer(d)
		}
	}, _initServerSelector: function () {
		this._serverLoadMessages = new Element("div", {id: "server-load-messages"});
		this._serverLoadMessages.hide();
		var c = new Element("select", {id: "server-selector"});
		c.insert(new Element("option", {value: "none"}).update("Loading server list..."));
		c.observe("change", this._onServerOptionChange.bind(this));
		this._serverSelector = new Element("div", {id: "server-selector-div"});
		this._serverSelector.hide();
		this._serverSelector.update(c);
		this._serverInfo = new Element("div", {id: "server-info"});
		this._serverManager.update(this._serverLoadMessages).insert(this._serverSelector).insert(this._serverInfo)
	}, _initMainFormActions: function () {
		var e = this;
		var d = new Element("div", {"class": "buttons"});
		d.insert(new Element("input", {type: "hidden", name: "xaction", value: "push"}));
		d.insert(new Element("input", {type: "hidden", name: "patient", value: this._patientId}));
		var c = this._pushManyPatients ? "Next: Select patients and data fields to be pushed" : "Next: Select data fields to be pushed";
		d.insert(new Element("input", {type: "submit", name: "submit", value: c, "class": "button", id: "push_patient_button"}).wrap("span", {"class": "buttonwrapper"}));
		d.insert(new Element("input", {type: "button", name: "close", value: "Cancel", "class": "button secondary"}).wrap("span", {"class": "buttonwrapper"}));
		this._container.insert(d);
		this._pushResultSection = new Element("div", {"class": "section-contents"});
		this._container.insert(this._pushResultSection);
		this._cancelButton = d.down('input[name="close"]');
		this._cancelButton.observe("click", function (f) {
			e._dialog.closeDialog()
		});
		this._pushButton = d.down('input[name="submit"]');
		this._checkBoxApprove.observe("click", function (f) {
			e._pushResultSection.update("");
			if (e._checkBoxApprove.checked) {
				e._pushButton.enable()
			} else {
				e._pushButton.disable()
			}
		});
		this._container.observe("submit", function (f) {
			f.stop();
			e._pushSelectFieldsAndPatients()
		})
	}, _updatingExistingPatient: function () {
		var d = false;
		var c = document.getElementById("choice-update-patient");
		if (c) {
			d = c.checked
		}
		return d
	}, _selectPushNewPatient: function () {
		var c = document.getElementById("choice-update-patient");
		var d = document.getElementById("choice-new-patient");
		if (c && d) {
			c.checked = false;
			d.checked = true
		}
	}, _disableUpdateOption: function () {
		var e = document.getElementById("choice-new-patient");
		if (e) {
			e.checked = true
		}
		var c = document.getElementById("choice-update-patient-label");
		if (c) {
			var d = document.getElementById("server-description");
			d.insert("<p>Selected server does not allow updating existing patients, so can only push again to a new patient record.</p>");
			c.hide()
		}
	}, _pushPatient: function (f, d, g) {
		var i = this;
		if (i._pushManyPatients && (!d || !g)) {
			return
		}
		if (!i._pushManyPatients) {
			i._pushResultSection.update("")
		}
		if (f) {
			i._lastSelectedColumnList = f
		} else {
			f = i._lastSelectedColumnList
		}
		if (!f || f.length == 0) {
			i._pushResultSection.update(new Element("div", {"class": "errormessage"}).update("No columns were selected"));
			return
		}
		var d = d ? d : this._patientId;
		var h = {"do": "push", serverid: this._selectedServer, patientid: d};
		h.fields = f ? Object.toJSON(f) : Object.toJSON(this._patientFieldList);
		if (i._pushManyPatients) {
			h.guid = "auto"
		} else {
			if (this._updatingExistingPatient()) {
				h.guid = i._remoteServers[i._selectedServer].remoteGUID
			}
		}
		var e = $$('input:checked[type=radio][name="select-group"]')[0].value;
		if (e != "__self") {
			h.groupname = e
		}
		var c = {consents: i._consentsModule.listGrantedConsentIDs()};
		h.patientState = stringifyObject(c);
		console.log("PUSH request params: " + stringifyObject(h));
		new Ajax.Request(this._serviceURL, {method: i._container.method, parameters: h, onCreate: function () {
			i._disableInputs(true)
		}, onSuccess: function (k) {
			try {
				console.log("Got response: " + stringifyObject(k.responseJSON));
				var l = k.responseJSON;
				if (i._pushManyPatients) {
					g(l, d);
					return
				}
				if (l.status == "success") {
					i._checkBoxApprove.checked = false;
					var o = i._remoteServers[i._selectedServer].url + l.patienturl;
					i._remoteServers[i._selectedServer]["pushAgeHours"] = 0;
					i._remoteServers[i._selectedServer]["remoteID"] = l.patientid;
					i._remoteServers[i._selectedServer]["remoteGUID"] = l.patientguid;
					i._remoteServers[i._selectedServer]["remoteURL"] = o;
					if (i._updatingExistingPatient()) {
						var n = "(<a href='" + o + "' target='_blank'>click here to open remote patient</a>)";
						i._pushResultSection.update(new Element("div", {"class": "infomessage"}).update("Updated patient successfully. " + n))
					} else {
						var j = "<a href='" + o + "' target='_blank'>" + l.patientid + "</a>";
						i._pushResultSection.update(new Element("div", {"class": "infomessage"}).update("Pushed patient successfully, ID of the new patient on the remote server is " + j))
					}
					i._selectServer(i._selectedServer, true);
					i._displayGroupPicker()
				} else {
					if (l.updatesdisabled) {
						i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient - updates are disbaled on the remote server"))
					} else {
						if (l.invalidguid) {
							i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient - stored remote GUID is incorrect. Maybe the patient was deleted on the remote server&nbsp;", false, true))
						} else {
							if (l.accessdeniedguid) {
								i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient - access denied. Check if the given remote user has access rights to update the patient"))
							} else {
								if (l.accessdeniedguid) {
									i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient: access denied"))
								} else {
									if (l.cantconnect) {
										i._pushResultSection.update(i._generateFailedToPushPatient("Unable to connect to server", true))
									} else {
										if (l.missingconsent) {
											i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient - missing a required consent", true))
										} else {
											i._pushResultSection.update(i._generateFailedToPushPatient("Unable to update this patient", true))
										}
									}
								}
							}
						}
					}
				}
			} catch (m) {
				console.log("EXCEPTION: " + m);
				i._pushResultSection.update(i._generateFailedToPushPatient("Error updating patient ( __e__ )".replace("__e__", m), true))
			}
		}, onFailure: function (k) {
			if (i._pushManyPatients) {
				g({status: "error"}, d);
				return
			}
			var j = false;
			var l = k.statusText;
			if (k.statusText == "" || k.status == 12031) {
				l = "Server not responding";
				j = true
			}
			i._pushResultSection.update(i._generateFailedToPushPatient(l, j))
		}, on0: function (j) {
			if (i._pushManyPatients) {
				g({status: "error"}, d);
				return
			}
			j.request.options.onFailure(j)
		}, onComplete: function () {
			i._restoreInputs();
			if (!i._checkBoxApprove.checked) {
				i._pushButton.disable()
			}
		}})
	}, _addHTTP: function (c) {
		if (!/^(f|ht)tps?:\/\//i.test(c)) {
			c = "http://" + c
		}
		return c
	}, _pushSelectFieldsAndPatients: function () {
		var j = this;
		var g = function (k, m) {
			j._checkBoxApprove.checked = false;
			var o = new Element("div", {"class": "multi-push-results infomessage"});
			j._pushResultSection.update(o);
			var n = 0;
			var l = function (q, r) {
				if (q && r) {
					if (q.status != "success") {
						o.className = "multi-push-results errormessage";
						if (q.cantconnect) {
							o.insert(" Unable to connect to server");
							return
						}
						var s = "failed.";
						if (q.invalidguid) {
							s = "Unable to update: stored remote GUID is incorrect"
						} else {
							if (q.accessdeniedguid) {
								s = "Unable to update: access denied."
							} else {
								if (q.missingconsent) {
									s = "Unable to update this patient - missing a required consent"
								}
							}
						}
						o.insert(" " + s + "<br/>")
					} else {
						o.innerHTML = o.innerHTML.replace(/Pushing (\w+?)\.\.\.$/, "");
						var u = j._remoteServers[j._selectedServer].url + q.patienturl;
						var t = "<a href='" + u + "' target='_blank'>" + q.patientid + "</a>";
						o.insert("<div class='pushed-ok-message'>" + "Pushed __prevPatientID__ successfully, remote patient ID is __linkToRemote__".replace("__prevPatientID__", r).replace("__linkToRemote__", t) + "</div>")
					}
				}
				if (n < k.length) {
					var p = k[n++];
					o.insert("Pushing __nextPatientID__...".replace("__nextPatientID__", p));
					j._pushPatient(m, p, l)
				}
			};
			l()
		};
		var d = function (k, l) {
			if (k.length == 0) {
				return
			}
			var m = "Do you want to push the following __numPatients__ patients to __selectServer__?".replace("__numPatients__", k.length).replace("__selectServer__", j._selectedServer) + "<br/><div class='plainmessage multi-push-patient-list'><ol>";
			k.each(function (n) {
				m += "<li>" + n + "</li>"
			});
			m += "</ol></div>";
			new XWiki.widgets.ConfirmationBox({onYes: function () {
				g(k, l)
			}, }, {confirmationText: m, showCancelButton: false})
		};
		if (j._pushManyPatients) {
			var i = $("phenotips_export");
			if (!i) {
				return
			}
			var f = new b.widgets.ModalPopup('<img src="resources/icons/xwiki/ajax-loader-large.gif"/>', false, {title: "Select patients and fields to be pushed", verticalPosition: "top", removeOnClose: true, extraClassName: "export-dialog"});
			f.showDialog();
			var e = function () {
				alert("Failed to get the list of patients to be pushed")
			};
			new Ajax.Request(new XWiki.Document("ExportPreferences", "PhenoTips").getURL("get", "space=" + /space=([^&]+)/.exec(i.href)[1] + "&push=true&multipatient=true&remoteserver=" + this._selectedServer), {parameters: {enabledFields: this._lastLoginResponse.serverfields}, onSuccess: function (l) {
				var k = f.dialogBox._x_contentPlug;
				k.update(l.responseText);
				k.__dialog = f;
				document.fire("xwiki:dom:updated", {elements: [k], pushPreferences: k, pushMulti: true, callbackOK: d, callbackFail: e})
			}})
		} else {
			var f = new b.widgets.ModalPopup('<img src="resources/icons/xwiki/ajax-loader-large.gif"/>', false, {title: "Select fields to be pushed", verticalPosition: "top", removeOnClose: true, extraClassName: "narrow-export-dialog export-dialog"});
			f.showDialog();
			var c = function () {
				alert("Failed to get the list of fields to be pushed")
			};
			var h = function (k) {
				j._pushPatient(k)
			};
			new Ajax.Request(new XWiki.Document("ExportPreferences", "PhenoTips").getURL("get", "push=true&singlepatient=false&remoteserver=" + this._selectedServer), {parameters: {enabledFields: this._lastLoginResponse.serverfields}, onSuccess: function (l) {
				var k = f.dialogBox._x_contentPlug;
				k.update(l.responseText);
				k.__dialog = f;
				document.fire("xwiki:dom:updated", {elements: [k], pushPreferences: k, pushMulti: false, callbackOK: h, callbackFail: c})
			}})
		}
	}});
	return b
}(PhenoTips || {}));
["xwiki:dom:updated"].each(function (a) {
	document.observe(a, function (g) {
		if (!g.memo || !g.memo.pushPreferences || !g.memo.callbackOK) {
			return
		}
		var d = g.memo.pushPreferences.__dialog;
		var c = g.memo.callbackOK;
		var f = g.memo.callbackFail;
		var e = g.memo.pushMulti;
		var h = $("export_cancel");
		h && h.observe("click", function (i) {
			d.closeDialog()
		});
		var b = g.memo.pushMulti ? $("push-multiple-patients") : $("push-patient");
		b && b.observe("click", function (n) {
			n.stop();
			var m = b.up("form");
			if (m) {
				var k = [];
				var j = m.down(".push-fields");
				var o = j.select('input[name="columns"]');
				o.each(function (q) {
					if (q.checked) {
						k.push(q.identify().replace("columns_", ""))
					}
				});
				if (!e) {
					d.closeDialog();
					c(k);
					return
				}
				var p = $("filter-match-count");
				var l = "/get/PhenoTips/ExportFilter?list=true&" + m.serialize();
				var i = new Ajax.Request(l, {method: "get", onSuccess: function (r) {
					var q = [];
					r.responseJSON.each(function (s) {
						q.push(s.replace("data.", ""))
					});
					c(q, k)
				}, onFailure: function (q) {
					f && f()
				}})
			}
			d.closeDialog()
		})
	})
});
document.observe("xwiki:dom:loaded", function () {
	new PhenoTips.widgets.PushPatientWidget()
});
function stringifyObject(a) {
	return _printObjectInternal(a, 1)
}
function _printObjectInternal(d, e) {
	if (e > 10) {
		return"...[too deep, possibly a recursive object]..."
	}
	var b = "";
	if (typeof d == "object") {
		if (Object.prototype.toString.call(d) === "[object Array]") {
			b = "[";
			for (var c = 0; c < d.length; c++) {
				if (c > 0) {
					b += ", "
				}
				b += _printObjectInternal(d[c], e + 1)
			}
			b += "]"
		} else {
			b = "{";
			var a = 0;
			if (e == 0) {
				b += "\n"
			}
			for (property in d) {
				if (!d.hasOwnProperty(property)) {
					continue
				}
				if (e != 0 && a != 0) {
					b += ", "
				}
				b += property + ": " + _printObjectInternal(d[property], e + 1);
				if (e == 0) {
					b += "\n"
				}
				a++
			}
			b += "}"
		}
	} else {
		if (typeof d == "string") {
			b = "'" + d + "'"
		} else {
			b = "" + d
		}
	}
	return b
};
(function () {
	function a(b) {
		if (typeof console != "undefined" && typeof console.warn == "function") {
			console.warn(b)
		}
	}

	if (typeof XWiki.widgets == "object" && typeof XWiki.widgets.FullScreen == "function") {
		XWiki.editors = XWiki.editors || {};
		XWiki.editors.FullScreenEditing = Class.create(XWiki.widgets.FullScreen, {initialize: function ($super) {
			a("XWiki.editors.FullScreenEditing is deprecated since XWiki 2.6RC2. Use XWiki.widgets.FullScreen instead.");
			$super()
		}})
	}
	if (window.useXWKns) {
		a("_xwk namespace is deprecated since XWiki 2.6RC1. Use the XWiki namespace instead.");
		if (typeof _xwk == "undefined") {
			_xwk = new Object()
		}
	} else {
		_xwk = window
	}
	_xwk.ajaxSuggest = Class.create(XWiki.widgets.Suggest, {initialize: function ($super) {
		a("ajaxSuggest is deprecated since XWiki 2.6RC1. Use XWiki.widgets.Suggest instead.");
		var b = $A(arguments);
		b.shift();
		$super.apply(_xwk, b)
	}});
	window.displayDocExtra = XWiki.displayDocExtra.wrap(function () {
		a("window.displayDocExtra is deprecated since XWiki 1.9M2. Use XWiki.displayDocExtra instead.");
		var b = $A(arguments), c = b.shift();
		return c.apply(window, b)
	});
	if (typeof XWiki.widgets == "object" && typeof XWiki.widgets.LiveTable == "function") {
		window.ASSTable = Class.create(XWiki.widgets.LiveTable, {initialize: function ($super, b, f, e, c, g, h, i, d) {
			a("window.ASSTable is deprecated since XWiki 1.9M2. Use XWiki.widgets.LiveTable instead.");
			if ($("showLimits")) {
				if ($("showLimits").up("tr")) {
					$("showLimits").up("tr").insert({after: new Element("tr").update(new Element("td").update(new Element("div", {id: e + "-pagination", "class": "xwiki-grid-pagination-content"})))})
				}
				$("showLimits").id = e + "-limits"
			}
			if ($("scrollbar1") && $("scrollbar1").up("td")) {
				if ($("scrollbar1").up("td").next()) {
					$("scrollbar1").up("td").next().remove()
				}
				$("scrollbar1").up("td").remove()
			}
			if ($("table-filters")) {
				$("table-filters").id = e + "-filters"
			}
			$super(b, e, h, {action: d})
		}})
	}
	window.hideForm = function (b) {
		a("window.hideForm is deprecated since XWiki 2.6RC1. Use a CSS selector + Element#toggleClassName instead.");
		b.getElementsByTagName("fieldset").item(0).className = "collapsed"
	};
	window.toggleForm = function (c) {
		a("window.toggleForm is deprecated since XWiki 2.6RC1. Use a CSS selector + Element#toggleClassName instead.");
		var b = c.getElementsByTagName("fieldset").item(0);
		if (b.className == "collapsed") {
			b.className = "expanded"
		} else {
			b.className = "collapsed"
		}
	};
	window.createCookie = XWiki.cookies.create.wrap(function () {
		a("window.createCookie is deprecated since XWiki 2.6RC1. Use XWiki.cookies.create instead.");
		var b = $A(arguments), c = b.shift();
		return c.apply(window, b)
	});
	window.readCookie = XWiki.cookies.read.wrap(function () {
		a("window.readCookie is deprecated since XWiki 2.6RC1. Use XWiki.cookies.read instead.");
		var b = $A(arguments), c = b.shift();
		return c.apply(window, b)
	});
	window.eraseCookie = XWiki.cookies.erase.wrap(function () {
		a("window.eraseCookie is deprecated since XWiki 2.6RC1. Use XWiki.cookies.erase instead.");
		var b = $A(arguments), c = b.shift();
		return c.apply(window, b)
	});
	window.togglePanelVisibility = XWiki.togglePanelVisibility.wrap(function () {
		a("window.togglePanelVisibility is deprecated since XWiki 2.6RC1. Use XWiki.togglePanelVisibility instead.");
		var b = $A(arguments), c = b.shift();
		return c.apply(window, b)
	});
	window.cancelEdit = function () {
		a("window.cancelEdit is deprecated since XWiki 4.1M1. Use XWiki.EditLock.unlock instead.");
		XWiki.EditLock.unlock()
	};
	window.lockEdit = function () {
		a("window.lockEdit is deprecated since XWiki 4.1M1. Use XWiki.EditLock.lock instead.");
		XWiki.EditLock.lock()
	};
	window.cancelCancelEdit = function () {
		a("window.cancelCancelEdit is deprecated since XWiki 4.1M1. Use XWiki.EditLock.setLocked(false) instead.");
		XWiki.EditLock.setLocked(false)
	};
	XWiki.resource = XWiki.resource || {};
	Object.extend(XWiki.resource, {getWikiFromResourceName: function (b) {
		if (b.include(XWiki.constants.wikiSpaceSeparator)) {
			return b.substring(0, b.indexOf(XWiki.constants.wikiSpaceSeparator))
		}
		return null
	}, getSpaceFromResourceName: function (c) {
		var b = c;
		if (c.include(XWiki.constants.wikiSpaceSeparator)) {
			c = c.substring(c.indexOf(XWiki.constants.wikiSpaceSeparator) + 1, c.length)
		}
		if (c.include(XWiki.constants.spacePageSeparator)) {
			if (c.include(XWiki.constants.pageAttachmentSeparator) && c.indexOf(XWiki.constants.spacePageSeparator) > c.indexOf(XWiki.constants.pageAttachmentSeparator)) {
				return null
			}
			return c.substring(0, c.indexOf(XWiki.constants.spacePageSeparator))
		}
		if (b.include(XWiki.constants.wikiSpaceSeparator) && !b.include(XWiki.constants.pageAttachmentSeparator) && !b.include(XWiki.constants.anchorSeparator)) {
			return c
		}
		return null
	}, getNameFromResourceName: function (c) {
		var b = c;
		if (c.include(XWiki.constants.wikiSpaceSeparator)) {
			c = c.substring(c.indexOf(XWiki.constants.wikiSpaceSeparator) + 1, c.length)
		}
		if (c.include(XWiki.constants.pageAttachmentSeparator)) {
			c = c.substring(0, c.indexOf(XWiki.constants.pageAttachmentSeparator))
		}
		if (c.include(XWiki.constants.anchorSeparator)) {
			c = c.substring(0, c.indexOf(XWiki.constants.anchorSeparator))
		}
		if (c.include(XWiki.constants.spacePageSeparator)) {
			return c.substring(c.indexOf(XWiki.constants.spacePageSeparator) + 1, c.length)
		} else {
			if (b.include(XWiki.constants.wikiSpaceSeparator)) {
				return null
			} else {
				return c
			}
		}
	}, getAttachmentFromResourceName: function (b) {
		if (b.include(XWiki.constants.pageAttachmentSeparator)) {
			return b.substring(b.indexOf(XWiki.constants.pageAttachmentSeparator) + 1, b.length)
		}
		return null
	}, getAnchorFromResourceName: function (b) {
		if (b.include(XWiki.constants.anchorSeparator)) {
			return b.substring(b.indexOf(XWiki.constants.anchorSeparator) + 1, b.length)
		}
		return null
	}});
	XWiki.constants = XWiki.constants || {};
	Object.extend(XWiki.constants, {wikiSpaceSeparator: ":", spacePageSeparator: ".", pageAttachmentSeparator: "@"});
	(function () {
		if ($$("meta[name='document']").length > 0) {
			return
		}
		var c = $$("html")[0];
		var b = $$("head")[0];
		var d = function (e, f) {
			b.insert(new Element("meta", {name: e, content: c.readAttribute("data-xwiki-" + f)}))
		};
		d("document", "document");
		d("wiki", "wiki");
		d("space", "space");
		d("page", "page");
		d("version", "version");
		d("restURL", "resturl");
		d("form_token", "form-token");
		b.insert(new Element("meta", {name: "language", content: c.readAttribute("lang")}))
	})()
})();
XWiki.lastScriptLoaded = true;
if (XWiki.failedInit) {
	XWiki.initialize()
}
;
/**
 * Class for storing either exact or fuzzy dates.
 *
 * Assert:
 *   if day is set   => all of {decade, year, month, day} are set
 *   if month is set => all of {decade, year, month} are set
 *   if year is set  => decade is also set
 *
 * Note:
 *   month is from 1 to 12
 *   day starts at 1
 */

var PedigreeDate = Class.create({

	/**
	 * Accepts either a string representation of date or a javascript Date object or an
	 * object with {year[,month][,day]} string or integer fields
	 */
	initialize: function (date) {
		this.decade = null;
		this.year = null;
		this.month = null;
		this.day = null;
		if (date == null || !date) return;

		var jsDate = null;
		if (typeof date === 'string' || date instanceof String) {
			// check if string matches the "decade only" format
			if (date.match(/^\d\d\d\ds$/)) {
				this.decade = date;
			}
			else if (!isNaN(Date.parse(date))) {  // empty string also parses to NaN
				// deal with timezone differences: treat all dates as being in the same timezone.
				// for that need to parse input string, if posible, and extract day/month/year
				// "as is", regardless of the timezone attached
				// As of now, expected/supported format is "Tue Dec 09 00:00:00 UTC 2014"
				var parsed = date.match(/\w\w\w (\w\w\w) (\d\d) \d\d:\d\d:\d\d \w\w\w (\d\d\d\d)/);
				if (parsed !== null) {
					// use Date("Dec 09, 2014") constructor
					var timezonelessDate = parsed[1] + " " + parsed[2] + ", " + parsed[3];
					jsDate = new Date(timezonelessDate);
				} else {
					// Also suport the PhenoTips patient JSON format "yyyy-mm-dd"
					var parsed = date.match(/(\d\d\d\d)-(\d\d)-(\d\d)/);
					if (parsed !== null) {
						// use Date("Dec 09, 2014") constructor
						var month0based = parseInt(parsed[2]) - 1;
						var timezonelessDate = this._getMonthName("en", month0based) + " " + parsed[3] + ", " + parsed[1];
						jsDate = new Date(timezonelessDate);
					} else {
						// parse any other format
						jsDate = new Date(date);
					}
				}
			}
		} else if (Object.prototype.toString.call(date) === '[object Date]') {
			jsDate = date;
		}

		if (jsDate !== null) {
			this.year = jsDate.getFullYear();
			this.month = jsDate.getMonth() + 1;   // js Date's months are 0 to 11, this.month is 1 to 12
			this.day = jsDate.getDate();
		}
		else if (typeof date === 'object') {
			date.hasOwnProperty("decade") && ( this.decade = date.decade );
			// keep null-s, convert strings to integers
			date.hasOwnProperty("year") && ( this.year = this.parseIntOrNull(date.year) );
			date.hasOwnProperty("month") && ( this.month = this.parseIntOrNull(date.month) );
			date.hasOwnProperty("day") && ( this.day = this.parseIntOrNull(date.day) );
		}

		if (this.year !== null && this.decade === null) {
			this.decade = this.year.toString().slice(0, -1) + '0s';
		}
	},

	parseIntOrNull: function (expectedInteger) {
		var result = parseInt(expectedInteger);
		if (isNaN(result)) {
			return null;
		}
		return result;
	},

	// Returns a string which will either be a year with an "s" at the end (e.g. "1990s") or
	// a string in one of "year", "monthName year", "datOfWeek monthName day year" format.
	// initialize() is expected to accept this string as valid input
	toString: function () {
		// note: Date.toDateString() is used for date-to-string conversions instead of
		//       Date.toUTCString because output of toDateString is the only one which seems
		//       to be uniformly supported by all browsers, new and old.

		if (this.year === null && this.decade !== null) {
			return this.decade;
		}
		if (this.year !== null && this.month == null) {
			return this.year.toString();
		}
		if (this.year !== null && this.month !== null && this.day === null) {
			return this.getMonthName() + " " + this.year;
		}
		if (this.year !== null && this.month !== null && this.day !== null) {
			var jsDate = this.toJSDate();
			return jsDate.toDateString();
		}
		return "";
	},

	getMonthName: function (locale) {
		if (this.getMonth() == null) return "";
		locale = locale && (locale in localeMonthNames) ? locale : 'en';
		return this._getMonthName(locale, this.getMonth() - 1);
	},

	_getMonthName: function (locale, month0based) {
		var localeMonthNames = {"en": ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] };
		return localeMonthNames[locale][month0based];
	},

	// Returns a string which is a valid GEDCOM date (GEDCOME supports "ABT" keyword)
	toGEDCOMString: function () {
		if (this.year === null && this.decade !== null) {
			// getYear(true) returns first year of decade as integer
			return "ABT " + this.getYear(true).toString();
		}
		return this.toString();
	},

	/** Returns true if any part of the date has been set. */
	isSet: function () {
		return (this.decade !== null || this.year !== null || this.month !== null || this.day !== null);
	},

	/** Returns true iff the minimum precision level is set, ie. the decade. Useful for displaying the date. */
	isComplete: function () {
		return (this.decade !== null);
	},

	onlyDecadeAvailable: function () {
		return (this.decade !== null && this.year == null);
	},

	// Returns a string or null
	getDecade: function () {
		return this.decade;
	},

	// Returns simple object with only the fields (decade, year, month, day) set
	getSimpleObject: function () {
		var date = {};
		if (this.decade !== null) date["decade"] = this.decade;
		if (this.year !== null) date["year"] = this.year;
		if (this.month !== null) date["month"] = this.month;
		if (this.day !== null) date["day"] = this.day;
		return date;
	},

	// Returns best possible estimation of this date as a javascript Date object.
	//
	// Aproximate dates (e.g. decades, or dates without a day or month) are set as
	// oldest possible date satisfying the date set (e.g. first year of decade, first month of the year, etc.)
	toJSDate: function () {
		var year = this.getYear(true);       // true: failsafe, get first year of decade if only decade is set
		var month = this.getMonth(true) - 1;  // "-1": js Date's months are 0 to 11, this.month is 1 to 12
		var day = this.getDay(true);
		var jsDate = new Date(year, month, day);
		return jsDate;
	},

	// Returns either a decade or the year (as string, which may include non-numeric characters, e.g. "1920s")
	getBestPrecisionStringYear: function () {
		if (!this.isComplete()) return "";
		if (this.year == null) return this.decade;
		return this.year.toString();
	},

	// If year is given returns the year; for decades returns the first year of the decade
	// (as string representation of an integer)
	getMostConservativeYearEstimate: function () {
		if (!this.isComplete()) return "";
		return this.getYear(true, false).toString();
	},

	// If year is given returns the year; for decades returns the middle of the decade
	// (as string representation of an integer)
	getAverageYearEstimate: function () {
		if (!this.isComplete()) return "";
		return this.getYear(true, true).toString();
	},

	getBestPrecisionStringDDMMYYY: function (dateFormat) {
		if (!dateFormat) {
			dateFormat = "DMY";
		}
		if (!this.isComplete()) return "";
		if (this.year == null) return this.decade;
		var dateStr = this.getYear().toString();
		if (this.getMonth() != null) {
			dateStr = ("0" + this.getMonth()).slice(-2) + "-" + dateStr;
			if (this.getDay() != null && dateFormat == "DMY") {
				dateStr = ("0" + this.getDay()).slice(-2) + "-" + dateStr;
			}
		}
		return dateStr;
	},

	// Returns the number of milliseconds since 1 January 1970 (same as Date.getTime())
	getTime: function () {
		return this.toJSDate().getTime();
	},

	// Returns an integer or null.
	// Iff "failsafe" returns a value even if only decade is availabe (and year is not):
	//  - iff "average" the middle year of the decade is returned, otherwise the first year of the decade.
	getYear: function (failsafe, average) {
		if (this.isComplete() && this.year == null && failsafe) {
			// remove trailing "s" from the decade && convert to integer
			var year = parseInt(this.decade.slice(0, -1));
			if (average) {
				year += 5;
			}
			return year;
		}
		return this.year;
	},

	// Returns an integer or null
	// Iff "failsafe" returns 1 if month is not set but at least some date (with any precision) is
	getMonth: function (failsafe) {
		if (this.isComplete() && this.month == null && failsafe) {
			return 1;
		}
		return this.month;
	},

	// Returns an integer or null
	// Iff "failsafe" returns 1 if day is not set but at least some date (with any precision) is
	getDay: function (failsafe) {
		if (this.isComplete() && this.day == null && failsafe) {
			return 1;
		}
		return this.day;
	},

	canBeAfterDate: function (otherPedigreeDate) {
		if (!this.isComplete()) {
			return true;
		}
		if (!otherPedigreeDate.isComplete()) {
			return true;
		}
		if (this.getTime() > otherPedigreeDate.getTime()) {
			return true;
		}
		var leastOtherYear = otherPedigreeDate.getYear(true);
		var leastOtherMonth = otherPedigreeDate.getMonth(true);
		var leastOtherDay = otherPedigreeDate.getDay(true);

		var maxThisYear = this.year ? this.year : this.getYear(true) + 9;
		var maxThisMonth = this.month ? this.month : 12;
		var maxThisDay = this.day ? this.day : 31;

		if (maxThisYear > leastOtherYear) {
			return true;
		}
		if (maxThisYear < leastOtherYear) {
			return false;
		}
		if (maxThisMonth > leastOtherMonth) {
			return true;
		}
		if (maxThisMonth < leastOtherMonth) {
			return false;
		}
		return (maxThisDay >= leastOtherDay);
	}
});

//attributes for graphical elements in the editor

var PedigreeEditorParameters = {};

PedigreeEditorParameters.styles = {
	"blackAndWhite": {
		nodeShapeFemale: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeMale: {fill: "#ffffff", stroke: "#111111"},
		nodeShapeOther: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeDiag: {fill: "#ffffff", stroke: "#222222"},
		nodeShapeAborted: {fill: "#ffffff", stroke: "#222222"}
	}
};

PedigreeEditorParameters.attributes = {
	radius: 40,
	orbRadius: 6,
	touchOrbRadius: 8,
	personHoverBoxRadius: 90,  // 80    for old handles, 90 for new
	newHandles: true,          // false for old handles
	personHandleLength: 75,    // 60    for old handles, 75 for new
	personHandleBreakX: 55,
	personHandleBreakY: 53,
	personSiblingHandleLengthX: 65,
	personSiblingHandleLengthY: 30,
	enableHandleHintImages: true,
	handleStrokeWidth: 5,
	groupNodesScale: 0.85,
	infertileMarkerHeight: 4,
	infertileMarkerWidth: 14,
	twinCommonVerticalLength: 6,
	twinMonozygothicLineShiftY: 24,
	curvedLinesCornerRadius: 25,
	unbornShape: {'font-size': 50, 'font-family': 'Cambria'},
	carrierShape: {fill: '#595959'},
	carrierDotRadius: 8,
	presymptomaticShape: {fill: '#777777', "stroke": "#777777"},
	presymptomaticShapeWidth: 8,
	uncertainShape: {'font-size': '45px', 'font-family': 'Arial', 'fill': '#696969', 'font-weight': 'bold'},
	uncertainSmallShape: {'font-size': '30px', 'font-family': 'Arial', 'fill': '#696969', 'font-weight': 'bold'},
	evaluationShape: {'font-size': 40, 'font-family': 'Arial'},
	nodeShapeFemale: PedigreeEditorParameters.styles.blackAndWhite.nodeShapeFemale,
	nodeShapeMale: PedigreeEditorParameters.styles.blackAndWhite.nodeShapeMale,
	nodeShapeOther: PedigreeEditorParameters.styles.blackAndWhite.nodeShapeOther,
	nodeShapeDiag: PedigreeEditorParameters.styles.blackAndWhite.nodeShapeDiag,
	nodeShapeAborted: PedigreeEditorParameters.styles.blackAndWhite.nodeShapeAborted,
	nodeShapeMenuOn: {fill: "#000", stroke: "none", "fill-opacity": 0.1},
	nodeShapeMenuOff: {fill: "#000", stroke: "none", "fill-opacity": 0},
	nodeShapeMenuOnPartner: {fill: "#000", stroke: "none", "fill-opacity": 0.1},
	nodeShapeMenuOffPartner: {fill: "#000", stroke: "none", "fill-opacity": 0},
	boxOnHover: {fill: "gray", stroke: "none", opacity: 1, "fill-opacity": .35},
	menuBtnIcon: {fill: "#1F1F1F", stroke: "none"},
	deleteBtnIcon: {fill: "#990000", stroke: "none"},
	btnMaskHoverOn: {opacity: .6, stroke: 'none'},
	btnMaskHoverOff: {opacity: 0},
	btnMaskClick: {opacity: 1},
	orbHue: .53,
	phShape: {fill: "white", "fill-opacity": 0, "stroke": 'black', "stroke-dasharray": "- "},
	dragMeLabel: {'font-size': 14, 'font-family': 'Tahoma'},
	pedNumberLabel: {'font-size': 19, 'font-family': 'Serif'},
	descendantGroupLabel: {'font-size': 21, 'font-family': 'Tahoma'},
	label: {'font-size': 20, 'font-family': 'Arial'},
	nameLabels: {'font-size': 20, 'font-family': 'Arial'},
	commentLabel: {'font-size': 19, 'font-family': 'Arial' },
	cancerAgeOfOnsetLabels: {'font-size': 19, 'font-family': 'Arial' },
	externalIDLabels: {'font-size': 16, 'font-family': 'Arial' },
	disorderShapes: {},
	partnershipNode: {fill: '#d79185', stroke: 'black', 'stroke-width': 2},  //#dc7868, #E25740
	partnershipRadius: 7.0,
	partnershipHandleBreakY: 18,
	partnershipHandleLength: 36,
	partnershipLines: {"stroke-width": 1.25, stroke: '#303058'},
	partnershipLinesAdoptedIn: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "--"},
	consangrPartnershipLines: {"stroke-width": 1.25, stroke: '#402058'},
	noContactLines: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "-.-."},
	noContactAdoptedIn: {"stroke-width": 1.25, stroke: '#303058', "stroke-dasharray": "-- ."},
	noContactLinesConsangr: {"stroke-width": 1.25, stroke: '#402058', "stroke-dasharray": "-.-."},
	childlessShapeAttr: {"stroke-width": 2.5, stroke: "#3C3C3C"},
    participatingInTestAttr: {"stroke-width": 1.5, 'font-size': 16, 'font-weight':'boold', 'font-family': 'Tahoma'},//{"stroke-width": 2.5, stroke: "#3C3C3C"},
    partnershipChildlessShapeAttr: {"stroke-width": 2.0, stroke: "#3C3C3C"},
	childlessLength: 14,
	parnershipChildlessLength: 27,
	graphToCanvasScale: 12,
	layoutRelativePersonWidth: 10,
	layoutRelativeOtherWidth: 2,
	layoutScale: { xscale: 12.0, yscale: 8 },
	maxPrintPreviewPaneHeight: 600,
	minPrintPreviewPaneHeight: 250
};


var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.SolrQueryProcessor = Class.create({
		initialize: function (queryFields, restriction) {
			this.queryFields = queryFields;
			this.restriction = restriction;
		},

		processQuery: function (query) {
			return this.inflateQuery(query);
		},

		generateParameters: function (query) {
			var parameters = {'defType': 'edismax', 'spellcheck.collate': true, 'spellcheck': true, 'lowercaseOperators': false};
			if (this.setupMandatoryQuery(query, parameters)) {
				return parameters;
			}
			this.restrictQuery(query, parameters);
			this.setupQueryFields(query, parameters);
			return parameters;
		},

		setupMandatoryQuery: function (query, parameters) {
			var txt = query.strip();
			var mandatoryQuery = "";
			var hasMandatoryFields = false;
			for (var field in this.queryFields) {
				var fieldOptions = this.queryFields[field];
				var activationRegex = fieldOptions['activationRegex'];
				if (!fieldOptions['mandatory'] || !activationRegex || !txt.match(activationRegex)) {
					continue;
				}
				mandatoryQuery += field + ":" + (fieldOptions['transform'] ? fieldOptions['transform'](query) : query) + " ";
				hasMandatoryFields = true;
			}
			if (mandatoryQuery) {
				parameters.fq = mandatoryQuery.strip();
			}
			return hasMandatoryFields;
		},

		restrictQuery: function (query, parameters) {
			if (!this.restriction) {
				return;
			}
			var result = "";
			for (var rField in this.restriction) {
				var restrictionString = (rField.substring(0, 1) == '-' ? '-' : '+') + "(";
				for (var i = 0; i < this.restriction[rField].length; ++i) {
					restrictionString += rField.replace(/^-/, '') + ":" + this.restriction[rField][i].replace(/:/g, "\\:") + " ";
				}
				restrictionString = restrictionString.strip() + ") ";
				result += restrictionString;
			}
			if (result) {
				parameters.fq = result.strip();
			}
		},

		setupQueryFields: function (query, parameters) {
			var txt = query.strip();
			var wordFields = "";
			var phraseFields = "";
			var boostQuery = "";
			var lastWord = query.replace(/.*\W/g, '');
			for (var field in this.queryFields) {
				var fieldOptions = this.queryFields[field];
				var activationRegex = fieldOptions['activationRegex'];
				if (activationRegex && !txt.match(activationRegex)) {
					continue;
				}
				if (fieldOptions['wordBoost']) {
					wordFields += field + "^" + fieldOptions['wordBoost'] + " ";
				}
				if (fieldOptions['phraseBoost']) {
					phraseFields += field + "^" + fieldOptions['phraseBoost'] + (fieldOptions['phraseSlop'] ? "~" + fieldOptions['phraseSlop'] : "") + " ";
				}
				if (lastWord && fieldOptions['stubBoost']) {
					boostQuery += field + ":" + lastWord.replace(/:/g, "\\:") + "*^" + fieldOptions['stubBoost'] + " ";
				}
			}
			if (wordFields) {
				parameters.qf = wordFields.strip();
			}
			if (phraseFields) {
				parameters.pf = phraseFields.strip();
			}
			if (boostQuery) {
				parameters.bq = boostQuery.strip();
			}
		},

		inflateQuery: function (query) {
			var lastWord = query.replace(/.*\W/g, '');
			if (!lastWord) {
				return query;
			}
			var result = query;

			for (var field in this.queryFields) {
				if (this.queryFields[field].stubTrigger) {
					result += " " + field + ":" + lastWord.replace(/:/g, "\\:") + "*";
				}
			}
			return result.strip();
		}
	});
	return PhenoTips;
}(PhenoTips || {}));


var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.OntologyBrowser = Class.create({
		options: {
			script: "${xwiki.getURL('PhenoTips.SolrService', 'get', 'sort=nameSort asc&start=0&rows=10000')}&",
			varname: "query",
			method: "post",
			json: true,
			responseFormat: "application/json",
			resultsParameter: function(){return "rows"}, //Added for GEL(GenomicsEngland), use function instead of fixed-value
			resultId: function(){return "id"}, //Added for GEL(GenomicsEngland), use function instead of fixed-value
			resultValue: function(){return "name"}, //Added for GEL(GenomicsEngland), use function instead of fixed-value
			resultCategory: "term_category",
			resultParent: {
				selector: 'is_a',
				processingFunction: function (text) {
					var data = {};
					data.id = text.replace(/\s+/gm, ' ').replace(/(HP:[0-9]+)\s*!\s*(.*)/m, "$1");
					data.value = text.replace(/\s+/gm, ' ').replace(/(HP:[0-9]+)\s*!\s*(.*)/m, "$2");
					return data;
				}
			},
			noresults: "No sub-terms",
			targetQueryProcessor: typeof(PhenoTips.widgets.SolrQueryProcessor) == "undefined" ? null : new PhenoTips.widgets.SolrQueryProcessor({
				'id': {'activationRegex': /^HP:[0-9]+$/i, 'mandatory': true, 'transform': function (query) {
					return query.toUpperCase().replace(/:/g, "\\:");
				}}
			}),
			expandQueryProcessor: typeof(PhenoTips.widgets.SolrQueryProcessor) == "undefined" ? null : new PhenoTips.widgets.SolrQueryProcessor({
				'is_a': {'activationRegex': /^HP:[0-9]+$/i, 'mandatory': true, 'transform': function (query) {
					return query.toUpperCase().replace(/:/g, "\\:");
				}}
			}),
			showParents: true,
			showRoot: true,
			enableSelection: true,
			enableBrowse: true,
			isTermSelected: function (id) {
				return false;
			},
			unselectTerm: function (id) {
			},

			defaultEntryAction: 'browse' /* {browse, select} */
		},

		initialize: function (suggest, container, options) {
			this.options = Object.extend(Object.clone(this.options), options || { });
			this.suggest = suggest;
			this.loadingMessage = new Element('div', {'class': 'plainmessage loading'}).update("Loading...");
			if (container) {
				this.container = container;
			} else {
				this.container = new PhenoTips.widgets.ModalPopup(this.loadingMessage, {}, {
					idPrefix: 'ontology-browser-window-',
					title: "Related terms",
					backgroundColor: "#ffffff",
					verticalPosition: "top",
					extraDialogClassName: "dialog-ontology-browser",
					removeOnClose: true
				});
				this.options.modal = true;
			}
			this._obrowserExpandEventHandler = this._obrowserExpandEventHandler.bindAsEventListener(this);
		},

		load: function (id) {
			this.setContent(this.loadingMessage);
			var query = id;
			var parameters = {};
			if (this.options.targetQueryProcessor != null && typeof(this.options.targetQueryProcessor.generateParameters) == "function") {
				parameters = this.options.targetQueryProcessor.generateParameters(query);
			}
			if (this.options.targetQueryProcessor != null && typeof(this.options.targetQueryProcessor.processQuery) == "function") {
				query = this.options.targetQueryProcessor.processQuery(query);
			}
			var url = this.options.script + this.options.varname + "=" + encodeURIComponent(query);
			var headers = {};
			headers.Accept = this.options.responseFormat;

			var ajx = new Ajax.Request(url, {
				method: this.options.method,
				parameters: parameters,
				requestHeaders: headers,
				onSuccess: function (response) {
					this.setContent(this.buildTree(this._getDataFromResponse(response)));
					this.__crtRoot = id;
					if (this.container.content) {
						Event.fire(document, 'xwiki:dom:updated', {'elements': [this.container.contentContainer || this.container.content]});
					}
				}.bind(this),
				onFailure: function (response) {
					this.setContent("Failed to retrieve data : " + response.statusText);
					this.__crtRoot = '';
				}.bind(this)
			});
		},

		expandTo: function (termId, categories) {
			if (categories.indexOf(this.__crtRoot) == -1) {
				// not in the right tree, nothing to do
				return;
			}
			this._expandToStep(termId, categories.without(this.__crtRoot, termId));
		},

		_expandToStep: function (termId, categories) {
			var _this = this;
			//alert ("expanding " + termId + " " + categories);
			var target = this.container.contentContainer.down('li.entry input.select-tool[value="' + termId.replace(/"/g, '\\"') + '"]');
			if (target) {
				return;
			}
			var finishedStep = false;
			categories.each(function (category) {
				if (finishedStep) {
					return
				}
				var categoryInput = _this.container.contentContainer.down('li.entry input.select-tool[value="' + category.replace(/"/g, '\\"') + '"]');
				if (categoryInput) {
					//alert ("start expanding " + category + " " + categories);
					var categoryEntry = categoryInput.up('li');
					if (categoryEntry.hasClassName('collapsed') || !categoryEntry.down('.descendents')) {
						Event.observe(categoryEntry, "obrowser:expand:finished", function (event) {
							Event.stopObserving(categoryEntry, "obrowser:expand:finished");
							_this._expandToStep(termId, categories.without(category));
						});
						_this._toggleExpandState(categoryEntry);
						finishedStep = true;
					}
				}
			});
		},

		expand: function (element, doPopulate) {
			var query = element.__termId;
			var parameters = {};
			if (this.options.expandQueryProcessor != null && typeof(this.options.expandQueryProcessor.generateParameters) == "function") {
				parameters = this.options.expandQueryProcessor.generateParameters(query);
			}
			if (this.options.expandQueryProcessor != null && typeof(this.options.expandQueryProcessor.processQuery) == "function") {
				query = this.options.expandQueryProcessor.processQuery(query);
			}
			var url = this.options.script + this.options.varname + "=" + encodeURIComponent(query);
			var headers = {};
			headers.Accept = this.options.responseFormat;

			var ajx = new Ajax.Request(url, {
				method: this.options.method,
				requestHeaders: headers,
				parameters: parameters,
				onCreate: function () {
					this._lockExpandTool(element)
				}.bind(this),
				onSuccess: function (response) {
					var memo = {};
					if (doPopulate) {
						var newAdditions = this.buildDescendentsList(this._getDataFromResponse(response));
						element.insert({'bottom': newAdditions});
						Event.fire(document, "obrowser:content:added", {added: newAdditions, obrowser: this});
						Event.fire(element, "obrowser:expand:finished");
						Event.fire(this.container.contentContainer || document, "obrowser:expand:finished");
						Event.fire(document, 'xwiki:dom:updated', {'elements': [newAdditions]});
						//memo.data = this.buildDescendentsList(this._getDataFromResponse(response));
						//Event.fire(element, 'obrowser:expand:done', memo);
					} else {
						memo.count = this.countDescendents(this._getDataFromResponse(response));
						//Event.fire(element, 'obrowser:count:done', memo);
					}
					if ((memo.count === 0) || (doPopulate && !element.down('.descendents .entry, .error'))) {
						element.addClassName('collapsed');
						var expandTool = element.down('.expand-tool');
						if (expandTool) {
							expandTool.update(this._getExpandCollapseSymbol(true)).addClassName('disabled');
							expandTool.stopObserving('click');
						}
					}
					Event.fire(document, "ms:popup:content-updated", {popup: this.container});
				}.bind(this),
				onFailure: function (response) {
					Event.fire(element, 'obrowser:expand:failed', {data: new Element('div', {'class': 'error'}).update("Failed to retrieve data : " + response.statusText), count: -1});
				},
				onComplete: function () {
					this._unlockExpandTool(element)
				}.bind(this)
			});
		},

		_getDataFromResponse: function (response) {
			if (this.options.json) {
				return response.responseJSON;
			}
			return response.responseXML;
		},
		_getResultset_json: function (data, fieldName) {
			return data && data[fieldName] || [];
		},
		_getResultFieldValue_json: function (data, fieldName) {
			return data && data[fieldName] || '';
		},
		_getResultFieldValueAsArray_json: function (data, fieldName) {
			return new Array(data && data[fieldName] || '').flatten();
		},
		_getResultset_xml: function (data, selector) {
			var elements = data && data.getElementsByTagName(selector);
			return elements;
		},
		_getResultFieldValue_xml: function (data, selector) {
			var element = data && Element.down(data, selector);
			return element && element.firstChild && element.firstChild.nodeValue || '';
		},
		_getResultFieldValueAsArray_xml: function (data, selector) {
			var result = new Array();
			if (data) {
				Element.select(data, selector).each(function (item) {
					var value = item.firstChild && item.firstChild.nodeValue;
					if (value) {
						result.push(value);
					}
				});
			}
			return result;
		},
		_getResultset: function (data, fieldName) {
			if (this.options.json) {
				return this._getResultset_json(data, fieldName);
			}
			return this._getResultset_xml(data, fieldName);
		},
		_getResultFieldValue: function (data, fieldName) {
			if (this.options.json) {
				return this._getResultFieldValue_json(data, fieldName);
			}
			return this._getResultFieldValue_xml(data, fieldName);
		},
		_getResultFieldValueAsArray: function (data, fieldName) {
			if (this.options.json) {
				return this._getResultFieldValueAsArray_json(data, fieldName);
			}
			return this._getResultFieldValueAsArray_xml(data, fieldName);
		},

		buildTree: function (data) {
			//Added for GEL(GenomicsEngland), use function instead of fixed-value
			//var results = this._getResultset(data, this.options.resultsParameter);
			var results = this._getResultset(data, this.options.resultsParameter());
			if (results.length == 0) {
				return new Element('div', {'class': 'error'}).update(this.options.noresults);
			}
			var targetResult = results[0];
			var newContent = new Element('div');
			if (this.options.showParents) {
				var parents = new Element('ul', {'class': 'parents'});
				this._getResultFieldValueAsArray(targetResult, this.options.resultParent.selector).each(function (item) {
					var text = item;
					var data = {};
					if (typeof (this.options.resultParent.processingFunction) == "function") {
						data = this.options.resultParent.processingFunction(text);
					}
					parents.insert({'bottom': this._createParentBranch(data)});
				}.bind(this));
				if (parents.hasChildNodes()) {
					newContent.insert({'top': parents});
				}
				Event.fire(document, "obrowser:content:added", {added: parents, obrowser: this});
			}

			//Commented for GEL(GenomicsEngland), use function instead of fixed-value
			//var data = {
			//	id: this._getResultFieldValue(targetResult, this.options.resultId),
			//	value: this._getResultFieldValue(targetResult, this.options.resultValue),
			//	category: this._generateEntryCategory(targetResult)
			//}
			//Added for GEL(GenomicsEngland), use function instead of fixed-value
			var data = {
				id: this._getResultFieldValue(targetResult, this.options.resultId()),
				value: this._getResultFieldValue(targetResult, this.options.resultValue()),
				category: this._generateEntryCategory(targetResult)
			}
			var root = this._createRoot(data);
			newContent.insert({'bottom': root});
			Event.fire(document, "obrowser:content:added", {added: root, obrowser: this});
			//this._toggleExpandState(root);
			return newContent;
		},

		countDescendents: function (xml) {
			//Added for GEL(GenomicsEngland), use function instead of fixed-value
			//return this._getResultset(xml, this.options.resultsParameter).length;
			return this._getResultset(xml, this.options.resultsParameter()).length;
		},

		buildDescendentsList: function (xml) {
			//Added for GEL(GenomicsEngland), use function instead of fixed-value
			//var results = this._getResultset(xml, this.options.resultsParameter);
			var results = this._getResultset(xml, this.options.resultsParameter());
			var list = new Element('ul', {'class': 'descendents'});
			for (var i = 0; i < results.length; i++) {
				//Added for GEL(GenomicsEngland), use function instead of fixed-value
				//var data = {
				//	id: this._getResultFieldValue(results[i], this.options.resultId),
				//	value: this._getResultFieldValue(results[i], this.options.resultValue),
				//	category: this._generateEntryCategory(results[i])
				//};
				var data = {
					id: this._getResultFieldValue(results[i], this.options.resultId()),
					value: this._getResultFieldValue(results[i], this.options.resultValue()),
					category: this._generateEntryCategory(results[i])
				};
				list.insert({'bottom': this._createDescendentBranch(data)});
			}
			if (list.hasChildNodes()) {
				return list;
			}
			return new Element('div', {'class': 'descendents hint empty'}).update(this.options.noresults);
		},

		_createBranch: function (eltName, className, data, expandable) {
			var element = new Element(eltName, {'class': 'entry ' + className});
			element.__termId = data.id;
			element.__termCategory = data.category;
			var wrapper = new Element('div', {'class': 'entry-data'});
			wrapper.insert({'bottom': this._generateEntryTitle(data.id, data.value)});
			var entryTools = new Element('span', {'class': 'entry-tools'});
			entryTools.observe('click', function (event) {
				event.stop()
			}); // don't forward click events
			wrapper.insert({'bottom': entryTools});
			element.update(wrapper);

			if (!this._isRootEntry(element)) {
				if (this.options.defaultEntryAction == 'browse') {
					wrapper.down('.info').observe('click', this._browseEntry.bindAsEventListener(this));
				}
			}
			entryTools.insert(new Element('span', {'class': 'fa fa-info-circle phenotype-info xHelpButton', title: data.id}));

			if (this.options.enableSelection) {
				element.__selectTool = new Element('input', {'type': 'checkbox', name: 'term_selector', value: data.id, 'class': 'select-tool'});
				wrapper.insert({'top': element.__selectTool});
				if (this.options.isTermSelected(element.__termId)) {
					element.addClassName('accepted');
					element.__selectTool.checked = 'checked';
				}
				element.__selectTool.observe('click', this._toggleEntrySelection.bindAsEventListener(this));
				if (this.options.defaultEntryAction == 'select') {
					wrapper.down('.info').observe('click', this._toggleEntrySelection.bindAsEventListener(this));
				}
			}

			if (expandable) {
				var expandTool = new Element('span', {'class': 'expand-tool'}).update(this._getExpandCollapseSymbol(!element.hasClassName('root')));
				expandTool.observe('click', function (event) {
					var entry = event.element().up('.entry');
					if (!this._isExpandToolLocked(entry)) {
						this._toggleExpandState(entry);
					}
				}.bindAsEventListener(this));
				var expandOnSelect = function (e) {
					if (!this._isExpandToolLocked(element) && e.memo.selected == "yes") {
						this._expandEntry(element);
					}
				}
				element.observe('obrowser:entry:selected', expandOnSelect.bindAsEventListener(this));
				element.observe('ynpicker:selectionChanged', expandOnSelect.bindAsEventListener(this));
				wrapper.insert({'top': expandTool});
				this.expand(element, element.hasClassName('root'));
				//element.observe('obrowser:expand:done', this._obrowserExpandEventHandler);
				//element.observe('obrowser:count:done', this._obrowserExpandEventHandler);
				//element.observe('obrowser:expand:failed', this._obrowserExpandEventHandler);
			}
			return element;
		},

		_generateEntryTitle: function (id, value) {
			return  new Element('span', {'class': 'info'}).insert(
				{'bottom': new Element('span', {'class': 'key'}).update('[' + id + ']')}).insert(
				{'bottom': ' '}).insert(
				{'bottom': new Element('span', {'class': 'value'}).update(value)});
		},

		_generateEntryCategory: function (xmlFragment) {
			var category = new Element("span", {'class': 'hidden term-category'});
			if (this.options.resultCategory) {
				this._getResultFieldValueAsArray(xmlFragment, this.options.resultCategory).each(function (c) {
					category.insert(new Element('input', {'type': 'hidden', 'value': c}));
				});
			}
			if (category.hasChildNodes()) {
				return category;
			} else {
				return null;
			}
		},

		_expandEntry: function (target) {
			if (!target) return;
			if (!target.down('.descendents')) {
				//This is the first expansion, fetch subterms
				target.down(".error") && target.down(".error").remove();
				this.expand(target, true);
			} else {
				Event.fire(target, "obrowser:expand:finished");
			}
			target.removeClassName('collapsed');
			target.down('.expand-tool').update(this._getExpandCollapseSymbol(false));
		},
		_collapseEntry: function (target) {
			if (!target) return;
			target.addClassName('collapsed');
			Event.fire(target, "obrowser:expand:finished");
			target.down('.expand-tool').update(this._getExpandCollapseSymbol(true));
		},
		_toggleExpandState: function (target) {
			if (target) {
				if (!target.down('.descendents') || target.hasClassName('collapsed')) {
					this._expandEntry(target);
				} else {
					this._collapseEntry(target);
				}
			}
		},

		_obrowserExpandEventHandler: function (event) {
			var element = event.element();
			if (!event.memo) {
				return;
			}
			if (event.memo.data) {
				element.insert({'bottom': event.memo.data});
				element.stopObserving('obrowser:expand:done', this._obrowserExpandEventHandler);
			} else if (typeof (event.memo.count) != "undefined") {
				element.stopObserving('obrowser:count:done', this._obrowserExpandEventHandler);
			}
			element.stopObserving('obrowser:expand:failed', this._obrowserExpandEventHandler);
			if ((event.memo.count == "0") || (!element.hasClassName('root') && event.memo.data && !element.down('.descendents .entry, .error'))) {
				element.addClassName('collapsed');
				var expandTool = element.down('.expand-tool');
				if (expandTool) {
					expandTool.update(this._getExpandCollapseSymbol(true)).addClassName('disabled');
					expandTool.stopObserving('click');
				}
			}
			this._unlockExpandTool(element);
			Event.fire(document, "ms:popup:content-updated", {popup: this.container});
			if (event.memo.data) {
				Event.fire(element, "obrowser:expand:finished");
			}
		},

		_lockExpandTool: function (element) {
			var expandTool = element.down('.expand-tool');
			if (expandTool) {
				expandTool.addClassName('locked');
			}
		},

		_unlockExpandTool: function (element) {
			var expandTool = element.down('.expand-tool');
			if (expandTool) {
				expandTool.removeClassName('locked');
			}
		},

		_isExpandToolLocked: function (element) {
			if (element.down('.expand-tool.locked')) {
				return true;
			}
			return false;
		},

		_getExpandCollapseSymbol: function (isCollapsed) {
			if (isCollapsed) {
				return "&#x25ba;";
			}
			return "&#x25bc;";
		},
		_toggleEntrySelection: function (event) {
			var trigger = event.element();
			if (!trigger.hasClassName('select-tool')) {
				trigger.up('.entry').down('input').click();
				return;
			}
			var elt = trigger.up('.entry');
			if (trigger.checked) {
				this._selectEntry(elt);
			} else {
				this._unselectEntry(elt);
			}
		},
		_selectEntry: function (entry) {
			if (this.suggest) {
				if (this.options.modal && typeof (this.container.getPositionInViewport) == 'function') {
					var prevPosition = this.container.getPositionInViewport();
				}
				var value = entry.down('.value').firstChild.nodeValue;
				this.suggest.acceptEntry({'id': entry.__termId, 'value': value, 'category': entry.__termCategory, 'negative': entry.down('.selected.no')}, value, '', true);
				entry.addClassName('accepted');
				if (prevPosition && (typeof (this.container.positionDialogInViewport) == 'function')) {
					this.container.positionDialogInViewport(prevPosition.left, prevPosition.top);
				}
				entry.fire('obrowser:entry:selected', {selected: (entry.down('.selected.no')) ? "no" : "yes"});
			}
		},
		_unselectEntry: function (entry) {
			this.options.unselectTerm(entry.__termId);
			this.options.unselectTerm(entry.__termId, true);
			entry.removeClassName('accepted');
		},

		_browseEntry: function (event) {
			event.stop();
			var elt = event.element().up('.entry');
			this.load(elt.__termId);
		},

		_createParentBranch: function (parent) {
			var parent = this._createBranch('li', 'parent', parent, false);
			return parent;
		},

		_createRoot: function (data) {
			var root = this._createBranch('div', 'root', data, true);
			if (!this.options.showRoot) {
				root.addClassName('no-root');
				root.down('.entry-data').addClassName('invisible');
			}
			return root;
		},

		_createDescendentBranch: function (data) {
			return this._createBranch('li', 'descendent', data, true);
		},

		_isRootEntry: function (element) {
			return element.hasClassName('entry') && element.hasClassName('root');
		},

		setContent: function (content) {
			this.container.setContent(new Element('div', {'class': 'ontology-tree'}).update(content));
		},

		show: function (id) {
			if (id) {
				this.container.show();
				if (this.__crtRoot != id) {
					this.load(id);
				} else {
					Event.fire(this.container.contentContainer || document, 'obrowser:expand:finished');
				}
			}
		},

		hide: function () {
			this.container.close();
		}
	});

	return PhenoTips;
}(PhenoTips || {}));


var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.DropDown = Class.create({
		options: {},
		initialize: function (element) {
			this.element = element;
			this.hasForceOpen = false;
			var existingDropdown = element.next(".dropdown");
			if (existingDropdown) {
				this.contentContainer = null;
				this.dropdown = existingDropdown;
				this.hasForceOpen = true;
			} else {
				this.dropdown = new Element('div', {'class': 'dropdown'});

				this.contentContainer = new Element('div');
				this.dropdown.update(this.contentContainer);
			}
			//var closeButton = new Element('div', {'class': 'close', 'title': 'Close'}).update("&#215;");
			//closeButton.observe("click", this.close.bindAsEventListener(this));
			//this.dropdown.insert({top: closeButton});
		},
		setContent: function (content) {
			this.contentContainer != null ? this.contentContainer.update(content) : null;
		},
		show: function (force) {
			if (force && !this.hasForceOpen) {
				return false;
			}
			if (this.dropdown.hasClassName('invisible')) {
				this.dropdown.removeClassName('invisible');
			} else {
				this.element.insert({after: this.dropdown});
			}
			return true;
		},
		close: function (force) {
			if (force && !this.hasForceOpen) {
				return false;
			}
			this.dropdown.addClassName('invisible');
			return true;
			//this.dropdown.remove();
		}
	});
	return PhenoTips;
}(PhenoTips || {}));


StickyBox = Class.create({
	options: {
		offsetTop: 6,
		offsetBottom: 0,
		resize: false,
		isSticky: function (element) {
			return true
		}
	},
	initialize: function (stickyElement, stickyAreaElement, options) {
		this.stickyElement = stickyElement;
		this.stickyAreaElement = stickyAreaElement;
		if (this.stickyElement && this.stickyAreaElement) {
			this.options = Object.extend(Object.clone(this.options), options || { });
			// Temporary, for backwards compatibility with deprecated parameter 'shadowSize'
			if (this.options.shadowSize && options.offsetTop === undefined) {
				this.options.offsetTop = this.options.shadowSize;
			}
			this.resetPosition = this.resetPosition.bindAsEventListener(this);
			Event.observe(window, 'scroll', this.resetPosition);
			Event.observe(window, 'resize', this.resetPosition);
			if (typeof(this.options.makeDefault) == 'function') {
				thid.makeDefault = this.options.makeDefault.bind(this);
			}
			this.resetPosition();
		}
	},

	resetPosition: function () {
		if (!this.options.isSticky(this.stickyElement) || this.stickyElement.getHeight() >= this.stickyAreaElement.getHeight()) {
			return;
		}
		this.stickyElement.style.height = '';
		this.stickyElement.style.overflow = '';
		this.stickyElement.fire('size:changed');
		this.boxHeight = this.stickyElement.getHeight();
		var maxBoxHeight = document.viewport.getHeight() - this.options.offsetTop - this.options.offsetBottom;
		if (this.options.resize) {
			var memo = {'diff': (maxBoxHeight - this.boxHeight), 'original': this.boxHeight};
			this.boxHeight = maxBoxHeight;
			this.stickyElement.style.height = this.boxHeight + "px";
			this.stickyElement.style.overflow = 'auto';
			this.stickyElement.fire('size:changed', memo);
		}
		this.boxWidth = this.stickyElement.getWidth();
		this.boxMinTop = this.stickyAreaElement.cumulativeOffset().top + this.options.offsetTop;
		this.boxMaxTop = this.stickyAreaElement.cumulativeOffset().top + this.stickyAreaElement.getHeight() - this.boxHeight;
		this.boxLeft = this.stickyElement.cumulativeOffset().left;
		this.boxRelativeLeft = this.boxLeft - this.stickyElement.getOffsetParent().viewportOffset().left;
		var relativeContentPosition = this.stickyAreaElement.viewportOffset().top;
		this.direction = 0;
		if (this.stickyAreaElement._prevPosition) {
			if (this.stickyAreaElement._prevPosition > relativeContentPosition) {
				this.direction = 1;
			} else if (this.stickyAreaElement._prevPosition < relativeContentPosition) {
				this.direction = -1;
			}
		}
		if ((this.options.isSticky(this.stickyElement) || this.direction == 1) &&
			document.viewport.getScrollOffsets().top >= this.boxMinTop &&
			document.viewport.getScrollOffsets().top < this.boxMaxTop) {
			this.makeFixed();
		} else if ((this.options.isSticky(this.stickyElement) || this.direction == -1) &&
			document.viewport.getScrollOffsets().top >= this.boxMaxTop) {
			this.makeAbsolute();
		} else {
			this.makeDefault();
		}
		this.stickyAreaElement._prevPosition = relativeContentPosition;
	},

	makeFixed: function () {
		if (this.stickyElement.style.position != 'fixed') {
			this.stickyElement.addClassName('sticky');
			this.stickyElement.style.left = this.boxLeft + 'px';
			this.stickyElement.style.width = (this.boxWidth) + 'px';
			this.stickyElement.style.top = this.options.offsetTop + 'px';
			this.stickyElement.style.right = '';
			this.stickyElement.style.position = 'fixed';
		}
	},
	makeAbsolute: function (top) {
		if (this.stickyElement.style.position != 'absolute') { // || top && this.stickyElement.style.top != top + 'px'){
			this.stickyElement.addClassName('sticky');
			top = top || (this.stickyAreaElement.getHeight() - this.stickyElement.getHeight());
			this.stickyElement.style.top = top + 'px';
			this.stickyElement.style.right = '';
			var originalPosition = this.stickyElement.getStyle('position');
			this.stickyElement.style.position = 'absolute';
			if (originalPosition == 'fixed' && !Prototype.Browser.WebKit) {
				this.stickyElement.style.left = (this.boxRelativeLeft - this.stickyElement.getOffsetParent().viewportOffset().left + 2) + 'px';
			} else {
				this.stickyElement.style.left = this.boxRelativeLeft + 'px';
			}
		}
	},
	makeDefault: function () {
		if (this.stickyElement.style.position != '') {
			this.stickyElement.removeClassName('sticky');
			this.stickyElement.style.position = '';
			this.stickyElement.style.top = '';
			this.stickyElement.style.left = '';
			this.stickyElement.style.right = '';
			this.stickyElement.style.width = '';
		}
	},
	isFixed: function () {
		return (this.stickyElement.style.position == 'fixed');
	},
	isAbsolute: function () {
		return (this.stickyElement.style.position == 'absolute');
	},
	isDefault: function () {
		return (this.stickyElement.style.position == '');
	}
});

var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.FreeMultiselect = Class.create({
		counter: 1,
		options: {
			returnKeyNavigation: false
		},
		initialize: function (element, options) {
			this.options = Object.extend(Object.clone(this.options), options || { });
			var _this = this;

			// Suggest?
			var suggestInfoSource = element.previous('input[name="xwiki-free-multiselect-suggest-script"][type="hidden"]');
			if (suggestInfoSource && suggestInfoSource.value && typeof(XWiki.widgets.Suggest) != "undefined") {
				this.suggestOptions = {
					script: suggestInfoSource.value,
					shownoresults: false,
					varname: "input",
					timeout: 0
				}
			}

			// Add a delete button and a "KEY_RETURN" keypress event listener for each line
			this.enhanceLine = this.enhanceLine.bind(this);
			var values = element.select('li input.xwiki-free-multiselect-value');
			values.each(this.enhanceLine);

			// Generate and insert the "add" button, edit mode only
			if (element.down('input.xwiki-free-multiselect-value')) {
				var addTool = new Element('a', {'title': 'add', 'href': '#' + element.id}).update('+...');
				element.insert(addTool.wrap('li'));
				addTool.observe('click', function (event) {
					event.stop();
					var prevLine = addTool.up('li').previous();
					var template = prevLine && prevLine.down('input.xwiki-free-multiselect-value');
					if (template) {
						_this.generateInput(template);
					}
				}.bindAsEventListener(this));
			}
		},

		enhanceLine: function (element) {
			element.id = this.generateId(element);
			element.up('li').addClassName('xwiki-free-multiselect-line');
			this.attachDeleteTool(element);
			if (this.suggestOptions) {
				new XWiki.widgets.Suggest(element, this.suggestOptions);
			}
			this.enableAddInput(element);
		},

		attachDeleteTool: function (element) {
			var wrapper = element.up('.xwiki-free-multiselect-line');
			var deleteTool = new Element('a', {'title': 'delete', 'href': '#' + element.id}).update('✖');
			wrapper.insert(' ').insert(deleteTool);
			deleteTool.observe('click', function (event) {
				event.stop();
				var wrapper = event.findElement('.xwiki-free-multiselect-line');
				if (wrapper.previous('.xwiki-free-multiselect-line') || wrapper.next('.xwiki-free-multiselect-line')) {
					wrapper.remove();
				} else {
					var target = wrapper.down('input');
					target.value = '';
					target.focus();
				}
			});
		},

		enableAddInput: function (element) {
			var wrapper = element.up('.xwiki-free-multiselect-line');
			var _this = this;
			if (!wrapper) {
				return;
			}
			element.observe('keypress', function (event) {
				if (event.keyCode == Event.KEY_RETURN) {
					event.stop();
					var next = wrapper.next('.xwiki-free-multiselect-line');
					if (_this.options.returnKeyNavigation && next && next.down('input')) {
						next.down('input').focus();
					} else {
						element.next().removeClassName('inactive');
						_this.generateInput(element);
					}
				} else if (event.keyCode == Event.KEY_BACKSPACE && element.value == '') {
					event.stop();
					var previous = wrapper.previous('.xwiki-free-multiselect-line');
					if (previous && previous.down('input')) {
						previous.down('input').focus();
						element.up('.xwiki-free-multiselect-line').remove();
					}
				}
			});
		},

		generateInput: function (template) {
			var newInput = new Element('input', {'name': template.name, id: this.generateId(template), type: template.type, size: template.size, 'class': 'xwiki-free-multiselect-value'});
			var newWrapper = new Element('li');
			newWrapper.insert(newInput);
			template.up('.xwiki-free-multiselect-line').insert({after: newWrapper});
			this.enhanceLine(newInput);
			newInput.focus();
		},

		generateId: function (element) {
			return element.name + '_' + this.nextIndex();
		},

		nextIndex: function () {
			return ++this.counter;
		},

		lastIndex: function () {
			return this.counter;
		}

	});
	return PhenoTips;
}(PhenoTips || {}));

document.observe("xwiki:dom:loaded", function () {
	$$('.xwiki-free-multiselect').each(function (element) {
		new PhenoTips.widgets.FreeMultiselect(element);
	});
});


var XWiki = (function (XWiki) {
	// Start XWiki augmentation
	var widgets = XWiki.widgets = XWiki.widgets || {};

	widgets.VisibilityController = Class.create({
		initialize: function (element) {
			this.element = element;
			this.reverse = this.element.hasClassName("exclude");
			this.controller = this.element.select(".controller input[type=checkbox]");
			var eventName = "change";
			if (this.controller.length == 0) {
				return;
			} else if (this.controller.length == 1) {
				this.controller = this.controller[0];
			} else {
				this.controller = this.element.down(".controller .yes input[type=checkbox]");
				eventName = "picker:change";
			}
			if (!this.controller) {
				// No controller, nothing else to do...
				return;
			}
			this.controlled = this.element.select(".controlled");
			if (this.element.hasClassName("complete-hide")) {
				this.hiddenStyle = {"display": "none"};
				this.visibleStyle = {"display": ""};
			} else {
				this.hiddenStyle = {"visibility": "hidden"};
				this.visibleStyle = {"visibility": "visible"};
			}
			this.controlVisibility();
			this.controller.observe(eventName, this.controlVisibility.bindAsEventListener(this));
		},
		controlVisibility: function () {
			if (this.controller.checked ^ this.reverse) {
				this.controlled.invoke("setStyle", this.hiddenStyle);
				this.element.select(".controlled input").invoke("disable");
			} else {
				this.controlled.invoke("setStyle", this.visibleStyle);
				this.element.select(".controlled input").invoke("enable");
			}
		}
	});

	var init = function (event) {
		((event && event.memo.elements) || [document.getElementById(PedigreeEditorTool.divId)]).each(function (element) {
			element.select(".controlled-group").each(function (group) {
				if (!group.__visibilityController) {
					group.__visibilityController = new XWiki.widgets.VisibilityController(group);
				}
			});
		});
		return true;
	};

	(XWiki.domIsLoaded && init()) || document.observe("xwiki:dom:loaded", init);
	document.observe("xwiki:dom:updated", init);

	// End XWiki augmentation.
	return XWiki;
}(XWiki || {}));


var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.UnitConverter = Class.create({

		CONVERSION_META: {
			'weight': {
				'imperial_units': ['lb', 'oz'],
				'metric_unit': 'kg',
				'inter_unit_scale': 16,
				'inter_system_scale': 0.0283495
			},
			'length': {
				'imperial_units': ['ft', 'in'],
				'metric_unit': 'cm',
				'inter_unit_scale': 12,
				'inter_system_scale': 2.54
			}
		},

		DEFAULT_UNIT_SYSTEM: 'metric',

		initialize: function (container, selector, triggerInsertionElt, triggerInsertionPosition, system) {
			this._selector = selector;
			this._container = container || document.documentElement;
			if (!this._selector || !triggerInsertionElt) {
				return;
			}

			this.crtUnitSystem = system || this.DEFAULT_UNIT_SYSTEM;

			this.initializeElements = this.initializeElements.bind(this);
			this.attachConverter = this.attachConverter.bind(this);

			this.generateTrigger(triggerInsertionElt, triggerInsertionPosition || 'bottom');

			this.initializeElements();
			var _this = this;
			document.observe('xwiki:dom:updated', function (event) {
				if (event.memo && event.memo.elements) {
					event.memo.elements.each(_this.initializeElements.bind(_this));
				}
			});
		},

		generateTrigger: function (atElement, position) {
			this._trigger = new Element('select', {"class": "unit-system-selector"});

			var optionMetric = new Element('option', {
				value: 'metric'
			}).update('Metric units (' + this.CONVERSION_META.weight.metric_unit + ', ' + this.CONVERSION_META.length.metric_unit + ')');
			if (this.crtUnitSystem == 'metric') {
				optionMetric.selected = 'selected';
			}
			var optionImperial = new Element('option', {
				value: 'imperial'
			}).update('Imperial units (' + this.CONVERSION_META.weight.imperial_units.join(' / ') + ', ' + this.CONVERSION_META.length.imperial_units.join(' / ') + ')');
			if (this.crtUnitSystem == 'imperial') {
				optionImperial.selected = 'selected';
			}
			this._trigger.insert(optionMetric).insert(optionImperial);

			insertionInfo = {};
			insertionInfo[position] = this._trigger;
			atElement.insert(insertionInfo);

			var _this = this;
			this._trigger.observe('change', function (event) {
				_this.crtUnitSystem = _this._trigger.options[_this._trigger.selectedIndex].value;
				_this.switchUnits(_this.crtUnitSystem);
			});
		},

		initializeElements: function (element) {
			container = element || this._container;
			if (container.__unitSwitcher || (!container.up('.measurements') && !container.hasClassName('measurements'))) {
				return;
			}
			container.__unitSwitcher = this;
			container.select(this._selector).each(this.attachConverter);
			this.switchUnits(this.crtUnitSystem, container);
		},

		switchUnits: function (type, element) {
			container = element || this._container;
			container.select('.unit-conversion-values .unit-type').each(function (item) {
				if (item.hasClassName(type)) {
					item.show();
				} else {
					item.hide();
				}
			});
		},

		attachConverter: function (element) {
			if (element.tagName.toLowerCase() != 'input' || element.type != 'text') {
				return;
			}
			var unitElt = element.next('.unit');
			var converterElement = new Element('div', {'class': 'unit-conversion-values'});
			var imperialUnits;
			var type = (element.up('.weight')) ? 'weight' : 'length';

			converterElement.addClassName(type);
			converterElement._meta = this.CONVERSION_META[type];

			var values = this.metricToImperial(converterElement._meta, parseFloat(element.value) || 0);

			var metricZone = element.up('.metric');
			if (!metricZone) {
				metricZone = new Element('div', {'class': 'unit-type metric'});
				metricZone.insert(element).insert(unitElt || converterElement._meta.metric_unit);
				element.insert({after: converterElement});
			} else {
				metricZone.addClassName('unit-type');
				metricZone.insert({after: converterElement});
			}
			var imperialZone = new Element('div', {'class': 'unit-type imperial'});
			converterElement.insert(metricZone).insert(imperialZone);

			converterElement._meta.imperial_units.each(function (unit) {
				imperialZone.insert(new Element('label').insert(new Element('input', {'style': 'width: auto', 'name': unit, type: 'text', size: 3, value: (values[unit] || '')})).insert(unit));
			});

			this.enableSyncValues(converterElement);
		},

		enableSyncValues: function (element) {
			var _this = this;
			element.select('.imperial input').invoke('observe', 'change', function (event) {
				_this.syncMetricWithImperial(element);
			});
			element.select('.metric input').invoke('observe', 'change', function (event) {
				_this.syncImperialWithMetric(element);
			});
		},

		syncMetricWithImperial: function (element) {
			var metricInput = element.down('.metric input');
			metricInput.value = this.imperialToMetric(element._meta,
					parseFloat(element.down('.imperial input[name="' + element._meta.imperial_units[0] + '"]').value) || 0,
					parseFloat(element.down('.imperial input[name="' + element._meta.imperial_units[1] + '"]').value) || 0
			) || '';
			Event.fire(metricInput, 'phenotips:measurement-updated');
		},

		syncImperialWithMetric: function (element) {
			var imperialValues = this.metricToImperial(element._meta, parseFloat(element.down('.metric input').value) || 0);
			element._meta.imperial_units.each(function (unit) {
				element.down('.imperial input[name="' + unit + '"]').value = imperialValues[unit] || '';
			});
		},

		metricToImperial: function (conversionMeta, value) {
			var result = {};
			var lowerUnitValue = value / conversionMeta.inter_system_scale;
			var higherUnitValue = Math.floor(lowerUnitValue / conversionMeta.inter_unit_scale);
			lowerUnitValue = lowerUnitValue - higherUnitValue * conversionMeta.inter_unit_scale;
			if (lowerUnitValue) {
				lowerUnitValue = lowerUnitValue.toFixed(2);
			}
			result[conversionMeta.imperial_units[0]] = higherUnitValue;
			result[conversionMeta.imperial_units[1]] = lowerUnitValue;
			return result;
		},

		imperialToMetric: function (conversionMeta, higherUnitValue, lowerUnitValue) {
			return ((conversionMeta.inter_unit_scale * higherUnitValue + lowerUnitValue) * conversionMeta.inter_system_scale).toFixed(2);
		}
	});
	return PhenoTips;
}(PhenoTips || {}));


PhenoTips = (function (PhenoTips) {
	// Start augmentation
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};

	widgets.HelpButton = Class.create({

		infoServices: {
			'xHelpButton': {
				'hint': $services.localization.render('phenotips.widgets.helpButtons.xHelpButton.hint'),
				'callback': function (helpButton) {
					helpButton.helpBox.content.update(helpButton._information || '');
				}
			},
			'phenotype-info': {
				'hint': $services.localization.render('phenotips.widgets.helpButtons.phenotype.hint'),
				'service': "$xwiki.getURL('PhenoTips.PhenotypeInfoService', 'get')",
				'callback': function (helpButton, json) {
					var c = helpButton.helpBox.content;
					var elt = function (type, cssClass, content) {
						return new Element(type, cssClass && {'class': cssClass} || {}).update(content || '');
					};

					c.update(
						elt('span', 'info').insert(elt('span', 'key').update(json.id))
							.insert(' ')
							.insert(elt('span', 'value').update(json.label))
					);
					json.def && c.insert(elt('p').update(json.def.replace(/\s*\n\s*/, ' ').replace(/`([^`]+)`\s+\(([A-Z]+:[0-9]+)`?\)/g, '<em title="$2">$1</em>')));

					var labels = {'synonym': $services.localization.render('phenotips.widgets.helpButtons.phenotype.synonym'), 'is_a': $services.localization.render('phenotips.widgets.helpButtons.phenotype.typeOf')};
					var advancedInfo = elt('dl');
					for (var l in labels) {
						if (json[l]) {
							advancedInfo.insert(elt('dt', '', labels[l]));
							json[l].each(function (item) {
								advancedInfo.insert(elt('dd', '', item.label || item));
							})
						}
					}
					if (advancedInfo.firstDescendant()) {
						c.insert(advancedInfo);
					}

					if (PhenoTips.widgets.OntologyBrowser) {
						var browseButton = new Element('a', {'class': 'button', href: '#'}).update($services.localization.render('phenotips.widgets.helpButtons.phenotype.browseRelated'));
						browseButton._id = json.id;
						browseButton.observe('click', function (event) {
							event.stop();
							var suggest = ($('quick-phenotype-search') || $$('input.suggestHpo')[0])._suggest;
							var params = {};
							if (typeof isPhenotypeSelected !== 'undefined') {
								params = {
									isTermSelected: isPhenotypeSelected,
									unselectTerm: unselectPhenotype
								};
							}
							browseButton._obrowser = new PhenoTips.widgets.OntologyBrowser(suggest, null, params);
							browseButton._obrowser.show(browseButton._id);
						});
						c.insert(elt('div', 'term-tools').insert(browseButton.wrap('span', {'class': 'buttonwrapper'})));
					}
				}
			},
			'phenotype-qualifier-info': {
				'hint': $services.localization.render('phenotips.widgets.helpButtons.phenotypeQualifier.hint'),
				'service': "$xwiki.getURL('PhenoTips.PhenotypeInfoService', 'get')",
				'callback': function (helpButton, json) {
					var c = helpButton.helpBox.content;
					var elt = function (type, cssClass, content) {
						return new Element(type, cssClass && {'class': cssClass} || {}).update(content || '');
					};
					c.update(
						elt('span', 'info').insert(elt('span', 'key').update(json.id))
							.insert(' ')
							.insert(elt('span', 'value').update(json.label))
					);
					json.def && c.insert(elt('p').update(json.def.replace(/\s*\n\s*/, ' ').replace(/`([^`]+)`\s+\(([A-Z]+:[0-9]+)`?\)/g, '<em title="$2">$1</em>')));
				}
			},
			'omim-disease-info': {
				'hint': "About this disease",
				'service': "$xwiki.getURL('PhenoTips.OmimInfoService', 'get')",
				'callback': function (helpButton, json) {
					var c = helpButton.helpBox.content;
					var elt = function (type, cssClass, content) {
						return new Element(type, cssClass && {'class': cssClass} || {}).update(content || '');
					};

					c.update(
						elt('span', 'info').insert(elt('span', 'key').update(json.id))
							.insert(' ')
							.insert(elt('span', 'value').update(json.label.splice(0, 1)[0]))
					);

					var labels = {'label': '', 'symptoms': $services.localization.render('phenotips.widgets.helpButtons.omimDisease.symptoms'), 'not_symptoms': $services.localization.render('phenotips.widgets.helpButtons.omimDisease.notSymptoms')};
					var advancedInfo = elt('dl');
					for (var l in labels) {
						if (json[l] && json[l].length > 0) {
							advancedInfo.insert(elt('dt', '', labels[l]));
							json[l].each(function (item) {
								advancedInfo.insert(elt('dd', '', item.label || item));
							})
						}
					}
					if (advancedInfo.firstDescendant()) {
						c.insert(advancedInfo);
					}
					var viewButton = new Element('a', {'class': 'button', href: 'http://www.omim.org/entry/' + json.id, 'target': '_blank'}).update($services.localization.render('phenotips.widgets.helpButtons.omimDisease.linkToOmim'));
					c.insert(elt('div', 'term-tools').insert(viewButton.wrap('span', {'class': 'buttonwrapper'})));
					viewButton.observe('click', function (event) {
						event.stop();
						window.open(viewButton.href);
					});
					if (json.gene_reviews_link) {
						var geneReviewsButton = new Element('a', {'class': 'button', href: json.gene_reviews_link, 'target': '_blank'}).update('Read about it on Gene Reviews...');
						c.insert(elt('div', 'term-tools').insert(geneReviewsButton.wrap('span', {'class': 'buttonwrapper'})));
						geneReviewsButton.observe('click', function (event) {
							event.stop();
							window.open(geneReviewsButton.href);
						});
					}
				}
			},
			'gene-info': {
				'hint': $services.localization.render('phenotips.widgets.helpButtons.gene.hint'),
				'service': "$xwiki.getURL('PhenoTips.GeneInfoService', 'get')",
				'callback': function (helpButton, json) {
					var c = helpButton.helpBox.content;
					var elt = function (type, cssClass, content) {
						return new Element(type, cssClass && {'class': cssClass} || {}).update(content || '');
					};

					c.update(
						elt('span', 'info').insert(elt('span', 'key').update(json.symbol))
							.insert(' ')
							.insert(elt('span', 'value').update(json.name))
					);

					var labels = {'alias_symbol': $services.localization.render('phenotips.widgets.helpButtons.gene.alias'), 'prev_symbol': $services.localization.render('phenotips.widgets.helpButtons.gene.previousSymbols'), 'gene_family': $services.localization.render('phenotips.widgets.helpButtons.gene.family')};
					var advancedInfo = elt('dl');
					for (var l in labels) {
						if (json[l] && json[l].length > 0) {
							advancedInfo.insert(elt('dt', '', labels[l]));
							if (Object.prototype.toString.call(json[l]) === '[object Array]') {
								json[l].each(function (item) {
									advancedInfo.insert(elt('dd', '', item.label || item));
								})
							} else {
								advancedInfo.insert(elt('dd', '', json[l]));
							}
						}
					}
					if (advancedInfo.firstDescendant()) {
						c.insert(advancedInfo);
					}

					if (json.external_ids) {
						var tools = elt('div', 'term-tools');
						var externalDBs = [
							{ name: 'GENECARDS', url: 'http://www.genecards.org/cgi-bin/carddisp.pl?gene=', field: 'genecards_id'},
							{ name: 'OMIM', url: 'http://www.omim.org/entry/', field: 'omim_id'},
							{ name: 'Entrez', url: 'http://www.ncbi.nlm.nih.gov/gene/?term=', field: 'entrez_id'},
							{ name: 'RefSeq', url: 'http://www.ncbi.nlm.nih.gov/nuccore/', field: 'refseq_accession'},
							{ name: 'Ensembl', url: 'http://useast.ensembl.org/Homo_sapiens/Gene/Compara_Tree?g=', field: 'ensembl_gene_id'}
						];
						externalDBs.each(function (item) {
							var value = json.external_ids[item.field];
							if (value) {
								if (!value.each) {
									value = [value];
								}
								value.each(function (id) {
									tools.insert(new Element('a', {
										'href': item.url + id,
										'class': 'button'
									}).update(item.name + ': ' + id).wrap('span', {'class': 'buttonwrapper'}));
								});
							}
						});
						// We must stop the event, otherwise this item will be selected; as a consequence, we must also manually open the link
						tools.select('a').each(function (item) {
							item.observe('click', function (event) {
								event.stop();
								window.open(item.href);
							})
						});
						c.insert(tools);
					}
				}
			}
		},

		initialize: function (icon) {
			this.icon = icon;
			this._information = this.icon._information || this.icon.title;
			for (var label in this.infoServices) {
				if (this.icon.hasClassName(label)) {
					this._builder = this.infoServices[label];
					this.icon.title = this.infoServices[label].hint || '';
				}
			}
			if (!this._builder) {
				return;
			}
			this.icon.observe("click", this.toggleHelp.bindAsEventListener(this));
			this.hideAllHelpOnOutsideClick = this.hideAllHelpOnOutsideClick.bindAsEventListener(this);
		},

		toggleHelp: function () {
			if (!this.helpBox || this.helpBox.hasClassName('hidden')) {
				this.showHelp();
				document.observe('click', this.hideAllHelpOnOutsideClick);
			} else {
				this.hideHelp();
			}
		},

		hideAllHelpOnOutsideClick: function (event) {
			if (!event.findElement('.xTooltip') && !event.findElement('.xHelpButton')) {
				this.hideHelp();
				document.stopObserving('click', this.hideAllHelpOnOutsideClick);
			}
		},

		hideHelp: function (event) {
			event && event.stop();
			if (this.helpBox) {
				if (this.helpBox.hasClassName('error')) {
					this.helpBox.remove();
					delete this.helpBox;
				} else {
					this.helpBox.addClassName('hidden');
				}
			}
		},

		showHelp: function () {
			if (!this.helpBox) {
				this.createHelpBox();
			}
			$$('div.xTooltip:not(.hidden)').invoke('_hideHelp');
			this.helpBox.removeClassName('hidden');
		},

		createHelpBox: function () {
			this.helpBox = new Element('div', {'class': 'hidden xTooltip'});
			this.helpBox._behavior = this;
			this.helpBox._hideHelp = function () {
				this._behavior.hideHelp();
			}.bind(this.helpBox);

			this.helpBox.content = new Element('div');
			this.helpBox.insert(this.helpBox.content);

			if (this._builder.service) {
				this.createHelpContentFromService();
			} else {
				this._builder.callback && this._builder.callback(this);
			}

			var closeButton = new Element('span', {'class': 'hide-tool', 'title': 'Hide'});
			closeButton.update('×');
			closeButton.observe('click', this.hideHelp.bindAsEventListener(this));
			this.helpBox.insert({'top': closeButton});
			this.icon.insert({'after': this.helpBox});
		},

		createHelpContentFromService: function () {
			var _this = this;
			new Ajax.Request(_this._builder.service, {
				parameters: {'id': _this._information},
				onCreate: function () {
					_this.helpBox.content.update(new Element('span', {'class': 'hint temporary'}).update($services.localization.render('phenotips.widgets.helpButtons.loading')));
				},
				onSuccess: function (response) {
					_this._builder.callback(_this, response.responseJSON);
				},
				onFailure: function (response) {
					_this.helpBox.addClassName('error');
					_this.helpBox.down('.temporary').remove();
					_this.helpBox.insert($services.localization.render('phenotips.widgets.helpButtons.failedToLoad').replace("__subject__", _this._information) + " : " + response.statusText);
				}
			});
		}
	});

	var init = function (event) {
		((event && event.memo.elements) || [document.getElementById(PedigreeEditorTool.divId)]).each(function (element) {
			(element.hasClassName("xHelpButton") ? [element] : element.select(".xHelpButton")).each(function (icon) {
				if (!icon.__helpController) {
					icon.__helpController = new PhenoTips.widgets.HelpButton(icon);
				}
			});
		});
		return true;
	};

	(XWiki.domIsLoaded && init()) || document.observe("xwiki:dom:loaded", init);
	document.observe("xwiki:dom:updated", init);

	// End augmentation.
	return PhenoTips;
}(PhenoTips || {}));

var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};

	widgets.FuzzyDatePickerDropdown = Class.create({
		initialize: function (options) {
			this.span = new Element('span');
			this.options = options;
			this.callback = null;
		},

		populate: function (values) {
			var selectedIndex = this.dropdown ? (this.dropdown.selectedIndex || this._tmpSelectedIndex) : 0;

			// using raw HTML for performance reasons: generating many years takes a noticeable time using
			// more proper methods (e.g. new Element()...)
			// (Note: using span around select because IE9 does not allow setting innerHTML of <select>-s)
			var optionsHTML = '<select name="' + this.options.name +
				'" class="' + (this.options.cssClass || this.options.name || '') +
				'" placeholder="' + (this.options.hint || this.options.name || '') +
				'" title="' + (this.options.hint || this.options.name || '') + '">';

			optionsHTML += '<option value="" class="empty"> </option>';
			values.each(function (item) {
				optionsHTML += '<option value="' + item.value + '"';
				if (item.cssClass) {
					optionsHTML += ' class="' + item.cssClass + '"';
				}
				if (item.selected) {
					optionsHTML += ' selected="selected"';
				}
				optionsHTML += '>' + (item.text || item.value || '') + '</option>';
			});
			optionsHTML += "</select>";
			this.span.innerHTML = optionsHTML;
			this.dropdown = this.span.firstChild;
			this.callback && this.onSelect(this.callback);
			if (this.dropdown.selectedIndex <= 0 && selectedIndex >= 0 && selectedIndex < this.dropdown.options.length) {
				this.dropdown.selectedIndex = selectedIndex;
			}
		},

		enable: function () {
			this.dropdown.enable();
			if (this.dropdown.selectedIndex <= 0 && this._tmpSelectedIndex < this.dropdown.options.length) {
				this.dropdown.selectedIndex = this._tmpSelectedIndex;
				return (this._tmpSelectedIndex > 0);
			}
			return false;
		},

		disable: function () {
			this.dropdown.disable();
			this._tmpSelectedIndex = this.dropdown.selectedIndex;
			this.dropdown.selectedIndex = 0;
		},

		getElement: function () {
			return this.span;
		},

		onSelect: function (callback) {
			var _this = this;
			this.callback = callback;
			var events = ['change'];
			browser.isGecko && events.push('keyup');
			events.each(function (eventName) {
				_this.dropdown.observe(eventName, function () {
					callback();
					_this._tmpSelectedIndex = _this.dropdown.selectedIndex;
				});
			});
		},

		onFocus: function (callback) {
			var _this = this;
			this.dropdown.observe('focus', function () {
				callback();
				if (_this.dropdown.selectedIndex == -1 && _this._tmpSelectedIndex < _this.dropdown.options.size()) {
					_this.dropdown.selectedIndex = _this._tmpSelectedIndex;
				}
			});
		},
		onBlur: function (callback) {
			this.dropdown.observe('blur', callback);
		},

		getSelectedValue: function () {
			return (this.dropdown.selectedIndex >= 0) ? this.dropdown.options[this.dropdown.selectedIndex].value : '';
		},

		getSelectedOption: function () {
			return (this.dropdown.selectedIndex >= 0) ? this.dropdown.options[this.dropdown.selectedIndex].innerHTML : '';
		}
	});

	widgets.FuzzyDatePicker = Class.create({
		initialize: function (input) {
			if (!input) {
				return
			}
			;
			this.__input = input;
			this.__input.hide();
			this.__fuzzyInput = $(this.__input.name + '_entered')
			if (this.__fuzzyInput) {
				this.__recordBoth = true;
			}
			if (this.__fuzzyInput && this.__fuzzyInput.value) {
				this.__date = JSON.parse(this.__fuzzyInput.value || '{}');
			} else if (this.__input.alt) {
				var parsedDate = new Date(this.__input.alt);
				this.__date = {'year': parsedDate.getUTCFullYear(), 'month': parsedDate.getUTCMonth() + 1, 'day': parsedDate.getUTCDate()};
			} else {
				this.__date = {};
			}

			this.container = new Element('div', {'class': 'fuzzy-date-picker'});

			//Insertion is done before, so that validation errors can appear after it
			this.__input.insert({before: this.container});
			var format = (this.__input.title || 'yyyy-MM-dd').split(/\W+/);
			for (var i = 0; i < format.length; ++i) {
				switch (format[i][0]) {
					case 'y':
						this.container.insert(this.createYearDropdown());
						break;
					case 'M':
						this.container.insert(this.createMonthDropdown());
						break;
					case 'd':
						this.container.insert(this.createDayDropdown());
						break;
				}
			}

			// TODO: yearSelector's (and month's & day's) .onSelect() does not seem to fire
			//       upon programmatic update if a substitute is found can remove these hackish events
			this.container.observe("datepicker:date:changed", this.onProgrammaticUpdate.bind(this));
			this.onProgrammaticUpdate();
		},

		onProgrammaticUpdate: function () {
			this.yearSelected();
			this.monthSelected();
			this.updateDate();
		},

		createYearDropdown: function () {
			this.yearSelector = new widgets.FuzzyDatePickerDropdown({name: "year"});

			var today = new Date();
			var crtYear = today.getYear() + 1900;
			var startYear = 1900;

			var values = [];
			for (var y = crtYear; y >= startYear; --y) {
				values.push({"value": y, "selected": this.__date.year == y});
				if (y % 10 == 0) {
					values.push({"value": (y + "s"), "cssClass": "decade", "text": (y + 's'), "selected": this.__date.decade == y + "s"});
				}
			}
			values.push({"value": "1800s", "cssClass": "decade", "selected": this.__date.decade == "1800s"});
			values.push({"value": "1700s", "cssClass": "decade", "selected": this.__date.decade == "1700s"});
			values.push({"value": "1600s", "cssClass": "decade", "selected": this.__date.decade == "1600s"});

			this.yearSelector.populate(values);
			this.yearSelector.onSelect(this.yearSelected.bind(this));

			return this.yearSelector.getElement();
		},

		yearSelected: function () {
			if (!this.yearSelector) {
				return;
			}
			if (this.yearSelector.getSelectedValue() > 0) {
				//  this.monthSelector.enable();
				this.monthSelector && this.monthSelected();
				//} else {
				//  this.monthSelector.disable();
				//  this.daySelector.disable();
			}
			this.updateDate();
		},

		createMonthDropdown: function () {
			this.monthSelector = new widgets.FuzzyDatePickerDropdown({name: "month"});
			this.monthSelector.populate(this.getZeroPaddedValueRange(1, 12, this.__date.month));
			//this.monthSelector.disable();
			this.monthSelector.onSelect(this.monthSelected.bind(this));
			return this.monthSelector.getElement();
		},

		monthSelected: function () {
			if (!this.monthSelector) {
				return;
			}
			if (this.monthSelector.getSelectedValue() > 0) {
				this.daySelector && this.daySelector.populate(this.getAvailableDays());
				//  this.daySelector.enable();
				//} else {
				//  this.daySelector.disable();
			}
			this.updateDate();
		},

		createDayDropdown: function () {
			this.daySelector = new widgets.FuzzyDatePickerDropdown({name: "day"});
			this.daySelector.populate(this.getZeroPaddedValueRange(1, 31, this.__date.day));
			//this.daySelector.disable();
			this.daySelector.onSelect(this.updateDate.bind(this));
			return this.daySelector.getElement();
		},

		getAvailableDays: function () {
			var year = this.yearSelector.getSelectedValue() * 1;
			var month = this.monthSelector.getSelectedValue() * 1;
			var lastDayOfMonth = 0;
			if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) >= 0) {
				lastDayOfMonth = 31;
			} else if ([4, 6, 9, 11].indexOf(month) >= 0) {
				lastDayOfMonth = 30
			} else if (month == 2) {
				if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
					lastDayOfMonth = 29;
				} else {
					lastDayOfMonth = 28;
				}
			}
			return this.getZeroPaddedValueRange(1, lastDayOfMonth);
		},

		getZeroPaddedValue: function (value) {
			return value ? ("0" + value).slice(-2) : "01";
		},

		getZeroPaddedValueRange: function (start, end, selected) {
			var values = [];
			if (start <= end) {
				for (var v = start; v <= end; ++v) {
					values.push({'value': v, 'text': ("0" + v).slice(-2), 'selected': selected == v});
				}
			} else {
				for (var v = end; v <= start; --v) {
					values.push({'value': v, 'text': ("0" + v).slice(-2), 'selected': selected == v});
				}
			}
			return values;
		},

		updateDate: function () {
			var dateObject = {};

			var y = this.yearSelector.getSelectedValue();
			if (y.match(/\d\d\d\ds$/)) {
				dateObject["decade"] = y;
			} else {
				if (y != "") {
					dateObject["year"] = y;
				}
			}

			if (y > 0) {
				var m = this.monthSelector && this.monthSelector.getSelectedValue();
				if (m > 0) {
					dateObject["month"] = this.monthSelector.getSelectedOption();

					var d = this.daySelector && this.daySelector.getSelectedValue();
					if (d > 0) {
						dateObject["day"] = this.daySelector.getSelectedOption();
					}
				}
			}

			var newValue = JSON.stringify(dateObject);
			if (this.__recordBoth) {
				var oldValue = this.__fuzzyInput.value;
				if (newValue != oldValue) {
					this.__fuzzyInput.value = JSON.stringify(dateObject);
					this.__input.value = (y && !y.match(/\d\d\d\ds$/)) ? (y + "-" + this.getZeroPaddedValue(m) + "-" + this.getZeroPaddedValue(d)) : "";
					this.__input.alt = (y && !y.match(/\d\d\d\ds$/)) ? (y + "-" + this.getZeroPaddedValue(m) + "-" + this.getZeroPaddedValue(d) + "T00:00:00Z") : "";
					this.__input.fire("xwiki:date:changed");
				}
			} else {
				var oldValue = this.__input.value;
				if (newValue != oldValue) {
					this.__input.value = JSON.stringify(dateObject);
					this.__input.alt = (y && !y.match(/\d\d\d\ds$/)) ? (y + "-" + this.getZeroPaddedValue(m) + "-" + this.getZeroPaddedValue(d) + "T00:00:00Z") : "";
					this.__input.fire("xwiki:date:changed");
				}
			}
		}
	});

	var init = function (event) {
		((event && event.memo.elements) || [document.getElementById(PedigreeEditorTool.divId)]).each(function (element) {
			(element.hasClassName("fuzzy-date") ? [element] : element.select(".fuzzy-date")).each(function (dateInput) {
				if (!dateInput.__datePicker) {
					dateInput.__datePicker = new PhenoTips.widgets.FuzzyDatePicker(dateInput);
				}
			});
		});
		return true;
	};

	(XWiki.domIsLoaded && init()) || document.observe("xwiki:dom:loaded", init);
	document.observe("xwiki:dom:updated", init);

	// End augmentation.

	return PhenoTips;
}(PhenoTips || {}));

(function () {
	var init = function (event) {
		var containers = (event && event.memo.elements) || [document.getElementById(PedigreeEditorTool.divId)];
		containers.each(function (container) {
			container.select('input.suggestWorkgroups').each(function (input) {
				if (!input.hasClassName('initialized')) {
					var options = {
						script: new XWiki.Document('SuggestWorkgroupsService', 'PhenoTips').getURL('get', 'outputSyntax=plain&'),
						noresults: $services.localization.render('phenotips.widgets.workgroupPicker.noResults')
					};
					// The picker suggests by default local workgroups.
					if (input.hasClassName('global')) {
						// Suggest global users or groups.
						options.script = options.script + 'wiki=global&';
					}
					new XWiki.widgets.UserPicker(input, options);
					input.addClassName('initialized');
				}
			});
		});
	};
	(XWiki.domIsLoaded && init()) || document.observe('xwiki:dom:loaded', init);
	document.observe('xwiki:dom:updated', init);
})()

var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.SegmentedBar = Class.create({
		options: {
			segments: 5,
			displayValue: true
		},
		/**
		 A PhenoTips widget for displaying a value as a segmented bar HTML element. It uses the current text color and font size, so adjusting the look of the bar means changing the color and font-size on the HTML element returned by the generateSegmentedBar method, or on one of its ancestors, either via a CSS extension or programmatically. Example:

		 var barOptions = {
          segments : 10,
          displayValue : false
        };
		 container.insert(new PhenoTips.widgets.SegmentedBar(score, barOptions).generateSegmentedBar().setStyle({color: 'red', fontSize: '200%'}));

		 @param value The value that this bar is meant to display. Must be between 0 and 1.

		 @param options Options for styling the segmented bar, all values are optional:

		 {
  segments: The number of segments in the bar; default is 5,
  displayValue: Option to display the percentage value after the bar; default is true
}

		 */
		initialize: function (value, options) {
			this.value = value;
			this.options = Object.extend(Object.clone(this.options), options || { });
		},
		generateSegmentedBar: function () {
			if (this.value > 1 || this.value < 0) {
				console.log("Invalid segmented bar value");
				return;
			}
			var bar = new Element('div', {
				'class': 'segmented-bar',
				'title': Math.round(this.value * 100) + '%' || ''
			});
			var valueUnit = 1 / this.options.segments;
			for (var i = 0; i < this.options.segments; ++i) {
				var segmentFill = 100 * Math.min(Math.max((this.value - i * valueUnit) / valueUnit, 0), 1);
				var segment = new Element('span', {
					'class': 'segmented-unit'
				});
				var segmentFillElement = new Element('span', {
					'class': 'segmented-unit-fill'
				});
				segmentFillElement.setStyle({
					width: segmentFill + '%'
				});
				segment.insert(segmentFillElement);
				bar.insert(segment);
			}
			if (this.options.displayValue) {
				bar.insert(' ' + Math.round(this.value * 100) + '%');
			}
			return bar;
		}
	});
	return PhenoTips;
})(PhenoTips || {});


var PhenoTips = (function (PhenoTips) {

	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};

	if (typeof XWiki.widgets.XList == 'undefined') {
		if (typeof console != "undefined" && typeof console.warn == "function") {
			console.warn("[Suggest widget] Required class missing: XWiki.widgets.XList");
		}
	} else {
		widgets.XList = XWiki.widgets.XList;
		widgets.XListItem = XWiki.widgets.XListItem;
		/**
		 * Suggest class.
		 * Provide value suggestions to users when starting to type in a text input.
		 */
		widgets.Suggest = Class.create({
			options: {
				// The minimum number of characters after which to trigger the suggest
				minchars: 1,
				// The HTTP method for the AJAX request
				method: "get",
				// The name of the request parameter holding the input stub
				varname: "input",
				// The CSS classname of the suggest list
				className: "ajaxsuggest",
				timeout: 2500,
				delay: 500,
				offsety: 0,
				// Display a "no results" message, or simply hide the suggest box when no suggestions are available
				shownoresults: true,
				// The message to display as the "no results" message
				noresults: "No results!",
				maxheight: 250,
				cache: false,
				seps: "",
				icon: null,
				// The name of the JSON variable or XML element holding the results.
				// "results" for the old suggest, "searchResults" for the REST search.
				resultsParameter: function(){return "results";},
				// The name of the JSON parameter or XML attribute holding the result identifier.
				// "id" for both the old suggest and the REST search.
				resultId: function(){return "id"},
				// The name of the JSON parameter or XML attribute holding the result value.
				// "value" for the old suggest, "pageFullName" for the REST page search.
				resultValue: function(){return "value";},
				// The name of the JSON parameter or XML attribute holding the result auxiliary information.
				// "info" for the old suggest, "pageFullName" for the REST search.
				resultInfo: "info",
				// The name of the JSON parameter or XML attribute holding the result category.
				resultCategory: "category",
				// The name of the JSON parameter or XML attribute holding the result alternative name.
				resultAltName: "",
				// The name of the JSON parameter or XML attribute holding the result icon.
				resultIcon: "icon",
				// The name of the JSON parameter or XML attribute holding a potential result hint (displayed next to the value).
				resultHint: "hint",
				// What kind of tooltip (if any) should be attached to each entry. Default: none.
				tooltip: false,
				// The id of the element that will hold the suggest element
				//parentContainer : "body",
				// Should results fragments be highlighted when matching typed input
				highlight: true,
				// Fade the suggestion container on clear
				fadeOnClear: true,
				// Show a 'hide suggestions' button
				enableHideButton: true,
				insertBeforeSuggestions: null,
				// Should id be displayed or hidden
				displayId: false,
				// Should value be displayed as a hint
				displayValue: false,
				// Display value prefix text
				displayValueText: "Value :",
				// How to align the suggestion list when its width is different from the input field width
				align: "left",
				// When there are several suggest sources, should the widget displays only one, unified, "loading" indicator for all requests undergoing,
				// Or should it displays one loading indicator per request next to the corresponding source.
				unifiedLoader: false,
				// The DOM node to use to display the loading indicator when in mode unified loader (it will receive a "loading" class name for the time of the loading)
				// Default is null, which falls back on the input itself. This option is used only when unifiedLoader is true.
				loaderNode: null,
				// A function returning true or false for each fetched suggestion. If defined, only suggestions for which 'true' is returned
				// are added to the list
				filterFunc: null
			},
			sInput: "",
			nInputChars: 0,
			aSuggestions: [],
			iHighlighted: null,
			isActive: false,

			//Added for GEL(GenomicsEngland)................................................
			//to get track of the number of rows loaded in case of using pagination
			resultTotal:0,
			resultPage:-1,
			resultLimit:10,
			resultHasMore: false,
			//..............................................................................

			/**
			 * Initialize the suggest
			 *
			 * @param {Object} fld the suggest field
			 * @param {Object} param the options
			 */
			initialize: function (fld, param) {

				if (!fld) {
					return false;
				}
				this.setInputField(fld);

				// Clone default options from the prototype so that they are not shared and extend options with passed parameters
				this.options = Object.extend(Object.clone(this.options), param || { });
				if (typeof this.options.sources == 'object' && this.options.sources.length > 1) {
					// We are in multi-sources mode
					this.sources = this.options.sources;
				} else {
					// We are in mono-source mode
					this.sources = this.options;
				}

				// Flatten sources
				this.sources = [ this.sources ].flatten().compact();

				// Reset the container if the configured parameter is not valid
				if (!$(this.options.parentContainer)) {
					this.options.parentContainer = $(document.body);
				}

				if (this.options.seps) {
					this.seps = this.options.seps;
				} else {
					this.seps = "";
				}

				// Initialize a request number that will keep track of the latest request being fired.
				// This will help to discard potential non-last requests callbacks ; this in order to have better performance
				// (less unneccessary DOM manipulation, and less unneccessary highlighting computation).
				this.latestRequest = 0;

			},

			/**
			 * Sets or replace the input field associated with this suggest.
			 */
			setInputField: function (input) {
				if (this.fld) {
					this.fld.stopObserving();
				}
				this.fld = $(input);
				this.fld._suggestWidget = this;
				// Bind the key listeners on the input field.
				this.fld.observe("keyup", this.onKeyUp.bindAsEventListener(this));
				if (Prototype.Browser.IE || Prototype.Browser.WebKit) {
					this.fld.observe("keydown", this.onKeyPress.bindAsEventListener(this));
				} else {
					this.fld.observe("keypress", this.onKeyPress.bindAsEventListener(this));
				}
				this.fld.observe("paste", this.onPaste.bindAsEventListener(this));

				// Prevent normal browser autocomplete
				this.fld.setAttribute("autocomplete", "off");

				this.fld.observe("blur", function (event) {
					// Make sure any running request will be dropped after the input field has been left
					this.latestRequest++;

				}.bind(this));
			},

			/**
			 * Treats normal characters and triggers the autocompletion behavior. This is needed since the field value is not
			 * updated when keydown/keypress are called, so the suggest would work with the previous value. The disadvantage is
			 * that keyUp is not fired for each stroke in a long keypress, but only once at the end. This is not a real problem,
			 * though.
			 */
			onKeyUp: function (event) {
				var key = event.keyCode;
				switch (key) {
					// Ignore special keys, which are treated in onKeyPress
					case Event.KEY_RETURN:
					case Event.KEY_ESC:
					case Event.KEY_UP:
					case Event.KEY_DOWN:
						break;
					default:
					{
						// If there are separators in the input string, get suggestions only for the text after the last separator
						// TODO The user might be typing in the middle of the field, not in the last item. Do a better detection by
						// comparing the new value with the old one.
						if (this.seps) {
							var lastIndx = -1;
							for (var i = 0; i < this.seps.length; i++) {
								if (this.fld.value.lastIndexOf(this.seps.charAt(i)) > lastIndx) {
									lastIndx = this.fld.value.lastIndexOf(this.seps.charAt(i));
								}
							}
							if (lastIndx == -1) {

								this.getSuggestions(this.fld.value);
							} else {

								this.getSuggestions(this.fld.value.substring(lastIndx + 1));
							}
						} else {

							this.getSuggestions(this.fld.value);
						}
					}
				}
			},
			/**
			 * Use the key press routine to search as if some "other" key was pressed;
			 * Pasted value is not yet available at the time of the "paste" event, so schedule
			 * the handler to fire immediately after paste processing is done.
			 */
			onPaste: function (event) {
				setTimeout(function () {
					this.onKeyUp({"keyCode": null});
				}.bind(this), 0);
			},
			/**
			 * Treats Up and Down arrows, Enter and Escape, affecting the UI meta-behavior. Enter puts the currently selected
			 * value inside the target field, Escape closes the suggest dropdown, Up and Down move the current selection.
			 */
			onKeyPress: function (event) {
				if (!$(this.isActive)) {
					// Stop Return from submitting the form
					if (event.keyCode == Event.KEY_RETURN) {
						Event.stop(event);
					}
					// Let all other key events pass through if the UI is not displayed
					return;
				}
				var key = event.keyCode;

				switch (key) {
					case Event.KEY_RETURN:
						this.setHighlightedValue();
						Event.stop(event);
						break;
					case Event.KEY_ESC:
						this.clearSuggestions();
						Event.stop(event);
						break;
					case Event.KEY_UP:
						this.changeHighlight(key);
						Event.stop(event);
						break;
					case Event.KEY_DOWN:
						this.changeHighlight(key);
						Event.stop(event);
						break;
					default:
						break;
				}
			},

			/**
			 * Get suggestions
			 *
			 * @param {Object} val the value to get suggestions for
			 */
			getSuggestions: function (val) {

				// if input stays the same, do nothing
				//
				val = val.strip().toLowerCase();
				if (val == this.sInput && val.length > 1) {
					return false;
				}

				if (val.length == 0) {
					this.sInput = "";
					this.clearSuggestions();
					return false;
				}
				// input length is less than the min required to trigger a request
				// reset input string
				// do nothing
				//
				if (val.length < this.options.minchars) {
					this.sInput = "";
					return false;
				}

				// if caching enabled, and user is typing (ie. length of input is increasing)
				// filter results out of aSuggestions from last request
				//
				if (val.length > this.nInputChars && this.aSuggestions.length && this.options.cache) {
					var arr = [];
					for (var i = 0; i < this.aSuggestions.length; i++) {
						if (this.aSuggestions[i].value.substr(0, val.length).toLowerCase() == val) {
							arr.push(this.aSuggestions[i]);
						}
					}

					this.sInput = val;
					this.nInputChars = val.length;
					this.aSuggestions = arr;

					this.createList(this.aSuggestions);

					return false;
				} else {

					//Added for GEL(GenomicsEngland)................................................
					//As it is a new request, set resultPage offset to -1
					this.resultPage = -1;
					//..............................................................................

					// do new request
					this.sInput = val;
					this.nInputChars = val.length;

					//Added for GEL(GenomicsEngland).....................................................................
					//this.container is the main container of the suggestion and we use it later to access LoadMore text
					this.container = this.prepareContainer();
					//...................................................................................................

					this.latestRequest++;
					var pointer = this;
					var requestId = this.latestRequest;
					clearTimeout(this.ajID);
					this.ajID = setTimeout(function () {
						
						pointer.doAjaxRequests(requestId)
					}, this.options.delay);

				}
				return false;
			},

			/**
			 * Fire the AJAX Request(s) that will get suggestions
			 */
			doAjaxRequests: function (requestId) {

				if (this.fld.value.length < this.options.minchars) {
					return;
				}

				for (var i = 0; i < this.sources.length; i++) {
					var source = this.sources[i];

					// create ajax request
					var query = this.fld.value.strip();
					var parameters = {};
					if (this.options.queryProcessor != null && typeof(this.options.queryProcessor.generateParameters) == "function") {
						parameters = this.options.queryProcessor.generateParameters(query);
					}
					if (this.options.queryProcessor != null && typeof(this.options.queryProcessor.processQuery) == "function") {
						query = this.options.queryProcessor.processQuery(query);
					}
					//Added by Soheil for GEL(GenomicsEngland)
					//Load the ajax call path from scriptFunction if it's provided otherwise use script string
					var url = "";
					if (source.scriptFunction != undefined && typeof source.scriptFunction === "function"){
						url = source.scriptFunction() + source.varname + "=" + encodeURIComponent(query);
					}else{
						url = source.script + source.varname + "=" + encodeURIComponent(query);
					}

					var method = source.method || "get";
					var headers = {};
					if (source.json) {
						headers.Accept = "application/json";
					} else {
						headers.Accept = "application/xml";
					}

					var _GELThisAjaxCall = this;
					//Added for GEL(GenomicsEngland) .........................................................................
					//If the suggestion configured to use pagination, then pass "page" and "limit" parameters into the query
					//it is used for GEL SnomedCT queries
					if(_GELThisAjaxCall.options.resultUsePagination && _GELThisAjaxCall.options.resultUsePagination()) {
						this.resultPage = this.resultPage + 1;
						url = url + "&page=" + this.resultPage + "&limit=" + this.resultLimit;
					}
					//........................................................................................................


					var ajx = new Ajax.Request(url, {
						method: method,
						parameters: parameters,
						requestHeaders: headers,
						onCreate: function () {
							this.fld.addClassName("loading");
						}.bind(this),
						onSuccess: function(_GELResult){

							//Added for GEL(GenomicsEngland) .........................................................................
							//If the request is a pagination one, then get 'more' and 'total' values from the result
							if(_GELThisAjaxCall.options.resultUsePagination && _GELThisAjaxCall.options.resultUsePagination()){
								var result = _GELResult.responseJSON;
								_GELThisAjaxCall.resultHasMore = result.more;
								_GELThisAjaxCall.resultTotal   = result.total;
								if(!result.more){
									_GELThisAjaxCall.hideLoadMore();
								}else{
									_GELThisAjaxCall.updateLoadMore(_GELThisAjaxCall.resultPage, _GELThisAjaxCall.resultLimit, _GELThisAjaxCall.resultTotal)
								}
							}
							//........................................................................................................


							//Changed by SOHEIL for GEL(GenomicsEngland)
							//this.setSuggestions.bindAsEventListener(this, source, requestId)
							_GELThisAjaxCall.setSuggestions(_GELResult, source, requestId);
						},
						onFailure: function (response) {

							//new PhenoTips.widgets.Notification("Failed to retrieve suggestions : ')" + response.statusText, "error", {timeout: 5});
							alert("Failed to retrieve suggestions : " + response.statusText);
						},
						onComplete: function () {

							if (requestId < this.latestRequest) {
								return;
							}
							this.fld.removeClassName("loading");
						}.bind(this)
					});
				}
			},

			/**
			 * Set suggestions
			 *
			 * @param {Object} req
			 * @param {Object} source
			 * @param {Number} requestId the identifier of the request for which this callback is triggered.
			 */
			setSuggestions: function (req, source, requestId) {

				// If there has been one or several requests fired in the mean time (between the time the request for which this callback
				// has been triggered and the time of the callback itself) ; we don't do anything and leave it to following callbacks to
				// set potential suggestions
				if (requestId < this.latestRequest) {
					return;
				}

				this.aSuggestions = this.getSuggestionList(req, source);
				this.createList(this.aSuggestions, source);
			},

			getSuggestionList: function (req, source) {

				var aSuggestions = [];
				if (source && source.json) {
					var jsondata = req.responseJSON;
					if (!jsondata) {
						return false;
					}
					var results = jsondata[source.resultsParameter() || this.options.resultsParameter()];

					var _getResultFieldValue = function (data, fieldName) {
						return data && data[fieldName] || '';
					}

					var _getResultFieldValueAsArray = function (data, fieldName) {
                        return new Array(data && data[fieldName] || '').flatten();
					};
				} else {
					var xmldata = req.responseXML;
					if (!xmldata) {
						return false;
					}
					var results = xmldata.getElementsByTagName((source && source.resultsParameter()) || this.options.resultsParameter());

					var _getResultFieldValue = function (data, selector) {
						var element = data && Element.down(data, selector);
						return element && element.firstChild && element.firstChild.nodeValue || '';
					}

					var _getResultFieldValueAsArray = function (data, selector) {
						var result = new Array();
						if (data) {
							Element.select(data, selector).each(function (item) {
								var value = item.firstChild && item.firstChild.nodeValue;
								if (value) {
									result.push(value);
								}
							});
						}
						return result;
					};
				}

				var _getExpandCollapseTriggerSymbol = function (isCollapsed) {
					if (isCollapsed) return "&#x25B8;";
					return "&#x25BE;";
				}
				for (var i = 0; i < results.length; i++) {
					var info = new Element("dl");
					for (var section in this.options.resultInfo) {
						var sOptions = this.options.resultInfo[section];

						sectionClass = section.strip().toLowerCase().replace(/[^a-z0-9 ]/gi, '').replace(/\s+/gi, "-");

						var sectionState = ""
						if (sOptions.collapsed) {
							sectionState = "collapsed";
						}

						var processingFunction = sOptions.processor;

						if (sOptions.extern) {
							var trigger = new Element("a").update(section);
							trigger._processingFunction = processingFunction;
							info.insert({"bottom": new Element("dt", {'class': sectionState + " " + sectionClass}).insert({'bottom': trigger})});
							trigger._processingFunction.call(this, trigger);
							continue;
						}

						var selector = sOptions.selector;
						if (!selector) {
							continue;
						}

						var sectionContents = null;
						_getResultFieldValueAsArray(results[i], selector).each(function (item) {
							var text = item || '';
							if (typeof (processingFunction) == "function") {
								text = processingFunction(text);
							}
							if (text == '') {
								return;
							}
							if (!sectionContents) {
								var trigger = new Element("a", {'class': 'expand-tool'}).update(_getExpandCollapseTriggerSymbol(sOptions.collapsed));
								info.insert({"bottom": new Element("dt", {'class': sectionState}).insert({'top': trigger}).insert({'bottom': section})});
								sectionContents = new Element("dd", {'class': 'expandable'});
								info.insert({"bottom": sectionContents});
								trigger.observe('click', function (event) {
									event.stop();
									trigger.up().toggleClassName('collapsed');
									trigger.update(_getExpandCollapseTriggerSymbol(trigger.up().hasClassName('collapsed')));
								}.bindAsEventListener(this));
							}
							sectionContents.insert({"bottom": new Element("div").update(text)});
						});
					}
					if (!info.hasChildNodes()) {
						info = '';
					}
					if (this.options.resultCategory) {
						var category = new Element("span", {'class': 'hidden term-category'});
						_getResultFieldValueAsArray(results[i], this.options.resultCategory).each(function (c) {
							category.insert(new Element('input', {'type': 'hidden', 'value': c}));
						});
					}
					if (!this.options.resultCategory || !category.hasChildNodes()) {
						category = '';
					}

					if (this.options.resultAltName) {
						var bestNameMatch = '';
						var name = _getResultFieldValue(results[i], source.resultValue() || this.options.resultValue());
						var altNames = _getResultFieldValueAsArray(results[i], source.resultAltName || this.options.resultAltName);
						var nameMatchScore = this.computeSimilarity(name, this.sInput);
						for (var k = 0; k < altNames.length; ++k) {
							var altNameMatchScore = this.computeSimilarity(altNames[k], this.sInput);
							if (altNameMatchScore > nameMatchScore) {
								bestNameMatch = altNames[k];
								nameMatchScore = altNameMatchScore;
							}
						}
					}

					aSuggestions.push({
						'id': _getResultFieldValue(results[i], source.resultId() || this.options.resultId()),
						'value': _getResultFieldValue(results[i], source.resultValue() || this.options.resultValue()),
						'valueAll': results[i],
						'altName': bestNameMatch,
						'info': info,
						'category': category
					});
				}
				return aSuggestions;
			},

			/**
			 * Compute the Smith Waterman similarity between two strings
			 */
			computeSimilarity: function (str1, str2) {
				var score;
				var maxSoFar = 0;
				var gapCost = 2;

				// get values
				var a = str1;
				var m = a.length;

				//n is the length of currFieldValue
				var b = str2;
				var n = b.length;

				//declare the matrix
				var d = new Array();

				for (i = 0; i < n; i++) {
					d[i] = new Array();

					// get the substitution score
					score = (a.charAt(i) == b.charAt(0)) ? 1 : -1;

					if (i == 0) {
						d[0][0] = Math.max(0, -gapCost, score);
					} else {
						d[i][0] = Math.max(0, d[i - 1][0] - gapCost, score);
					}

					//update max possible if available
					if (d[i][0] > maxSoFar) {
						maxSoFar = d[i][0];
					}
				}

				for (j = 0; j < m; j++) {
					// get the substitution score
					score = (a.charAt(0) == b.charAt(j)) ? 1 : -1;

					if (j == 0) {
						d[0][0] = Math.max(0, -gapCost, score);
					} else {
						d[0][j] = Math.max(0, d[0][j - 1] - gapCost, score);
					}

					//update max possible if available
					if (d[0][j] > maxSoFar) {
						maxSoFar = d[0][j];
					}
				}

				// cycle through rest of table filling values from the lowest cost value of the three part cost function
				for (i = 1; i < n; i++) {
					for (j = 1; j < m; j++) {
						// get the substitution score
						score = (a.charAt(i) == b.charAt(j)) ? 1 : -1;

						// find lowest cost at point from three possible
						d[i][j] = Math.max(0, d[i - 1][j] - gapCost, d[i][j - 1] - gapCost, d[i - 1][j - 1] + score);
						//update max possible if available
						if (d[i][j] > maxSoFar) {
							maxSoFar = d[i][j];
						}
					}
				}
				// return max value within matrix as holds the maximum edit score
				return maxSoFar;
			},


			/**
			 * Creates the container that will hold one or multiple source results.
			 * Modified widget placement so dropdown is absolute and relative to tab container and not relative
			 * to body. This was because the absolute position of the dropdown is calculated based on absolute position
			 * of the associated element. When the element is in a scroll container, its abs value is still not based
			 * on the scrolled part causing a mis-alignment.
			 */
			prepareContainer: function () {
				//var crtContainer = $(this.options.parentContainer).down('.suggestItems');

				var elName = this.fld.name;

                // changed to tab container.
				var containerName = $$('div.tabholder')[0]; //could also be $$('div.field-[elName]')[0];

				var crtContainer = $(containerName).down('.suggestItems');

				if (crtContainer && crtContainer.__targetField != this.fld) {
					if (crtContainer.__targetField) {
						crtContainer.__targetField._suggest.clearSuggestions();
					} else {
						crtContainer.remove();
					}
					crtContainer = false;
				}

				if (!crtContainer) {
					// If the suggestion top container is not in the DOM already, we create it and inject it
					var div = new Element("div", { 'class': "suggestItems " + this.options.className  });

					// Get position of target textfield
					//var pos = $(this.options.parentContainer).tagName.toLowerCase() == 'body' ? this.fld.cumulativeOffset() : this.fld.positionedOffset();
					var pos = $(containerName).tagName.toLowerCase() == 'body' ? this.fld.cumulativeOffset() : this.fld.positionedOffset();

					// Container width is passed as an option, or field width if no width provided.
					// The 2px substracted correspond to one pixel of border on each side of the field,
					// this allows to have the suggestion box borders well aligned with the field borders.
					// FIXME this should be computed instead, since border might not always be 1px.
					var containerWidth = this.options.width ? this.options.width : (this.fld.offsetWidth - 2)

					if (this.options.align == 'left') {
						// Align the box on the left
						div.style.left = pos.left + "px";
					} else if (this.options.align == "center") {
						// Align the box to the center
						div.style.left = pos.left + (this.fld.getWidth() - containerWidth - 2) / 2 + "px";
					} else {
						// Align the box on the right.
						// This has a visible effect only when the container width is not the same as the input width
						div.style.left = (pos.left - containerWidth + this.fld.offsetWidth - 2) + "px";
					}


                    var offsetTop = document.getElementsByName(elName)[0].offsetTop;
					div.style.top = (offsetTop +  this.fld.offsetHeight) + "px";
					div.style.width = containerWidth + "px";

					div.style.height = "100px";
					div.style.maxHeight = "100px";

					// set mouseover functions for div
					// when mouse pointer leaves div, set a timeout to remove the list after an interval
					// when mouse enters div, kill the timeout so the list won't be removed
					var pointer = this;
					div.onmouseover = function () {
						pointer.killTimeout()
					}
					div.onmouseout = function () {
						pointer.resetTimeout()
					}

					this.resultContainer = new Element("div", {'class': 'resultContainer' +" " + elName+"_class" });
					div.appendChild(this.resultContainer);

					// add DIV to document
					//$(this.options.parentContainer).insert(div);
					$(containerName).insert(div);

					this.container = div;

					if (this.options.insertBeforeSuggestions) {
						this.resultContainer.insert(this.options.insertBeforeSuggestions);
					}

					document.fire("ms:suggest:containerCreated", {
						'container': this.container,
						'suggest': this
					});
					div.style.maxHeight = "100px";
				}

				if (this.sources.length > 1) {
					// If we are in multi-source mode, we need to prepare a sub-container for each of the suggestion source
					for (var i = 0; i < this.sources.length; i++) {

						var source = this.sources[i];
						source.id = i

						if (this.resultContainer.down('.results' + source.id)) {
							// If the sub-container for this source is already present, we just re-initialize it :
							// - remove its content
							// - set it as loading
							if (this.resultContainer.down('.results' + source.id).down('ul')) {
								this.resultContainer.down('.results' + source.id).down('ul').remove();
							}
							if (!this.options.unifiedLoader) {
								this.resultContainer.down('.results' + source.id).down('.sourceContent').addClassName('loading');
							}
							else {
								(this.options.loaderNode || this.fld).addClassName("loading");
								this.resultContainer.down('.results' + source.id).addClassName('hidden loading');
							}
						}
						else {
							// The sub-container for this source has not been created yet
							// Really create the subcontainer for this source and inject it in the global container
							var sourceContainer = new Element('div', {'class': 'results results' + source.id}),
								sourceHeader = new Element('div', {'class': 'sourceName'});

							if (this.options.unifiedLoader) {
								sourceContainer.addClassName('hidden loading');
							}

							if (typeof source.icon != 'undefined') {
								// If there is an icon for this source group, set it as background image
								var iconImage = new Image();
								iconImage.onload = function () {
									this.sourceHeader.setStyle({
										backgroundImage: "url(" + this.iconImage.src + ")"
									});
									this.sourceHeader.setStyle({
										textIndent: (this.iconImage.width + 6) + 'px'
									});
								}.bind({
										sourceHeader: sourceHeader,
										iconImage: iconImage
									});
								iconImage.src = source.icon;
							}
							sourceHeader.insert(source.name)
							sourceContainer.insert(sourceHeader);
							var classes = "sourceContent " + (this.options.unifiedLoader ? "" : "loading");
							sourceContainer.insert(new Element('div', {'class': classes}));

							if (typeof source.before !== 'undefined') {
								this.resultContainer.insert(source.before);
							}
							this.resultContainer.insert(sourceContainer);
							if (typeof source.after !== 'undefined') {
								this.resultContainer.insert(source.after);
							}
						}
					}
				} else {
					// In mono-source mode, reset the list if present
					if (this.resultContainer.down("ul")) {
						this.resultContainer.down("ul").remove();
					}
				}

				var ev = this.container.fire("ms:suggest:containerPrepared", {
					'container': this.container,
					'suggest': this
				});

				this.container.__targetField = this.fld;
				if (this.options.enableHideButton && !this.container.down('.hide-button')) {

					//Commented for GEL(GenomicsEngland) .........................................................................
					//We do not need to show "hide suggestions" text
					//var hideButton = new Element('span', {'class': 'hide-button', 'style':'float:left;'}).update("hide suggestions");
					//hideButton.observe('click', this.clearSuggestions.bindAsEventListener(this));
					//this.container.insert({top: new Element('div', {'class': 'hide-button-wrapper'}).update(hideButton)});

					//hideButton = new Element('span', {'class': 'hide-button'}).update("hide suggestions");
					//hideButton.observe('click', this.clearSuggestions.bindAsEventListener(this));
					//this.container.insert({bottom: new Element('div', {'class': 'hide-button-wrapper'}).update(hideButton)});
					//............................................................................................................

					//Added for GEL(GenomicsEngland) ...................................................................
					//If suggestion uses 'pagination', then show 'Load more' text
					var pagination = (this.options.resultUsePagination ? this.options.resultUsePagination() : false);
					if(pagination){
						hideButton = new Element('span', {'class': 'hide-button loadMore', 'style':'float:left;'}).update("Load more");
						hideButton.observe('click', this.loadMode.bindAsEventListener(this));
						this.container.insert({bottom: new Element('div', {'class': 'hide-button-wrapper'}).update(hideButton)});
					}
					//..................................................................................................
				}
				return this.container;
			},

			getBoundPosition:function(elemName){
            		    try{
            		        var note = document.getElementsByName(elemName)[0];
                            var screenPosition = note.getBoundingClientRect();
                            if (screenPosition.y){
                                //console.warn('element location for ' + elemName +  " : " + screenPosition.y );
                                return {y : screenPosition.y, x : screenPosition.x};
                            }else if (screenPosition.top){
                               // console.warn('element location for ' + elemName +  " : " + screenPosition.top );
                                return {y : screenPosition.top, x : screenPosition.left};
                            }
                            return null;

            		    }
            		    catch (err){
            		        console.warn("Could not find element with name " + elemName + ". " + err)
            		    }
            		    return null;

            		},

			//Added for GEL(GenomicsEngland) ...................................................................
			//This will hide 'Load More' text
			hideLoadMore: function(){
				var container = this.container;
				if(container && container.select("span.loadMore").length > 0){
					(container.select("span.loadMore")[0]).hide();
				}
			},

			//Added for GEL(GenomicsEngland) ...............................................................................
			//This will update 'Load More' text and add the number of items that are loaded already and the total number
			updateLoadMore: function(page, limit, total){
				var container = this.container;
				var loadMoreSpan = container.select("span.loadMore");
				if(container && loadMoreSpan.length > 0){
					loadMoreSpan[0].update("(" + (page + 1) * 10 +"/"+ total+") Load more");
				}
			},

			//Added for GEL(GenomicsEngland) ...............................................................................
			//This will call the back-end service to load more, this is called when the user clicks on 'Load more' text
			loadMode : function(){
				// do new request
				var val = this.fld.value;
				this.sInput = val;
				this.nInputChars = val.length;

				this.latestRequest++;
				var pointer = this;
				var requestId = this.latestRequest;
				clearTimeout(this.ajID);
				this.ajID = setTimeout(function () {
					pointer.doAjaxRequests(requestId)
				}, this.options.delay);

				return false;
			},

			/**
			 * Create the HTML list of suggestions.
			 *
			 * @param {Object} arr
			 * @param {Object} source the source for data for which to create this list of results.
			 */
			createList: function (arr, source) {
				this.isActive = true;
				var pointer = this;

				this.killTimeout();
				this.clearHighlight();

				// create holding div
				//
				if (this.sources.length > 1) {
					var div = this.resultContainer.down(".results" + source.id);
					if (arr.length > 0 || this.options.shownoresults) {
						div.down('.sourceContent').removeClassName('loading');
						this.resultContainer.down(".results" + source.id).removeClassName("hidden loading");
					}

					// If we are in mode "unified loader" (showing one loading indicator for all requests and not one per request)
					// and there aren't any source still loading, we remove the unified loading status.
					if (this.options.unifiedLoader && !this.resultContainer.down("loading")) {
						(this.options.loaderNode || this.fld).removeClassName("loading");
					}
				}
				else {
					var div = this.resultContainer;
				}

				// if no results, and shownoresults is false, go no further
				if (arr.length == 0 && !this.options.shownoresults) {
					return false;
				}

				//Commented for GEL(GenomicsEngland) .................................................
				// Ensure any previous list of results for this source gets removed
				//if (div.down('ul')) {
				//	div.down('ul').remove();
				//}
				//....................................................................................

				//Added for GEL(GenomicsEngland) .....................................................
				//If we are loading more items and the 'ul' is already there,
				//then just add new item in it otherwise create 'ul'
				var list = undefined;
				if (div.down('ul')) {
					var oldUL = div.down('ul');
					var newUL = this.createListElement(arr, pointer);
					for(var i = 0; i < newUL.select("li").length;i++) {
						oldUL.appendChild(newUL.select("li")[i]);
					}
					list = oldUL;
				}
				else{
					list = this.createListElement(arr, pointer);
					div.appendChild(list);
				}
				//....................................................................................

				//Commented for GEL(GenomicsEngland) .................................................
				// create and populate list
				//var list = this.createListElement(arr, pointer);
				//div.appendChild(list);
				//....................................................................................
				Event.fire(document, "xwiki:dom:updated", {elements: [list]});

				this.suggest = div;

				// remove list after an interval
				var pointer = this;
				if (this.options.timeout > 0) {
					this.toID = setTimeout(function () {
						pointer.clearSuggestions()
					}, this.options.timeout);
				}
				this.highlightFirst();
			},

			createListElement: function (arr, pointer) {
				var list = new PhenoTips.widgets.XList([], {
					icon: this.options.icon,
					classes: 'suggestList',
					eventListeners: {
						'click': function () {
							pointer.setHighlightedValue();
							return false;
						},
						'mouseover': function () {
							pointer.setHighlight(this.getElement());
						}
					}
				});

				if (this.fld.hasClassName('accept-value')) {
					var customItemId = this.fld.value.replace(/[^a-z0-9_]+/gi, "_");
					var customItemCategoryInfo = this.fld.next('input[name="_category"]');
					var customItemCategories = customItemCategoryInfo && customItemCategoryInfo.value.split(",") || [];
					var customItemCategoriesElt = new Element('div', {'class': 'hidden term-category'});
					var categoryFieldName = this.fld.name + "__" + customItemId + "__category";
					customItemCategories.each(function (c) {
						if (c) {
							customItemCategoriesElt.insert(new Element('input', {'type': 'hidden', name: categoryFieldName, value: c}));
						}
					});

					//Added for GEL (GenomicsEngland) ..................................................................
					// "your text, not a standard term" add this text just in the beginning of the results list
					var pagination     = (this.options.resultUsePagination ? this.options.resultUsePagination() : false);
					var canSelectInputTerm = (this.options.canSelectInputTerm ? this.options.canSelectInputTerm() : true);
					if((!pagination && canSelectInputTerm) || (pagination && this.resultPage == 0 && canSelectInputTerm)){
						list.addItem(this.generateListItem({
							id: this.fld.value,
							value: this.fld.value,
							category: customItemCategoriesElt,
							info: new Element('div', {'class': 'hint'}).update('(your text, not a standard term)')
						}, 'custom-value', true));
					}
					//..................................................................................................
				}



				// loop throught arr of suggestions
				// creating an XlistItem for each suggestion
				//
				for (var i = 0, len = arr.length; i < len; i++) {
					if (!this.options.filterFunc || this.options.filterFunc(arr[i])) {
						list.addItem(this.generateListItem(arr[i]));
					}
				}
				// no results
				if (arr.length == 0) {
					list.addItem(new PhenoTips.widgets.XListItem(this.options.noresults, {
						'classes': 'noSuggestion',
						noHighlight: true }));
				}


				//Commented for GEL(GenomicsEngland) ...................................................................
				//show the text '(your text, not a standard term)' in the begining of the list not at the end
				//if (this.fld.hasClassName('accept-value')) {
				//	var customItemId = this.fld.value.replace(/[^a-z0-9_]+/gi, "_");
				//	var customItemCategoryInfo = this.fld.next('input[name="_category"]');
				//	var customItemCategories = customItemCategoryInfo && customItemCategoryInfo.value.split(",") || [];
				//	var customItemCategoriesElt = new Element('div', {'class': 'hidden term-category'});
				//	var categoryFieldName = this.fld.name + "__" + customItemId + "__category";
				//	customItemCategories.each(function (c) {
				//		if (c) {
				//			customItemCategoriesElt.insert(new Element('input', {'type': 'hidden', name: categoryFieldName, value: c}));
				//		}
				//	});
				//	list.addItem(this.generateListItem({
				//		id: this.fld.value,
				//		value: this.fld.value,
				//		category: customItemCategoriesElt,
				//		info: new Element('div', {'class': 'hint'}).update('(your text, not a standard term)')
				//	}, 'custom-value', true));
				//}
				//......................................................................................................
				return list.getElement();
			},

			/*
			 Added for GEL(GenomicsEngland), this method will make the searchTerm bold in
			 the search result
			 */
			highLightSearchResult: function(text, queryTerm){
				 var newText = text.replace(new RegExp(queryTerm, "ig"), '<strong>$&</strong>')
				 return newText;
			},

			generateListItem: function (data, cssClass, disableTooltip) {
				var displayNode = new Element("div", {'class': 'tooltip-' + this.options.tooltip});
				// If the search result contains an icon information, we insert this icon in the result entry.
				if (data.icon) {
					displayNode.insert(new Element("img", {'src': data.icon, 'class': 'icon' }));
				}
				if (this.options.displayId) {
					displayNode.insert(new Element('span', {'class': 'suggestId'}).update(data.id.escapeHTML()));
				}

				//commented for GEL(GenomicsEngland)
				//displayNode.insert(new Element('span', {'class': 'suggestValue'}).update(data.value.escapeHTML()));
				//Added for GEL(GenomicsEngland)
				//Check if 'displaySuggestItemFunction' exists and then call it to format the
				//search result item ...............................................................................
				if(this.options.displaySuggestItemFunction){
					var displaySuggestItem = this.options.displaySuggestItemFunction(this.sInput, data, this);
					//if it returns an element (and not null)
					if(displaySuggestItem) {
						displayNode.insert(displaySuggestItem);
					}else{
						//if the function exists but it returns null
						var newDataValue = this.highLightSearchResult(data.value.escapeHTML(), this.sInput);
						displayNode.insert(new Element('span', {'class': 'suggestValue'}).update(newDataValue));
					}
				}else{
					var newDataValue = this.highLightSearchResult(data.value.escapeHTML(), this.sInput);
					displayNode.insert(new Element('span', {'class': 'suggestValue'}).update(newDataValue));
				}
				//..................................................................................................

				if (this.options.tooltip && !disableTooltip) {
					var infoTool = new Element('span', {'class': 'fa fa-info-circle xHelpButton ' + this.options.tooltip, 'title': data.id});
					infoTool.observe('click', function (event) {
						event.stop()
					});
					displayNode.insert(' ').insert(infoTool);
				}
				var displayInfo = new Element('div', {'class': 'suggestInfo'}).update(data.info);
				displayNode.insert(displayInfo);
				if (data.altName) {
					displayInfo.insert({'top': new Element('span', {'class': 'matching-alternative-name'}).update(data.altName.escapeHTML())});
				}

				var valueNode = new Element('div')
					.insert(new Element('span', {'class': 'suggestId'}).update(data.id.escapeHTML()))
					.insert(new Element('span', {'class': 'suggestValue'}).update(data.value.escapeHTML()))
					.insert(new Element('div', {'class': 'suggestCategory'}).update(data.category));
				valueNode.store('itemData', data);

				var item = new PhenoTips.widgets.XListItem(displayNode, {
					containerClasses: 'suggestItem ' + (cssClass || ''),
					value: valueNode,
					noHighlight: true // we do the highlighting ourselves
				});

				Event.fire(this.fld, "ms:suggest:suggestionCreated", {element: item.getElement(), suggest: this});

				return item;
			},

			/**
			 * Emphesize the elements in passed value that matches one of the words typed as input by the user.
			 *
			 * @param String input the (typed) input
			 * @param String value the value to emphasize
			 */
			emphasizeMatches: function (input, value) {
				// If the source declares that results are matching, we highlight them in the value
				var output = value,
				// Separate words (called fragments hereafter) in user input
					fragments = input.split(' ').uniq().compact(),
					offset = 0,
					matches = {};

				for (var j = 0, flen = fragments.length; j < flen; j++) {
					// We iterate over each fragments, and try to find one or several matches in this suggestion
					// item display value.
					var index = output.toLowerCase().indexOf(fragments[j].toLowerCase());
					while (index >= 0) {
						// As long as we have matches, we store their index and replace them in the output string with the space char
						// so that they don't get matched for ever.
						// Note that the space char is the only one safe to use, as it cannot be part of a fragment.
						var match = output.substring(index, index + fragments[j].length),
							placeholder = "";
						fragments[j].length.times(function () {
							placeholder += " ";
						});
						matches[index] = match;
						output = output.substring(0, index) + placeholder + output.substring(index + fragments[j].length);
						index = output.toLowerCase().indexOf(fragments[j].toLowerCase());
					}
				}
				// Now that we have found all matches for all possible fragments, we iterate over them
				// to construct the final "output String" that will be injected as a suggestion item,
				// with all matches emphasized
				Object.keys(matches).sortBy(function (s) {
					return parseInt(s)
				}).each(function (key) {
					var before = output.substring(0, parseInt(key) + offset);
					var after = output.substring(parseInt(key) + matches[key].length + offset);
					// Emphasize the match in the output string that will be displayed
					output = before + "<em>" + matches[key] + "</em>" + after;
					// Increase the offset by 9, which correspond to the number of chars in the opening and closing "em" tags
					// we have introduced for this match in the output String
					offset += 9;
				});

				return output;
			},

			/**
			 * Change highlight
			 *
			 * @param {Object} key
			 */
			changeHighlight: function (key) {
				var list = this.resultContainer;
				if (!list)
					return false;

				var n, elem;

				if (this.iHighlighted) {
					// If there is already a highlighted element, we look for the next or previous highlightable item in the list
					// of results, according to which key has been pressed.
					if (key == Event.KEY_DOWN) {
						elem = this.iHighlighted.next();
						if (!elem && this.iHighlighted.up('div.results')) {
							// if the next item could not be found and multi-source mode, find the next not empty source
							var source = this.iHighlighted.up('div.results').next();
							while (source && !elem) {
								elem = source.down('li');
								source = source.next();
							}
						}
						if (!elem) {
							elem = list.down('li');
						}
					}
					else if (key == Event.KEY_UP) {
						elem = this.iHighlighted.previous();
						if (!elem && this.iHighlighted.up('div.results')) {
							// if the previous item could not be found and multi-source mode, find the previous not empty source
							var source = this.iHighlighted.up('div.results').previous();
							while (source && !elem) {
								elem = source.down('li:last-child');
								source = source.previous();
							}
						}
						if (!elem) {
							elem = list.select('ul')[list.select('ul').length - 1].down('li:last-child');
						}
					}
				}
				else {
					// No item is highlighted yet, so we just look for the first or last highlightable item,
					// according to which key, up or down, has been pressed.
					if (key == Event.KEY_DOWN) {
						if (list.down('div.results')) {
							elem = list.down('div.results').down('li')
						}
						else {
							elem = list.down('li');
						}
					}
					else if (key == Event.KEY_UP)
						if (list.select('li') > 0) {
							elem = list.select('li')[list.select('li').length - 1];
						}
				}

				if (elem) {
					this.setHighlight(elem);
				}
			},

			/**
			 * Set highlight
			 *
			 * @param {Object} n
			 */
			setHighlight: function (highlightedItem) {
				if (this.iHighlighted)
					this.clearHighlight();

				highlightedItem.addClassName("xhighlight");

				this.iHighlighted = highlightedItem;

				this.killTimeout();
			},

			/**
			 * Clear highlight
			 */
			clearHighlight: function () {
				if (this.iHighlighted) {
					this.iHighlighted.removeClassName("xhighlight");
					delete this.iHighlighted;
				}
			},

			highlightFirst: function () {
				if (this.suggest && this.suggest.down('ul')) {
					var first = this.suggest.down('ul').down('li');
					if (first) {
						this.setHighlight(first);
					}
				}
			},

			/**
			 * return true if a suggestion is highlighted, false otherwise
			 */
			hasActiveSelection: function () {
				return this.iHighlighted;
			},

			setHighlightedValue: function () {
				if (this.iHighlighted && !this.iHighlighted.hasClassName('noSuggestion')) {
					var selection, newFieldValue
					if (this.sInput == "" && this.fld.value == "")
						selection = newFieldValue = this.iHighlighted.down(".suggestValue").innerHTML;
					else {
						if (this.seps) {
							var lastIndx = -1;
							for (var i = 0; i < this.seps.length; i++)
								if (this.fld.value.lastIndexOf(this.seps.charAt(i)) > lastIndx)
									lastIndx = this.fld.value.lastIndexOf(this.seps.charAt(i));
							if (lastIndx == -1)
								selection = newFieldValue = this.iHighlighted.down(".suggestValue").innerHTML;
							else {
								newFieldValue = this.fld.value.substring(0, lastIndx + 1) + this.iHighlighted.down(".suggestValue").innerHTML;
								selection = newFieldValue.substring(lastIndx + 1);
							}
						}
						else
							selection = newFieldValue = this.iHighlighted.down(".suggestValue").innerHTML;
					}

					var inputData = this.iHighlighted.down('.value div').retrieve('itemData');
					var data = {
						suggest: this,
						id: inputData.id || this.iHighlighted.down(".suggestId").innerHTML,
						value: inputData.value || this.iHighlighted.down(".suggestValue").innerHTML,
						valueAll: inputData.valueAll,
						info: inputData.info || this.iHighlighted.down(".suggestInfo").innerHTML,
						icon: inputData.icon || (this.iHighlighted.down('img.icon') ? this.iHighlighted.down('img.icon').src : ''),
						category: this.iHighlighted.down(".suggestCategory").innerHTML
					};
					this.acceptEntry(data, selection, newFieldValue);
				}
			},

			acceptEntry: function (data, selection, newFieldValue, silent) {
				var hpoPresent = document.getElementsByName("hpoPresent")[0].value;
                data.valueAll.hpoPresent = hpoPresent
				var fld = this.fld;
                //var container = this.fld.up('.field-box');
                var container = this.fld.up('.accepted-suggestion');
                if (container) {
					var nmm = "hpo_positive"
                    container.select('input[type=hidden][name=' + nmm + ']').each(function (item) {
                        var li = item.up("li");
                        var valueAll;
                        if(li != undefined){
                            valueAll = li.retrieve("valueAll");
                            valueAll.hpoPresent = hpoPresent;
                        }
                        if(valueAll.hpoModifiers == undefined){
                            valueAll.hpoModifiers = [];
						}
                        if(fld.className.indexOf("suggest-hpo-modifier") != -1) {
                            var containsValue = false;
                            valueAll.hpoModifiers.forEach(function (elem) {
                                if (elem.uid == li.retrieve("valueAll").uid) {
                                    containsValue = true
                                }
                            });
                            if (!containsValue && li != undefined) {
                                valueAll.hpoModifiers.push(data.valueAll);
                            }
                        }
                    });

				}

				var nm = "hpo_positive";
                if(window.editor._nodeMenu.fieldMap[nm].crtValue)
                {
                 	(window.editor._nodeMenu.fieldMap[nm].crtValue).forEach(function(elem) {
						if(data.id == elem.id){
							console.log("id equals id");
                            elem.valueAll.hpoPresent = data.valueAll.hpoPresent
                            elem.hpoPresent = data.valueAll.hpoPresent
                        }
					});
				}
				var event = Event.fire(this.fld, "ms:suggest:selected", data);

				if (!event.stopped) {
					if (!silent) {
						this.sInput = selection;
						this.fld.value = newFieldValue || this.fld.defaultValue || '';
						this.fld.focus();
						this.clearSuggestions();
					}
					// pass selected object to callback function, if exists
					if (typeof(this.options.callback) == "function") {
						this.options.callback(data);
					}

					//there is a hidden input
					if (this.fld.id.indexOf("_suggest") > 0) {
						var hidden_id = this.fld.id.substring(0, this.fld.id.indexOf("_suggest"));
						var hidden_inp = $(hidden_id);
						if (hidden_inp) {
							hidden_inp.value = info;
						}
					}
				}
			},

			/**
			 * Kill timeout
			 */
			killTimeout: function () {
				clearTimeout(this.toID);
			},

			/**
			 * Reset timeout
			 */
			resetTimeout: function () {
				clearTimeout(this.toID);
				var pointer = this;
				this.toID = setTimeout(function () {
					pointer.clearSuggestions()
				}, 1000000);
			},

			/**
			 * Clear suggestions
			 */
			clearSuggestions: function () {
				this.killTimeout();
				this.isActive = false;
				var ele = $(this.container);
				var pointer = this;
				if (ele && ele.parentNode) {
					if (this.options.fadeOnClear) {
						var fade = new Effect.Fade(ele, {duration: "0.25", afterFinish: function () {
							if ($(pointer.container)) {
								$(pointer.container).remove();
							}
						}});
					}
					else {
						$(this.container).remove();
					}
					document.fire("ms:suggest:clearSuggestions", { 'suggest': this});
				}
			}

		});

	}

	return PhenoTips;

})(PhenoTips || {});

var PhenoTips = (function (PhenoTips) {
// Start PhenoTips augmentation.
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.ModalPopup = Class.create({
		/** Configuration. Empty values will fall back to the CSS. */
		options: {
			idPrefix: "modal-popup-",
			title: "",
			displayCloseButton: true,
			screenColor: "",
			borderColor: "",
			titleColor: "",
			backgroundColor: "",
			screenOpacity: "0.5",
			verticalPosition: "center",
			horizontalPosition: "center",
			resetPositionOnShow: true,
			removeOnClose: false,
			onClose: Prototype.emptyFunction
		},
		/** Constructor. Registers the key listener that pops up the dialog. */
		initialize: function (content, shortcuts, options) {
			/** Shortcut configuration. Action name -> {method: function(evt), keys: string[]}. */
			this.shortcuts = {
				"show": { method: this.showDialog, keys: []},
				"close": { method: this.closeDialog, keys: ['Esc']}
			},

				this.content = content || "Hello world!";
			// Add the new shortcuts
			this.shortcuts = Object.extend(Object.clone(this.shortcuts), shortcuts || { });
			// Add the custom options
			this.options = Object.extend(Object.clone(this.options), options || { });
			// Register a shortcut for showing the dialog.
			this.registerShortcuts("show");

			if (typeof (widgets.ModalPopup.instanceCounter) == 'undefined') {
				widgets.ModalPopup.instanceCounter = 0;
			}
			this.id = ++widgets.ModalPopup.instanceCounter;
		},

		getBoxId: function () {
			return this.options.idPrefix + this.id;
		},

		/** Create the dialog, if it is not already loaded. Otherwise, just make it visible again. */
		createDialog: function (event) {
			this.dialog = new Element('div', {'class': 'msdialog-modal-container'});
			if (this.options.extraDialogClassName) {
				this.dialog.addClassName(this.options.extraDialogClassName);
			}
			// A full-screen semi-transparent screen covering the main document
			this.screen = new Element('div', {'class': 'msdialog-screen'}).setStyle({
				opacity: this.options.screenOpacity,
				backgroundColor: this.options.screenColor
			});
			this.dialog.update(this.screen);
			// The dialog chrome
			this.dialogBox = new Element('div', {'class': 'msdialog-box', 'id': this.getBoxId()});
			if (this.options.extraClassName) {
				this.dialogBox.addClassName(this.options.extraClassName);
			}
			// Insert the content
			this.dialogBox._x_contentPlug = new Element('div', {'class': 'content'});
			this.dialogBox.update(this.dialogBox._x_contentPlug);
			this.dialogBox._x_contentPlug.update(this.content);
			// Add the dialog title
			if (this.options.title) {
				var title = new Element('div', {'class': 'msdialog-title'}).update(this.options.title);
				title.setStyle({"color": this.options.titleColor, "backgroundColor": this.options.borderColor});
				this.dialogBox.insertBefore(title, this.dialogBox.firstChild);
			}
			// Add the close button
			if (this.options.displayCloseButton) {
				var closeButton = new Element('div', {'class': 'msdialog-close', 'title': 'Close'}).update("&#215;");
				closeButton.setStyle({"color": this.options.titleColor});
				closeButton.observe("click", this.closeDialog.bindAsEventListener(this));
				this.dialogBox.insertBefore(closeButton, this.dialogBox.firstChild);
			}
			this.dialog.appendChild(this.dialogBox);
			this.dialogBox.setStyle({
				"textAlign": "left",
				"borderColor": this.options.borderColor,
				"backgroundColor": this.options.backgroundColor
			});
			this.positionDialog();
			
			// Append to the end of the document body.
			//document.body.appendChild(this.dialog);
			
			//modified JG: get pedigree-tool element and append to it instead of body
			document.getElementById(PedigreeEditorTool.divId).appendChild(this.dialog);
			
			if (typeof (Draggable) != 'undefined') {
				new Draggable(this.getBoxId(), {
					handle: $(this.getBoxId()).down('.msdialog-title'),
					scroll: window,
					change: this.updateScreenSize.bind(this)
				});
			}
			this.dialog.hide();
			var __enableUpdateScreenSize = function (event) {
				if (this.dialog.visible()) {
					this.updateScreenSize();
				}
			}.bindAsEventListener(this);
			['resize', 'scroll'].each(function (eventName) {
				Event.observe(window, eventName, __enableUpdateScreenSize);
			}.bind(this));
			Event.observe(document, 'ms:popup:content-updated', __enableUpdateScreenSize);
		},
		positionDialog: function () {
			switch (this.options.verticalPosition) {
				case "top":
					this.dialogBox.setStyle({"top": (document.viewport.getScrollOffsets().top + 6) + "px"});
					break;
				case "bottom":
					this.dialogBox.setStyle({"bottom": ".5em"});
					break;
				default:
					// TODO: smart alignment according to the actual height
					this.dialogBox.setStyle({"top": "20%"});
					break;
			}
			this.dialogBox.setStyle({"left": "", "right": ""});
			switch (this.options.horizontalPosition) {
				case "left":
					this.dialog.setStyle({"textAlign": "left"});
					break;
				case "right":
					this.dialog.setStyle({"textAlign": "right"});
					break;
				default:
					this.dialog.setStyle({"textAlign": "center"});
					this.dialogBox.setStyle({"margin": "auto"});
					break;
			}
		},
		positionDialogInViewport: function (left, top) {
			this.dialogBox.setStyle({
				"left": (document.viewport.getScrollOffsets().left + left) + "px",
				"top": (document.viewport.getScrollOffsets().top + top ) + "px",
				"margin": "0"
			});
		},
		getPositionInViewport: function () {
			return this.dialogBox.viewportOffset();
		},

		updateScreenSize: function () {
			var __getNewDimension = function (eltToFit, dimensionAccessFunction, position) {
				var crtDimension = $(document.documentElement)[dimensionAccessFunction]();
				var viewportDimension = document.viewport.getScrollOffsets()[position] + document.viewport[dimensionAccessFunction]();
				if (eltToFit) {
					var limit = eltToFit.cumulativeOffset()[position] + eltToFit[dimensionAccessFunction]();
				}
				var result = '';
				if (crtDimension < viewportDimension) {
					result = viewportDimension + 'px';
				}
				/*if (limit && crtDimension < limit) {
				 result = limit + 'px';
				 } else if (limit && limit < viewportDimension) {
				 result = viewportDimension + 'px';
				 }*/
				return result;
			};
			this.screen.style.width = __getNewDimension(this.dialogBox, 'getWidth', 'left');
			this.screen.style.height = __getNewDimension(this.dialogBox, 'getHeight', 'top');
		},
		/** Set a class name to the dialog box */
		setClass: function (className) {
			this.dialogBox.addClassName('msdialog-box-' + className);
		},
		/** Remove a class name from the dialog box */
		removeClass: function (className) {
			this.dialogBox.removeClassName('msdialog-box-' + className);
		},
		/** Set the content of the dialog box */
		setContent: function (content) {
			this.content = content;
			this.dialogBox._x_contentPlug.update(this.content);
			this.updateScreenSize();
		},
		/** Called when the dialog is displayed. Enables the key listeners and gives focus to the (cleared) input. */
		showDialog: function (event) {
			if (event) {
				Event.stop(event);
			}
			// Only do this if the dialog is not already active.
			//if (!widgets.ModalPopup.active) {
			//  widgets.ModalPopup.active = true;
			if (!this.active) {
				this.active = true;
				if (!this.dialog) {
					// The dialog wasn't loaded, create it.
					this.createDialog();
				}
				// Start listening to keyboard events
				this.attachKeyListeners();
				// In IE, position: fixed does not work.
				/*if (Prototype.Browser.IE6x) {
				 this.dialog.setStyle({top : document.viewport.getScrollOffsets().top + "px"});
				 this.dialog._x_scrollListener = this.onScroll.bindAsEventListener(this);
				 Event.observe(window, "scroll", this.dialog._x_scrollListener);
				 $$("select").each(function(item) {
				 item._x_initiallyVisible = item.style.visibility;
				 item.style.visibility = 'hidden';
				 });
				 }*/
				// Display the dialog
				this.dialog.show();
				if (this.options.resetPositionOnShow) {
					this.positionDialog();
				}
				this.updateScreenSize();
			}
		},
		onScroll: function (event) {
			this.dialog.setStyle({top: document.viewport.getScrollOffsets().top + "px"});
		},
		/** Called when the dialog is closed. Disables the key listeners, hides the UI and re-enables the 'Show' behavior. */
		closeDialog: function (event) {
			if (event) {
				Event.stop(event);
			}
			/*if (window.browser.isIE6x) {
			 Event.stopObserving(window, "scroll", this.dialog._x_scrollListener);
			 $$("select").each(function(item) {
			 item.style.visibility = item._x_initiallyVisible;
			 });
			 }*/
			// Call optional callback
			this.options.onClose.call(this);
			// Hide the dialog, without removing it from the DOM.
			this.dialog.hide();
			if (this.options.removeOnClose) {
				this.dialog.remove();
			}
			// Stop the UI shortcuts (except the initial Show Dialog one).
			this.detachKeyListeners();
			// Re-enable the 'show' behavior.
			// widgets.ModalPopup.active = false;
			this.active = false;
		},
		/** Enables all the keyboard shortcuts, except the one that opens the dialog, which is already enabled. */
		attachKeyListeners: function () {
			for (var action in this.shortcuts) {
				if (action != "show") {
					this.registerShortcuts(action);
				}
			}
		},
		/** Disables all the keyboard shortcuts, except the one that opens the dialog. */
		detachKeyListeners: function () {
			for (var action in this.shortcuts) {
				if (action != "show") {
					this.unregisterShortcuts(action);
				}
			}
		},
		/**
		 * Enables the keyboard shortcuts for a specific action.
		 *
		 * @param {String} action The action to register
		 * {@see #shortcuts}
		 */
		registerShortcuts: function (action) {
			var shortcuts = this.shortcuts[action].keys;
			var method = this.shortcuts[action].method;
			for (var i = 0; i < shortcuts.size(); ++i) {
				if (Prototype.Browser.IE || Prototype.Browser.WebKit) {
					shortcut.add(shortcuts[i], method.bindAsEventListener(this, action), {type: 'keyup'});
				} else {
					shortcut.add(shortcuts[i], method.bindAsEventListener(this, action), {type: 'keypress'});
				}
			}
		},
		/**
		 * Disables the keyboard shortcuts for a specific action.
		 *
		 * @param {String} action The action to unregister {@see #shortcuts}
		 */
		unregisterShortcuts: function (action) {
			for (var i = 0; i < this.shortcuts[action].keys.size(); ++i) {
				shortcut.remove(this.shortcuts[action].keys[i]);
			}
		},
		createButton: function (type, text, title, id) {
			var wrapper = new Element("span", {"class": "buttonwrapper"});
			var button = new Element("input", {
				"type": type,
				"class": "button",
				"value": text,
				"title": title,
				"id": id
			});
			wrapper.update(button);
			return wrapper;
		},
		show: function (event) {
			this.showDialog(event);
		},
		close: function (event) {
			this.closeDialog(event);
		}
	});
	/** Whether or not the dialog is already active (or activating). */
	widgets.ModalPopup.active = false;
// End PhenoTips augmentation.
	return PhenoTips;
}(PhenoTips || {}));


var PhenoTips = (function (PhenoTips) {
	var widgets = PhenoTips.widgets = PhenoTips.widgets || {};
	widgets.SuggestPicker = Class.create({

		options: {
			'showKey': true,
			'showTooltip': false,
			'showDeleteTool': true,
			'enableSort': true,
			'showClearTool': true,
			'inputType': 'hidden',
			'listInsertionElt': null,
			'listInsertionPosition': 'after',
			'predefinedEntries': null,
			'acceptFreeText': false
		},
		initialize: function (element, suggest, options, serializedDataInput) {
			this.options = Object.extend(Object.clone(this.options), options || { });
			this.serializedDataInput = serializedDataInput;
			this.input = element;
			this.suggest = suggest;
			this.inputName = this.input.name;
			if (!this.options.acceptFreeText) {
				this.input.name = this.input.name + "__suggested";
			} else {
				this.input.addClassName("accept-value");
			}
			this.suggest.options.callback = this.acceptSuggestion.bind(this);


			//Commented for GEL(GenomicsEngland)
			//this.list = new Element('ul', {'class': 'accepted-suggestions'});

			//Added for GEL(GenomicsEngland), to add more CSS class into suggestions list
			//based on the name of the name of the suggestion list
			var extraClass = "";
			if(this.options.name){
				extraClass = this.options.name +"_suggestions";
			}
			this.list = new Element('ul', {'class': 'accepted-suggestions gel-accepted-suggestions ' + extraClass});
			//..........................................................................................................

			var listInsertionElement;
			if (this.options.listInsertionElt) {
				if (typeof(this.options.listInsertionElt) == "string") {
					listInsertionElement = this.input.up().down(this.options.listInsertionElt);
				} else {
					listInsertionElement = this.options.listInsertionElt;
				}
			}
			if (!listInsertionElement) {
				listInsertionElement = this.input;
			}
			var insertion = {};
			insertion[this.options.listInsertionPosition] = this.list;
			listInsertionElement.insert(insertion);
			this.predefinedEntries = this.options.predefinedEntries ? $(this.options.predefinedEntries) : null;

            if (this.options.showClearTool) {

				//replace by Soheil for GEL(GenomicsEngland), this will help to load messages from localization class
				//this.clearTool = new Element('span', {'class': 'clear-tool delete-tool invisible', 'title': "$services.localization.render('phenotips.widgets.multiSuggest.clear.title')"}).update('Delete all &#x2716;');

				if(this.options.name  != "hpo-modifier") {
                    this.clearTool = new Element('span', {
                        'class': 'clear-tool delete-tool invisible',
                        'title': $services.localization.render('phenotips.widgets.multiSuggest.clear.title')
                    }).update('Delete all &#x2716;');
                    this.clearTool.observe('click', this.clearAcceptedList.bindAsEventListener(this));
                }
				this.list.insert({'after': this.clearTool});
			}
			if (typeof(this.options.onItemAdded) == "function") {
				this.onItemAdded = this.options.onItemAdded;
			}
		},

		acceptAddItem: function (key, negative) {
			console.log("acceptAddItem",key,negative)
			var searchFor = 'input[id="' + this.getInputId(key, negative).replace(/[^a-zA-Z0-9_-]/g, '\\$&') + '"]';
			var input = this.predefinedEntries ? this.predefinedEntries.down(searchFor) : this.list ? this.list.down(searchFor) : $(this.getInputId(key, negative));

			//Added for GEL(GenomicsEngland)

			//In some cases like ICD10 and SnomedCT we can let user select an item several times
			//by default suggestion just accept unique item and uses the id to find the selected item, among current items
			//If 'acceptsDuplicate' is true, by making the 'input' as undefined, we can allow a selected item to be selected again
			if(this.options.acceptsDuplicate != undefined && typeof this.options.acceptsDuplicate === "function"){
			 	var acceptsDuplicate = this.options.acceptsDuplicate();
				if(acceptsDuplicate){
					input = undefined;
				}
			}
			//..................................................................................................................

			if (input) {
				input.checked = true;
				Event.fire(input, 'suggest:change');
				//this.ensureVisible(input.up(), true);
				this.synchronizeSelection(input);
				return false;
			}
			return true;
		},

		ensureVisible: function (element, force) {
			if (this.silent || (!force && this.options.silent) || element.up('.hidden')) {
				return;
			}
			var section = element.up('.collapsed:not(.force-collapse)');
			while (section) {
				section.removeClassName('collapsed');
				if (section.down('.expand-tool')) {
					section.down('.expand-tool').update('▼');
				}
				section = section.up('.collapsed:not(.force-collapse)');
			}
			if (element.viewportOffset().top > this.input.viewportOffset().top) {
				if (element.viewportOffset().top > document.viewport.getHeight()) {
					if (element.viewportOffset().top - this.input.viewportOffset().top < document.viewport.getHeight()) {
						this.input.scrollTo();
					} else {
						element.scrollTo();
					}
				}
			} else {
				if (element.cumulativeOffset().top < document.viewport.getScrollOffsets().top) {
					element.scrollTo();
				}
			}
		},

		acceptSuggestion: function (obj) {
			console.log("objjj",obj)
			this.input.value = this.input.defaultValue || "";
			if (this.acceptAddItem(obj.id || obj.value, obj.negative)) {
				this.addItem(obj.id || obj.value, obj.value, obj.info, obj.category, obj.valueAll);
			}
			return false;
		},

		addItem: function (key, value, info, category, valueAll) {
			if (!key) {
				return;
			}
			var id = this.getInputId(key);

			//Added for GEL(GenomicsEngland)
			//In some cases like ICD10 and SnomedCT we can let user select an item several times
			//by default suggestion just accept unique item and uses the id to find the selected item, among current items
			//If 'acceptsDuplicate' is true, we add a random text to make a unique id for each 'li' HTML element
			if(this.options.acceptsDuplicate != undefined && typeof this.options.acceptsDuplicate === "function"){
				var acceptsDuplicate = this.options.acceptsDuplicate();
				if(acceptsDuplicate){
					id = id + "_" + Helpers.createRandomID();
				}
			}
			//..................................................................................................................


			var listItem = new Element("li");
			listItem.store("valueAll", valueAll);
			var displayedValue = new Element("label", {"class": "accepted-suggestion", "for": id});
			// insert input
			var inputOptions = {"type": this.options.inputType, "name": this.inputName, "id": id, "value": key};
			if (this.options.inputType == 'checkbox') {
				inputOptions.checked = true;
			}
			displayedValue.insert({'bottom': new Element("input", inputOptions)});
			// if the key should be displayed, insert it
			if (this.options.showKey) {
				displayedValue.insert({'bottom': new Element("span", {"class": "key"}).update("[" + key.escapeHTML() + "]")});
				displayedValue.insert({'bottom': new Element("span", {"class": "sep"}).update(" ")});
			}
			// insert the displayed value
			displayedValue.insert({'bottom': new Element("span", {"class": "value"}).update(value.escapeHTML())});


			//********************************************************************************************************
			//Added by Soheil for GEL(GenomicsEngland)
			//customizeItemDisplay is a function that is passed to the options of the suggest
			//if it exists, it will be called and it will customize the display item like adding type of disorder to
			//found disorder list and ......
			if(this.options.customizeItemDisplay != undefined && typeof this.options.customizeItemDisplay === "function"){
				this.options.customizeItemDisplay(key, value, valueAll, displayedValue,this.options);
			}
			//********************************************************************************************************


			listItem.insert(displayedValue);
			if (category && category != '') {
				listItem.insert(category);
			}
			// delete tool
			if (this.options.showDeleteTool) {
				var deleteTool = new Element("span", {'class': "delete-tool", "title": "Delete this term"}).update('&#x2716;');
				deleteTool.observe('click', this.removeItem.bindAsEventListener(this));
				listItem.appendChild(deleteTool);
			}
			// tooltip, if information exists and the options state there should be a tooltip
			if (this.options.showTooltip && info) {
				listItem.appendChild(new Element("div", {'class': "tooltip"}).update(info));
				listItem.select('.expand-tool').invoke('observe', 'click', function (event) {
					event.stop();
				});
			}
			this.list.insert(listItem);
			var newItem = this.list ? this.list.down('input[id="' + id.replace(/[^a-zA-Z0-9_-]/g, '\\$&') + '"]') : $(id);
			//this.ensureVisible(newItem);
			this.synchronizeSelection(newItem);
			newItem.observe('change', this.synchronizeSelection.bind(this, newItem));
			this.updateListTools();
			this.onItemAdded(newItem)
			return newItem;
		},

		onItemAdded: function (element) {
		},

		removeItem: function (event) {
			var item = event.findElement('li');
			this.synchronizeSelection({
				value: (item.down('input[type=checkbox]') || item.down('input')).value,
				checked: false
			});
			item.remove();
			this.notifySelectionChange(item);
			this.input.value = this.input.defaultValue || "";
			this.updateListTools();
		},

		clearAcceptedList: function () {
			// The list items are recreated after each update, so we can't cache the set of items, we must request them one by one
			var item = this.list.down('li .delete-tool');
			var i = 0;
			while (item && i < 100) {
                item.click();
				item = this.list.down('li .delete-tool')
				i++;
			}
		},

		updateListTools: function () {
			if (this.clearTool) {
				if (this.list.select('li .accepted-suggestion').length > 0) {
					this.clearTool.removeClassName('invisible');
				} else {
					this.clearTool.addClassName('invisible');
				}
			}
			if (this.options.enableSort && this.list.select('li .accepted-suggestion').length > 0 && typeof(Sortable) != "undefined") {
				Sortable.create(this.list);
			}
			if (this.serializedDataInput) {
				var value = '';
				this.list.select('li .accepted-suggestion input[type=checkbox]').each(function (entry) {
					value += entry.value + '|';
				});
				this.serializedDataInput.value = value;
			}
		},

		getInputId: function (key, negative) {
			return (negative ? this.inputName.replace(/(_\d+)_/, "$1_negative_") : this.inputName) + "_" + key;
		},

		synchronizeSelection: function (input) {
			var element = (typeof (input.up) == 'function') && input.up('li');
			if (element) {
				if (this.input.hasClassName('generateYesNo') && !input.up('.yes-no-picker')) {
					Element.select(element, 'input[name="fieldName"][type="hidden"]').each(function (n) {
						var target = n.up('li').down('input[type="checkbox"]');
						var originalName = target.name;
						target.id = target.id.replace(target.name, n.value);
						target.name = n.value;
						target.up('label').addClassName(n.className);
						target.up('label').htmlFor = target.id;
						n.value = originalName;
						if (n.up('.term-category')) {
							n.up('.term-category').insert({before: n});
						}
					});
					var positiveName = this.input.name.replace(/__suggested$/, "");
					var negativeName = this.input.name.replace(/(_\d+)_/, "$1_negative_").replace(/__suggested$/, "");
					;
					var value = input.value;
					var text = element.down('.value').firstChild.nodeValue;
					var ynpickerElt = YesNoPicker.generatePickerElement([
						{type: 'na', selected: !isValueSelected(positiveName, value) && !isValueSelected(negativeName, value)},
						{type: 'yes', name: positiveName, selected: isValueSelected(positiveName, value)},
						{type: 'no', name: negativeName, selected: isValueSelected(negativeName, value)}
					], value, text, true, input.next());
					input.insert({before: ynpickerElt});
					input.hide();
					input.name = '';
					input.id = '';
					input.value = '';
					enableHighlightChecked(ynpickerElt.down('.yes input'));
					enableHighlightChecked(ynpickerElt.down('.no input'));
				}
			}
			if (element) {
				this.notifySelectionChange(element);
			}
		},

		notifySelectionChange: function (elt) {
			if (!elt.__categoryArray) {
				elt.__categoryArray = [];
				Element.select(elt, '.term-category input[type=hidden]').each(function (c) {
					elt.__categoryArray.push(c.value);
				});
			}
			//Event.fire(this.input, 'xwiki:form:field-value-changed');
			if(this.input.className.indexOf("suggest-hpo-modifier") != -1 && this.inputName == ""){
                this.inputName = "hpo_positive"
			}

            Event.fire(document, "custom:selection:changed", {
                'categories': elt.__categoryArray,
                'trigger': this.input,
                'fieldName': this.inputName,
                'customElement':elt
            });
		},



	});
	return PhenoTips;
}(PhenoTips || {}));
(function() {

	window.pedigreeStatus = window.pedigreeStatus || {};

	var previousState = [];


    var reset = function (){

        previousState = getCurrentState();
    };

    var getCurrentState = function(){

        var privacySetting = "all";
        var exportString = PedigreeExport.exportAsSimpleJSON(editor.getGraph().DG, privacySetting);

        var pedigreeData = JSON.parse(exportString);

        pedigreeData.forEach(function(elem){
        if(elem.hpoTermsFullDetails != undefined){
            elem.hpoTermsFullDetails.forEach(function(hpoFullDetail){
                if(hpoFullDetail.valueAll != undefined && hpoFullDetail.valueAll.hpoModifiers != undefined && hpoFullDetail.valueAll.hpoModifiers.size() > 0){
                    hpoFullDetail.hpoModifiers = hpoFullDetail.valueAll.hpoModifiers;
                }
            });
            }
        });

        return pedigreeData;
    };

    var isDirty = function(){

        var currentStateJson = getCurrentState();

        var currentStateString = JSON.stringify(currentStateJson);

        var previousStateString = JSON.stringify(previousState);
        
        return !(currentStateString === previousStateString);

    }

    window.pedigreeStatus.isDirty = isDirty;
    window.pedigreeStatus.reset = reset;


}());
(function() {

	var refreshTokenProxyFunc = function(){
				
		if (window.refreshAccessToken && typeof window.refreshAccessToken === "function"){			
			var newAccessToken = window.refreshAccessToken();
			window.PedigreeEditorTool.accessToken = newAccessToken;
		}
		else{
			throw "refreshTokenFunction is not defined. It must be defined at window level for pedigree tool app to work.";
		}
	};
	
	var config = {};
	
	var embeddedAppConfigFunc = window.embeddedAppConfig;
		 
	if (embeddedAppConfigFunc && typeof embeddedAppConfigFunc === "function"){		
		
		config = embeddedAppConfigFunc();		
		
	}
	else{
		throw "embeddedAppConfigFunc is not defined. It must be defined at window level for pedigree tool app to work.";		
	}

    //allow host to call save function in pedigree
    var hostSaveFunction = function(callbackFunc){
        if (callbackFunc !== null){

            if (!Object.isFunction(callbackFunc)){
                throw ('Save callback function is not a function');
            }
        }
        window.editor.getSaveLoadEngine().save(null, callbackFunc);
    }
	
	var isStandAlone = false;
	if (CONSTANTS.STANDALONE){
		// if CONSTANTS.STANDALONE is not defined it is embedded. It must be defined and set to true
		isStandAlone =  true;
	}
	
	initializeEditor(config.accessToken, null, config.divId, config.referralId, null, refreshTokenProxyFunc, isStandAlone, hostSaveFunction);

}());